diff --git a/Makefile b/Makefile
index 44efd1252ab8..2ba4c6d892e3 100644
--- a/Makefile
+++ b/Makefile
@@ -303,7 +303,7 @@ CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
 
 HOSTCC       = gcc
 HOSTCXX      = g++
-HOSTCFLAGS   = -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu89
+HOSTCFLAGS   = -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu89 -g -ggdb
 HOSTCXXFLAGS = -O2
 
 ifeq ($(shell $(HOSTCC) -v 2>&1 | grep -c "clang version"), 1)
diff --git a/README b/README
index f4756ee1c918..492005386e85 100644
--- a/README
+++ b/README
@@ -1,4 +1,17 @@
-        Linux kernel release 4.x <http://kernel.org/>
+Based on: https://github.com/ssrg-vt/popcorn-kernel "edaf90e430ed"
+Recycled code from local branch "tso-adv" (pushed, commits included)
+
+=======================================
+Descriptions for other branches
+pop-hype - PuzzleHype (wroking on)
+master_stat - for analying DSM latencies
+master-tso - paper ICDCS19(X), SoCC(X) IPDPS(x) XXXXXXXX (tso-adv)
+master-tso-develop - developing branch for master-tso
+pf - auto prefetch
+master - root
+
+========================================
+		Linux kernel release 4.x <http://kernel.org/>
 
 These are the release notes for Linux version 4.  Read them carefully,
 as they tell you what this is all about, explain how to install the
diff --git a/README.md b/README.md
index d57329fa391a..44f81b4fad05 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,9 @@
+ATTENTION: If you are looking for the lastest release code of TSO implementation, please checkout "master-tso" branch.
+
+"master-tso-develop" is a private & development branch which is only used for synchronizing/backing up code on different machines.
+
+----------------------------------------------
+
 Popcorn Linux for Distributed Thread Execution
 ----------------------------------------------
 
diff --git a/README_PuzzleHype b/README_PuzzleHype
new file mode 100644
index 000000000000..d911ca81ef39
--- /dev/null
+++ b/README_PuzzleHype
@@ -0,0 +1,38 @@
+
+If you cannot boot
+RAMDISK SIZE
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_BLK_DEV_RAM_SIZE=2097152 // 2G
+
+- Don't upload copy_patch_to_desktop_dropbox.sh (echo5 will not be able to apply)
+
+
+
+
+
+Disable KPTI
+CONFIG_PAGE_TABLE_ISOLATION=n
+
+Intel MPX Diasable (Intel® Memory Protection Extensions (Intel® MPX))
+When MPX is enable, remote cannot malloc/calloc memory. The address will be GROWNDOWN and thus DSM cannot handle.
+
+
+[kernel config]
+Problem 1: when moving from echo to mir. During bootup, remote node invokes hypercall (VM_EXIT -> handle_vmcall())
+Solution 1:
+Disable CONFIG_PARAVIRT_SPINLOCKS
+	mir originally CONFIG_PARAVIRT_SPINLOCKS=y
+	echo CONFIG_PARAVIRT_SPINLOCKS=n
+	so I disable CONFIG_PARAVIRT_SPINLOCKS on mir as well
+and
+Enable
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+and
+Disable CONFIG_X86_DEBUG_FPU
+One of these above makes hypercall
+
+For our convinience, we init a few things only on vcpu0 in the guest kernel.
+Search "pophype_set_cpu0" for the things.
diff --git a/arch/powerpc/include/asm/systbl.h b/arch/powerpc/include/asm/systbl.h
index 3a5e44f0f3c7..0b83b173c463 100644
--- a/arch/powerpc/include/asm/systbl.h
+++ b/arch/powerpc/include/asm/systbl.h
@@ -387,3 +387,11 @@ SYSCALL(popcorn_migrate)
 SYSCALL(popcorn_propose_migration)
 SYSCALL(popcorn_get_status)
 SYSCALL(popcorn_get_node_info)
+SYSCALL(popcorn_broadcast_cpu_table)
+SYSCALL(popcorn_false_share)
+SYSCALL(popcorn_true_share)
+SYSCALL(popcorn_no_share)
+SYSCALL(pophype_migrate)
+SYSCALL(pophype_remote_checkin_vcpu_pid)
+SYSCALL(pophype_origin_checkin_vcpu_pid)
+SYSCALL(pophype_vcpu_migrate_trigger)
diff --git a/arch/powerpc/include/uapi/asm/unistd.h b/arch/powerpc/include/uapi/asm/unistd.h
index 186a6b4d7cc2..c1a78615cff1 100644
--- a/arch/powerpc/include/uapi/asm/unistd.h
+++ b/arch/powerpc/include/uapi/asm/unistd.h
@@ -393,5 +393,14 @@
 #define __NR_popcorn_propose_migration	380
 #define __NR_popcorn_get_thread_status	381
 #define __NR_popcorn_get_node_info	382
+#define __NR_popcorn_broadcast_cpu_table 390
+#define __NR_popcorn_false_share 395
+#define __NR_popcorn_true_share 396
+#define __NR_popcorn_no_share 397
+#define __NR_pophype_migrate 400
+#define __NR_pophype_migrate_on_hostusr 401
+#define __NR_pophype_remote_checkin_vcpu_pid 402
+#define __NR_pophype_origin_checkin_vcpu_pid 403
+#define __NR_pophype_vcpu_migrate_trigger 404
 
 #endif /* _UAPI_ASM_POWERPC_UNISTD_H_ */
diff --git a/arch/x86/Kconfig.cpu b/arch/x86/Kconfig.cpu
index 3ba5ff2f2d08..88b91b1c5378 100644
--- a/arch/x86/Kconfig.cpu
+++ b/arch/x86/Kconfig.cpu
@@ -302,6 +302,8 @@ config X86_GENERIC
 
 #
 # Define implied options from the CPU selection here
+# mir7: || MCORE2
+# echo5: || GENERIC_CPU
 config X86_INTERNODE_CACHE_SHIFT
 	int
 	default "12" if X86_VSMP
diff --git a/arch/x86/boot/bitops.h b/arch/x86/boot/bitops.h
index 878e4b9940d9..5270b61f70c4 100644
--- a/arch/x86/boot/bitops.h
+++ b/arch/x86/boot/bitops.h
@@ -16,15 +16,30 @@
 #define BOOT_BITOPS_H
 #define _LINUX_BITOPS_H		/* Inhibit inclusion of <linux/bitops.h> */
 
+#ifdef CONFIG_POPCORN_HYPE
+////#include <popcorn/bundle.h>
+//#include <popcorn/debug.h>
+#endif
+
 static inline int constant_test_bit(int nr, const void *addr)
 {
 	const u32 *p = (const u32 *)addr;
+//#ifdef CONFIG_POPCORN_HYPE
+//#if !POPHYPE_HOST_KERNEL
+//	GSMPBSPPRINTK("\t<%d> %s():\n", smp_processor_id(), __func__);
+//#endif
+//#endif
 	return ((1UL << (nr & 31)) & (p[nr >> 5])) != 0;
 }
 static inline int variable_test_bit(int nr, const void *addr)
 {
 	u8 v;
 	const u32 *p = (const u32 *)addr;
+//#ifdef CONFIG_POPCORN_HYPE
+//#if !POPHYPE_HOST_KERNEL
+//	GSMPBSPPRINTK("\t<%d> %s():\n", smp_processor_id(), __func__);
+//#endif
+//#endif
 
 	asm("btl %2,%1; setc %0" : "=qm" (v) : "m" (*p), "Ir" (nr));
 	return v;
diff --git a/arch/x86/entry/syscalls/syscall_64.tbl b/arch/x86/entry/syscalls/syscall_64.tbl
index 6a7cfd9f4a4e..6feff2d26573 100644
--- a/arch/x86/entry/syscalls/syscall_64.tbl
+++ b/arch/x86/entry/syscalls/syscall_64.tbl
@@ -336,6 +336,15 @@
 331 64	popcorn_propose_migration	sys_popcorn_propose_migration
 332 64	popcorn_get_thread_status	sys_popcorn_get_thread_status
 333 64	popcorn_get_node_info	sys_popcorn_get_node_info
+370 64	popcorn_broadcast_cpu_table	sys_popcorn_broadcast_cpu_table
+375 64	popcorn_fasle_share	sys_popcorn_false_share
+376 64	popcorn_true_share	sys_popcorn_true_share
+377 64	popcorn_no_share	sys_popcorn_no_share
+380 64  pophype_migrate    sys_pophype_migrate
+381 64  pophype_migrate_on_hostusr    sys_pophype_migrate_on_hostusr
+382 64	pophype_remote_checkin_vcpu_pid sys_pophype_remote_checkin_vcpu_pid
+383 64	pophype_origin_checkin_vcpu_pid sys_pophype_origin_checkin_vcpu_pid
+384 64	pophype_vcpu_migrate_trigger sys_pophype_vcpu_migrate_trigger
 
 #
 # x32-specific system call numbers start at 512 to avoid cache impact
diff --git a/arch/x86/include/asm/bitops.h b/arch/x86/include/asm/bitops.h
index cfe3b954d5e4..25f70ca3a076 100644
--- a/arch/x86/include/asm/bitops.h
+++ b/arch/x86/include/asm/bitops.h
@@ -17,6 +17,11 @@
 #include <asm/rmwcc.h>
 #include <asm/barrier.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+////#include <popcorn/bundle.h>
+//#include <popcorn/debug.h>
+#endif
+
 #if BITS_PER_LONG == 32
 # define _BITOPS_LONG_SHIFT 5
 #elif BITS_PER_LONG == 64
@@ -307,6 +312,11 @@ static inline int test_and_change_bit(long nr, volatile unsigned long *addr)
 
 static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
 {
+//#ifdef CONFIG_POPCORN_HYPE
+//#if !POPHYPE_HOST_KERNEL
+//	GSMPBSPPRINTK("\t<%d> %s():\n", smp_processor_id(), __func__);
+//#endif
+//#endif
 	return ((1UL << (nr & (BITS_PER_LONG-1))) &
 		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
 }
@@ -314,6 +324,11 @@ static __always_inline int constant_test_bit(long nr, const volatile unsigned lo
 static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
 {
 	int oldbit;
+//#ifdef CONFIG_POPCORN_HYPE
+//#if !POPHYPE_HOST_KERNEL
+//	printk("\t<%d> %s():\n", smp_processor_id(), __func__);
+//#endif
+//#endif
 
 	asm volatile("bt %2,%1\n\t"
 		     "sbb %0,%0"
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 74fda1a453bd..65ad377cbc4c 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -32,6 +32,16 @@
 #include <asm/msr-index.h>
 #include <asm/asm.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+//#include <popcorn/hype_kvm.h> /* cannot include this and thus cannot use hype_node_info. Sol: get vcpu and in put it form outside */
+struct pophype_migrate_update_info {
+    struct kvm_vcpu *from_vcpu; /* read content from msg */
+    struct kvm_vcpu *to_vcpu; /* lookup table once landed */
+	struct kvm_regs regs;
+    int test;
+};
+#endif
+
 #define KVM_MAX_VCPUS 255
 #define KVM_SOFT_MAX_VCPUS 160
 #define KVM_USER_MEM_SLOTS 509
@@ -164,7 +174,7 @@ enum {
 #define PFERR_PRESENT_MASK (1U << PFERR_PRESENT_BIT)
 #define PFERR_WRITE_MASK (1U << PFERR_WRITE_BIT)
 #define PFERR_USER_MASK (1U << PFERR_USER_BIT)
-#define PFERR_RSVD_MASK (1U << PFERR_RSVD_BIT)
+#define PFERR_RSVD_MASK (1U << PFERR_RSVD_BIT) /* MMIO fault */
 #define PFERR_FETCH_MASK (1U << PFERR_FETCH_BIT)
 
 /* apic attention bits */
@@ -271,7 +281,10 @@ struct kvm_mmu {
 	unsigned long (*get_cr3)(struct kvm_vcpu *vcpu);
 	u64 (*get_pdptr)(struct kvm_vcpu *vcpu, int index);
 	int (*page_fault)(struct kvm_vcpu *vcpu, gva_t gva, u32 err,
-			  bool prefault);
+		  bool prefault);
+#ifdef CONFIG_POPCORN_HYPE
+		  //bool prefault, long read_gva, unsigned long exit_qualification);
+#endif
 	void (*inject_page_fault)(struct kvm_vcpu *vcpu,
 				  struct x86_exception *fault);
 	gpa_t (*gva_to_gpa)(struct kvm_vcpu *vcpu, gva_t gva, u32 access,
@@ -607,7 +620,7 @@ struct kvm_arch_memory_slot {
 struct kvm_apic_map {
 	struct rcu_head rcu;
 	u8 mode;
-	struct kvm_lapic *phys_map[256];
+	struct kvm_lapic *phys_map[256];	/* LAPIC ID to kvm_lapic */
 	/* first index is cluster id second is cpu id in a cluster */
 	struct kvm_lapic *logical_map[16][16];
 };
@@ -911,6 +924,30 @@ struct kvm_x86_ops {
 	void (*post_block)(struct kvm_vcpu *vcpu);
 	int (*update_pi_irte)(struct kvm *kvm, unsigned int host_irq,
 			      uint32_t guest_irq, bool set);
+#ifdef CONFIG_POPCORN_HYPE
+	void (*dump_vmcs)(void);
+	void (*pophype_check_vmcs)(struct kvm_vcpu *vcpu);
+	unsigned long (*pophype_vmcs_readl)(unsigned long field);
+	void (*pophype_vmcs_writel)(unsigned long field, unsigned long value);
+#ifdef CONFIG_POPCORN_STAT
+	unsigned long (*get_kvm_eptfault_new_ns)(void);
+	unsigned long (*get_kvm_eptfault_new_cnt)(void);
+	unsigned long (*get_user_gva_cnt)(void);
+	unsigned long (*get_kernel_gva_cnt)(void);
+	unsigned long (*get_unknow_gva_cnt)(void);
+	unsigned long (*get_wrong_validity_gva_cnt)(void);
+	unsigned long (*get_gva_ret_kernelspace_cnt)(void);
+	unsigned long (*get_gva_ret_userspace_cnt)(void);
+	void (*set_kvm_eptfault_new_ns)(u64 data);
+	void (*set_kvm_eptfault_new_cnt)(u64 data);
+	void (*set_user_gva_cnt)(u64 data);
+	void (*set_kernel_gva_cnt)(u64 data);
+	void (*set_unknow_gva_cnt)(u64 data);
+	void (*set_wrong_validity_gva_cnt)(u64 data);
+	void (*set_gva_ret_kernelspace_cnt)(u64 data);
+	void (*set_gva_ret_userspace_cnt)(u64 data);
+#endif
+#endif
 };
 
 struct kvm_arch_async_pf {
@@ -1090,7 +1127,8 @@ gpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,
 int kvm_emulate_hypercall(struct kvm_vcpu *vcpu);
 
 int kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gva_t gva, u32 error_code,
-		       void *insn, int insn_len);
+		       void *insn, int insn_len,
+			   unsigned long real_gva, unsigned long exit_qualification);
 void kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva);
 void kvm_mmu_new_cr3(struct kvm_vcpu *vcpu);
 
@@ -1259,4 +1297,60 @@ void kvm_set_msi_irq(struct kvm_kernel_irq_routing_entry *e,
 static inline void kvm_arch_vcpu_blocking(struct kvm_vcpu *vcpu) {}
 static inline void kvm_arch_vcpu_unblocking(struct kvm_vcpu *vcpu) {}
 
+#ifdef CONFIG_POPCORN_HYPE
+int pophype_peek_vcpu_enter_guest(struct kvm_vcpu *vcpu);
+void pophype_dump_vmcs(void);
+#ifdef CONFIG_POPCORN_STAT
+unsigned long pophype_get_kvm_eptfault_new_ns(void);
+unsigned long pophype_get_kvm_eptfault_new_cnt(void);
+unsigned long pophype_get_user_gva_cnt(void);
+unsigned long pophype_get_kernel_gva_cnt(void);
+unsigned long pophype_get_unknow_gva_cnt(void);
+unsigned long pophype_get_wrong_validity_gva_cnt(void);
+unsigned long pophype_get_gva_ret_kernelspace_cnt(void);
+unsigned long pophype_get_gva_ret_userspace_cnt(void);
+
+void pophype_set_kvm_eptfault_new_ns(u64 data);
+void pophype_set_kvm_eptfault_new_cnt(u64 data);
+void pophype_set_user_gva_cnt(u64 data);
+void pophype_set_kernel_gva_cnt(u64 data);
+void pophype_set_unknow_gva_cnt(u64 data);
+void pophype_set_wrong_validity_gva_cnt(u64 data);
+void pophype_set_gva_ret_kernelspace_cnt(u64 data);
+void pophype_set_gva_ret_userspace_cnt(u64 data);
+#endif
+void pophype_save_vcpu_states(struct kvm_vcpu *vcpu);
+struct kvm_mp_state* pophype_get_mp_state(int vcpu_id);
+struct kvm_regs* pophype_get_regs(int vcpu_id);
+struct kvm_sregs* pophype_get_sregs(int vcpu_id);
+struct kvm_fpu* pophype_get_fpu(int vcpu_id);
+struct kvm_xcrs* pophype_get_xcrs(int vcpu_id);
+struct kvm_lapic_state* pophype_get_lapic(int vcpu_id);
+struct kvm_xsave* pophype_get_xsave(int vcpu_id);
+struct kvm_vcpu_events* pophype_get_vcpu_event(int vcpu_id);
+//struct kvm_msrs* pophype_get_msrs(void);
+struct pophype_kvm_msrs* pophype_get_msrs(int vcpu_id);
+struct kvm_run* pophype_get_kvm_run(int vcpu_id);
+
+void pophype_vcpu_check_vmcs(struct kvm_vcpu *vcpu);
+int pophype_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu, struct kvm_xcrs *xcrs);
+int pophype_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu, struct kvm_lapic_state *lapic);
+int pophype_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu, struct kvm_xsave *xsave);
+int pophype_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu, struct kvm_vcpu_events *vcpu_events);
+int pophype_do_set_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data);
+//int pophype_msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs, struct kvm_msr_entry *entries, int (*pophype_do_set_msr)(struct kvm_vcpu *vcpu, unsigned index, u64 *data), int writeback);
+//int pophype_msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs, int (*pophype_do_set_msr)(struct kvm_vcpu *vcpu, unsigned index, u64 *data), int writeback);
+//
+int pophype_msr_io(struct kvm_vcpu *vcpu, struct pophype_kvm_msrs *msrs, int (*pophype_do_get_set_msr)(struct kvm_vcpu *vcpu, unsigned index, u64 *data), int writeback);
+int pophype_read_sysenter_states(struct kvm_vcpu *vcpu);
+void pophype_vmcs_writel_guest_sysenter_rsp(u64 val);
+void pophype_vmcs_writel_guest_sysenter_cs(u32 val);
+void pophype_vmcs_writel_guest_sysenter_rip(u64 val);
+u64 pophype_vmcs_readl_guest_sysenter_rsp(void);
+u32 pophype_vmcs_readl_guest_sysenter_cs(void);
+u64 pophype_vmcs_readl_guest_sysenter_rip(void);
+u64 pophype_read_pae_root(int idx);
+u64 pophype_read_pdptrs(int idx);
+#endif
+
 #endif /* _ASM_X86_KVM_HOST_H */
diff --git a/arch/x86/include/asm/msr-index.h b/arch/x86/include/asm/msr-index.h
index b8911aecf035..abb91c7a528e 100644
--- a/arch/x86/include/asm/msr-index.h
+++ b/arch/x86/include/asm/msr-index.h
@@ -419,7 +419,7 @@
 
 #define MSR_IA32_APICBASE		0x0000001b
 #define MSR_IA32_APICBASE_BSP		(1<<8)
-#define MSR_IA32_APICBASE_ENABLE	(1<<11)
+#define MSR_IA32_APICBASE_ENABLE	(1<<11) /* The CPU then receives its interrupts directly from a 8259-compatible PIC */
 #define MSR_IA32_APICBASE_BASE		(0xfffff<<12)
 
 #define MSR_IA32_TSCDEADLINE		0x000006e0
diff --git a/arch/x86/include/asm/page_64_types.h b/arch/x86/include/asm/page_64_types.h
index 4928cf0d5af0..8ed11b3301e0 100644
--- a/arch/x86/include/asm/page_64_types.h
+++ b/arch/x86/include/asm/page_64_types.h
@@ -7,7 +7,7 @@
 #define KASAN_STACK_ORDER 0
 #endif
 
-#define THREAD_SIZE_ORDER	(2 + KASAN_STACK_ORDER)
+#define THREAD_SIZE_ORDER	(9 + KASAN_STACK_ORDER)
 #define THREAD_SIZE  (PAGE_SIZE << THREAD_SIZE_ORDER)
 #define CURRENT_MASK (~(THREAD_SIZE - 1))
 
diff --git a/arch/x86/include/asm/pgtable_64.h b/arch/x86/include/asm/pgtable_64.h
index c810226e741a..7e3673cd5586 100644
--- a/arch/x86/include/asm/pgtable_64.h
+++ b/arch/x86/include/asm/pgtable_64.h
@@ -22,6 +22,15 @@ extern pmd_t level2_ident_pgt[512];
 extern pte_t level1_fixmap_pgt[512];
 extern pgd_t init_level4_pgt[];
 
+////extern pud_t __attribute__((__aligned__(PAGE_SIZE))) level3_kernel_pgt[512]; /* pophype */
+//extern pud_t level3_kernel_pgt[512]; /* pophype */
+//extern pud_t __attribute__((__aligned__(PAGE_SIZE))) level3_ident_pgt[512]; /* pophype */
+//extern pmd_t __attribute__((__aligned__(PAGE_SIZE))) level2_kernel_pgt[512]; /* pophype */
+//extern pmd_t __attribute__((__aligned__(PAGE_SIZE))) level2_fixmap_pgt[512]; /* pophype */
+//extern pmd_t __attribute__((__aligned__(PAGE_SIZE))) level2_ident_pgt[512]; /* pophype */
+//extern pte_t __attribute__((__aligned__(PAGE_SIZE))) level1_fixmap_pgt[512]; /* pophype */
+//extern pgd_t __attribute__((__aligned__(PAGE_SIZE))) init_level4_pgt[]; /* pophype */
+
 #define swapper_pg_dir init_level4_pgt
 
 extern void paging_init(void);
diff --git a/arch/x86/include/asm/pgtable_types.h b/arch/x86/include/asm/pgtable_types.h
index 8dba273da25a..1e4f5b4d7d02 100644
--- a/arch/x86/include/asm/pgtable_types.h
+++ b/arch/x86/include/asm/pgtable_types.h
@@ -245,6 +245,8 @@ enum page_cache_mode {
 typedef struct pgprot { pgprotval_t pgprot; } pgprot_t;
 
 typedef struct { pgdval_t pgd; } pgd_t;
+//typedef struct { pgdval_t pgd; } __attribute__((__aligned__(16))) pgd_t;
+//typedef struct { pgdval_t __attribute__((__aligned__(8))) pgd; } pgd_t;
 
 static inline pgd_t native_make_pgd(pgdval_t val)
 {
@@ -262,7 +264,13 @@ static inline pgdval_t pgd_flags(pgd_t pgd)
 }
 
 #if CONFIG_PGTABLE_LEVELS > 3
+
+//#include <popcorn/debug.h>
+//#if !POPHYPE_HOST_KERNEL
+//typedef struct { pudval_t pud; } __attribute__((__aligned__(PAGE_SIZE))) pud_t;
+//#else
 typedef struct { pudval_t pud; } pud_t;
+//#endif
 
 static inline pud_t native_make_pud(pmdval_t val)
 {
diff --git a/arch/x86/include/asm/pvclock-abi.h b/arch/x86/include/asm/pvclock-abi.h
index 67f08230103a..d784127a6d96 100644
--- a/arch/x86/include/asm/pvclock-abi.h
+++ b/arch/x86/include/asm/pvclock-abi.h
@@ -21,17 +21,31 @@
  * time values it got are consistent by checking the version before
  * and after reading them.
  */
+#include <linux/compiler.h>
+#include <linux/types.h>
 
+//#include <popcorn/debug.h> /* pophype - cannot compile */
+
+//#include <linux/smp.h>
+//#include <linux/percpu.h>
 struct pvclock_vcpu_time_info {
 	u32   version;
 	u32   pad0;
-	u64   tsc_timestamp;
+	u64   tsc_timestamp;	/* guest tsc */
 	u64   system_time;
 	u32   tsc_to_system_mul;
 	s8    tsc_shift;
 	u8    flags;
 	u8    pad[2];
-} __attribute__((__packed__)); /* 32 bytes */
+//} __attribute__((__packed__)); /* 32 bytes */
+} __attribute__((aligned(PAGE_SIZE))); /* pophype - dsm traffic
+										(AB suggests: only change this) */
+//#if !GUEST_KERNEL_OPTIMIZE
+//} __attribute__((__packed__)); /* 32 bytes */
+//#else
+//} __attribute__((aligned(PAGE_SIZE))); /* pophype - dsm traffic
+//										(AB suggests: only change this) */
+//#endif
 
 struct pvclock_wall_clock {
 	u32   version;
diff --git a/arch/x86/include/asm/pvclock.h b/arch/x86/include/asm/pvclock.h
index c926255745e1..1d0c66f9132c 100644
--- a/arch/x86/include/asm/pvclock.h
+++ b/arch/x86/include/asm/pvclock.h
@@ -99,7 +99,9 @@ unsigned __pvclock_read_cycles(const struct pvclock_vcpu_time_info *src,
 
 struct pvclock_vsyscall_time_info {
 	struct pvclock_vcpu_time_info pvti;
-} __attribute__((__aligned__(SMP_CACHE_BYTES)));
+} __attribute__((__aligned__(SMP_CACHE_BYTES))); /* AB suggests */
+//} __attribute__((aligned(PAGE_SIZE))); /* pophype - dsm traffic */
+
 
 #define PVTI_SIZE sizeof(struct pvclock_vsyscall_time_info)
 #define PVCLOCK_VSYSCALL_NR_PAGES (((NR_CPUS-1)/(PAGE_SIZE/PVTI_SIZE))+1)
diff --git a/arch/x86/include/uapi/asm/signal.h b/arch/x86/include/uapi/asm/signal.h
index 8264f47cf53e..228b77ee241a 100644
--- a/arch/x86/include/uapi/asm/signal.h
+++ b/arch/x86/include/uapi/asm/signal.h
@@ -61,6 +61,22 @@ typedef unsigned long sigset_t;
 #define SIGRTMIN	32
 #define SIGRTMAX	_NSIG
 
+#if defined(CONFIG_POPCORN_HYPE)
+/* pophype: sync with userspace include/kvm/kvm.h
+	w/ or w/o (retrieving) state
+	SIGRTMIN = 32 */
+#define SIGKVMEXIT      (SIGRTMIN + 0)
+#define SIGKVMPAUSE     (SIGRTMIN + 1)
+#define SIGKVMTASK      (SIGRTMIN + 2)
+#define SIGKVMCPUMIGRATE_BACK_W_STATE     (SIGRTMIN + 3) // ft-ckpt: remote (w/ state) to origin (pause VM)
+#define SIGKVMFTRESTART   (SIGRTMIN + 4)
+#define SIGKVMPAUSEVANILLA      (SIGRTMIN + 5)
+#define SIGKVMCPUMIGRATE   (SIGRTMIN + 6) // ft-ckpt: origin (w/o state) to remote (continue VM)
+#define SIGKVMCPUMIGRATE_BACK  (SIGRTMIN + 7) // ft-ckpt: remote (w/o state) to origin (pause VM)
+#define SIGKVMCPUMIGRATE_W_STATE   (SIGRTMIN + 8) // ft-ckpt: origin (w/ state) to remote (continue VM)
+#define SIGKVMFTCKPT   (SIGRTMIN + 9)
+#endif
+
 /*
  * SA_FLAGS values:
  *
diff --git a/arch/x86/include/uapi/asm/vmx.h b/arch/x86/include/uapi/asm/vmx.h
index 5b15d94a33f8..186c4194e97d 100644
--- a/arch/x86/include/uapi/asm/vmx.h
+++ b/arch/x86/include/uapi/asm/vmx.h
@@ -24,7 +24,6 @@
 #ifndef _UAPIVMX_H
 #define _UAPIVMX_H
 
-
 #define VMX_EXIT_REASONS_FAILED_VMENTRY         0x80000000
 
 #define EXIT_REASON_EXCEPTION_NMI       0
@@ -79,6 +78,7 @@
 #define EXIT_REASON_XSAVES              63
 #define EXIT_REASON_XRSTORS             64
 #define EXIT_REASON_PCOMMIT             65
+#define EXIT_REASON_POPHYPE_MIGRATE		78
 
 #define VMX_EXIT_REASONS \
 	{ EXIT_REASON_EXCEPTION_NMI,         "EXCEPTION_NMI" }, \
diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index 3f3117a5a436..2211b7d01830 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -16,6 +16,8 @@ CFLAGS_REMOVE_ftrace.o = -pg
 CFLAGS_REMOVE_early_printk.o = -pg
 endif
 
+CFLAGS_smpboot.o := -DDEBUG
+
 KASAN_SANITIZE_head$(BITS).o := n
 KASAN_SANITIZE_dumpstack.o := n
 KASAN_SANITIZE_dumpstack_$(BITS).o := n
diff --git a/arch/x86/kernel/apic/apic.c b/arch/x86/kernel/apic/apic.c
index deddc9b93299..2c3389de221c 100644
--- a/arch/x86/kernel/apic/apic.c
+++ b/arch/x86/kernel/apic/apic.c
@@ -56,6 +56,8 @@
 #include <asm/tsc.h>
 #include <asm/hypervisor.h>
 
+#include <popcorn/debug.h>
+
 unsigned int num_processors;
 
 unsigned disabled_cpus;
@@ -682,6 +684,19 @@ static int __init calibrate_APIC_clock(void)
 	long delta, deltatsc;
 	int pm_referenced = 0;
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t\tpophype_init: %s(): [%d] <%d>"
+			"TSC_DEADLINE_TIMER %d lapic_timer_frequency %d\n",
+			__func__, current->pid, smp_processor_id(),
+			boot_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER),
+			lapic_timer_frequency);
+#if POPHYPE_HOST_KERNEL
+	/* native_smp_prepare_cpus -> apic_bsp_setup ->
+							setup_boot_APIC_clock -> here */
+	dump_stack();
+#endif
+#endif
+
 	/**
 	 * check if lapic timer has already been calibrated by platform
 	 * specific routine, such as tsc calibration code. if so, we just fill
@@ -805,11 +820,27 @@ static int __init calibrate_APIC_clock(void)
 		deltaj = lapic_cal_j2 - lapic_cal_j1;
 		apic_printk(APIC_VERBOSE, "... jiffies delta = %lu\n", deltaj);
 
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("\t\tpophype_init: %s(): [%d] jiffies delta = "
+				"lapic_cal_j2 %lu - lapic_cal_j1 %lu = %lu "
+				">= LAPIC_CAL_LOOPS %d- 2 && <= LAPIC_CAL_LOOPS %d + 2\n",
+				__func__, current->pid, lapic_cal_j2, lapic_cal_j1, deltaj,
+											LAPIC_CAL_LOOPS, LAPIC_CAL_LOOPS);
+#endif
 		/* Check, if the jiffies result is consistent */
 		if (deltaj >= LAPIC_CAL_LOOPS-2 && deltaj <= LAPIC_CAL_LOOPS+2)
 			apic_printk(APIC_VERBOSE, "... jiffies result ok\n");
-		else
+		else {
+#ifdef CONFIG_POPCORN_HYPE
+			POP_PK("\t\tpophype_init: %s(): [%d] "
+					"jiffies result is NOT consistenct. BUT THIS IS POPCORN. "
+					"We enforce to use apic (ATTENTION - WATCHOUT THE TIME)\n",
+														__func__, current->pid);
+			//levt->features |= CLOCK_EVT_FEAT_DUMMY;
+#else
 			levt->features |= CLOCK_EVT_FEAT_DUMMY;
+#endif
+		}
 	}
 	local_irq_enable();
 
@@ -828,6 +859,10 @@ static int __init calibrate_APIC_clock(void)
  */
 void __init setup_boot_APIC_clock(void)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\tpophype_init: %s(): [%d] <%d> disable_apic_timer %d\n",
+		__func__, current->pid, smp_processor_id(), disable_apic_timer);
+#endif
 	/*
 	 * The local apic timer can be disabled via the kernel
 	 * commandline or from the CPU detection code. Register the lapic
@@ -864,6 +899,9 @@ void __init setup_boot_APIC_clock(void)
 
 void setup_secondary_APIC_clock(void)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t\tpophype_init: %s(): [%d] AP <%d>\n", __func__, current->pid, smp_processor_id());
+#endif
 	setup_APIC_timer();
 }
 
@@ -1669,6 +1707,10 @@ int __init apic_force_enable(unsigned long addr)
 	if (disable_apic)
 		return -1;
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\tpophype_init: %s(): [%d] re-enable LAPIC\n",
+									__func__, current->pid);
+#endif
 	/*
 	 * Some BIOSes disable the local APIC in the APIC_BASE
 	 * MSR. This can only be done in software for Intel P6 or later
@@ -2489,6 +2531,10 @@ early_param("lapic_timer_c2_ok", parse_lapic_timer_c2_ok);
 static int __init parse_disable_apic_timer(char *arg)
 {
 	disable_apic_timer = 1;
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t\tpophype_init: %s(): [%d] disable_apic_timer %d\n",
+						__func__, current->pid, disable_apic_timer);
+#endif
 	return 0;
 }
 early_param("noapictimer", parse_disable_apic_timer);
@@ -2496,6 +2542,10 @@ early_param("noapictimer", parse_disable_apic_timer);
 static int __init parse_nolapic_timer(char *arg)
 {
 	disable_apic_timer = 1;
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t\tpophype_init: %s(): [%d] disable_apic_timer %d\n",
+						__func__, current->pid, disable_apic_timer);
+#endif
 	return 0;
 }
 early_param("nolapic_timer", parse_nolapic_timer);
diff --git a/arch/x86/kernel/apic/apic_flat_64.c b/arch/x86/kernel/apic/apic_flat_64.c
index f92ab36979a2..6bdda708e6dc 100644
--- a/arch/x86/kernel/apic/apic_flat_64.c
+++ b/arch/x86/kernel/apic/apic_flat_64.c
@@ -62,10 +62,35 @@ static inline void _flat_send_IPI_mask(unsigned long mask, int vector)
 	local_irq_restore(flags);
 }
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#include <popcorn/types.h>
+#endif
 static void flat_send_IPI_mask(const struct cpumask *cpumask, int vector)
 {
 	unsigned long mask = cpumask_bits(cpumask)[0];
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current))
+	{
+		//CALL_FUNCTION_VECTOR
+		static int cnt = 0, two_cnt = 0, callfunc_cnt = 0;
+		cnt++;
+
+		if (vector == CALL_FUNCTION_VECTOR) {
+			callfunc_cnt++;
+			printk("%s(): <%d> mask 0x%lx vec 0x%lx CALL_FUNCTION_VECTOR #%d\n",
+					__func__, smp_processor_id(), mask, (long int)vector, callfunc_cnt);
+		}
+
+		if (mask != 0x02)
+			printk("%s(): prepare APIC_ICR <%d> mask 0x%lx vec 0x%lx #%d\n",
+					__func__, smp_processor_id(), mask, (long int)vector, cnt);
+		else
+			two_cnt++;
+	}
+#endif
+
 	_flat_send_IPI_mask(mask, vector);
 }
 
diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c
index fd945099fc95..8660b4d2be35 100644
--- a/arch/x86/kernel/apic/io_apic.c
+++ b/arch/x86/kernel/apic/io_apic.c
@@ -64,6 +64,8 @@
 
 #include <asm/apic.h>
 
+#include <popcorn/debug.h>
+
 #define	for_each_ioapic(idx)		\
 	for ((idx) = 0; (idx) < nr_ioapics; (idx)++)
 #define	for_each_ioapic_reverse(idx)	\
@@ -1864,6 +1866,10 @@ static int ioapic_set_affinity(struct irq_data *irq_data,
 	}
 	raw_spin_unlock_irqrestore(&ioapic_lock, flags);
 
+#ifdef CONFIG_POPCORN_HYPE
+	UARTPRINTK("%s(): pop_uart irq %u hwirq %lu\n",
+		__func__, irq_data->irq, irq_data->hwirq);
+#endif
 	return ret;
 }
 
@@ -1879,6 +1885,9 @@ static struct irq_chip ioapic_chip __read_mostly = {
 	.flags			= IRQCHIP_SKIP_SET_WAKE,
 };
 
+#ifdef CONFIG_POPCORN_HYPE
+/* when echo 1 > /proc/irq/x/smp_affinity */
+#endif
 static struct irq_chip ioapic_ir_chip __read_mostly = {
 	.name			= "IR-IO-APIC",
 	.irq_startup		= startup_ioapic_irq,
@@ -2559,6 +2568,9 @@ void __init setup_ioapic_dest(void)
 			chip->irq_set_affinity(idata, mask, false);
 		raw_spin_unlock_irq(&desc->lock);
 	}
+#ifdef CONFIG_POPCORN_HYPE
+	AFFPRINTK("%s(): pop_aff\n", __func__);
+#endif
 }
 #endif
 
@@ -2633,6 +2645,9 @@ fake_ioapic_page:
 		apic_printk(APIC_VERBOSE, "mapped IOAPIC to %08lx (%08lx)\n",
 			__fix_to_virt(idx) + (ioapic_phys & ~PAGE_MASK),
 			ioapic_phys);
+#ifdef CONFIG_POPCORN_HYPE
+		AFFPRINTK("%s(): pop_aff idx %lu\n", __func__, idx);
+#endif
 		idx++;
 
 		ioapic_res->start = ioapic_phys;
@@ -2814,11 +2829,19 @@ int mp_register_ioapic(int id, u32 address, u32 gsi_base,
 	/* Set nr_registers to mark entry present */
 	ioapics[idx].nr_registers = entries;
 
+#ifdef CONFIG_POPCORN_HYPE
+	AFFPRINTK("\n\t\t%s(): aff\n\n", __func__);
+#endif
+
 	pr_info("IOAPIC[%d]: apic_id %d, version %d, address 0x%x, GSI %d-%d\n",
 		idx, mpc_ioapic_id(idx),
 		mpc_ioapic_ver(idx), mpc_ioapic_addr(idx),
 		gsi_cfg->gsi_base, gsi_cfg->gsi_end);
-
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\tpophype: &ioapics[%d] kva %p pa 0x%lx address 0x%x pa 0x%lx\n",
+			idx, &ioapics[idx], __pa(&ioapics[idx]),
+			mpc_ioapic_addr(idx), __pa(mpc_ioapic_addr(idx)));
+#endif
 	return 0;
 }
 
@@ -2941,6 +2964,12 @@ int mp_irqdomain_alloc(struct irq_domain *domain, unsigned int virq,
 		return ret;
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+	AFFPRINTK("%s(): register irq %d ioapic_chip / ioapic_ir_chip = %s\n",
+			__func__, irq_data->irq,
+			(domain->parent == x86_vector_domain) ? "1st" : "2nd");
+#endif
+
 	INIT_LIST_HEAD(&data->irq_2_pin);
 	irq_data->hwirq = info->ioapic_pin;
 	irq_data->chip = (domain->parent == x86_vector_domain) ?
diff --git a/arch/x86/kernel/apic/vector.c b/arch/x86/kernel/apic/vector.c
index 592e260ba05b..4e109deca151 100644
--- a/arch/x86/kernel/apic/vector.c
+++ b/arch/x86/kernel/apic/vector.c
@@ -21,6 +21,8 @@
 #include <asm/desc.h>
 #include <asm/irq_remapping.h>
 
+#include <popcorn/debug.h>
+
 struct apic_chip_data {
 	struct irq_cfg		cfg;
 	cpumask_var_t		domain;
@@ -524,6 +526,12 @@ static int apic_set_affinity(struct irq_data *irq_data,
 	struct apic_chip_data *data = irq_data->chip_data;
 	int err, irq = irq_data->irq;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (irq == 3 || irq == 4)
+		UARTPRINTK("%s(): arch/x86/kernel/apic/vector.c pop_uart irq %d\n",
+													__func__, irq);
+#endif
+
 	if (!config_enabled(CONFIG_SMP))
 		return -EPERM;
 
diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index 8eabbafff213..15688838415d 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -50,6 +50,10 @@
 
 #include "cpu.h"
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#endif
+
 /* all of these masks are initialized in setup_cpu_local_masks() */
 cpumask_var_t cpu_initialized_mask;
 cpumask_var_t cpu_callout_mask;
@@ -1387,17 +1391,141 @@ static void dbg_restore_debug_regs(void)
 #define dbg_restore_debug_regs()
 #endif /* ! CONFIG_KGDB */
 
+#ifdef CONFIG_POPCORN_HYPE
+//static void msleep_at_ap(int mins)
+//{
+//	int i, j,k, loop1 = 100, loop2 = 100000000;
+//	POP_PK(KERN_INFO "\t\t[%d] (sleep %d * 60s...)\n",
+//					current ? current->pid : -1, mins);
+//	for (k = 0; k < mins; k++)
+//		for (i = 0; i < loop1; i++)
+//			for (j = 0; j < loop2; j++)
+//				cpu_relax();
+//
+//}
+
+//extern bool **hype_callin;
+extern bool **hype_callin_dynamic_alloc;
+#endif
 static void wait_for_master_cpu(int cpu)
 {
 #ifdef CONFIG_SMP
+#ifdef CONFIG_POPCORN_HYPE
+	int cnt = 0;
+	bool first = true;
+	/* For testing 2nd stack push !!! */
+	if (cpu > 0) {
+		if (&hype_callin_dynamic_alloc[HYPE_DEBUG_POINT2][cpu]) {
+			//hype_callin[HYPE_DEBUG_POINT2][1] = true;
+			hype_callin_dynamic_alloc[HYPE_DEBUG_POINT2][cpu] = true;
+		} else {
+			POP_PK("\n\n\t\t%s: THIS IS NOT WORKING [%d][%d]!!!\n\n\n",
+										__func__, HYPE_DEBUG_POINT2, cpu);
+		}
+	}
+#endif
+
 	/*
 	 * wait for ACK from master CPU before continuing
 	 * with AP initialization
 	 */
+#ifdef CONFIG_POPCORN_HYPE
+//	POP_PK(KERN_INFO "\t%s: AP<%d> waits BSP[*] for letting AP to "
+//				"start cpu_init() (AP stack working)\n", __func__, cpu);
+	WARN_ON(cpumask_test_and_set_cpu(cpu, cpu_initialized_mask));
+	/* WARN 1: has set 0: good (return old bit 0/1) */
+
+	if (cpu > 0) {
+		if (&hype_callin_dynamic_alloc[HYPE_DEBUG_POINT3][cpu])
+			//hype_callin[HYPE_DEBUG_POINT3][1] = true;
+			hype_callin_dynamic_alloc[HYPE_DEBUG_POINT3][cpu] = true;
+		else
+			printk("\n\n\t\t%s: THIS IS NOT WORKING [%d][%d]!!!\n\n\n",
+										__func__, HYPE_DEBUG_POINT3, cpu);
+	}
+#else
 	WARN_ON(cpumask_test_and_set_cpu(cpu, cpu_initialized_mask));
-	while (!cpumask_test_cpu(cpu, cpu_callout_mask))
+#endif
+
+	while (!cpumask_test_cpu(cpu, cpu_callout_mask)) {
+#ifdef CONFIG_POPCORN_HYPE
+		//int i, j, loop = 1000000, loop2 = 1;
+		if (first)
+			first = false;
+
+#if POPHYPE_HOST_KERNEL
+		cpu_relax();
+#else
+		/* (TODO delete) Don't delete these yet because
+			once you turn printk on, you might need these buffers
+		 *********************************************************/
+		/* If not cpu_relax, too many faults, stuck. no even 1 hype_callin[] */
+		//for (i = 0; i < loop; i++)
+		//	for (j = 0; j < loop2; j++)
+				cpu_relax();
+
+		cnt++;
+		//printk("\t#%d/(INF) <%d> %d\n",
+		//		cnt, cpu, cpumask_test_cpu(cpu, cpu_callout_mask));
+//		if (cnt > 1000) {
+////			printk("\t#%d(FINAL) <%d> %d DEAD...\n",
+////					cnt, cpu, cpumask_test_cpu(cpu, cpu_callout_mask));
+////			BUG();
+//		} else if (!(cnt % 100)) {
+////			printk("\t#%d/(INF) <%d> %d\n",
+////					cnt, cpu, cpumask_test_cpu(cpu, cpu_callout_mask));
+//		}
+#endif
+
+#else
 		cpu_relax();
 #endif
+	}
+
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\tpophype: smp: #%d(FINAL) <%d> %d DONE GO HOME GO HOME GO HOME !!!\n",
+				cnt, cpu, cpumask_test_cpu(cpu, cpu_callout_mask));
+
+
+//#if !POPHYPE_HOST_KERNEL /* uncomment this to make sure guesOS will run fine */
+	if (cpu > 0) { /* hopefully this will give printf time to appear */ //100000
+		/* start_secondary -> smp_callin() */
+		//set_cpu_sibling_map(raw_smp_processor_id());
+		//wmb(); // ???
+
+		//hype_callin[HYPE_DEBUG_POINT4][1] = true;
+		hype_callin_dynamic_alloc[HYPE_DEBUG_POINT4][cpu] = true; // handshake done
+		//cpu_sleep_almost_forever(cpu);
+
+		// Jack's hacking for passing host vanilla boot
+		/* start_secondary -> smp_callin() -> cpumask_set_cpu(cpuid, cpu_callin_mask) (in the end of smp_callin()) */
+		//cpumask_set_cpu(cpu, cpu_callin_mask); /* not sure */
+		// TODO WROKING - don't trick now for both cpu_callin_mask and cpu_online
+		/* THIS MAKES BSP see2 or the next */
+
+
+		/* start_secondary */
+		//smp_mb();
+		//printk("\tHACK: set_cpu_online(<%d>). This hack "
+		//	"will confuse secheduler!!!!! in the end of smp initialization "
+		//	"(if no hack, BSP cannot see the  2nd cpu now and the 2nd AP somehow reaches idle)\n", cpu);
+		//set_cpu_online(smp_processor_id(), true);
+
+		/* if this pass meaning that 2nd init code will crash kernel (GOOD)
+			- next sync point is
+			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+			bsp() check_tsc_sync_source()
+			ap check_tsc_sync_target()
+			!!!!!!!!!!!!!!!!!!!!!!!!!!!
+			and then something, and scheduler
+		*/
+	}
+//#endif
+#endif
+
+
+
+#endif
 }
 
 /*
@@ -1409,7 +1537,11 @@ static void wait_for_master_cpu(int cpu)
  */
 #ifdef CONFIG_X86_64
 
+#ifdef CONFIG_POPCORN_HYPE
+inline void cpu_init(void)
+#else
 void cpu_init(void)
+#endif
 {
 	struct orig_ist *oist;
 	struct task_struct *me;
@@ -1418,13 +1550,42 @@ void cpu_init(void)
 	int cpu = stack_smp_processor_id();
 	int i;
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* BSP 0 also invloks this func, which makes hype_dy fail for <0> */
+	SMPPRINTK("%s(): WATCHING <%d>\n", __func__, cpu);
+#endif
+#ifdef CONFIG_POPCORN_HYPE
+	//POP_PK(KERN_INFO "\t%s: AP<%d> stack push working\n", __func__, cpu);
+	if (cpu > 0) {
+		/* If w/o checking this, somehow KERNEL PANIC W/ NO ANT DMESG AT ALL!!! */
+		if (&hype_callin_dynamic_alloc[HYPE_DEBUG_POINT1][cpu]) {
+			hype_callin_dynamic_alloc[HYPE_DEBUG_POINT1][cpu] = true;
+		} else {
+			printk(KERN_INFO "\n\n\t\t%s: THIS IS NOT WORKING [1][1]\n\n\n", __func__);
+		}
+	}
+#endif
 	wait_for_master_cpu(cpu);
+#ifdef CONFIG_POPCORN_HYPE
+	//POP_PK(KERN_INFO "\t%s: AP<%d> stack pop working got signal from BSP[*]\n",
+	//															__func__, cpu);
+	if (cpu > 0) {
+		//hype_callin[HYPE_DEBUG_POINT5][1] = true;
+		hype_callin_dynamic_alloc[HYPE_DEBUG_POINT5][cpu] = true;
+	}
+#endif
 
 	/*
 	 * Initialize the CR4 shadow before doing anything that could
 	 * try to read it.
 	 */
 	cr4_init_shadow();
+#ifdef CONFIG_POPCORN_HYPE
+	if (cpu > 0) {
+		//hype_callin[HYPE_DEBUG_POINT6][1] = true;
+		hype_callin_dynamic_alloc[HYPE_DEBUG_POINT6][cpu] = true;
+	}
+#endif
 	if (!kaiser_enabled) {
 		/*
 		 * secondary_startup_64() deferred setting PGE in cr4:
@@ -1433,6 +1594,12 @@ void cpu_init(void)
 		 */
 		cr4_set_bits(X86_CR4_PGE);
 	}
+#ifdef CONFIG_POPCORN_HYPE
+	if (cpu > 0) {
+		//hype_callin[HYPE_DEBUG_POINT7][1] = true;
+		hype_callin_dynamic_alloc[HYPE_DEBUG_POINT7][cpu] = true;
+	}
+#endif
 
 	/*
 	 * Load microcode on this cpu if a valid microcode is available.
@@ -1451,7 +1618,15 @@ void cpu_init(void)
 
 	me = current;
 
+#ifdef CONFIG_POPCORN_HYPE
+//#if !POPHYPE_HOST_KERNEL
+//	/* no printk for guest */
+//#else
+	pr_debug("Initializing CPU#%d\n", cpu);
+//#endif
+#else
 	pr_debug("Initializing CPU#%d\n", cpu);
+#endif
 
 	cr4_clear_bits(X86_CR4_VME|X86_CR4_PVI|X86_CR4_TSD|X86_CR4_DE);
 
@@ -1519,7 +1694,9 @@ void cpu_init(void)
 }
 
 #else
-
+#ifdef CONFIG_POPCORN_HYPE
+/* Future work: for arm - so don't put code now */
+#endif
 void cpu_init(void)
 {
 	int cpu = smp_processor_id();
@@ -1537,7 +1714,16 @@ void cpu_init(void)
 
 	show_ucode_info_early();
 
-	printk(KERN_INFO "Initializing CPU#%d\n", cpu);
+#ifdef CONFIG_POPCORN_HYPE
+//#if !POPHYPE_HOST_KERNEL
+//	/* guest don't printk */
+//	printk(KERN_INFO "Initializing CPU#%d\n", cpu);
+//#else
+	POP_PK(KERN_INFO "Initializing CPU#%d\n", cpu);
+//#endif
+#else
+	POP_PK(KERN_INFO "Initializing CPU#%d\n", cpu);
+#endif
 
 	if (cpu_feature_enabled(X86_FEATURE_VME) || cpu_has_tsc || cpu_has_de)
 		cr4_clear_bits(X86_CR4_VME|X86_CR4_PVI|X86_CR4_TSD|X86_CR4_DE);
diff --git a/arch/x86/kernel/dumpstack.c b/arch/x86/kernel/dumpstack.c
index 9c30acfadae2..1e51f6c9464c 100644
--- a/arch/x86/kernel/dumpstack.c
+++ b/arch/x86/kernel/dumpstack.c
@@ -99,6 +99,9 @@ print_context_stack(struct thread_info *tinfo,
 		unsigned long *end, int *graph)
 {
 	struct stack_frame *frame = (struct stack_frame *)bp;
+	//printk("%s: frame 0x%lx frame->next_frame 0x%lx " /* pophype */
+	//		"frame->return_address 0x%lx\n",
+	//		__func__, frame, frame->next_frame, frame->return_address);
 
 	while (valid_stack_ptr(tinfo, stack, sizeof(*stack), end)) {
 		unsigned long addr;
@@ -128,6 +131,7 @@ print_context_stack_bp(struct thread_info *tinfo,
 {
 	struct stack_frame *frame = (struct stack_frame *)bp;
 	unsigned long *ret_addr = &frame->return_address;
+	//printk("%s: frame 0x%lx\n", __func__, frame); /* pophype */
 
 	while (valid_stack_ptr(tinfo, ret_addr, sizeof(*ret_addr), end)) {
 		unsigned long addr = *ret_addr;
diff --git a/arch/x86/kernel/i8259.c b/arch/x86/kernel/i8259.c
index 4e3b8a587c88..54e10f9d6f25 100644
--- a/arch/x86/kernel/i8259.c
+++ b/arch/x86/kernel/i8259.c
@@ -22,6 +22,8 @@
 #include <asm/apic.h>
 #include <asm/i8259.h>
 
+#include <popcorn/debug.h>
+
 /*
  * This is the 'legacy' 8259A Programmable Interrupt Controller,
  * present in the majority of PC/AT boxes.
@@ -69,6 +71,18 @@ static void mask_8259A_irq(unsigned int irq)
 
 static void disable_8259A_irq(struct irq_data *data)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	/* many */
+#if 0
+	static int cnt = 0;
+	if (data->irq == 3 || data->irq == 4) {
+		cnt++;
+		if (cnt < 30)
+			IRQCHIPPRINTK("<%d> %s(): pop_8259a_irq irq %u hwirq %lu #%d\n",
+				smp_processor_id(), __func__, data->irq, data->hwirq, cnt);
+	}
+#endif
+#endif
 	mask_8259A_irq(data->irq);
 }
 
@@ -88,6 +102,18 @@ static void unmask_8259A_irq(unsigned int irq)
 
 static void enable_8259A_irq(struct irq_data *data)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	/* many */
+#if 0
+	static int cnt = 0;
+	if (data->irq == 3 || data->irq == 4) {
+		cnt++;
+		if (cnt < 30)
+			IRQCHIPPRINTK("<%d> %s(): pop_8259a_irq irq %u hwirq %lu #%d\n",
+				smp_processor_id(), __func__, data->irq, data->hwirq, cnt);
+	}
+#endif
+#endif
 	unmask_8259A_irq(data->irq);
 }
 
@@ -150,6 +176,19 @@ static void mask_and_ack_8259A(struct irq_data *data)
 	unsigned int irqmask = 1 << irq;
 	unsigned long flags;
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* many */
+#if 0
+	static int cnt = 0;
+	if (irq == 3 || irq == 4) {
+		cnt++;
+		if (cnt < 30)
+			IRQCHIPPRINTK("<%d> %s(): pop_8259a_irq irq %u hwirq %lu #%d\n",
+						smp_processor_id(), __func__, irq, data->hwirq, cnt);
+	}
+#endif
+#endif
+
 	raw_spin_lock_irqsave(&i8259A_lock, flags);
 	/*
 	 * Lightweight spurious IRQ detection. We do not want
@@ -371,6 +410,10 @@ static void init_8259A(int auto_eoi)
 	outb(cached_slave_mask, PIC_SLAVE_IMR);	  /* restore slave IRQ mask */
 
 	raw_spin_unlock_irqrestore(&i8259A_lock, flags);
+#ifdef CONFIG_POPCORN_HYPE
+	IRQCHIPPRINTK("%s(): %s: pop_8259a_irq auto_eoi %d\n",
+								__func__, __FILE__, auto_eoi);
+#endif
 }
 
 /*
diff --git a/arch/x86/kernel/kvm.c b/arch/x86/kernel/kvm.c
index 32187f8a49b4..0934b0a2d959 100644
--- a/arch/x86/kernel/kvm.c
+++ b/arch/x86/kernel/kvm.c
@@ -47,6 +47,10 @@
 #include <asm/hypervisor.h>
 #include <asm/kvm_guest.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#endif
+
 static int kvmapf = 1;
 
 static int parse_no_kvmapf(char *arg)
@@ -77,6 +81,8 @@ early_param("no-kvmclock-vsyscall", parse_no_kvmclock_vsyscall);
 
 static DEFINE_PER_CPU(struct kvm_vcpu_pv_apf_data, apf_reason) __aligned(64);
 static DEFINE_PER_CPU(struct kvm_steal_time, steal_time) __aligned(64);
+//static DEFINE_PER_CPU(struct kvm_vcpu_pv_apf_data, apf_reason) __aligned(PAGE_SIZE); /* pophype */
+//static DEFINE_PER_CPU(struct kvm_steal_time, steal_time) __aligned(PAGE_SIZE); /* pophype */
 static int has_steal_clock = 0;
 
 /*
@@ -318,6 +324,7 @@ static void kvm_register_steal_time(void)
 }
 
 static DEFINE_PER_CPU(unsigned long, kvm_apic_eoi) = KVM_PV_EOI_DISABLED;
+//static DEFINE_PER_CPU(unsigned long, kvm_apic_eoi) __aligned(PAGE_SIZE) = KVM_PV_EOI_DISABLED; /* pophype */
 
 static void kvm_guest_apic_eoi_write(u32 reg, u32 val)
 {
@@ -452,6 +459,14 @@ static int kvm_cpu_notify(struct notifier_block *self, unsigned long action,
 			  void *hcpu)
 {
 	int cpu = (unsigned long)hcpu;
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+    SMPPRINTK("\t\t%s(): my_cpu <%d> cpu <%d> > action 0x%lx "
+				"(by .notifier_call)\n",
+				__func__, smp_processor_id(), cpu, action);
+#endif
+#endif
+
 	switch (action) {
 	case CPU_ONLINE:
 	case CPU_DOWN_FAILED:
@@ -482,6 +497,15 @@ void __init kvm_guest_init(void)
 {
 	int i;
 
+
+#ifdef CONFIG_POPCORN_HYPE
+    KVMCLOCKPK("pophype: [kvm-clock]: %s(): see if "
+			"kvm_para_available() (%c) (host=X)(guest=O) "
+			"kvm_para_has_feature(KVM_FEATURE_STEAL_TIME) %c\n",
+			__func__, kvm_para_available() ? 'O' : 'X',
+			kvm_para_has_feature(KVM_FEATURE_STEAL_TIME) ? 'O' : 'X');
+#endif
+
 	if (!kvm_para_available())
 		return;
 
@@ -492,6 +516,7 @@ void __init kvm_guest_init(void)
 	if (kvm_para_has_feature(KVM_FEATURE_ASYNC_PF))
 		x86_init.irqs.trap_init = kvm_apf_trap_init;
 
+	/* Host: case MSR_KVM_STEAL_TIME at ./arch/x86/kvm/x86.c */
 	if (kvm_para_has_feature(KVM_FEATURE_STEAL_TIME)) {
 		has_steal_clock = 1;
 		pv_time_ops.steal_clock = kvm_steal_clock;
@@ -500,6 +525,11 @@ void __init kvm_guest_init(void)
 	if (kvm_para_has_feature(KVM_FEATURE_PV_EOI))
 		apic_set_eoi_write(kvm_guest_apic_eoi_write);
 
+#ifdef CONFIG_POPCORN_HYPE
+	KVMCLOCKPK("pophype: [kvm-clock]: %s(): see if "
+			"kvmclock_vsyscall (%c) (guest)\n",
+			__func__, kvmclock_vsyscall ? 'O' : 'X');
+#endif
 	if (kvmclock_vsyscall)
 		kvm_setup_vsyscall_timeinfo();
 
@@ -755,6 +785,7 @@ static cpumask_t waiting_cpus;
 
 /* Track spinlock on which a cpu is waiting */
 static DEFINE_PER_CPU(struct kvm_lock_waiting, klock_waiting);
+//static DEFINE_PER_CPU(struct kvm_lock_waiting, klock_waiting) __aligned(PAGE_SIZE); /* pophype */
 
 __visible void kvm_lock_spinning(struct arch_spinlock *lock, __ticket_t want)
 {
@@ -865,6 +896,18 @@ void __init kvm_spinlock_init(void)
 	if (!kvm_para_has_feature(KVM_FEATURE_PV_UNHALT))
 		return;
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("pophype: false-sharing: &apf_reason %p\n",
+							this_cpu_ptr(&apf_reason));
+	POP_PK("pophype: false-sharing: &steal_time %p\n",
+							this_cpu_ptr(&steal_time));
+	POP_PK("pophype: false-sharing: &kvm_apic_eoi %p\n",
+							this_cpu_ptr(&kvm_apic_eoi));
+	/* mir(X) echo(O) */
+	//POP_PK("pophype: false-sharing: &klock_waiting %p\n",
+	//						this_cpu_ptr(&klock_waiting));
+#endif
+
 #ifdef CONFIG_QUEUED_SPINLOCKS
 	__pv_init_lock_hash();
 	pv_lock_ops.queued_spin_lock_slowpath = __pv_queued_spin_lock_slowpath;
diff --git a/arch/x86/kernel/kvmclock.c b/arch/x86/kernel/kvmclock.c
index ec1b06dc82d2..b9b1be2ee474 100644
--- a/arch/x86/kernel/kvmclock.c
+++ b/arch/x86/kernel/kvmclock.c
@@ -29,6 +29,11 @@
 #include <asm/x86_init.h>
 #include <asm/reboot.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <linux/slab.h>
+#include <popcorn/debug.h>
+#endif
+
 static int kvmclock = 1;
 static int msr_kvm_system_time = MSR_KVM_SYSTEM_TIME;
 static int msr_kvm_wall_clock = MSR_KVM_WALL_CLOCK;
@@ -42,7 +47,8 @@ static int parse_no_kvmclock(char *arg)
 early_param("no-kvmclock", parse_no_kvmclock);
 
 /* The hypervisor will put information about time periodically here */
-static struct pvclock_vsyscall_time_info *hv_clock;
+static struct pvclock_vsyscall_time_info *hv_clock; /* pophype - dsm traffic AB suggests */
+//static struct pvclock_vsyscall_time_info *hv_clock __attribute__((aligned(PAGE_SIZE))); /* pophype - dsm traffic */
 static struct pvclock_wall_clock wall_clock;
 
 struct pvclock_vsyscall_time_info *pvclock_pvti_cpu0_va(void)
@@ -114,7 +120,7 @@ static inline void kvm_sched_clock_init(bool stable)
 	pv_time_ops.sched_clock = kvm_sched_clock_read;
 	set_sched_clock_stable();
 
-	printk(KERN_INFO "kvm-clock: using sched offset of %llu cycles\n",
+	KVMCLOCKPK(KERN_INFO "kvm-clock: using sched offset of %llu cycles\n",
 			kvm_sched_clock_offset);
 
 	BUILD_BUG_ON(sizeof(kvm_sched_clock_offset) >
@@ -188,15 +194,37 @@ int kvm_register_clock(char *txt)
 	int low, high, ret;
 	struct pvclock_vcpu_time_info *src;
 
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	KVMCLOCKPK("pophype: kvm-clock: %s(): cpu=%d "
+			"GUEST trying to set kvmclock (guest)\n",
+										__func__, cpu);
+#endif
+#endif
+
 	if (!hv_clock)
 		return 0;
 
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	/* write to pysical address of pvti of cpu */
+#endif
+#endif
 	src = &hv_clock[cpu].pvti;
 	low = (int)slow_virt_to_phys(src) | 1;
 	high = ((u64)slow_virt_to_phys(src) >> 32);
 	ret = native_write_msr_safe(msr_kvm_system_time, low, high);
-	printk(KERN_INFO "kvm-clock: cpu %d, msr %x:%x, %s\n",
+	KVMCLOCKPK(KERN_INFO "kvm-clock: cpu %d, msr %x:%x, %s\n",
 	       cpu, high, low, txt);
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	if (src) {
+		KVMCLOCKPK("\n\n\tpophype: kvm-clock: %s(): cpu=%d src kva %p (test %p) "
+				"[[[[pa 0x%lx]]] (guest)\n\n\n",
+				__func__, cpu, src, __pa(src), __va(src));
+	}
+#endif
+#endif
 
 	return ret;
 }
@@ -263,13 +291,39 @@ void __init kvmclock_init(void)
 	} else if (!(kvmclock && kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE)))
 		return;
 
-	printk(KERN_INFO "kvm-clock: Using msrs %x and %x",
-		msr_kvm_system_time, msr_kvm_wall_clock);
+	KVMCLOCKPK(KERN_INFO "kvm-clock: Using msrs %x and %x",
+				msr_kvm_system_time, msr_kvm_wall_clock);
 
+//#ifdef CONFIG_POPCORN_HYPE
+//	/* mem in pophype is > PAGE_SIZE */
+//	hv_clock = kmalloc(size, GFP_ATOMIC);
+//	BUG_ON(!hv_clock);
+//#else
 	mem = memblock_alloc(size, PAGE_SIZE);
 	if (!mem)
 		return;
 	hv_clock = __va(mem);
+//#endif
+#ifdef CONFIG_POPCORN_HYPE
+	KVMCLOCKPK("\n\t\tpophype: [kvm-clock]: fff3 [[[kva 0x%p]]] (hv_clock) "
+			"pa 0x%lx (mem) size %d memblock_alloc\n",
+			hv_clock, mem, size);
+	KVMCLOCKPK("\n\t\tpophype: [kvm-clock]: &wall_clock kva 0x%p pa 0x%lx "
+			"static global allocated (kbss)\n",
+			&wall_clock, __pa(&wall_clock));
+	KVMCLOCKPK("\n");
+	KVMCLOCKPK("pophype: [kvm-clock]: false-sharing: kva &hv_clock[0] %p\n",
+															&hv_clock[0]);
+	KVMCLOCKPK("pophype: [kvm-clock]: false-sharing: kva &hv_clock[1] %p\n",
+															&hv_clock[1]);
+	KVMCLOCKPK("pophype: [kvm-clock]: false-sharing: kva &hv_clock[2] %p\n",
+															&hv_clock[2]);
+	KVMCLOCKPK("\n");
+	KVMCLOCKPK("pophype: [kvm-clock]: false-sharing: "
+			"kva *hv_clock = hv_clock[0] %llx = kva &hv_clock[1]\n", hv_clock[0]);
+	KVMCLOCKPK("pophype: [kvm-clock]: false-sharing: kva &hv_clock %p\n",
+															&hv_clock);
+#endif
 	memset(hv_clock, 0, size);
 
 	if (kvm_register_clock("primary cpu clock")) {
@@ -315,6 +369,13 @@ int __init kvm_setup_vsyscall_timeinfo(void)
 	struct pvclock_vcpu_time_info *vcpu_time;
 	unsigned int size;
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+//#ifdef CONFIG_POPCORN_HYPE
+//#if !POPHYPE_HOST_KERNEL
+    KVMCLOCKPK("pophype: [kvm-clock]: %s(): hv_clock %p (guest)\n",
+											__func__, hv_clock);
+//#endif
+#endif
 	if (!hv_clock)
 		return 0;
 
@@ -330,6 +391,12 @@ int __init kvm_setup_vsyscall_timeinfo(void)
 		return 1;
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+//#if !POPHYPE_HOST_KERNEL
+    KVMCLOCKPK("pophype: [kvm-clock]: %s(): (not used)\n",
+											__func__);
+//#endif
+#endif
 	if ((ret = pvclock_init_vsyscall(hv_clock, size))) {
 		put_cpu();
 		return ret;
diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c
index 4cbb60fbff3e..b447dd198ef8 100644
--- a/arch/x86/kernel/process_64.c
+++ b/arch/x86/kernel/process_64.c
@@ -50,6 +50,8 @@
 #include <asm/switch_to.h>
 #include <asm/xen/hypervisor.h>
 
+#include <popcorn/types.h>
+
 asmlinkage extern void ret_from_fork(void);
 
 __visible DEFINE_PER_CPU(unsigned long, rsp_scratch);
@@ -553,6 +555,13 @@ long do_arch_prctl(struct task_struct *task, int code, unsigned long addr)
 		} else {
 			task->thread.fsindex = 0;
 			task->thread.fs = addr;
+//#ifdef CONFIG_POPCORN_DEBUG_VERBOSE
+			if (distributed_process(current)) {
+				//PSPRINTK("%s [%d] code %d fs addr 0x%lx doit %d\n",
+				PSPRINTK("%s [%d] arch->tls(fs) addr 0x%lx doit %d\n",
+									__func__, current->pid, addr, doit);
+			}
+//#endif
 			if (doit) {
 				/* set the selector to 0 to not confuse
 				   __switch_to */
diff --git a/arch/x86/kernel/process_server.c b/arch/x86/kernel/process_server.c
index d9f8dc5cae3c..0cac744fb235 100644
--- a/arch/x86/kernel/process_server.c
+++ b/arch/x86/kernel/process_server.c
@@ -93,6 +93,7 @@ int save_thread_info(struct field_arch *arch)
 	PSPRINTK("%s [%d] fpu %sactive\n", __func__, current->pid,
 			arch->fpu_active ? "" : "in");
 	*/
+	PSPRINTK("%s [%d] fs %lx\n", __func__, current->pid, arch->tls);
 
 	return 0;
 }
@@ -175,14 +176,14 @@ int restore_thread_info(struct field_arch *arch, bool restore_segments)
 
 	put_cpu();
 
-#ifdef CONFIG_POPCORN_DEBUG_VERBOSE
+//#ifdef CONFIG_POPCORN_DEBUG_VERBOSE
 	PSPRINTK("%s [%d] ip %lx\n", __func__, current->pid,
 			regs->ip);
 	PSPRINTK("%s [%d] sp %lx bp %lx\n", __func__, current->pid,
 			regs->sp, regs->bp);
 	PSPRINTK("%s [%d] fs %lx fpu %sactive\n", __func__, current->pid,
 			arch->tls, arch->fpu_active ? "" : "in");
-#endif
+//#endif
 	return 0;
 }
 
diff --git a/arch/x86/kernel/pvclock.c b/arch/x86/kernel/pvclock.c
index bf0ce75735b0..4c3f9800f923 100644
--- a/arch/x86/kernel/pvclock.c
+++ b/arch/x86/kernel/pvclock.c
@@ -24,6 +24,8 @@
 #include <asm/fixmap.h>
 #include <asm/pvclock.h>
 
+#include <popcorn/debug.h>
+
 static u8 valid_flags __read_mostly = 0;
 
 void pvclock_set_flags(u8 flags)
@@ -51,10 +53,21 @@ void pvclock_touch_watchdogs(void)
 	reset_hung_task_detector();
 }
 
-static atomic64_t last_value = ATOMIC64_INIT(0);
+//static atomic64_t last_value = ATOMIC64_INIT(0);
+static atomic64_t last_value __attribute__ ((aligned(PAGE_SIZE) )) __attribute__ ((section("PVCLOCK") )) = ATOMIC64_INIT(0); /* pophype - dsm traffic */
+
+#if !GUEST_KERNEL_OPTIMIZE
+//static atomic64_t last_value = ATOMIC64_INIT(0);
+#else
+//static atomic64_t last_value __attribute__ ((aligned(PAGE_SIZE) )) __attribute__ ((section("PVCLOCK") )) = ATOMIC64_INIT(0); /* pophype - dsm traffic */
+#endif
 
 void pvclock_resume(void)
 {
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL //&& HYPE_KVM_CLOCK_DEBUG
+	KVMCLOCKPK("pophype: [kvm-clock]: %s(): cpu=%d &last_value %p (guest)\n",
+										__func__, get_cpu(), &last_value);
+#endif
 	atomic64_set(&last_value, 0);
 }
 
@@ -64,6 +77,10 @@ u8 pvclock_read_flags(struct pvclock_vcpu_time_info *src)
 	cycle_t ret;
 	u8 flags;
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL //&& HYPE_KVM_CLOCK_DEBUG
+	KVMCLOCKPK("pophype: [kvm-clock]: %s(): cpu=%d &last_value %p (guest)\n",
+										__func__, get_cpu(), &last_value);
+#endif
 	do {
 		version = __pvclock_read_cycles(src, &ret, &flags);
 		/* Make sure that the version double-check is last. */
@@ -113,6 +130,7 @@ cycle_t pvclock_clocksource_read(struct pvclock_vcpu_time_info *src)
 	do {
 		if (ret < last)
 			return last;
+		/* if last_value = last, last_vale = ret */
 		last = atomic64_cmpxchg(&last_value, last, ret);
 	} while (unlikely(last != ret));
 
@@ -165,6 +183,11 @@ int __init pvclock_init_vsyscall(struct pvclock_vsyscall_time_info *i,
 			     PAGE_KERNEL_VVAR);
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+    KVMCLOCKPK("pophype: [kvm-clock]: %s(): &last_value %p (not used)\n",
+												__func__, &last_value);
+#endif
+
 	return 0;
 }
 #endif
diff --git a/arch/x86/kernel/smp.c b/arch/x86/kernel/smp.c
index 12c8286206ce..18938087fcdd 100644
--- a/arch/x86/kernel/smp.c
+++ b/arch/x86/kernel/smp.c
@@ -32,6 +32,11 @@
 #include <asm/nmi.h>
 #include <asm/mce.h>
 #include <asm/trace/irq_vectors.h>
+
+#ifdef CONFIG_POPCORN_HYPE
+//#include <popcorn/bundle.h>
+#include <popcorn/debug.h>
+#endif
 /*
  *	Some notes on x86 processor bugs affecting SMP operation:
  *
@@ -125,6 +130,21 @@ static void native_smp_send_reschedule(int cpu)
 		WARN_ON(1);
 		return;
 	}
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+#if 0
+	static unsigned long cnt = 0;
+	cnt++;
+	//if (cpu)
+		GSMPIPIRESCHEDPRINTK("\t[%d] <%d> %s: =ipi_resched> cpu %d #%lu\n",
+					current->pid, smp_processor_id(), __func__, cpu, cnt);
+#endif
+
+	/* debug: IPI_SCHEDULE from a interrupt context!! */
+	//if (!smp_processor_id() && cpu && !current->pid) /* ori => rem */
+	//	dump_stack();
+#endif
+#endif
 	apic->send_IPI_mask(cpumask_of(cpu), RESCHEDULE_VECTOR);
 }
 
@@ -259,6 +279,14 @@ static inline void __smp_reschedule_interrupt(void)
 
 __visible void smp_reschedule_interrupt(struct pt_regs *regs)
 {
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+// POPHYPE_GUEST_DEBUG_CPU
+	//if (cpu)
+	//	printk("\t\t-ipi_resched> [%d] <%d> %s():\n",
+	//		current->pid, smp_processor_id(), __func__);
+#endif
+#endif
 	ack_APIC_irq();
 	__smp_reschedule_interrupt();
 	/*
diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c
index 48ca93242bfd..51ef7c282205 100644
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@ -76,6 +76,31 @@
 #include <asm/realmode.h>
 #include <asm/misc.h>
 
+
+#define DEBUG 1 // Jack
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/bundle.h>
+#include <popcorn/debug.h>
+#include <popcorn/hype_kvm.h>
+
+extern bool **hype_callin;
+extern bool **hype_callin_dynamic_alloc;
+
+//dbg
+extern pgd_t early_level4_pgt[PTRS_PER_PGD];
+
+
+char __attribute__((__aligned__(PAGE_SIZE))) pophype_data = 'a';
+char __attribute__((__aligned__(PAGE_SIZE))) pophype_bss;
+
+
+void msleep_at_bsp(int mins)
+{
+	POP_PK(KERN_INFO "\t\t== <BSP> (sleep %d * 60s...) ==\n", mins);
+	msleep(mins * 60 * 1000);
+}
+#endif
+
 /* Number of siblings per CPU package */
 int smp_num_siblings = 1;
 EXPORT_SYMBOL(smp_num_siblings);
@@ -168,7 +193,7 @@ static void smp_callin(void)
 	 */
 	calibrate_delay();
 	cpu_data(cpuid).loops_per_jiffy = loops_per_jiffy;
-	pr_debug("Stack at about %p\n", &cpuid);
+	pr_debug("%s(): Stack at <%d> about %p\n", __func__, cpuid, &cpuid);
 
 	/*
 	 * This must be done before setting cpu_online_mask
@@ -176,14 +201,42 @@ static void smp_callin(void)
 	 */
 	set_cpu_sibling_map(raw_smp_processor_id());
 	wmb();
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t\t<%d> %s(): set_cpu_sibling_map() look?\n", cpuid, __func__);
+#endif
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* TODO retmoe signal */
+	POP_PK("\t\t<%d> %s(): notify_cpu_starting(%d) (TODO return)\n",
+											cpuid,  __func__, cpuid);
 	notify_cpu_starting(cpuid);
-
+#else
+	notify_cpu_starting(cpuid);
+#endif
 	/*
 	 * Allow the master to continue.
 	 */
 	cpumask_set_cpu(cpuid, cpu_callin_mask);
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK(KERN_INFO "\t\t%s(): AP <%d> phys_id/APIC(%d) callin done "
+				"-signal-> BSP to resume. set cpu_callin_mask\n",
+										__func__, cpuid, phys_id);
+#endif
+}
+
+#ifdef CONFIG_POPCORN_HYPE
+#define POPCORN_VMCALL_DEBUG 100
+/* not working don't use */
+inline void popcorn_vmcall_debug(void)
+{
+#if HYPE_VMCALL_DEBUG
+#ifdef CONFIG_POPCORN_HYPE_DEBUG
+	/* func:out:in */
+	asm volatile ("vmcall"::"eax"(POPCORN_VMCALL_DEBUG));
+#endif
+#endif
 }
+#endif
 
 static int cpu0_logical_apicid;
 static int enable_start_cpu0;
@@ -197,11 +250,36 @@ static void notrace start_secondary(void *unused)
 	 * fragile that we want to limit the things done here to the
 	 * most necessary things.
 	 */
+#ifdef CONFIG_POPCORN_HYPE
+	int cpu = smp_processor_id();
+	//wmb(); // DSM has handled it
+
+	/* 0603 - if put 2 printks side by side here, you will not see the second one.
+		Instead, it will somehow restart kernel....... */
+	//POP_PK("\t\tI'm AP %d\n", cpumask_test_cpu(cpu, cpu_callout_mask)); // if turn on bsp will take longer. (lots of dsm traffic)
+	POP_PK("\t\tpophype: I'm AP <%d>\n", cpu);
+
+	//POP_PK("\t\t %d\n", cpumask_test_cpu(cpu, cpu_callout_mask));
+	//POP_PK(KERN_INFO "\t\t%s: I'm AP\n", __func__);
+	//POP_PK(KERN_INFO "\t\t%s: I'm AP<%d>\n", __func__, cpu);
+	//POP_PK(KERN_INFO "\t\t%s: I'm AP<%d>\n", __func__, cpu);
+	//hype_callin[1] = true; /* remote guest kernel cannot printk() */
+	hype_callin_dynamic_alloc[HYPE_DEBUG_POINT0][cpu] = true;
+	//POP_PK("\t\t (%s)\n",
+	//POP_PK(KERN_INFO "\t\t%s: I'm AP<%d>\n", __func__, cpu);
+#endif
+
 	cpu_init();
 	x86_cpuinit.early_percpu_clock_init();
 	preempt_disable();
+#ifdef CONFIG_POPCORN_HYPE
+	//TODO notify origin /* should by done by DSM */
+	//POP_PK(KERN_INFO "\t#smpboot [%d/%d] AP %d smp_callin *TODO*\n",
+	//					my_nid, current->pid, cpu);
+	smp_callin(); /* TODO */
+#else
 	smp_callin();
-
+#endif
 	enable_start_cpu0 = 0;
 
 #ifdef CONFIG_X86_32
@@ -215,8 +293,20 @@ static void notrace start_secondary(void *unused)
 	/*
 	 * Check TSC synchronization with the BP:
 	 */
+#ifdef CONFIG_POPCORN_HYPE
+	//hype_callin[HYPE_DEBUG_POINT7][cpu] = true;
+	hype_callin_dynamic_alloc[HYPE_DEBUG_POINT8][cpu] = true;
+	check_tsc_sync_target(); /* TODO */
+	if (&hype_callin_dynamic_alloc[HYPE_DEBUG_POINT9][cpu]) {
+		hype_callin_dynamic_alloc[HYPE_DEBUG_POINT9][cpu] = true; // last was 11->9
+	} else {
+		POP_PK("\n\n\n");
+		POP_PK("HYPE_DEBUG_POINT9 DIE DIE DIE <%d>\n", cpu);
+		POP_PK("\n\n\n");
+	}
+#else
 	check_tsc_sync_target();
-
+#endif
 	/*
 	 * Lock vector_lock and initialize the vectors on this cpu
 	 * before setting the cpu online. We must set it online with
@@ -226,6 +316,13 @@ static void notrace start_secondary(void *unused)
 	lock_vector_lock();
 	setup_vector_irq(smp_processor_id());
 	set_cpu_online(smp_processor_id(), true);
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL // comment out just for my convinience
+	//TODO notify origin
+	POP_PK(KERN_INFO "\t\t#smpboot %s(): [%d/%d] AP <%d> NOTIFY BSP "
+			"set set_cpu_online()\n", __func__, my_nid, current->pid, cpu);
+#endif
+#endif
 	unlock_vector_lock();
 	cpu_set_state_online(smp_processor_id());
 	x86_platform.nmi_init();
@@ -582,7 +679,7 @@ wakeup_secondary_cpu_via_init(int phys_apicid, unsigned long start_eip)
 		apic_read(APIC_ESR);
 	}
 
-	pr_debug("Asserting INIT\n");
+	pr_debug("Asserting INIT %d\n", phys_apicid);
 
 	/*
 	 * Turn INIT on target chip
@@ -598,7 +695,7 @@ wakeup_secondary_cpu_via_init(int phys_apicid, unsigned long start_eip)
 
 	udelay(init_udelay);
 
-	pr_debug("Deasserting INIT\n");
+	pr_debug("Deasserting INIT %d\n", phys_apicid);
 
 	/* Target chip */
 	/* Send IPI */
@@ -686,10 +783,35 @@ wakeup_secondary_cpu_via_init(int phys_apicid, unsigned long start_eip)
 	return (send_status | accept_status);
 }
 
+#if defined(CONFIG_POPCORN_HYPE) && HYPEBOOTDEBUG
+void popcorn_hype_check_remote_cpus(void) {
+	/* TODO: make it GUEST specific? */
+	int interested_vcpuid = 1; // TODO more
+	POP_PK("pophype: smp: upto %d vcpu online\n", pophype_available_vcpu());
+	POP_PK("pophype: smp: <SMP> last check AP[%d] inited? "
+			"hype_callin_dy[%d][%d] [[[(%s)]]] ***LAST***",
+			interested_vcpuid, HYPE_DEBUG_POINT9, interested_vcpuid, // last was 11->9
+			hype_callin_dynamic_alloc[HYPE_DEBUG_POINT9][interested_vcpuid] ? // last was 11->9
+																	"O" : "X");
+	if (hype_callin_dynamic_alloc[HYPE_DEBUG_POINT4][interested_vcpuid]) {
+		POP_PK("\tpophype: smp: 2nd AP running!!!\n");
+	} else {
+		POP_PK("\tpophype: smp: 2nd AP NOT running!!!\n");
+	}
+	POP_PK("pophype: smp: nr_cpu_ids(bios argv) %d\n", nr_cpu_ids);
+}
+#else
+void popcorn_hype_check_remote_cpus(void) {
+
+}
+#endif
+
 void smp_announce(void)
 {
 	int num_nodes = num_online_nodes();
 
+	popcorn_hype_check_remote_cpus();
+
 	printk(KERN_INFO "x86: Booted up %d node%s, %d CPUs\n",
 	       num_nodes, (num_nodes > 1 ? "s" : ""), num_online_cpus());
 }
@@ -825,10 +947,41 @@ static int do_boot_cpu(int apicid, int cpu, struct task_struct *idle)
 		(volatile u32 *) __va(real_mode_header->trampoline_status);
 	/* start_ip had better be page-aligned! */
 	unsigned long start_ip = real_mode_header->trampoline_start;
-
 	unsigned long boot_error = 0;
 	int cpu0_nmi_registered = 0;
 	unsigned long timeout;
+#ifdef CONFIG_POPCORN_HYPE
+#define LEN 100
+	//int i, loop = 1000000; //100:2480, 10000,199, 100000,19
+	//int i, loop = 1000, bsp_swait = 30; //100:2480, 10000,199, 100000,19
+	//int i, loop = 1000 * 1000, bsp_swait = 60; //100:2480, 10000,199, 100000,19
+#if !POPHYPE_HOST_KERNEL
+	int i, loop = 1000 * 1000, bsp_swait = 20; //100:2480, 10000,199, 100000,19 // used when long fault retry
+	//int i, loop = 1000 * 1000, bsp_swait = 30; //100:2480, 10000,199, 100000,19
+	int bsp_swait_first = 0;
+	int bsp_swait_second = 0;
+#else
+	/* WATCHOUT THIS WILL MAKE HOST FAILT TO BOOT SMP !!!....... */
+	/* DSM takes traffic espesically when debugging -
+				TODO try to uncommon all when !PERF_MODE*/
+	//int i, loop = 1000, bsp_swait = 10; //100:2480, 10000,199, 100000,19
+	int i, loop = 1; /* watch out printk... */
+	int bsp_swait = 10; /* vanilla = 10 */
+#endif
+
+	unsigned long cnt = 0; /* 4054000 */
+	bool first = true;
+	bool ap_olinen = true;
+	//char temp[LEN];
+	//int	i;
+	//memcpy(temp, (void*)start_ip, LEN - 1);
+	//if(copy_from_user(temp, (void __user *)start_ip, LEN - 1))
+	//	BUG();
+	HYPEBOOTDBGPRINTK("-------------------------------------------------------\n");
+	HYPEBOOTDBGPRINTK("Cannot read *start_ip......sad\n");
+	HYPEBOOTDBGPRINTK("get_uv_system_type() = %d\n", get_uv_system_type());
+	HYPEBOOTDBGPRINTK("-------------------------------------------------------\n");
+#endif
 
 	idle->thread.sp = (unsigned long) (((struct pt_regs *)
 			  (THREAD_SIZE +  task_stack_page(idle))) - 1);
@@ -837,6 +990,113 @@ static int do_boot_cpu(int apicid, int cpu, struct task_struct *idle)
 	initial_code = (unsigned long)start_secondary;
 	stack_start  = idle->thread.sp;
 
+	HYPEBOOTDBGPRINTK("<%d> start_ip = real_mode_header->trampoline_start = 0x%lx\n",
+															cpu, start_ip);
+	HYPEBOOTDBGPRINTK("<%d> real_mode_header->trampoline_pgd = 0x%lx\n\n",
+			cpu, (unsigned long)real_mode_header->trampoline_pgd);
+
+	HYPEBOOTDBGPRINTK("<%d> start_secondary = 0x%p pa 0x%lx (aka initial_code)\n\n",
+							cpu, start_secondary, __pa(start_secondary));
+
+
+	HYPEBOOTDBGPRINTK("__bss_stop %p 0x%lx\n", __bss_stop, __pa(__bss_stop));
+	HYPEBOOTDBGPRINTK("__bss_start %p 0x%lx\n\n", __bss_start, __pa(__bss_start));
+	HYPEBOOTDBGPRINTK("(__bss_start) kva - pa = 0x%lx BUT PAGE_OFFSET = 0x%lx !!\n\n",
+				(unsigned long)__bss_start - __pa(__bss_start), PAGE_OFFSET);
+
+	HYPEBOOTDBGPRINTK("jiffies %p pa 0x%lx\n\n", (void *)&jiffies, __pa(&jiffies));
+
+	HYPEBOOTDBGPRINTK("---\n");
+
+	HYPEBOOTDBGPRINTK("PAGE_OFFSET = 0x%lx !!\n\n", PAGE_OFFSET);
+
+	HYPEBOOTDBGPRINTK("<%d> stack_start 0x%lx pa 0x%lx\n\n",
+			cpu, idle->thread.sp, __pa(idle->thread.sp));
+
+	HYPEBOOTDBGPRINTK("<%d> early_gdt_descr.address 0x%lx pa 0x%lx "
+			"(akaget_cpu_gdt_table(cpu))\n\n",
+			cpu, early_gdt_descr.address, __pa(early_gdt_descr.address));
+	{
+		int i;
+		char *ptr = kmalloc(PAGE_SIZE * 10, GFP_ATOMIC);
+		//BUG_ON(!ptr);
+		if (ptr) {
+			for (i = 0; i < PAGE_SIZE * 10; i += PAGE_SIZE)
+				*(ptr + i) = 'a';
+			HYPEBOOTDBGPRINTK("pophype: kmalloc: ptr kva %p pa 0x%lx (global dynamic)\n\n",
+																ptr, __pa(ptr));
+			kfree(ptr);
+		} else {
+			HYPEBOOTDBGPRINTK("WHY CANNOT kmalloc here????\n\n");
+		}
+		HYPEBOOTDBGPRINTK("pophype: TODO: different size kmalloc large & small\n");
+	}
+
+	HYPEBOOTDBGPRINTK("pophype: \n");
+	HYPEBOOTDBGPRINTK("pophype: stack: &start_ip %p pa 0x%lx (inside func)\n\n",
+							&start_ip, __pa(&start_ip));
+	HYPEBOOTDBGPRINTK("pophype: data: &pophype_data %p pa 0x%lx (global static)\n\n",
+							&pophype_data, __pa(&pophype_data));
+	HYPEBOOTDBGPRINTK("pophype: bss: &pophype_bss %p pa 0x%lx (global static)\n\n",
+							&pophype_bss, __pa(&pophype_bss));
+
+	HYPEBOOTDBGPRINTK("\n---\n");
+	HYPEBOOTDBGPRINTK("pgd_t early_level4_pgt[] %p pa 0x%lx\n",
+				early_level4_pgt, __pa(early_level4_pgt));
+	// early_level4_pgt -> init_level4_pgt
+	HYPEBOOTDBGPRINTK("BUG_ON (__end_of_fixed_addresses 0x%x <= MODULES_END 0x%lx )\n",
+			__end_of_fixed_addresses, MODULES_END);
+
+	HYPEBOOTDBGPRINTK("pophype: \n");
+	HYPEBOOTDBGPRINTK("mm_struct: pgd -> pud -> pmd -> pte\n");
+	HYPEBOOTDBGPRINTK("size: pud_t %lu pmd_t %lu pte_t %lu pgd_t %lu\n",
+				sizeof(pud_t), sizeof(pmd_t), sizeof(pte_t), sizeof(pgd_t));
+	HYPEBOOTDBGPRINTK("pgd_t init_level4_pgt[] %p pa 0x%lx\n",
+				init_level4_pgt, __pa(init_level4_pgt)); // 1a0e
+
+	/* mir(X) echo(O) */
+	//HYPEBOOTDBGPRINTK("pud_t level3_ident_pgt[512] %p pa 0x%lx\n",
+	//			level3_ident_pgt, __pa(level3_ident_pgt)); // 1a10
+	//HYPEBOOTDBGPRINTK("pmd_t level2_ident_pgt[512] %p pa 0x%lx\n",
+	//			level2_ident_pgt, __pa(level2_ident_pgt)); // 1a11
+
+	HYPEBOOTDBGPRINTK("pud_t level3_kernel_pgt[512] %p pa 0x%lx\n",
+				level3_kernel_pgt, __pa(level3_kernel_pgt)); // 1a13
+	HYPEBOOTDBGPRINTK("pmd_t level2_kernel_pgt[512] %p pa 0x%lx\n",
+				level2_kernel_pgt, __pa(level2_kernel_pgt)); // 1a14
+	HYPEBOOTDBGPRINTK("pmd_t level2_fixmap_pgt[512] %p pa 0x%lx\n",
+				level2_fixmap_pgt, __pa(level2_fixmap_pgt)); // 1a15
+	HYPEBOOTDBGPRINTK("pte_t level1_fixmap_pgt[512] %p pa 0x%lx\n",
+				level1_fixmap_pgt, __pa(level1_fixmap_pgt)); // 1a16
+
+	HYPEBOOTDBGPRINTK("\n\n");
+	HYPEBOOTDBGPRINTK("size: pgd_t %lu pud_t %lu pmd_t %lu\n",
+			sizeof(pgd_t), sizeof(pud_t), sizeof(pmd_t));
+	{ int i = 0;
+		for (i=0; i<3; i++) {
+			HYPEBOOTDBGPRINTK("pud_t level3_kernel_pgt[%d] %p pa 0x%lx\n",
+						i, &level3_kernel_pgt[i], __pa(&level3_kernel_pgt[i])); // 1a13
+			HYPEBOOTDBGPRINTK("pmd_t level2_kernel_pgt[%d] %p pa 0x%lx\n",
+						i, &level2_kernel_pgt[i], __pa(&level2_kernel_pgt[i])); // 1a14
+		}
+	}
+	HYPEBOOTDBGPRINTK("\n---\n");
+	HYPEBOOTDBGPRINTK("host 0x7fffeb105000\n");
+	HYPEBOOTDBGPRINTK("guest ip 0xffffffff8134c402 pa 0x%lx\n", __pa(0xffffffff8134c402));
+	HYPEBOOTDBGPRINTK("guest sp 0xffffffff81bffce0 pa 0x%lx\n", __pa(0xffffffff81bffce0));
+	HYPEBOOTDBGPRINTK("\n---\n");
+//extern pud_t level3_kernel_pgt[512];
+//extern pud_t level3_ident_pgt[512];
+//extern pmd_t level2_kernel_pgt[512];
+////extern pmd_t level2_fixmap_pgt[512];
+//extern pmd_t __attribute__((__aligned__(PAGE_SIZE))) level2_fixmap_pgt[512];
+//extern pmd_t level2_ident_pgt[512];
+//extern pte_t level1_fixmap_pgt[512];
+//extern pgd_t init_level4_pgt[];
+
+	HYPEBOOTDBGPRINTK("-------------------------------------------------------\n");
+	HYPEBOOTDBGPRINTK("\n\n");
+
 	/*
 	 * Enable the espfix hack for this CPU
 	*/
@@ -886,26 +1146,111 @@ static int do_boot_cpu(int apicid, int cpu, struct task_struct *idle)
 	else
 		boot_error = wakeup_cpu_via_init_nmi(cpu, start_ip, apicid,
 						     &cpu0_nmi_registered);
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK(KERN_INFO "\t\tapic->wakeup_secondary_cpu (%s) "
+				"boot_error = %lu (%s) peek cpu %d\n",
+				apic->wakeup_secondary_cpu ? "Oapic" : "Xnmi",
+						boot_error, !boot_error ? "O" : "X", cpu);
+	if (cpu == 1) {
+//		int ssleep = 15;
+//		POP_PK(KERN_INFO "\tBSP sent & spinwaits cpu %d sleep %ds...(safe) "
+//					"let ap go first for testing\n", cpu, ssleep);
+//		msleep(ssleep * 1000);
+//		ssleep_at_ap(ssleep);
+#if !POPHYPE_HOST_KERNEL
+		POP_PK("before handshake_signal AP sleep %ds\n", bsp_swait_first);
+		msleep(bsp_swait_first * 1000);
+#endif
+	}
+#endif
 
 	if (!boot_error) {
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK(KERN_INFO " - sched() cnt = %d (total~=) bsp waits %ds\n",
+														loop, bsp_swait);
+#endif
 		/*
 		 * Wait 10s total for first sign of life from AP
 		 */
 		boot_error = -1;
+#ifdef CONFIG_POPCORN_HYPE
+		//timeout = jiffies + 30*HZ;
+		timeout = jiffies + bsp_swait*HZ;
+#else
 		timeout = jiffies + 10*HZ;
+#endif
+
+		/* TODO Jack first check info */
 		while (time_before(jiffies, timeout)) {
 			if (cpumask_test_cpu(cpu, cpu_initialized_mask)) {
 				/*
 				 * Tell AP to proceed with initialization
 				 */
-				cpumask_set_cpu(cpu, cpu_callout_mask);
+#ifdef CONFIG_POPCORN_HYPE
+				/* First AP started */
+				POP_PK(KERN_INFO "\t\tBSP[%d] got sig, =signal=> AP[]s to "
+						"run cpu_init() %d\n", stack_smp_processor_id(), cpu);
+				while (!cpumask_test_cpu(cpu, cpu_callout_mask)) {
+					cpumask_set_cpu(cpu, cpu_callout_mask);
+					schedule();
+				}
+#endif
+				cpumask_set_cpu(cpu, cpu_callout_mask); /* signal AP */
+#ifdef CONFIG_POPCORN_HYPE
+				// debug
+				POP_PK("\t<%d> cpumask_test_cpu(cpu, cpu_callout_mask) %d\n",
+									cpu, cpumask_test_cpu(cpu, cpu_callout_mask));
+#endif
 				boot_error = 0;
+				if (cpu == 1) {
+//					int ssleep = 15;
+//					POP_PK(KERN_INFO "\tBSP sent & spinwaits cpu %d sleep %ds..."
+//							"(safe) let ap go first for testing\n", cpu, ssleep);
+					//msleep(ssleep * 1000);
+//					ssleep_at_ap(ssleep);
+				}
 				break;
 			}
+
+#ifdef CONFIG_POPCORN_HYPE
+//			udelay(100); /* Jack: skeptical */
+			for (i = 0; i < loop; i++) {
+				schedule();
+			}
+#else
 			schedule();
+#endif
+
+#ifdef CONFIG_POPCORN_HYPE
+			cnt++;
+			if (!(cnt % 1000000)) {
+				POP_PK(KERN_INFO " - %lu/%lu #%lu\n", jiffies, timeout, cnt);
+			}
+
+			if (first && hype_callin_dynamic_alloc[HYPE_DEBUG_POINT0][cpu]) {
+						// hype_callin[HYPE_DEBUG_POINT0][1]
+				first = false;
+				POP_PK(KERN_INFO "\t==================================\n");
+				POP_PK(KERN_INFO "\t## <BSP>: AP "
+					"(hype_callin_dy[HYPE_DEBUG_POINT0][%d]) WORKING "
+											"after trying #%lu ##\n", cpu, cnt);
+				POP_PK(KERN_INFO "\t==================================\n");
+			}
+#endif
 		}
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK(KERN_INFO "\t\t== <BSP> %s ==\n",
+			!boot_error ? "(GOOD-1)AP signaled BSP go to second while"
+						: "(BAD-1)TIMEOUT");
+#if !POPHYPE_HOST_KERNEL
+	POP_PK("\t\tafter handshake_signal AP sleep %ds for clear dmesg logs\n",
+													bsp_swait_second);
+	msleep(bsp_swait_second * 1000);
+#endif
+#endif
+	/* First AP started otherwise skip */
 	if (!boot_error) {
 		/*
 		 * Wait till AP completes initial initialization
@@ -917,9 +1262,58 @@ static int do_boot_cpu(int apicid, int cpu, struct task_struct *idle)
 			 * for the MTRR work(triggered by the AP coming online)
 			 * to be completed in the stop machine context.
 			 */
+#ifdef CONFIG_POPCORN_HYPE
+			if(time_before(timeout, jiffies)) {
+				ap_olinen = false;
+				break;
+			}
+			/*
+			 * WATCHOUT THIS IS A FOREVER LOOP in VANILLA..........
+			 */
+			//if (!(cnt % 100000)) { // when all printk on
+//			if (!(cnt % 100)) { // when all printk on
+//				POP_PK(KERN_INFO "\t\t2.RIGHT PLACE checking AP[1] "
+//							"has inited? wait till AP registers "
+//							"[[[(%s)]]] #%lu\n",
+//							hype_callin[HYPE_DEBUG_POINT1][1]?"O":"X", cnt);
+//			}
+//			cnt++;
+			for (i = 0; i < loop; i++) {
+				schedule();
+			}
+#else
 			schedule();
+#endif
+		}
+#ifdef CONFIG_POPCORN_HYPE
+		/* exit may becasue timeout */
+		if (cpu == 1 && !boot_error) {
+			if (ap_olinen) {
+				POP_PK(KERN_INFO "\t\t== <BSP> AP CALLIN RUNNING!! PERFECT! ==\n");
+			} else {
+				POP_PK(KERN_INFO "\t\t== <BSP> AP FOREVER LOOP "
+									"waiting cpu_callout_mask WORST! ==\n");
+				/* roll back to let bsp run */
+				boot_error = -1;
+			}
+		}
+#endif
+	}
+
+#ifdef CONFIG_POPCORN_HYPE
+	for (i = HYPE_DEBUG_POINT0; i < HYPE_DEBUG_POINT_MAX; i++) {
+		/* HYPE_DEBUG_POINTi */
+		if (hype_callin_dynamic_alloc[i][cpu]) {
+			POP_PK("\t## <BSP>: check AP[%d] "
+					"hype_callin_dy[%d][%d] ***PASS***\n", cpu, i, cpu);
+		} else {
+			POP_PK("\t## <BSP>: check AP[%d] "
+					"hype_callin_dy[%d][%d] ***FAIL***\n", cpu, i, cpu);
 		}
 	}
+	POP_PK("\t<%d> cpumask_test_cpu(cpu, cpu_callout_mask) %d\n",
+						cpu, cpumask_test_cpu(cpu, cpu_callout_mask));
+#endif
 
 	/* mark "stuck" area as not stuck */
 	*trampoline_status = 0;
@@ -946,10 +1340,13 @@ int native_cpu_up(unsigned int cpu, struct task_struct *tidle)
 	unsigned long flags;
 	int err;
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("+++++++++++++++=_---CPU UP  %u\n", cpu); // pr_debug term:X dmesg:O
+#endif
+
 	WARN_ON(irqs_disabled());
 
 	pr_debug("++++++++++++++++++++=_---CPU UP  %u\n", cpu);
-
 	if (apicid == BAD_APICID ||
 	    !physid_isset(apicid, phys_cpu_present_map) ||
 	    !apic->apic_id_valid(apicid)) {
@@ -1001,13 +1398,48 @@ int native_cpu_up(unsigned int cpu, struct task_struct *tidle)
 	 * while doing so):
 	 */
 	local_irq_save(flags);
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	POP_PK("<BSP> check_tsc_sync_source(cpu) - 14 <%d>\n", cpu);
+//	if (cpu != 1) {
+		POP_PK("\t%s(): <BSP> 2nd sync for <%d>\n", __func__, cpu);
+				check_tsc_sync_source(cpu);
+//	} else {
+//		POP_PK("%s(): <BSP> skip 2nd sync for <%d>\n", __func__, cpu);
+//	}
+	// TODO TODO 2nd handshake with AP
+#else
+	check_tsc_sync_source(cpu);
+#endif
+#else
 	check_tsc_sync_source(cpu);
+#endif
 	local_irq_restore(flags);
 
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	POP_PK("<BSP> cpu_online(cpu) - 15 <%d>\n", cpu);
+//	if (cpu != 1) {
+		POP_PK("\t%s(): <BSP> check cpu_online for <%d>\n", __func__, cpu);
+		while (!cpu_online(cpu)) {
+			cpu_relax();
+			touch_nmi_watchdog();
+		}
+//	} else {
+//		POP_PK("%s(): <BSP> skip check cpu_online for <%d>\n", __func__, cpu);
+//	}
+#else
 	while (!cpu_online(cpu)) {
 		cpu_relax();
 		touch_nmi_watchdog();
 	}
+#endif
+#else
+	while (!cpu_online(cpu)) {
+		cpu_relax();
+		touch_nmi_watchdog();
+	}
+#endif
 
 	irq_unlock_sparse();
 
diff --git a/arch/x86/kvm/Makefile b/arch/x86/kvm/Makefile
index a1ff508bb423..adebce7064cd 100644
--- a/arch/x86/kvm/Makefile
+++ b/arch/x86/kvm/Makefile
@@ -22,3 +22,5 @@ kvm-amd-y		+= svm.o pmu_amd.o
 obj-$(CONFIG_KVM)	+= kvm.o
 obj-$(CONFIG_KVM_INTEL)	+= kvm-intel.o
 obj-$(CONFIG_KVM_AMD)	+= kvm-amd.o
+
+#obj-$(CONFIG_POPCORN_HYPE) += $(KVM)/hype_kvm.o
diff --git a/arch/x86/kvm/assigned-dev.c b/arch/x86/kvm/assigned-dev.c
index 9dc091acd5fb..05a119539829 100644
--- a/arch/x86/kvm/assigned-dev.c
+++ b/arch/x86/kvm/assigned-dev.c
@@ -194,6 +194,15 @@ static irqreturn_t kvm_assigned_dev_msix(int irq, void *dev_id)
 	u32 vector;
 	int ret = 0;
 
+#ifdef CONFIG_POPCORN_HYPE
+    static u64 cnt = 0;
+    cnt++;
+    POP_PK("\tpophype: vhost-net: <%d> %s(): msi #%llu\n",
+						smp_processor_id(), __func__, cnt);
+//  if (cnt < 300)
+//      dump_stack();
+#endif
+
 	if (index >= 0) {
 		vector = assigned_dev->guest_msix_entries[index].vector;
 		ret = kvm_set_irq_inatomic(assigned_dev->kvm,
diff --git a/arch/x86/kvm/i8254.c b/arch/x86/kvm/i8254.c
index ab5318727579..a107d1e0b411 100644
--- a/arch/x86/kvm/i8254.c
+++ b/arch/x86/kvm/i8254.c
@@ -40,6 +40,8 @@
 #include "i8254.h"
 #include "x86.h"
 
+#include <popcorn/debug.h>
+
 #ifndef CONFIG_X86_64
 #define mod_64(x, y) ((x) - (y) * div64_u64(x, y))
 #else
@@ -373,6 +375,11 @@ static void create_pit_timer(struct kvm *kvm, u32 val, int is_period)
 		}
 	}
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	POP_PK("\tpophype_init: %s(): [%d] vanilla QEMU many\n",
+									__func__, current->pid);
+#endif
+
 	hrtimer_start(&ps->timer, ktime_add_ns(ktime_get(), interval),
 		      HRTIMER_MODE_ABS);
 }
@@ -736,6 +743,15 @@ struct kvm_pit *kvm_create_pit(struct kvm *kvm, u32 flags)
 	kvm_iodevice_init(&pit->dev, &pit_dev_ops);
 	ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_PIT_BASE_ADDRESS,
 				      KVM_PIT_MEM_LENGTH, &pit->dev);
+
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\tpophype_init: %s(): pit->dev ret %d\n", __func__, ret);
+	if (ret < 0 ) {
+		POP_PK(KERN_ERR "\t(WATCHOUT) pophype_init: %s(): "
+							"pit->dev ret %d\n", __func__, ret);
+	}
+#endif
+
 	if (ret < 0)
 		goto fail;
 
@@ -744,6 +760,16 @@ struct kvm_pit *kvm_create_pit(struct kvm *kvm, u32 flags)
 		ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS,
 					      KVM_SPEAKER_BASE_ADDRESS, 4,
 					      &pit->speaker_dev);
+
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("\ttpophype_init: %s(): pit->speaker_dev ret %d\n",
+													__func__, ret);
+		if (ret < 0) {
+			POP_PK(KERN_ERR "\t(WATCHOUT) pophype_init: %s(): "
+						"pit->speaker_dev ret %d\n", __func__, ret);
+		}
+#endif
+
 		if (ret < 0)
 			goto fail_unregister;
 	}
diff --git a/arch/x86/kvm/irq_comm.c b/arch/x86/kvm/irq_comm.c
index d09544e826f6..fa30446ea874 100644
--- a/arch/x86/kvm/irq_comm.c
+++ b/arch/x86/kvm/irq_comm.c
@@ -25,6 +25,13 @@
 #include <linux/export.h>
 #include <trace/events/kvm.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#include <popcorn/bundle.h>
+#include <popcorn/types.h>
+#include <popcorn/hype_kvm.h>
+#endif
+
 #include <asm/msidef.h>
 
 #include "irq.h"
@@ -63,6 +70,7 @@ static int kvm_set_ioapic_irq(struct kvm_kernel_irq_routing_entry *e,
 				line_status);
 }
 
+/* !src: from msi */
 int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,
 		struct kvm_lapic_irq *irq, unsigned long *dest_map)
 {
@@ -71,13 +79,31 @@ int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,
 
 	if (irq->dest_mode == 0 && irq->dest_id == 0xff &&
 			kvm_lowest_prio_delivery(irq)) {
+		/* TODO have a look... DM_FIXED */
 		printk(KERN_INFO "kvm: apic: phys broadcast and lowest prio\n");
 		irq->delivery_mode = APIC_DM_FIXED;
 	}
+#ifdef CONFIG_POPCORN_HYPE
+	if (dest_map == REMOTE_APIC && irq->delivery_mode) { // mode 0 = APIC_DM_FIXED
+		IPIPRINTK("%s\t\t%s(): [%d/%d] <> => <%d?> %s - 1 mode %x (FROM %s)\n",
+			dest_map == REMOTE_APIC ? "\n\t\t->" : "",
+			__func__, my_nid, current->pid, irq->dest_id,
+			irq->dest_mode == APIC_DEST_PHYSICAL ? "PHYSICAL map TRUST" :
+				irq->dest_mode == APIC_DEST_LOGICAL ? "LOGICAL map DON'T TRUST" : "",
+			irq->delivery_mode, dest_map == REMOTE_APIC ? "REMOTE" : "LOCAL");
+	}
+
+	/* This is my assumption for using REMOTE_APIC */
+	BUG_ON(dest_map != REMOTE_APIC && dest_map); /* Happens when usidng qemu */
+#endif
 
 	if (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))
 		return r;
 
+#ifdef CONFIG_POPCORN_HYPE
+	IPIVPRINTK("\t\t%s(): [%d/%d] <> => <?> - 2 NEVER!!!!!\n",
+				__func__, my_nid, current->pid);
+#endif
 	kvm_for_each_vcpu(i, vcpu, kvm) {
 		if (!kvm_apic_present(vcpu))
 			continue;
@@ -89,6 +115,10 @@ int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,
 		if (!kvm_lowest_prio_delivery(irq)) {
 			if (r < 0)
 				r = 0;
+//#ifdef CONFIG_POPCORN_HYPE
+//			IPIVPRINTK("\t\t%s(): [%d/%d] <> => <?> - 3 itering <%d>\n",
+//						__func__, my_nid, current->pid, vcpu->vcpu_id);
+//#endif
 			r += kvm_apic_set_irq(vcpu, irq, dest_map);
 		} else if (kvm_lapic_enabled(vcpu)) {
 			if (!lowest)
@@ -98,8 +128,13 @@ int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,
 		}
 	}
 
-	if (lowest)
+	if (lowest) {
+//#ifdef CONFIG_POPCORN_HYPE
+//		IPIVPRINTK("\t\t%s(): [%d/%d] <> => <?> - 4\n",
+//					__func__, my_nid, current->pid);
+//#endif
 		r = kvm_apic_set_irq(lowest, irq, dest_map);
+	}
 
 	return r;
 }
@@ -120,6 +155,14 @@ void kvm_set_msi_irq(struct kvm_kernel_irq_routing_entry *e,
 		& MSI_ADDR_REDIRECTION_LOWPRI) > 0);
 	irq->level = 1;
 	irq->shorthand = 0;
+#ifdef CONFIG_POPCORN_HYPE
+    CRITICALNETPK("\t\t%s %s(): mq runtime: "
+					"then -> kvm_irq_delivery_to_apic_fast_/->"
+					"irq->dest_id <%d> dest_mode 0x%x %s\n",
+					__FILE__, __func__, irq->dest_id, irq->dest_mode,
+					irq->dest_mode == APIC_DEST_PHYSICAL ? "PHYSICAL map TRUST" :
+						irq->dest_mode == APIC_DEST_LOGICAL ? "LOGICAL map DON'T TRUST" : "");
+#endif
 }
 EXPORT_SYMBOL_GPL(kvm_set_msi_irq);
 
@@ -131,6 +174,18 @@ int kvm_set_msi(struct kvm_kernel_irq_routing_entry *e,
 	if (!level)
 		return -1;
 
+#ifdef CONFIG_POPCORN_HYPE
+#if POPHYPE_NET_OPTIMIZE_TMP_DEBUG
+	{
+		static int cnt = 0;
+		cnt++;
+		if (cnt < 100 || !(cnt % 100)) {
+			printk("%s %s(): mq runtime: vanilla virtio-host many\n",
+													__FILE__, __func__);
+		}
+	}
+#endif
+#endif
 	kvm_set_msi_irq(e, &irq);
 
 	return kvm_irq_delivery_to_apic(kvm, NULL, &irq, NULL);
@@ -147,6 +202,9 @@ int kvm_arch_set_irq_inatomic(struct kvm_kernel_irq_routing_entry *e,
 	if (unlikely(e->type != KVM_IRQ_ROUTING_MSI))
 		return -EWOULDBLOCK;
 
+#ifdef CONFIG_POPCORN_HYPE
+    CRITICALNETPK("%s %s():\n", __FILE__, __func__);
+#endif
 	kvm_set_msi_irq(e, &irq);
 
 	if (kvm_irq_delivery_to_apic_fast(kvm, NULL, &irq, &r, NULL))
@@ -239,8 +297,16 @@ int kvm_set_routing_entry(struct kvm_kernel_irq_routing_entry *e,
 	int delta;
 	unsigned max_pin;
 
+#if defined(CONFIG_POPCORN_HYPE) && HYPEBOOTDEBUG
+    printk("%s %s(): type %d if 1=IRQCHIP, "
+			"[ue->u.irqchip.irqchip %d (PIC m=0/s=1 or IOAPIC=2)] "
+			"else type 2=MSI gsi %u\n",
+			__FILE__, __func__, ue->type, ue->u.irqchip.irqchip, ue->gsi);
+	/* Copy ue info to e */
+#endif
 	switch (ue->type) {
 	case KVM_IRQ_ROUTING_IRQCHIP:
+		/* PIC (kvm_set_pic_irq) & IOAPIC (kvm_set_ioapic_irq) */
 		delta = 0;
 		switch (ue->u.irqchip.irqchip) {
 		case KVM_IRQCHIP_PIC_MASTER:
@@ -264,8 +330,11 @@ int kvm_set_routing_entry(struct kvm_kernel_irq_routing_entry *e,
 		if (e->irqchip.pin >= max_pin)
 			goto out;
 		break;
-	case KVM_IRQ_ROUTING_MSI:
-		e->set = kvm_set_msi;
+	case KVM_IRQ_ROUTING_MSI: /* set up kvm_set_msi() */
+		e->set = kvm_set_msi; /* pophype: important for net_msi
+								init by first time using net (like ping)
+								from usrspace
+								kvm_vm_ioctl(, KVM_SET_GSI_ROUTING, ) */
 		e->msi.address_lo = ue->u.msi.address_lo;
 		e->msi.address_hi = ue->u.msi.address_hi;
 		e->msi.data = ue->u.msi.data;
diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index a1afd80a68aa..ca0518c108ab 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -42,6 +42,13 @@
 #include "x86.h"
 #include "cpuid.h"
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/hype_kvm.h>
+#include <popcorn/types.h>
+#include <popcorn/debug.h>
+struct kvm_vcpu *pophype_vcpu0 = NULL;
+#endif
+
 #ifndef CONFIG_X86_64
 #define mod_64(x, y) ((x) - (y) * div64_u64(x, y))
 #else
@@ -55,8 +62,11 @@
 
 #define APIC_BUS_CYCLE_NS 1
 
-/* #define apic_debug(fmt,arg...) printk(KERN_WARNING fmt,##arg) */
+#if defined(CONFIG_POPCORN_HYPE) && PERF_EXP
 #define apic_debug(fmt, arg...)
+#else
+#define apic_debug(fmt,arg...) printk(KERN_WARNING fmt,##arg)
+#endif
 
 #define APIC_LVT_NUM			6
 /* 14 is the version for Xeon and Pentium 8.4.8*/
@@ -75,6 +85,10 @@
 #define VEC_POS(v) ((v) & (32 - 1))
 #define REG_POS(v) (((v) >> 5) << 4)
 
+int popcorn_apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,
+			     int vector, int level, int trig_mode,
+			     unsigned long *dest_map);
+
 static inline void apic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)
 {
 	*((u32 *) (apic->regs + reg_off)) = val;
@@ -134,7 +148,7 @@ static inline int kvm_apic_id(struct kvm_lapic *apic)
 }
 
 /* The logical map is definitely wrong if we have multiple
- * modes at the same time.  (Physical map is always right.)
+ * modes at the same time. (Physical map is always right.)
  */
 static inline bool kvm_apic_logical_map_valid(struct kvm_apic_map *map)
 {
@@ -155,12 +169,19 @@ apic_logical_id(struct kvm_apic_map *map, u32 dest_id, u16 *cid, u16 *lid)
 	*lid = dest_id & ((1 << lid_bits) - 1);
 }
 
+/* broadcasted/replayed by apic_reg_write() */
 static void recalculate_apic_map(struct kvm *kvm)
 {
 	struct kvm_apic_map *new, *old = NULL;
 	struct kvm_vcpu *vcpu;
 	int i;
 
+#ifdef CONFIG_POPCORN_HYPE
+	//if (distributed_process(current)) {
+		PHAPICPRINTK("%s(): $$$$[%d/%d] set up apic_map(phys & logic maps) POPHYPE\n",
+												__func__, my_nid, current->pid);
+	//}
+#endif
 	new = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);
 
 	mutex_lock(&kvm->arch.apic_map_lock);
@@ -176,11 +197,21 @@ static void recalculate_apic_map(struct kvm *kvm)
 		if (!kvm_apic_present(vcpu))
 			continue;
 
+		/* TODO pophype get aid ldr from remote */
 		aid = kvm_apic_id(apic);
 		ldr = kvm_apic_get_reg(apic, APIC_LDR);
 
-		if (aid < ARRAY_SIZE(new->phys_map))
+		if (aid < ARRAY_SIZE(new->phys_map)) {
+#ifdef CONFIG_POPCORN_HYPE
+			//if (distributed_process(current)) {
+				PHAPICPRINTK("\t\t%s(): $$$$$[%d/%d] <%d> phys_map[%d(<%lu)] %p\n",
+						__func__, my_nid, current->pid,
+						apic->vcpu->vcpu_id, aid,
+						ARRAY_SIZE(new->phys_map), apic);
+			//}
+#endif
 			new->phys_map[aid] = apic;
+		}
 
 		if (apic_x2apic_mode(apic)) {
 			new->mode |= KVM_APIC_MODE_X2APIC;
@@ -197,8 +228,22 @@ static void recalculate_apic_map(struct kvm *kvm)
 
 		apic_logical_id(new, ldr, &cid, &lid);
 
-		if (lid && cid < ARRAY_SIZE(new->logical_map))
+		if (lid && cid < ARRAY_SIZE(new->logical_map)) {
+#ifdef CONFIG_POPCORN_HYPE
+				PHAPICPRINTK("\t\t%s(): $$$$$[%d/%d] <%d> "
+						"logical_map[%d (<%lu)][%d] %p (%s)\n",
+						__func__, my_nid, current->pid,
+						apic->vcpu->vcpu_id,
+						cid, ARRAY_SIZE(new->logical_map), ffs(lid) - 1, apic,
+						distributed_process(current) ?
+							"POPCORN LOCAL" : "POPCORN REMOTE/VANILLA");
+			//if (distributed_process(current)) {
+			//	PHAPICPRINTK("\t\t\t%s(): me broadcast to others cid %d vcpu %d "
+			//					"(LOGICAL_MAP)\n", __func__, cid, ffs(lid) - 1);
+			//}
+#endif
 			new->logical_map[cid][ffs(lid) - 1] = apic;
+		}
 	}
 out:
 	old = rcu_dereference_protected(kvm->arch.apic_map,
@@ -576,8 +621,14 @@ static void apic_update_ppr(struct kvm_lapic *apic)
 	else
 		ppr = isrv & 0xf0;
 
+#ifdef CONFIG_POPCORN_HYPE
+// pophype
+//	apic_debug("vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x",
+//		   apic, ppr, isr, isrv);
+#else
 	apic_debug("vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x",
 		   apic, ppr, isr, isrv);
+#endif
 
 	if (old_ppr != ppr) {
 		apic_set_reg(apic, APIC_PROCPRI, ppr);
@@ -662,10 +713,15 @@ bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,
 	struct kvm_lapic *target = vcpu->arch.apic;
 	u32 mda = kvm_apic_mda(dest, source, target);
 
+#ifdef CONFIG_POPCORN_HYPE
+//	apic_debug("target %p, source %p, dest 0x%x, "
+//		   "dest_mode 0x%x, short_hand 0x%x\n",
+//		   target, source, dest, dest_mode, short_hand);
+#else
 	apic_debug("target %p, source %p, dest 0x%x, "
 		   "dest_mode 0x%x, short_hand 0x%x\n",
 		   target, source, dest, dest_mode, short_hand);
-
+#endif
 	ASSERT(target);
 	switch (short_hand) {
 	case APIC_DEST_NOSHORT:
@@ -686,6 +742,29 @@ bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,
 	}
 }
 
+#if POPCORN_STAT_MQ_INFO
+#define MAX_MQ 4
+u64 rx_total[MAX_MQ] = {0, 0, 0, 0};
+void pophype_mq_rx_stat(struct seq_file *seq, void *v)
+{
+    if (seq) {
+        seq_printf(seq, "cpu 0\t1\t2\t3\n");
+        seq_printf(seq, "rx %llu\t%llu\t%llu\t%llu\n",
+                    rx_total[0], rx_total[1], rx_total[2], rx_total[3]);
+    } else {
+        /* Clean all in all q (host:32/128 vm:1/4) */
+        int i;
+        for (i = 0; i < MAX_MQ; i++)
+            rx_total[i] = 0;
+    }
+}
+#endif
+#ifdef CONFIG_POPCORN_HYPE
+/*
+ * kvm_lapic: inject a vcpu interrupt and kick out the vcpu from guest mode.
+ * r = succ_cnt
+ */
+#endif
 bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,
 		struct kvm_lapic_irq *irq, int *r, unsigned long *dest_map)
 {
@@ -694,6 +773,9 @@ bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,
 	struct kvm_lapic **dst;
 	int i;
 	bool ret, x2apic_ipi;
+#if defined(CONFIG_POPCORN_HYPE) && HYPE_PERF_CRITICAL_DEBUG
+	static int cnt = 0;
+#endif
 
 	*r = -1;
 
@@ -718,26 +800,87 @@ bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,
 		goto out;
 	}
 
+#if HYPE_PERF_CRITICAL_DEBUG && defined(CONFIG_POPCORN_HYPE)
+	//if (distributed_process(current)) {
+		/* handle_ept_misconfig may come with !src. Too many */
+		/* will return from fast. only one exception */
+		cnt++;
+		if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT) {
+			IPIPRINTK("\t%s(): [%d/%d] <%d> -ipi> <%u><irq->dest_id> "
+				"dest_mode 0x%x %s - 5 0x%lx #%d\n",
+				__func__, my_nid, current->pid, src ? src->vcpu->vcpu_id : -1,
+				irq->dest_id, irq->dest_mode,
+					irq->dest_mode == APIC_DEST_PHYSICAL ? "PHYSICAL map TRUST" :
+						irq->dest_mode == APIC_DEST_LOGICAL ? "LOGICAL map DON'T TRUST" : "",
+				(long int)irq->dest_mode, cnt);
+		}
+	//}
+#endif
+
+	/* phy/local map */
 	if (irq->dest_mode == APIC_DEST_PHYSICAL) {
-		if (irq->dest_id >= ARRAY_SIZE(map->phys_map))
+		if (irq->dest_id >= ARRAY_SIZE(map->phys_map)) {
+#ifdef CONFIG_POPCORN_HYPE
+		//if (distributed_process(current)) {
+			IPIVPRINTK("\t%s(): [%d/%d] <%d> -ipi> <%u> - 6 "
+						"MAYBE BAD OUT ***NOT HAPPEN***\n",
+						__func__, my_nid, current->pid,
+						src ? src->vcpu->vcpu_id : -1, irq->dest_id);
+		//}
+#endif
 			goto out;
+		}
 
 		dst = &map->phys_map[irq->dest_id];
+#ifdef CONFIG_POPCORN_HYPE
+		/* not broadcase or not low priority */
+		//PHAPICPRINTK("%s(): take dst %p = map->phys_map[%u] (%s)\n",
+		//						__func__, dst, irq->dest_id,
+		//	distributed_process(current) ? "POPCORN" : "VANILLA");
+#endif
 	} else {
 		u16 cid;
 
 		if (!kvm_apic_logical_map_valid(map)) {
 			ret = false;
+#ifdef CONFIG_POPCORN_HYPE
+			//if (distributed_process(current)) {
+				IPIVPRINTK("\t%s(): [%d/%d] <%d> -ipi> <%d> - 7 "
+							"GOOD (important) ***NOT HAPPEN***\n",
+							__func__, my_nid, current->pid,
+							src ? src->vcpu->vcpu_id : -1, irq->dest_id);
+			//}
+#endif
 			goto out;
 		}
 
 		apic_logical_id(map, irq->dest_id, &cid, (u16 *)&bitmap);
 
-		if (cid >= ARRAY_SIZE(map->logical_map))
+		if (cid >= ARRAY_SIZE(map->logical_map)) {
+#ifdef CONFIG_POPCORN_HYPE
+			//if (distributed_process(current)) {
+				IPIVPRINTK("\t%s(): [%d/%d] <%d> -ipi> <%d> - 7-2 "
+							"GOOD OUT ***NOT HAPPEN***\n",
+							__func__, my_nid, current->pid,
+							src ? src->vcpu->vcpu_id : -1, irq->dest_id);
+			//}
+#endif
 			goto out;
+		}
 
 		dst = map->logical_map[cid];
 
+		//PHAPICPRINTK("%s(): take dst %p = map->logical_map[%u] (%s)\n",
+		//								__func__, dst, irq->dest_id,
+		//		distributed_process(current) ? "POPCORN" : "VANILLA");
+#ifdef CONFIG_POPCORN_HYPE
+	//if (distributed_process(current)) {
+		IPIVPRINTK("\t%s(): [%d/%d] <%d> -ipi> <%d> - double check %d\n",
+					__func__, my_nid, current->pid,
+					src ? src->vcpu->vcpu_id : -1, irq->dest_id, (int)cid);
+	//}
+#endif
+
 		if (kvm_lowest_prio_delivery(irq)) {
 			int l = -1;
 			for_each_set_bit(i, &bitmap, 16) {
@@ -753,17 +896,490 @@ bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,
 		}
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+#if HYPE_PERF_CRITICAL_DEBUG
+	//if (distributed_process(current)) {
+		IPIVPRINTK("\t%s(): [%d/%d] <%d> -ipi> <%d> - 8 bitmap 0x%lx dst %p *dst %p\n",
+				__func__, my_nid, current->pid,
+				src ? src->vcpu->vcpu_id : -1, irq->dest_id, bitmap, dst, *dst);
+	//}
+#endif
+#endif
+
 	for_each_set_bit(i, &bitmap, 16) {
-		if (!dst[i])
+#ifdef CONFIG_POPCORN_HYPE
+		static int cnt = 0, cnt2 = 0;
+		cnt2++;
+		IPIVPRINTK("\t%s(): [%d/%d] <%d> -ipi> <%d> - 9-0 peak dst[%d] %lx %p #%d\n",
+				__func__, my_nid, current->pid, src ? src->vcpu->vcpu_id : -1,
+				irq->dest_id, i, (unsigned long)&dst[i], dst[i], cnt2);
+#endif
+
+		if (!dst[i]) {
+#ifdef CONFIG_POPCORN_HYPE
+			/* TODO check good/vanilla cases*/
+#endif
 			continue;
+		}
 		if (*r < 0)
 			*r = 0;
+
+#ifdef CONFIG_POPCORN_HYPE
+		IPIVPRINTK("\t = %s(): [%d/%d] <%d>%s =kvmipi> <%d> - 9 "
+					"dest_map %p mode 0x%x <%u>\n",
+					__func__, my_nid, current->pid,
+					src ? src->vcpu->vcpu_id : -1,
+					!src ? "<hw>" : "",
+					dst[i]->vcpu->vcpu_id,
+					dest_map, irq->delivery_mode, irq->dest_id);
+		/* !src->vcpu->vcpu_id means not IPI?
+			from HW (100% from msi)? Here is the injection place */
+
+		/* sipi/ipi redirection
+		 * BSP wakes up each AP via a INIT-SIPI-SIPI (ISS) sequence:
+		 * 						APIC_DM_INIT x 1 + APIC_DM_STARTUP x 2
+		 */
+		if (distributed_process(current)
+			&& my_nid != popcorn_vcpuid_to_nid(dst[i]->vcpu->vcpu_id)
+			//&& my_nid >= 0 /* for vanilla */
+			/* for deferenciating from remote/local to prevent from
+				nesting redirection. pophype will inject a irq from remote/
+				Not from remote, from local. */
+			&& dest_map != REMOTE_APIC /* prevent from pophype recursive */
+		) { /* redirect ipi/irq insertion */
+			int old_r = *r;
+			static unsigned long pophype_sent_cnt = 0;
+			pophype_sent_cnt++;
+#define HANDLE_NET_MSI 1
+/* when meet interrupts caused by net package
+	1: vcpu0 is always used
+	0: use popcorn distribute it (testing required)*/
+#if !HANDLE_NET_MSI
+			/* Many dest_vcpu_id=2/3 to vcpu1 */
+			*r += popcorn_send_ipi(dst[i]->vcpu, irq, dest_map);
+#if POPCORN_STAT_MQ_INFO
+			/* Still peek handling NET_MSI case statis */
+			if (!src && irq->delivery_mode == APIC_DM_LOWEST) { /* NET_MSI case */
+				// working on
+				if (i < MAX_MQ)
+					rx_total[i]++;
+			}
+#endif
+			/* Since many printk on vcpu1 */
+			//if (!src && irq->delivery_mode == APIC_DM_LOWEST) { /* NET_MSI case */
+			//	if (dst[i]->vcpu->vcpu_id < 4) { /* BIG HACK - make it dynamic
+			//					(check guest kernel boot log), we may be good */
+			//		*r += popcorn_send_ipi(dst[i]->vcpu, irq, dest_map);
+			//	} /* Ignore vcpu_id >= 4 since they are not existing */
+			//} else { /* popcorn distributed case */
+			//	*r += popcorn_send_ipi(dst[i]->vcpu, irq, dest_map);
+			//}
+
+#else /* For NET_MSI 1 */
+			/* NET_MSI - before NIC working, msi_in&out both receive a irq in
+				the very beginning. However, these IRQ always happens on VCPU1
+				(idk why). They are ~6 misconfit mmio exit comes together.
+				I believe one of them injects the IRQ. This irq has no src.
+				It's not from other vCPU but IO */
+			/* It makes sense, !src -> not from vcpu but io (like msi) */
+			/* TODO: check if !src always comes with APIC_DM_LOWEST */
+			if (!src && irq->delivery_mode == APIC_DM_LOWEST) { /* NET_MSI case */
+				/* TODO - always redirect to HOST because
+					we restrict such things happen in the upper layer.
+					I (vcpu0) must be in the host now.
+					And thus use vcpu0's kvm_vcpu/kvm_lapic */
+				struct kvm_vcpu *vcpu0 = pophype_vcpu0;
+				cnt++;
+				//apic = vcpu->arch.apic;
+#if POPCORN_STAT_MQ_INFO
+				if (vcpu0->vcpu_id < MAX_MQ) {
+					rx_total[vcpu0->vcpu_id]++;
+				}
+#endif
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+				BUG_ON(!pophype_vcpu0);
+#endif
+				CRITICALNETPK("\t%s(): [%d/%d <%d>] ***NET_MSI*** case src %p mode 0x%x "
+							"= redirect to local cpu (dest_mode 0x%x) redirect [%u] -> [%u] #%d\n",
+							__func__, my_nid, current->pid, smp_processor_id(), /* CAN I AWALY PIN MYSELVE IF MSI */
+							src, irq->delivery_mode, irq->dest_mode,
+							dst[i]->vcpu->vcpu_id, vcpu0->vcpu_id, cnt);
+
+				/* HACK im testing */
+				//*r += kvm_apic_set_irq(dst[my_nid]->vcpu, irq, dest_map);
+
+				/* vanilla */
+				//*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map); /* vanilla */
+
+				/* pophype vhost-net handle msi on only node0 */
+				*r += kvm_apic_set_irq(vcpu0, irq, dest_map); /* pophype vhost-net handle msi */
+
+				/* Sould I prevent from multiple redirection?
+					I believe MSI INT (/any INT) doesn't signal more than 1 vcpu */
+				// return ret;
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+			} else if (!src && irq->delivery_mode != APIC_DM_LOWEST) {
+				/* corner case that I don't handle */
+				WARN_ON(!src && irq->delivery_mode != APIC_DM_LOWEST);
+#endif
+			} else { /* popcorn distributed case */
+				*r += popcorn_send_ipi(dst[i]->vcpu, irq, dest_map);
+			}
+#endif
+			/* no matter local or forward - debug here */
+			//if (r == 0)
+#if HYPE_PERF_CRITICAL_DEBUG
+			int remtoe_node_src = src ? src->vcpu->vcpu_id : 0; /*name is bad */
+			if (irq->delivery_mode ||
+				!(pophype_sent_cnt % 10000) || remtoe_node_src) {
+				/* ipi's mode > 0 // too many mode=0 BUT
+					dest mode = 0 : physical mode -
+						dest field means target cpu's apic ID.
+						0xff means broadcast
+					dest mode = 1 : logical mode -
+						dest field means Message Dest Address (MDA)
+							IPI sent to the bus, apic on each cpu
+							according to it's Logical Dest Reg (LDR) and
+							Dest Format Reg (DFR) decides whether
+							to accept tihs IPI
+				*/
+				/* e.g. APIC_DM_STARTUP 600 APIC_DM_INIT 500 */
+				IPIPRINTK("\t%s(): [%d/%d] <%d>%s =kvmipi> <%d> "
+							"irq->dst_id <%u> dest_mode 0x%x %s "
+							"bitmap 0x%lx - 90 "
+							"dest_map %p mode 0x%x r %s %d/%lu #%lu\n",
+							__func__, my_nid, current->pid,
+							src ? src->vcpu->vcpu_id : -1,
+							!src ? "<msi (aka hw?)>" : "",
+							dst[i]->vcpu->vcpu_id,
+							irq->dest_id, irq->dest_mode,
+							irq->dest_mode == APIC_DEST_PHYSICAL ?
+												"PHYSICAL map TRUST" :
+								irq->dest_mode == APIC_DEST_LOGICAL ?
+												"LOGICAL map DON'T TRUST" :
+												"BUG(not for MSI)",
+								/*TODO; check giant VM for phy&log int */
+							bitmap, dest_map,
+							irq->delivery_mode,
+							!r ? "bad":"good", i, bitmap, pophype_sent_cnt);
+#if HYPE_PERF_CRITICAL_IPI_DEBUG
+				if (pophype_sent_cnt >= 200 && pophype_sent_cnt <= 300) { // debug
+					dump_stack(); // debug
+				} else if (my_nid > 0) { dump_stack(); } // debug
+#endif
+			}
+#endif // end HYPE_PERF_CRITICAL_DEBUG
+
+#ifdef CONFIG_POPCORN_CHECK_SANITY /* Important debug info - since we don't hanle this now */
+			if (*r == old_r) { /* Didn't succ. e.g. remote found !dst[dst_vcpu_id] */
+				/* TODO - vanilla & pophype both happen */
+				/* leave it or retry? */
+				PHMIGRATEPRINTK(KERN_ERR "\t Remote found !dst_cpu<%d> new %d old %d "
+						"my_nid %d target_nid %d (%s) gcpus[0-4]\n",
+						dst[i]->vcpu->vcpu_id, *r, old_r,
+						my_nid, popcorn_vcpuid_to_nid(dst[i]->vcpu->vcpu_id),
+						my_nid == popcorn_vcpuid_to_nid(
+							dst[i]->vcpu->vcpu_id) ? "local" : "delegation");
+				popcorn_show_gcpu_table();
+				//dump_stack();
+				PHMIGRATEPRINTK(KERN_ERR "\t - [pophypemigrate] aka race condition "
+								"durring pophype migration. Handle it\n");
+				// local: my_nid == popcorn_vcpuid_to_nid(dst[i]->vcpu->vcpu_id)
+				// forward: my_nid != popcorn_vcpuid_to_nid(dst[i]->vcpu->vcpu_id)
+			}
+#endif
+		} else { /* !distributed_process */
+			if (dest_map == REMOTE_APIC) { /* local irq insertion req from a remote node */
+				dest_map = NULL; /* This is an assumption we don't handle any !!dest_map */
+
+				IPIPRINTK("\t =kvmipi> <*%d*> %s(): [%d/%d] <%d>%s "
+							"irq->dst_id <%u> dest_mode 0x%x %s - 91 "
+							"dest_map %p mode 0x%x r %s #%d\n",
+						dst[i]->vcpu->vcpu_id, __func__, my_nid, current->pid,
+						src ? src->vcpu->vcpu_id : -1,
+						!src ? "<msi (aka hw?)>" : "",
+						irq->dest_id, irq->dest_mode,
+						irq->dest_mode == APIC_DEST_PHYSICAL ?
+							"PHYSICAL map TRUST" :
+								irq->dest_mode == APIC_DEST_LOGICAL ?
+									"LOGICAL map DON'T TRUST" : "BUG",
+						dest_map, irq->delivery_mode, !r ? "bad":"good", cnt2);
+			}
+			/* <0> sends so many ipi to remote vcpu */
+
+			/* local msi irq injection also takes this path
+				because the MSI IRQ is injected by vhost-<PID> */
+			IPIPRINTK("\t vanilla ipi <%d> =vanillakvmipi> <*%d*>? %s(): "
+						"[%d] <%d>%s -%d/? (or from local MSI IRQ inj) #%d\n",
+						smp_processor_id(), dst[i]->vcpu->vcpu_id,
+						__func__, current->pid,
+						src ? src->vcpu->vcpu_id : -1,
+						!src ? "<msi (aka hw?)>" : "", i, cnt2);
+#if HYPE_PERF_CRITICAL_IPI_DEBUG
+			if (cnt2 > 300) // debug
+				dump_stack(); // debug
+#endif
+			*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);
+		}
+
+		//if (irq->delivery_mode
+#if HYPE_PERF_CRITICAL_IPI_DEBUG
+//		if (dst[i]->vcpu) { // for vanilla printk
+//			if (irq->delivery_mode)
+//				IPIVPRINTK("\t%s(): [%d/%d] <%d>%s =kvmipi> <%d> - 9 VANILLA"
+//					"dest_map %p mode 0x%x r %s #%d VANILLA\n",
+//					__func__, my_nid, current->pid,
+//					src ? src->vcpu->vcpu_id : -1,
+//					!src ? "<hw>" : "",
+//					dst[i]->vcpu->vcpu_id,
+//					dest_map, irq->delivery_mode, !r ? "bad":"good", cnt2);
+//		}
+#endif
+#else
 		*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);
+#endif
+	}
+out:
+	rcu_read_unlock();
+	return ret;
+}
+
+#ifdef CONFIG_POPCORN_HYPE
+/* We know which dest vcpu here */
+bool popcorn_kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,
+	struct kvm_lapic_irq *irq, int *r, unsigned long *dest_map, int dst_vcpu_id)
+{
+	struct kvm_apic_map *map;
+	unsigned long bitmap = 1;
+	struct kvm_lapic **dst;
+	//int i;
+	bool ret;
+
+	/******************* POPHYPE HACK ************************/
+	/******************* POPHYPE HACK ************************/
+	/******************* POPHYPE HACK ************************/
+	//irq->dest_mode = APIC_DEST_LOGICAL;
+	// There are routes can trigger this but I don't know where.
+	// Check process_ipi_request() if (sipi)'s else !!!!!!!
+	/******************* POPHYPE HACK ************************/
+	/******************* POPHYPE HACK ************************/
+	/******************* POPHYPE HACK ************************/
+
+
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	/* From remote. It's impossible to be itself */
+	BUG_ON(irq->shorthand == APIC_DEST_SELF);
+#endif
+
+	if (irq->shorthand) {
+		BUG(); /* Never happen */
+		return false;
+	}
+
+//  remove when supporting muti-vcpu
+//	bool x2apic_ipi;
+//	x2apic_ipi = src && apic_x2apic_mode(src);
+//	if (irq->dest_id == (x2apic_ipi ? X2APIC_BROADCAST : APIC_BROADCAST)) {
+//		BUG(); /* Never happen */
+//		return false;
+//	}
+
+	ret = true;
+	rcu_read_lock();
+	map = rcu_dereference(kvm->arch.apic_map);
+
+	if (!map) {
+		ret = false;
+		BUG(); /* Never happen */
+		goto out;
+	}
+
+#if HYPE_PERF_CRITICAL_DEBUG
+#ifdef CONFIG_POPCORN_HYPE
+	//if (distributed_process(current)) {
+	if (irq->delivery_mode) { /* ipi's mode > 0 (x500/600) // too many mode=0 */
+		/* handle_ept_misconfig may come with !src */
+		/* will return from fast. only one exception */
+		IPIPRINTK("\t => %s(): [%d/%d] <%d> -ipi> <%d> (%s) - 5 dst_mode 0x%lx "
+					"irq->dest_id %u\n",
+					__func__, my_nid, current->pid, src ? src->vcpu->vcpu_id : -1,
+					dst_vcpu_id,
+					irq->dest_mode == APIC_DEST_PHYSICAL ? "PHYSICAL map TRUST" :
+						irq->dest_mode == APIC_DEST_LOGICAL ? "LOGICAL map DON'T TRUST" : "BUG",
+					(long int)irq->dest_mode,
+					irq->dest_id);
+	}
+#endif
+#endif
+
+	/* phy/logic map */
+	if (irq->dest_mode == APIC_DEST_PHYSICAL) {
+		if (irq->dest_id >= ARRAY_SIZE(map->phys_map)) {
+#ifdef CONFIG_POPCORN_HYPE
+		//if (distributed_process(current)) {
+			IPIVPRINTK("\t => %s(): [%d/%d] <%d> -ipi> <%d> - 6 "
+						"MAYBE BAD OUT ***NOT HAPPEN***\n",
+						__func__, my_nid, current->pid,
+						src ? src->vcpu->vcpu_id : -1, dst_vcpu_id);
+		//}
+#endif
+			BUG();
+			goto out;
+		}
+
+#ifdef CONFIG_POPCORN_HYPE
+		/* not broadcast or not low priority */
+
+		/********** Popcorn recreated (synced across node) TODO CHECK!!! ************/
+#endif
+		/* TODO CHECK.... metadata not synced */
+		dst = &map->phys_map[irq->dest_id];
+	} else {
+		u16 cid;
+
+		/* The logical map is definitely wrong if we have multiple
+			modes at the same time. (Physical map is always right.) */
+		if (!kvm_apic_logical_map_valid(map)) {
+			ret = false;
+#ifdef CONFIG_POPCORN_HYPE
+			//if (distributed_process(current)) {
+				IPIVPRINTK("\t => %s(): [%d/%d] <%d> -ipi> <%d> - 7 "
+							"GOOD (important) ***NOT HAPPEN***\n",
+							__func__, my_nid, current->pid,
+							src ? src->vcpu->vcpu_id : -1, dst_vcpu_id);
+			//}
+#endif
+			BUG();
+			goto out;
+		}
+
+		/* TODO CHECK.... metadata not synced */
+		apic_logical_id(map, irq->dest_id, &cid, (u16 *)&bitmap);
+
+		if (cid >= ARRAY_SIZE(map->logical_map)) {
+#ifdef CONFIG_POPCORN_HYPE
+			//if (distributed_process(current)) {
+				IPIVPRINTK("\t => %s(): [%d/%d] <%d> -ipi> <%d> - 7-2 "
+							"GOOD OUT ***NOT HAPPEN***\n",
+							__func__, my_nid, current->pid,
+							src ? src->vcpu->vcpu_id : -1, dst_vcpu_id);
+			//}
+#endif
+			BUG();
+			goto out;
+		}
+
+		/********** Popcorn recreated (synced across node ) ************/
+		dst = map->logical_map[cid];
+
+#ifdef CONFIG_POPCORN_HYPE
+		//if (distributed_process(current)) {
+			IPIVPRINTK("\t => %s(): [%d/%d] <%d> -ipi> <%d> - double check cid %d\n",
+						__func__, my_nid, current->pid,
+						src ? src->vcpu->vcpu_id : -1, dst_vcpu_id, (int)cid);
+		//}
+#endif
+
+		/* TODO CHECK.... metadata not synced */
+		/* pophype dones't need it - if on,  bitmap will be the vcpu_id */
+#if 0
+		if (kvm_lowest_prio_delivery(irq)) {
+			int l = -1;
+			for_each_set_bit(i, &bitmap, 16) {
+				if (!dst[i])
+					continue;
+				if (l < 0)
+					l = i;
+				else if (kvm_apic_compare_prio(dst[i]->vcpu, dst[l]->vcpu) < 0)
+					l = i;
+			}
+
+			bitmap = (l >= 0) ? 1 << l : 0;
+		}
+#endif
 	}
+
+#ifdef CONFIG_POPCORN_HYPE
+#if HYPE_PERF_CRITICAL_DEBUG
+	//if (distributed_process(current))
+	{
+		static int cnt = 0; /* For debugging */
+		cnt++;
+		if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT || !(cnt % 10000)) {
+			IPIPRINTK("\t => %s(): [%d/%d] <%d> -ipi> <*%d*> - 8 "
+					"bitmap 0x%lx dst %p dst[0] %p "
+					//"->vcpu_id %d "
+					"irq->dest_id <%d?> %s #%d\n",
+					__func__, my_nid, current->pid,
+					src ? src->vcpu->vcpu_id : -1,
+					dst_vcpu_id, bitmap, dst, dst[0],
+					//dst[dst_vcpu_id]->vcpu->vcpu_id,
+					irq->dest_id,
+					irq->dest_mode == APIC_DEST_PHYSICAL ?
+						"PHYSICAL map TRUST" : "LOGICAL map DON'T TRUST", cnt);
+		}
+		// for dst[dst_vcpu_id]
+	}
+#endif
+#endif
+
+	/* popcorn forces to ipi !!! */
+#ifdef CONFIG_POPCORN_HYPE
+	//BUG_ON(!dst[dst_vcpu_id]); /* This can happen in vanilla kernel... if here, change to return 0*/
+	if (!dst[dst_vcpu_id]) { /* May run till user space but works for muti-threaded apps? */
+		*r = 0;
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+		ret = false; // redundnat
+		printk(KERN_ERR "\t => found !dst[%d]\n", dst_vcpu_id);
+#endif
+		goto out;
+	}
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	BUG_ON(!dst[dst_vcpu_id]->vcpu);
+#endif
+	// dst[dst_vcpu_id]->vcpu->vcpu_id on my nid?
+#endif
+	/* popcorn assumption REMOTE_APIC
+	 * HACK - assumption - all the local irq are always !dest_map
+	 * So here I've knew this is from remote (REMOTE_APIC),
+	 * now set it back to !dest_map
+	 * dst[dst_vcpu_id]->vcpu: source vcpu from a remote node
+	 *
+	 * Mimic lapic bus transfer
+	 * key func: kvm_apic_set_irq() -> __apic_accept_irq(dst_apic)
+	 */
+	*r += popcorn_kvm_apic_set_irq(dst[dst_vcpu_id]->vcpu, irq, NULL);
+
 out:
 	rcu_read_unlock();
 	return ret;
 }
+#endif
+
+#ifdef CONFIG_POPCORN_HYPE
+/* TODO tsk struct? */
+/*
+ * vcpu: source vcpu
+ * apic: source apic
+ * Finally here! From remote.
+ */
+int popcorn_kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,
+		unsigned long *dest_map)
+{
+	struct kvm_lapic *apic = vcpu->arch.apic;
+
+	// this is popcorn. I set it because for debugging. (REMOTE_APIC).
+	// but i only do for !sipi, this is sipi route right?
+	dest_map = NULL;
+	// Too many. Don't trust irq->dest_id
+	IPIVPRINTK("\t\t => %s(): -kvmipi> irq->dest_id <%u?> %s\n",
+			__func__, irq->dest_id,
+			irq->dest_mode == APIC_DEST_PHYSICAL ? "TRUST" : "DON'T TRUST");
+	//BUG_ON(!popcorn_on_right_nid(irq->dest_id)); // irq->dest_id is not true
+	return popcorn_apic_accept_irq(apic, irq->delivery_mode, irq->vector,
+			irq->level, irq->trig_mode, dest_map);
+}
+#endif
 
 bool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,
 			struct kvm_vcpu **dest_vcpu)
@@ -828,6 +1444,17 @@ out:
  * Add a pending IRQ into lapic.
  * Return 1 if successfully added and 0 if discarded.
  */
+#ifdef CONFIG_POPCORN_HYPE
+//extern bool hype_callin[][];
+#define LEN 8192
+unsigned long user_ram_start = 0x7ffec0000000;
+unsigned long user_ram_eip = 0x99000; // start_ip 612k < 1M real mode
+// = istart_ip = real_mode_header->trampoline_start
+//unsigned long user_start_second = 0xffffffff8108d680; // overflow
+#endif
+/* Accept/Inject irq on a dst apic/vcpu
+ * apic: dst apic
+ */
 static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,
 			     int vector, int level, int trig_mode,
 			     unsigned long *dest_map)
@@ -835,12 +1462,40 @@ static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,
 	int result = 0;
 	struct kvm_vcpu *vcpu = apic->vcpu;
 
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	if (unlikely(!vcpu)) {
+		printk(KERN_ERR "\n\ndelivery_mode %d\n\n", delivery_mode);
+		BUG(); // BUG_ON(!vcpu);
+	}
+#endif
 	trace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,
 				  trig_mode, vector);
 	switch (delivery_mode) {
-	case APIC_DM_LOWEST:
+	case APIC_DM_LOWEST: // 0x100
 		vcpu->arch.apic_arb_prio++;
-	case APIC_DM_FIXED:
+	case APIC_DM_FIXED: // 0x000
+#if defined(CONFIG_POPCORN_HYPE) && HYPEBOOTDEBUG
+		// many <0> doing APIC_ICR and <1>(remote) receives this
+		//if (vcpu->vcpu_id)
+		{
+			static unsigned int dm_fixed = 0;
+			dm_fixed++;
+			if (dm_fixed > 0 && dm_fixed < VM_SINGLE_HANDLE_DISPLAY_CNT) {
+				POP_PK("\t\t%s(): [%d/%d] IRQ local APIC_DM_FIXED -> <%d> "
+						"trig_mode %d level %d apic_enabled(apic) %s "
+						" &&& other test %s (if(O)->trig_mode 1:set 0:clear) "
+						"kvm_x86_ops->deliver_posted_interrupt %s "
+						"dest_map %p #%u\n",
+						__func__, my_nid, current->pid,
+						vcpu->vcpu_id, trig_mode, level,
+						apic_enabled(apic) ? "O" : "X",
+						apic_test_vector(vector, apic->regs + APIC_TMR) !=
+							!!trig_mode ? "O" : "X",
+						kvm_x86_ops->deliver_posted_interrupt ? "O" : "X",
+													dest_map, dm_fixed);
+			}
+		}
+#endif
 		if (unlikely(trig_mode && !level))
 			break;
 
@@ -875,21 +1530,34 @@ static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,
 		vcpu->arch.pv.pv_unhalted = 1;
 		kvm_make_request(KVM_REQ_EVENT, vcpu);
 		kvm_vcpu_kick(vcpu);
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("\t\t%s(): local IRQ APIC_DM_REMRD -> %d\n", __func__, vcpu->vcpu_id);
+#endif
 		break;
 
 	case APIC_DM_SMI:
 		result = 1;
 		kvm_make_request(KVM_REQ_SMI, vcpu);
 		kvm_vcpu_kick(vcpu);
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("\t\t%s(): local IRQ APIC_DM_SMI -> %d\n", __func__, vcpu->vcpu_id);
+#endif
 		break;
 
 	case APIC_DM_NMI:
 		result = 1;
 		kvm_inject_nmi(vcpu);
 		kvm_vcpu_kick(vcpu);
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("\t\t%s(): local IRQ APIC_DM_NMI -> %d\n", __func__, vcpu->vcpu_id);
+#endif
 		break;
 
 	case APIC_DM_INIT:
+// BSP at remote WORKING done in handle_apic_write
+//#ifdef CONFIG_POPCORN_HYPE
+//		KVM_EXIT_POPCORN_HYPE
+//#endif
 		if (!trig_mode || level) {
 			result = 1;
 			/* assumes that there are only KVM_APIC_INIT/SIPI */
@@ -899,6 +1567,10 @@ static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,
 			smp_wmb();
 			kvm_make_request(KVM_REQ_EVENT, vcpu);
 			kvm_vcpu_kick(vcpu);
+#ifdef CONFIG_POPCORN_HYPE
+			POP_PK("\t\t%s(): local IRQ APIC_DM_INIT -> %d\n",
+						__func__, vcpu->vcpu_id);
+#endif
 		} else {
 			apic_debug("Ignoring de-assert INIT to vcpu %d\n",
 				   vcpu->vcpu_id);
@@ -906,10 +1578,52 @@ static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,
 		break;
 
 	case APIC_DM_STARTUP:
-		apic_debug("SIPI to vcpu %d vector 0x%02x\n",
-			   vcpu->vcpu_id, vector);
+		apic_debug("SIPI to vcpu %d vector 0x%02x (%s())\n",
+			   vcpu->vcpu_id, vector, __func__);
+#ifdef CONFIG_POPCORN_HYPE
+		/* ***TWO*** SIPI from BSP => AP */
+		SIPIPRINTK("\t\t#kvm_smp_boot [%d/%d]: "
+				"IRQ redirect this SIPI on real node of vcpu %d\n",
+				current->pid, smp_processor_id(), vcpu->vcpu_id);
+		//popcorn_send_sipi(vcpu->vcpu_id, vector); // old code
+#ifdef CONFIG_POPCORN_HYPE
+#if ENFORCE_TOUCH_USR
+        if (vcpu->vcpu_id) {
+			int i;
+            char temp[ENFORCE_TOUCH_BYTES];
+            SIPIPRINTK("\t#kvm_smp_boot: before kvm_run, "
+					"check eip (set by BSP at origin) in the guest at remote\n");
+            SIPIPRINTK("\t#kvm_smp_boot: %lx eip %lx (manually keyin)\n",
+											user_ram_start, user_ram_eip);
+            if(copy_from_user(temp,
+				(void __user *)(user_ram_start + user_ram_eip),
+									ENFORCE_TOUCH_BYTES - 1)) {
+                BUG();
+			}
+			memset(temp + ENFORCE_TOUCH_BYTES - 1, 0, 1);
+            SIPIPRINTK("-----------------origin af touch---------------\n");
+			for (i = 0; i < ENFORCE_TOUCH_BYTES; i++) {
+				SIPIPRINTK("%02x ", *(temp + i));
+			}
+			SIPIPRINTK("\n");
+            SIPIPRINTK("-----------cnt = %lu af done----------\n", strlen(temp));
+
+//            if(copy_from_user(temp, (void __user *)(user_ram_start + user_start_second), ENFORCE_TOUCH_BYTES - 1))
+//                BUG();
+//			memset(temp + ENFORCE_TOUCH_BYTES - 1, 0, 1);
+//            printk("-----------------------origin start_second-----------\n");
+//            printk("%s\n", temp);
+//            printk("-----------------------------------------------------\n");
+        }
+#endif
+#endif
+
+		// req(vector, vcpu)
+		// handler() like below
+		// next: see how to notify bsp when ap is done
+#endif
 		result = 1;
-		apic->sipi_vector = vector;
+		apic->sipi_vector = vector; /* AP will read it. */
 		/* make sure sipi_vector is visible for the receiver */
 		smp_wmb();
 		set_bit(KVM_APIC_SIPI, &apic->pending_events);
@@ -923,16 +1637,209 @@ static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,
 		 * before NMI watchdog was enabled. Already handled by
 		 * kvm_apic_accept_pic_intr().
 		 */
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("\t\t%s(): local IRQ APIC_DM_EXTINT -> %d\n", __func__, vcpu->vcpu_id);
+#endif
 		break;
 
 	default:
-		printk(KERN_ERR "TODO: unsupported delivery mode %x\n",
+		printk(KERN_ERR "TODO: unsupported delivery_mode 0x%x\n",
 		       delivery_mode);
 		break;
 	}
 	return result;
 }
 
+int popcorn_apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,
+			     int vector, int level, int trig_mode,
+			     unsigned long *dest_map)
+{
+	int result = 0;
+	struct kvm_vcpu *vcpu = apic->vcpu;
+
+	trace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,
+				  trig_mode, vector);
+
+	switch (delivery_mode) {
+	case APIC_DM_LOWEST: // 0x100
+		vcpu->arch.apic_arb_prio++;
+	case APIC_DM_FIXED: // 0x000
+#if defined(CONFIG_POPCORN_HYPE) && HYPE_PERF_CRITICAL_DEBUG && HYPEBOOTDEBUG
+		// many <0> does APIC_ICR and <1> receives this
+		//if (vcpu->vcpu_id)
+		{
+			static unsigned int dm_fixed = 0;
+			dm_fixed++;
+			if (dm_fixed > 0 && dm_fixed < VM_SINGLE_HANDLE_DISPLAY_CNT) {
+				POP_PK("\t\t%s(): [%d/%d] IRQ local APIC_DM_FIXED -> <%d> "
+						"trig_mode %d level %d apic_enabled(apic) %s "
+						" &&& other test %s (if(O)->trig_mode 1:set 0:clear) "
+						"kvm_x86_ops->deliver_posted_interrupt %s "
+						"dest_map %p #%u\n",
+						__func__, my_nid, current->pid,
+						vcpu->vcpu_id, trig_mode, level,
+						apic_enabled(apic) ? "O" : "X",
+						apic_test_vector(vector, apic->regs + APIC_TMR) !=
+							!!trig_mode ? "O" : "X",
+						kvm_x86_ops->deliver_posted_interrupt ? "O" : "X",
+													dest_map, dm_fixed);
+			}
+		}
+#endif
+		if (unlikely(trig_mode && !level))
+			break;
+
+		/* FIXME add logic for vcpu on reset */
+		if (unlikely(!apic_enabled(apic)))
+			break;
+
+		result = 1;
+
+		if (dest_map)
+			__set_bit(vcpu->vcpu_id, dest_map);
+
+		if (apic_test_vector(vector, apic->regs + APIC_TMR) != !!trig_mode) {
+			if (trig_mode)
+				apic_set_vector(vector, apic->regs + APIC_TMR);
+			else
+				apic_clear_vector(vector, apic->regs + APIC_TMR);
+		}
+
+		// TODO if (delivery_mode == APIC_DM_FIXED)
+
+
+		if (kvm_x86_ops->deliver_posted_interrupt)
+			kvm_x86_ops->deliver_posted_interrupt(vcpu, vector);
+		else {
+			apic_set_irr(vector, apic);
+
+			kvm_make_request(KVM_REQ_EVENT, vcpu);
+			kvm_vcpu_kick(vcpu);
+		}
+		break;
+
+	case APIC_DM_REMRD:
+		result = 1;
+		vcpu->arch.pv.pv_unhalted = 1;
+		kvm_make_request(KVM_REQ_EVENT, vcpu);
+		kvm_vcpu_kick(vcpu);
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("\t\t%s(): local IRQ APIC_DM_REMRD -> %d\n", __func__, vcpu->vcpu_id);
+#endif
+		break;
+
+	case APIC_DM_SMI:
+		result = 1;
+		kvm_make_request(KVM_REQ_SMI, vcpu);
+		kvm_vcpu_kick(vcpu);
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("\t\t%s(): local IRQ APIC_DM_SMI -> %d\n", __func__, vcpu->vcpu_id);
+#endif
+		break;
+
+	case APIC_DM_NMI:
+		result = 1;
+		kvm_inject_nmi(vcpu);
+		kvm_vcpu_kick(vcpu);
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("\t\t%s(): local IRQ APIC_DM_NMI -> %d\n", __func__, vcpu->vcpu_id);
+#endif
+		break;
+
+	case APIC_DM_INIT:
+		if (!trig_mode || level) {
+			result = 1;
+			/* assumes that there are only KVM_APIC_INIT/SIPI */
+			apic->pending_events = (1UL << KVM_APIC_INIT);
+			/* make sure pending_events is visible before sending
+			 * the request */
+			smp_wmb();
+			kvm_make_request(KVM_REQ_EVENT, vcpu);
+			kvm_vcpu_kick(vcpu);
+#ifdef CONFIG_POPCORN_HYPE
+			/* BSP at remote - done in handle_apic_write */
+			POP_PK("\t\t%s(): local IRQ APIC_DM_INIT -> %d\n",
+						__func__, vcpu->vcpu_id);
+#endif
+		} else {
+			apic_debug("Ignoring de-assert INIT to vcpu %d\n",
+				   vcpu->vcpu_id);
+		}
+		break;
+
+	case APIC_DM_STARTUP:
+		apic_debug("SIPI to vcpu %d vector 0x%02x (%s())\n",
+			   vcpu->vcpu_id, vector, __func__);
+#ifdef CONFIG_POPCORN_HYPE
+		/* ***TWO*** SIPI from BSP => AP */
+		SIPIPRINTK("\t\t#kvm_smp_boot [%d/%d]: "
+				"IRQ redirect this SIPI on real node of vcpu %d\n",
+				current->pid, smp_processor_id(), vcpu->vcpu_id);
+#ifdef CONFIG_POPCORN_HYPE
+#if ENFORCE_TOUCH_USR
+        if (vcpu->vcpu_id) {
+			int i;
+            char temp[ENFORCE_TOUCH_BYTES];
+            SIPIPRINTK("\t#kvm_smp_boot: before kvm_run, "
+					"check eip (set by BSP at origin) in the guest at remote\n");
+            SIPIPRINTK("\t#kvm_smp_boot: %lx eip %lx (manually keyin)\n",
+											user_ram_start, user_ram_eip);
+            if(copy_from_user(temp,
+				(void __user *)(user_ram_start + user_ram_eip),
+									ENFORCE_TOUCH_BYTES - 1)) {
+                BUG();
+			}
+			memset(temp + ENFORCE_TOUCH_BYTES - 1, 0, 1);
+            SIPIPRINTK("-----------------origin af touch---------------\n");
+			for (i = 0; i < ENFORCE_TOUCH_BYTES; i++) {
+				SIPIPRINTK("%02x ", *(temp + i));
+			}
+			SIPIPRINTK("\n");
+            SIPIPRINTK("-----------cnt = %lu af done----------\n", strlen(temp));
+
+//            if(copy_from_user(temp, (void __user *)(user_ram_start + user_start_second), ENFORCE_TOUCH_BYTES - 1))
+//                BUG();
+//			memset(temp + ENFORCE_TOUCH_BYTES - 1, 0, 1);
+//            printk("-----------------------origin start_second-----------\n");
+//            printk("%s\n", temp);
+//            printk("-----------------------------------------------------\n");
+        }
+#endif
+#endif
+
+		// req(vector, vcpu)
+		// handler() like below
+		// next: see how to notify bsp when ap is done
+#endif
+		result = 1;
+		apic->sipi_vector = vector; /* AP will read it. */
+		/* make sure sipi_vector is visible for the receiver */
+		smp_wmb();
+		set_bit(KVM_APIC_SIPI, &apic->pending_events);
+		kvm_make_request(KVM_REQ_EVENT, vcpu);
+		kvm_vcpu_kick(vcpu);
+		break;
+
+	case APIC_DM_EXTINT:
+		/*
+		 * Should only be called by kvm_apic_local_deliver() with LVT0,
+		 * before NMI watchdog was enabled. Already handled by
+		 * kvm_apic_accept_pic_intr().
+		 */
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("\t\t%s(): local IRQ APIC_DM_EXTINT -> %d\n", __func__, vcpu->vcpu_id);
+#endif
+		break;
+
+	default:
+		printk(KERN_ERR "TODO: unsupported delivery_mode 0x%x\n",
+		       delivery_mode);
+		break;
+	}
+	return result;
+}
+
+
 int kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)
 {
 	return vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;
@@ -1022,17 +1929,94 @@ static void apic_send_ipi(struct kvm_lapic *apic)
 
 	trace_kvm_apic_ipi(icr_low, irq.dest_id);
 
-	apic_debug("icr_high 0x%x, icr_low 0x%x, "
-		   "short_hand 0x%x, dest 0x%x, trig_mode 0x%x, level 0x%x, "
-		   "dest_mode 0x%x, delivery_mode 0x%x, vector 0x%x, "
-		   "msi_redir_hint 0x%x\n",
-		   icr_high, icr_low, irq.shorthand, irq.dest_id,
-		   irq.trig_mode, irq.level, irq.dest_mode, irq.delivery_mode,
-		   irq.vector, irq.msi_redir_hint);
-
+// lmany
+//	apic_debug("icr_high 0x%x, icr_low 0x%x, "
+//		   "short_hand 0x%x, dest 0x%x, trig_mode 0x%x, level 0x%x, "
+//		   "dest_mode 0x%x, delivery_mode 0x%x, vector 0x%x, "
+//		   "msi_redir_hint 0x%x\n",
+//		   icr_high, icr_low, irq.shorthand, irq.dest_id,
+//		   irq.trig_mode, irq.level, irq.dest_mode, irq.delivery_mode,
+//		   irq.vector, irq.msi_redir_hint);
+#ifdef CONFIG_POPCORN_HYPE
+	{
+		int r;
+		r = kvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);
+		if (r < 0) {
+			POP_PK(KERN_ERR "IPI sent FAIL succ cnt r %d "
+							"apic->vcpu->vcpu_id %d -> %d\n",
+							r, apic ? apic->vcpu->vcpu_id : -1, irq.dest_id);
+		}
+	}
+#else
 	kvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);
+#endif
 }
 
+#ifdef CONFIG_POPCORN_HYPE
+/*
+ * from remote popcorn_send_ipi() req
+ */
+int popcorn_apic_inject_ipi(struct kvm_lapic *apic, struct kvm_lapic_irq *irq, int dst_vcpu_id)
+{
+//	u32 icr_low = kvm_apic_get_reg(apic, APIC_ICR);
+//	u32 icr_high = kvm_apic_get_reg(apic, APIC_ICR2);
+//	struct kvm_lapic_irq irq;
+
+/*
+ * pophype:
+ * If I redirect the entire ipi request when apic is rebuilding the argv,
+ * it cannot infer SIPI requests like APIC_DM_INIT and APIC_DM_STARTUP
+ * (Should I try to replay all these result? (collecting APIC_ICR regs))
+ *
+ * What happens now? renote got this and do it but cannot get right ICR
+ * reg info. So that cannot do SIPI tasks (and even callback).
+ *
+ * Don't get it from apic-reg again. The data is wrong
+ */
+
+//	irq.vector = icr_low & APIC_VECTOR_MASK;
+//	irq.delivery_mode = icr_low & APIC_MODE_MASK;
+//	irq.dest_mode = icr_low & APIC_DEST_MASK;
+//	irq.level = (icr_low & APIC_INT_ASSERT) != 0;
+//	irq.trig_mode = icr_low & APIC_INT_LEVELTRIG;
+//	irq.shorthand = icr_low & APIC_SHORT_MASK;
+//	irq.msi_redir_hint = false;
+//	if (apic_x2apic_mode(apic))
+//		irq->dest_id = icr_high;
+//	else
+//		irq->dest_id = GET_APIC_DEST_FIELD(icr_high);
+//	trace_kvm_apic_ipi(icr_low, irq.dest_id);
+
+	//int r = -1;
+	int r = 0;
+	// mode 0 == APIC_DM_FIXED too many
+	if (irq->delivery_mode) {
+		/* When HANDLE_NET_MSI == 1, this happends even when idle.
+			delivery_mode == APIC_DM_LOWEST: checking src(lapic) now,
+			dest_id == 2/3: even when 2-vcpu case */
+		/* HANDLE_NET_MSI is about networking.
+			It didn't happend becuase we only injected interrupts into vcpu0 */
+		POP_PK("\t\t%s(): replay irq injection (("
+				"src %p apic->vcpu->vcpu_id(lapic) <%d> "
+				"vector %u delivery_mode %u "
+				"dest_mode %u level %d trig_mode %u "
+				"shorthand %u dest_id <%u> msi_redir_hint %d\n",
+				__func__, apic, apic->vcpu->vcpu_id, irq->vector,
+				irq->delivery_mode,
+				irq->dest_mode, irq->level, irq->trig_mode,
+				irq->shorthand, irq->dest_id, irq->msi_redir_hint);
+	}
+
+	// smp - mount_root()
+	//return kvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, irq, REMOTE_APIC);
+	if (popcorn_kvm_irq_delivery_to_apic_fast(
+			apic->vcpu->kvm, apic, irq, &r, REMOTE_APIC, dst_vcpu_id)) // redundant
+		return r;
+	return 0; // redundant
+	//BUG(); /* this will happen now... */
+}
+#endif
+
 static u32 apic_get_tmcct(struct kvm_lapic *apic)
 {
 	ktime_t remaining;
@@ -1301,7 +2285,7 @@ static void start_apic_timer(struct kvm_lapic *apic)
 		hrtimer_start(&apic->lapic_timer.timer,
 			      ktime_add_ns(now, apic->lapic_timer.period),
 			      HRTIMER_MODE_ABS);
-
+#if 0 // Jack
 		apic_debug("%s: bus cycle is %" PRId64 "ns, now 0x%016"
 			   PRIx64 ", "
 			   "timer initial count 0x%x, period %lldns, "
@@ -1311,6 +2295,7 @@ static void start_apic_timer(struct kvm_lapic *apic)
 			   apic->lapic_timer.period,
 			   ktime_to_ns(ktime_add_ns(now,
 					apic->lapic_timer.period)));
+#endif
 	} else if (apic_lvtt_tscdeadline(apic)) {
 		/* lapic timer in tsc deadline mode */
 		u64 guest_tsc, tscdeadline = apic->lapic_timer.tscdeadline;
@@ -1356,12 +2341,106 @@ static void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)
 	}
 }
 
+/*
+ * Hight level
+ * (Not going to inject irq yet)
+ * For support recalc
+ */
 static int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
 {
 	int ret = 0;
+#ifdef CONFIG_POPCORN_HYPE
+	struct kvm_vcpu *vcpu = apic->vcpu; /* THIS IS SRC VCPU*/
+#if HYPE_PERF_CRITICAL_DEBUG
+	static int cnt_icr = 0;
+#endif
+	/* WORKING ON done in handle_apic_write */
+	if (distributed_process(current)) {
+		/* pophype - broadcast/replay + do locally!!! */
+		if (apic_x2apic_mode(apic))
+			printk(KERN_ERR "\n\n\t\tTODO support this 32bit\n\n");
+
+		if (!(val & 0x40000) && /* avoid nested (according "APIC_SELF_IPI") */
+			((reg == APIC_DFR && !apic_x2apic_mode(apic)) ||
+			(reg == APIC_LDR && !apic_x2apic_mode(apic)))
+			/* Don't handle APIC_ICR (aka IPI) */
+			/* __apic_accpet_irq - APIC_DM_LOWEST 0x100 fallthrough to APIC_DM_FIXED 0x0 */
+			) { /* only support recalc */
+			POP_PK("%s(): brocast + do locally - reg 0x%x (need 0xe0, 0xd0) vcpu\n",
+																__func__, reg);
+			popcorn_broadcast_apic_reg_write(vcpu->vcpu_id, reg, val);
+			//printk("Jack why this is not working? 1 reg %d (need 0xe0, 0xd0)\n",
+			//																reg);
+			// If we broad cast, do we do ipi twice? because here 1 + =kvmipi> 1 = 2 ???
+		}
+	}
+
+#if 0
+//	static unsigned long dbg = 0;
+//	static int cnt = 0;
+	/* NOT FULLY WORKING/TESTING YET!!! */
+	if (distributed_process(current) &&
+		//current->at_remote && // why this one is uncomment before 0606 ...
+		vcpu->vcpu_id) { // TODO... // && !smp_processor_id()) {
+		/* DON'T BE NESTED!!! */
+		/* ATTENTION:  smp_processor_id() can be any cpu */
+
+		/* OK.... TODO 0607 now I have to check whether this node owns
+			vcpu->vcpu_id. smp_processor_id() will not tell me about that */
+
+		////////////////////////////////////////////////////////////
+		////////////////////////////////////////////////////////////
+		//BUG_ON("TODO a function returning vcpu is on this node");
+		////////////////////////////////////////////////////////////
+		////////////////////////////////////////////////////////////
+
+		/* TODO BUG this only works for 2 nodes and 1cpu on 1 node */
+		if (!(my_nid && my_nid == vcpu->vcpu_id)) {
+			printk("\t%s(): (NOT SUPPORT) redirect from my [%d/%d] "
+					"<(%d) != %d> => <?> (reg %x val %x) #%d "
+					"(fix NESTING problem then turn on)\n",
+					__func__, my_nid, current->pid,
+					smp_processor_id(), vcpu->vcpu_id,
+					reg, val, cnt);
+
+			/* Not broadcast all but only a few in ipi __apic_accept_irq() */
+			////if (!(reg == APIC_ICR && val & 0x40000)) /* avoid nested reqs (according to code "APIC_SELF_IPI")*/
+			/* avoid nested reqs (according to code "APIC_SELF_IPI")*/
+			if (!(val & 0x40000) && // no nested
+				(reg == APIC_DFR && !apic_x2apic_mode(apic))) { // only support
+				popcorn_broadcast_apic_reg_write(vcpu->vcpu_id, reg, val);
+				printk("Jack why this is not working? 1\n");
+			//} else if (val & 0x40000) {
+			} else { // (val & 0x40000)
+				// from APIC_SELF_IPI
+			}
+			if (reg == APIC_DFR) {
+				printk("Jack why this is not working? 2\n");
+			}
+
+		} else {
+			printk("\t%s(): skip forward [%d/%d] <%d == %d> => <?>\n",
+					__func__, my_nid, current->pid, smp_processor_id(), vcpu->vcpu_id);
+		}
+
+		printk("\t%s(): [%d/%d] <%d> => <?>\n",
+				__func__, my_nid, current->pid, vcpu->vcpu_id);
+	} else {
+		dbg++;
+		if (dbg > 0 && dbg < 10) {
+			printk("\t%s(): vcpu->vcpu_id <%d> smp_processor_id() %d #%lu\n",
+						__func__, vcpu->vcpu_id, smp_processor_id(), dbg);
+		}
+	}
+#endif
+#endif
 
 	trace_kvm_apic_write(reg, val);
 
+	//lmany
+	//apic_debug("%s(): apic %p reg 0x%x val 0x%x\n",
+	//						__func__, apic, reg, val);
+
 	switch (reg) {
 	case APIC_ID:		/* Local APIC ID */
 		if (!apic_x2apic_mode(apic))
@@ -1379,15 +2458,29 @@ static int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
 		apic_set_eoi(apic);
 		break;
 
-	case APIC_LDR:
-		if (!apic_x2apic_mode(apic))
+	case APIC_LDR: /* looks right after DFR and cause recalculate_apic_map as well */
+		if (!apic_x2apic_mode(apic)) {
+#ifdef CONFIG_POPCORN_HYPE
+			/* LDR Logical Destination Register (Base + 0xD0) bit24-31 =
+													Logical APIC ID */
+			if (distributed_process(current)) {
+				POP_PK("\t\t%s(): ok let's go LDR (from local)\n", __func__);
+			}
+#endif
 			kvm_apic_set_ldr(apic, val & APIC_LDR_MASK);
-		else
+		} else
 			ret = 1;
 		break;
 
-	case APIC_DFR:
+	case APIC_DFR: /* register apic in kernel */
 		if (!apic_x2apic_mode(apic)) {
+#ifdef CONFIG_POPCORN_HYPE
+			/* DFR Destination Format Register (Base + 0xE0) bit28-31 = Model;
+										0000=Cluster Model, 1111=Flat Model */
+			if (distributed_process(current)) {
+				POP_PK("\t\t%s(): ok let's go DFR (from local)\n", __func__);
+			}
+#endif
 			apic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);
 			recalculate_apic_map(apic->vcpu->kvm);
 		} else
@@ -1418,6 +2511,25 @@ static int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
 	case APIC_ICR:
 		/* No delay here, so we always clear the pending bit */
 		apic_set_reg(apic, APIC_ICR, val & ~(1 << 12));
+#if HYPE_PERF_CRITICAL_DEBUG
+#ifdef CONFIG_POPCORN_HYPE
+//#if HYPE_PERF_CRITICAL_DEBUG /* only #122, a few after first bash script finished */
+		/* TODO my node and apic->vcpu->vcpu_id if are the same then don't broadcast */
+		/* this will trigger dst cpu to invoke __apic_accept_irq() -
+											SIPI is also from here */
+		//if (distributed_process(current)) {
+			if (cnt_icr < 100 || vcpu->vcpu_id) {
+				cnt_icr++;
+				POP_PK("\t%s(): [%d/%d] local APIC_ICR (apic_send_ipi) "
+						"<%d> => <?> (__apic_accept_irq()) val 0x%x #%d\n",
+						__func__, my_nid, current->pid,
+						vcpu->vcpu_id, val, cnt_icr);
+			}
+		//}
+		/* Looks like apic_send_ipi() fail will somehow retry w/o */
+//#endif
+#endif
+#endif
 		apic_send_ipi(apic);
 		break;
 
@@ -1425,6 +2537,12 @@ static int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
 		if (!apic_x2apic_mode(apic))
 			val &= 0xff000000;
 		apic_set_reg(apic, APIC_ICR2, val);
+#ifdef CONFIG_POPCORN_HYPE
+		if (distributed_process(current)) {
+			POP_PK("\t\t%s(): local APIC_ICR2 <%d> => <?>\n",
+							__func__, apic->vcpu->vcpu_id);
+		}
+#endif
 		break;
 
 	case APIC_LVT0:
@@ -1456,6 +2574,11 @@ static int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
 
 		hrtimer_cancel(&apic->lapic_timer.timer);
 		apic_set_reg(apic, APIC_TMICT, val);
+#ifdef CONFIG_POPCORN_HYPE
+		// many
+		//POP_PK("\t\t%s(): <%d> local APIC_TMICT => start_apic_timer()\n",
+		//				__func__, apic->vcpu->vcpu_id);
+#endif
 		start_apic_timer(apic);
 		break;
 
@@ -1474,7 +2597,14 @@ static int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
 		break;
 
 	case APIC_SELF_IPI:
+#ifdef CONFIG_POPCORN_HYPE
+		if (distributed_process(current)) {
+			POP_PK("\t\t%s(): local APIC_SELF_IPI <%d> => <?>\n",
+							__func__, apic->vcpu->vcpu_id);
+		}
+#endif
 		if (apic_x2apic_mode(apic)) {
+			/* Prevent from nested. Keep local remote working */
 			apic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));
 		} else
 			ret = 1;
@@ -1488,6 +2618,42 @@ static int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
 	return ret;
 }
 
+int popcorn_apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
+{
+	int ret = 0;
+	/* This is how I currently sync the apic_dst_map(logic/phys) */
+	POP_PK("=> %s(): remote apic req %p reg 0x%x val 0x%x (sync apic dst_map)\n",
+			//"(GOT from other node but not support yet, fix NESTING problem)\n", // 0712 commented out
+								__func__, apic, reg, val);
+	/* for cuurent code */
+	//BUG_ON(reg != APIC_DFR);
+	//return apic_reg_write(apic, reg, val);
+	//return 0;
+
+	/* vanilla */
+	switch (reg) {
+    case APIC_LDR: /* looks right after DFR and cause recalculate_apic_map as well */
+        if (!apic_x2apic_mode(apic)) {
+            kvm_apic_set_ldr(apic, val & APIC_LDR_MASK);
+        } else
+            ret = 1;
+        break;
+	case APIC_DFR: /* register apic in kernel */
+		if (!apic_x2apic_mode(apic)) {
+			apic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);
+			recalculate_apic_map(apic->vcpu->kvm);
+		} else
+			ret = 1;
+		break;
+	default:
+		printk(KERN_ERR "NOT SUPPORT reg %x\n", reg);
+		BUG_ON("NOT SUPPORT");
+	}
+	if (ret)
+		apic_debug("Local APIC Write to read-only register %x\n", reg);
+	return ret;
+}
+
 static int apic_mmio_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this,
 			    gpa_t address, int len, const void *data)
 {
@@ -1538,6 +2704,10 @@ void kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset)
 
 	apic_reg_read(vcpu->arch.apic, offset, 4, &val);
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* should we read locally or after delivered */
+	/* popcorn sipi current implementation read it locally */
+#endif
 	/* TODO: optimize to just emulate side effect w/o one more write */
 	apic_reg_write(vcpu->arch.apic, offset, val);
 }
@@ -1622,6 +2792,11 @@ void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)
 	u64 old_value = vcpu->arch.apic_base;
 	struct kvm_lapic *apic = vcpu->arch.apic;
 
+#ifdef CONFIG_POPCORN_HYPE
+	PHAPICPRINTK("[%d/%d] <%d> %s(): set_base\n",
+			my_nid, current->pid, vcpu->vcpu_id, __func__);
+#endif
+
 	if (!apic) {
 		value |= MSR_IA32_APICBASE_BSP;
 		vcpu->arch.apic_base = value;
@@ -1655,8 +2830,9 @@ void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)
 		pr_warn_once("APIC base relocation is unsupported by KVM");
 
 	/* with FSB delivery interrupt, we can restart APIC functionality */
-	apic_debug("apic base msr is 0x%016" PRIx64 ", and base address is "
-		   "0x%lx.\n", apic->vcpu->arch.apic_base, apic->base_address);
+	apic_debug("apic %d base msr is 0x%016" PRIx64 ", and base address is "
+							   "0x%lx. (AP redo)\n", apic->vcpu->vcpu_id,
+							   apic->vcpu->arch.apic_base, apic->base_address);
 
 }
 
@@ -1665,7 +2841,7 @@ void kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)
 	struct kvm_lapic *apic;
 	int i;
 
-	apic_debug("%s\n", __func__);
+	apic_debug("%s():\n", __func__);
 
 	ASSERT(vcpu);
 	apic = vcpu->arch.apic;
@@ -1715,6 +2891,17 @@ void kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)
 	vcpu->arch.apic_arb_prio = 0;
 	vcpu->arch.apic_attention = 0;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (vcpu->vcpu_id == 0 && kvm_apic_id(apic) == 0) {
+	//if (kvm_apic_id(apic) == 0) {
+		pophype_vcpu0 = vcpu;
+		IPIPRINTK("\tpophype %s(): [%d/%d] SAVE HOST VCPU0 %p "
+					"vcpu->vcpu_id %d kvm_apic_id(apic) %d "
+					"for interrupt delegation purpose (like NET_MSI) \n",
+					__func__, my_nid, current->pid,
+					pophype_vcpu0, vcpu->vcpu_id, kvm_apic_id(apic));
+	}
+#endif
 	apic_debug("%s: vcpu=%p, id=%d, base_msr="
 		   "0x%016" PRIx64 ", base_address=0x%0lx.\n", __func__,
 		   vcpu, kvm_apic_id(apic),
@@ -1792,6 +2979,11 @@ int kvm_create_lapic(struct kvm_vcpu *vcpu)
 	ASSERT(vcpu != NULL);
 	apic_debug("apic_init %d\n", vcpu->vcpu_id);
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("[%d/%d] <%d> %s(): create apic & regs\n",
+			my_nid, current->pid, vcpu->vcpu_id, __func__);
+#endif
+
 	apic = kzalloc(sizeof(*apic), GFP_KERNEL);
 	if (!apic)
 		goto nomem;
@@ -1822,6 +3014,13 @@ int kvm_create_lapic(struct kvm_vcpu *vcpu)
 	kvm_lapic_reset(vcpu, false);
 	kvm_iodevice_init(&apic->dev, &apic_mmio_ops);
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("[%d/%d] <%d> %s(): vcpu->cpu %d vcpu->arch.apic %p & "
+			"vcpu->arch.apic->regs %p created\n",
+			my_nid, current->pid, vcpu->vcpu_id,
+			__func__, vcpu->cpu, apic, apic->regs);
+#endif
+
 	return 0;
 nomem_free_apic:
 	kfree(apic);
@@ -1881,6 +3080,14 @@ int kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)
 	if (vector == -1)
 		return -1;
 
+#ifdef CONFIG_POPCORN_HYPE
+	{
+		static unsigned long cnt = 0;
+		cnt++;
+		POP_PK("\t%s(): <%d> jack #%lu\n", __func__, vcpu->vcpu_id, cnt);
+	}
+#endif
+
 	/*
 	 * We get here even with APIC virtualization enabled, if doing
 	 * nested virtualization and L1 runs with the "acknowledge interrupt
@@ -1927,6 +3134,20 @@ void kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,
 	if (ioapic_in_kernel(vcpu->kvm))
 		kvm_rtc_eoi_tracking_restore_one(vcpu);
 
+#if 0 /* check[100] - good */
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	{ int i;
+		for (i = 0; i < 100; ++i) {
+			printk("<%d> %s(): s->regs[%d] %x -> vcpu->arch.apic->regs[%d] %x\n",
+					vcpu->vcpu_id, __func__,
+					i, s->regs[i],
+					i, *((char*)(vcpu->arch.apic->regs) + i));
+//			printk("vcpu->arch.apic->regs[%d] %x\n",
+//					i, (char*)(vcpu->arch.apic->regs)[i]);
+		}
+	}
+#endif
+#endif
 	vcpu->arch.apic_arb_prio = 0;
 }
 
@@ -2147,15 +3368,27 @@ int kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data)
 					 addr, sizeof(u8));
 }
 
+#ifdef CONFIG_POPCORN_HYPE
+//static unsigned long cnt = 0;
+/* Receive pending events */
+#endif
 void kvm_apic_accept_events(struct kvm_vcpu *vcpu)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
 	u8 sipi_vector;
 	unsigned long pe;
 
+#if defined(CONFIG_POPCORN_HYPE) //&& defined(CONFIG_POPCORN_STAT)
+	/* #kvm_smp_boot: should be called right after AP OUT BLOCK */
+#endif
 	if (!kvm_vcpu_has_lapic(vcpu) || !apic->pending_events)
 		return;
 
+//#ifdef CONFIG_POPCORN_HYPE
+//	if (current->at_remote)
+//		SIPIPRINTK("\t#kvm_smp_boot: remote cannot see this then back trace\n");
+//#endif
+
 	/*
 	 * INITs are latched while in SMM.  Because an SMM CPU cannot
 	 * be in KVM_MP_STATE_INIT_RECEIVED state, just eat SIPIs
@@ -2169,24 +3402,81 @@ void kvm_apic_accept_events(struct kvm_vcpu *vcpu)
 	}
 
 	pe = xchg(&apic->pending_events, 0);
-	if (test_bit(KVM_APIC_INIT, &pe)) {
+#ifdef CONFIG_POPCORN_HYPE
+	SIPIPRINTK("\t#kvm_smp_boot: remote check KVM_APIC_INIT %s\n",
+						test_bit(KVM_APIC_INIT, &pe)?"O":"X");
+#endif
+	if (test_bit(KVM_APIC_INIT, &pe)) { // BUG();
+#ifdef CONFIG_POPCORN_HYPE
+		SIPIPRINTK("\t#kvm_smp_boot: %s(): (remote) good2\n", __func__);
+#endif
 		kvm_lapic_reset(vcpu, true);
 		kvm_vcpu_reset(vcpu, true);
 		if (kvm_vcpu_is_bsp(apic->vcpu))
 			vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;
-		else
+		else {
 			vcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;
+#ifdef CONFIG_POPCORN_HYPE
+			SIPIPRINTK("\t#kvm_smp_boot: %s(): (remote) good3 (not bsp)\n", __func__);
+#endif
+		}
 	}
+#ifdef CONFIG_POPCORN_HYPE
+	SIPIPRINTK("\t#kvm_smp_boot: remote check KVM_APIC_SIPI %s\n",
+				test_bit(KVM_APIC_SIPI, &pe)?"O":"X");
+#endif
 	if (test_bit(KVM_APIC_SIPI, &pe) &&
 	    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {
+#ifdef CONFIG_POPCORN_HYPE
+		SIPIPRINTK("\t#kvm_smp_boot: %s(): (remote) good4\n", __func__);
+#endif
 		/* evaluate pending_events before reading the vector */
 		smp_rmb();
-		sipi_vector = apic->sipi_vector;
-		apic_debug("vcpu %d received sipi with vector # %x\n",
-			 vcpu->vcpu_id, sipi_vector);
+		sipi_vector = apic->sipi_vector; /* set by BSP */
+		apic_debug("\t---------------------------------------------------\n"
+			"\t\t#kvm_smp_boot: vcpu %d received sipi with vector [[[0x%x]]]\n"
+					"\t\t------------------------------------------------\n",
+					vcpu->vcpu_id, sipi_vector);
+#ifdef CONFIG_POPCORN_HYPE
+#if ENFORCE_TOUCH_USR
+		if (vcpu->vcpu_id) {
+			int i;
+			char temp[ENFORCE_TOUCH_BYTES];
+			SIPIPRINTK("\t#kvm_smp_boot: before kvm_run, check eip "
+					"(set by BSP at origin) in the guest at remote "
+					"(This will trigger vm&pg faults)\n");
+			SIPIPRINTK("\t#kvm_smp_boot: %lx eip %lx (manually keyin)\n",
+										user_ram_start, user_ram_eip);
+            if(copy_from_user(temp,
+				(void __user *)(user_ram_start + user_ram_eip),
+									ENFORCE_TOUCH_BYTES - 1)) {
+				BUG();
+			}
+			memset(temp + ENFORCE_TOUCH_BYTES - 1, 0, 1);
+			SIPIPRINTK("----------remote af touch-------------\n");
+			for (i = 0; i < ENFORCE_TOUCH_BYTES; i++) {
+				SIPIPRINTK("%02x ", *(temp + i));
+			}
+			SIPIPRINTK("\n");
+            SIPIPRINTK("-------cnt = %lu af done-----------\n", strlen(temp));
+
+//            if(copy_from_user(temp, (void __user *)(user_ram_start + user_start_second), ENFORCE_TOUCH_BYTES - 1))
+//                BUG();
+//			memset(temp + ENFORCE_TOUCH_BYTES - 1, 0, 1);
+//            SIPIPRINTK("-----------------------remote start_second-----------\n");
+//            SIPIPRINTK("%s\n", temp);
+//            SIPIPRINTK("-----------------------------------------------------\n");
+		}
+#endif
+#endif
 		kvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);
 		vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;
 	}
+#ifdef CONFIG_POPCORN_HYPE
+	if (current->at_remote) {
+		SIPIPRINTK("\t#kvm_smp_boot: %s(): (remote) end\n", __func__);
+	}
+#endif
 }
 
 void kvm_lapic_init(void)
diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c
index 2b71f2c03b9e..47e89f31b54a 100644
--- a/arch/x86/kvm/mmu.c
+++ b/arch/x86/kvm/mmu.c
@@ -42,6 +42,17 @@
 #include <asm/io.h>
 #include <asm/vmx.h>
 
+
+#ifdef CONFIG_POPCORN_HYPE
+//#include "trace.h"
+#include "../../../kernel/popcorn/trace_events.h"
+#include <popcorn/types.h>
+#include <popcorn/page_server.h>
+#include <popcorn/hype_kvm.h>
+#define ORIGIN_DMAP_SKIP_CNT 45800 // 45933
+#define REMOTE_DMAP_SKIP_CNT 0
+extern bool pophype_debug;
+#endif
 /*
  * When setting this variable to true it enables Two-Dimensional-Paging
  * where the hardware walks 2 page tables:
@@ -147,10 +158,10 @@ struct pte_list_desc {
 
 struct kvm_shadow_walk_iterator {
 	u64 addr;
-	hpa_t shadow_addr;
-	u64 *sptep;
-	int level;
-	unsigned index;
+	hpa_t shadow_addr; 	/* hpa */
+	u64 *sptep; 		/* next etp ptr */
+	int level; 			/* curr */
+	unsigned index; 	/* curr */
 };
 
 #define for_each_shadow_entry(_vcpu, _addr, _walker)    \
@@ -261,7 +272,16 @@ static unsigned get_mmio_spte_access(u64 spte)
 static bool set_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,
 			  pfn_t pfn, unsigned access)
 {
+	/* is pfn in memslot - usually ram are in memslot but not mmio unless
+		lkvm uses assigned_dev_register_regions()
+		to mmap() the dev directly via sysfs */
 	if (unlikely(is_noslot_pfn(pfn))) {
+		/* mask as mmio so that next time
+			handle_ept_violation()
+				-> handle_mmio_page_fault()
+					-> handle_mmio_page_fault_common()
+						-> quickly_check_mmio_pf()
+									can quickly identift it */
 		mark_mmio_spte(vcpu, sptep, gfn, access);
 		return true;
 	}
@@ -846,6 +866,12 @@ static int host_mapping_level(struct kvm *kvm, gfn_t gfn)
 
 	page_size = kvm_host_page_size(kvm, gfn);
 
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	/* !support hugepage */
+	BUG_ON(distributed_process(current) && page_size != PAGE_SIZE);
+#endif
+#endif
 	for (i = PT_PAGE_TABLE_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {
 		if (page_size >= KVM_HPAGE_SIZE(i))
 			ret = i;
@@ -2078,6 +2104,10 @@ static bool is_obsolete_sp(struct kvm *kvm, struct kvm_mmu_page *sp)
 	return unlikely(sp->mmu_valid_gen != kvm->arch.mmu_valid_gen);
 }
 
+/***
+ * direct - 1:ept 0:shadow
+ * access - permission:rwx
+ */
 static struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,
 					     gfn_t gfn,
 					     gva_t gaddr,
@@ -2088,7 +2118,7 @@ static struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,
 {
 	union kvm_mmu_page_role role;
 	unsigned quadrant;
-	struct kvm_mmu_page *sp;
+	struct kvm_mmu_page *sp; /* e.g. sp->spt[i] see init_shadow_page_table() */
 	bool need_sync = false;
 
 	role = vcpu->arch.mmu.base_role;
@@ -2097,13 +2127,16 @@ static struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,
 	if (role.direct)
 		role.cr4_pae = 0;
 	role.access = access;
+	/* gpa -> quadrant */
 	if (!vcpu->arch.mmu.direct_map
 	    && vcpu->arch.mmu.root_level <= PT32_ROOT_LEVEL) {
 		quadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));
 		quadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;
 		role.quadrant = quadrant;
 	}
+	/* According to hash indxing - find available pte in page table (4k) */
 	for_each_gfn_sp(vcpu->kvm, sp, gfn) {
+		/* Check all failure cases */
 		if (is_obsolete_sp(vcpu->kvm, sp))
 			continue;
 
@@ -2116,6 +2149,7 @@ static struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,
 		if (sp->unsync && kvm_sync_page_transient(vcpu, sp))
 			break;
 
+		/* set sp->parent_pte = parent_pte */
 		mmu_page_add_parent_pte(vcpu, sp, parent_pte);
 		if (sp->unsync_children) {
 			kvm_make_request(KVM_REQ_MMU_SYNC, vcpu);
@@ -2127,12 +2161,15 @@ static struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,
 		trace_kvm_mmu_get_page(sp, false);
 		return sp;
 	}
+	/* pt cannot fine available pte - create a new page table */
 	++vcpu->kvm->stat.mmu_cache_miss;
 	sp = kvm_mmu_alloc_page(vcpu, parent_pte, direct);
 	if (!sp)
 		return sp;
+	/* set gfn */
 	sp->gfn = gfn;
 	sp->role = role;
+	/* Install new mmu page to hash */
 	hlist_add_head(&sp->hash_link,
 		&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);
 	if (!direct) {
@@ -2144,6 +2181,7 @@ static struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,
 		account_shadowed(vcpu->kvm, sp);
 	}
 	sp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;
+	/* clean all pte */
 	init_shadow_page_table(sp);
 	trace_kvm_mmu_get_page(sp, true);
 	return sp;
@@ -2193,6 +2231,7 @@ static void __shadow_walk_next(struct kvm_shadow_walk_iterator *iterator,
 	--iterator->level;
 }
 
+/* index next level EPT */
 static void shadow_walk_next(struct kvm_shadow_walk_iterator *iterator)
 {
 	return __shadow_walk_next(iterator, *iterator->sptep);
@@ -2484,6 +2523,9 @@ static bool kvm_is_mmio_pfn(pfn_t pfn)
 	return true;
 }
 
+#ifdef CONFIG_POPCORN_HYPE
+/* set entry - ram or mmio */
+#endif
 static int set_spte(struct kvm_vcpu *vcpu, u64 *sptep,
 		    unsigned pte_access, int level,
 		    gfn_t gfn, pfn_t pfn, bool speculative,
@@ -2559,11 +2601,15 @@ static int set_spte(struct kvm_vcpu *vcpu, u64 *sptep,
 
 set_pte:
 	if (mmu_spte_update(sptep, spte))
-		kvm_flush_remote_tlbs(vcpu->kvm);
+		kvm_flush_remote_tlbs(vcpu->kvm); /* Flush TLB */
 done:
 	return ret;
 }
 
+#ifdef CONFIG_POPCORN_HYPE
+/* create entry - for ram or for mmio */
+/* set gpa to sept - real setup */
+#endif
 static void mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep,
 			 unsigned pte_access, int write_fault, int *emulate,
 			 int level, gfn_t gfn, pfn_t pfn, bool speculative,
@@ -2576,6 +2622,9 @@ static void mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep,
 		 *sptep, write_fault, gfn);
 
 	if (is_rmap_spte(*sptep)) {
+		/* sept present && in ram (!mmio) -
+			updating EPT is requied -
+			overwrite or create a EPT entry at current level */
 		/*
 		 * If we overwrite a PTE page pointer with a 2MB PMD, unlink
 		 * the parent of the now unreachable PTE.
@@ -2597,8 +2646,10 @@ static void mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep,
 			was_rmapped = 1;
 	}
 
+	/* real set entry + TLB flush */
 	if (set_spte(vcpu, sptep, pte_access, level, gfn, pfn, speculative,
 	      true, host_writable)) {
+		/* ro */
 		if (write_fault)
 			*emulate = 1;
 		kvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);
@@ -2612,11 +2663,26 @@ static void mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep,
 		 is_large_pte(*sptep)? "2MB" : "4kB",
 		 *sptep & PT_PRESENT_MASK ?"RW":"R", gfn,
 		 *sptep, sptep);
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_CHECK_SANITY)
+
+//	if (INTERESTED_GFN(gfn)) {
+//#if 0
+//		printk("\tinstantiating %s PTE (%s) at %llx (spte %llx) addr %p\n",
+//			 is_large_pte(*sptep)? "*****2MB*****" : "4kB",
+//			 *sptep & PT_PRESENT_MASK ?"RW":"R", gfn,
+//			 *sptep, sptep);
+//#endif
+//		BUG_ON(is_large_pte(*sptep));
+//	}
+	//BUG_ON(is_large_pte(*sptep)); /* This happens ....... 200527 */
+#endif
 	if (!was_rmapped && is_large_pte(*sptep))
 		++vcpu->kvm->stat.lpages;
 
+	/* Allow not-present guest page faults to bypass kvm (by rmap?) */
 	if (is_shadow_present_pte(*sptep)) {
 		if (!was_rmapped) {
+			/* last level pte - for gfn_to_rmap/spte() lookup */
 			rmap_count = rmap_add(vcpu, sptep, gfn);
 			if (rmap_count > RMAP_RECYCLE_THRESHOLD)
 				rmap_recycle(vcpu, sptep, gfn);
@@ -2631,6 +2697,11 @@ static pfn_t pte_prefetch_gfn_to_pfn(struct kvm_vcpu *vcpu, gfn_t gfn,
 {
 	struct kvm_memory_slot *slot;
 
+#ifdef CONFIG_POPCORN_HYPE
+	printk("[%d] %s(): since gfn_to_pfn_memslot_atomic forces WRITE fault\n",
+														current->pid, __func__);
+#endif
+
 	slot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, no_dirty_log);
 	if (!slot)
 		return KVM_PFN_ERR_FAULT;
@@ -2680,6 +2751,19 @@ static void __direct_pte_prefetch(struct kvm_vcpu *vcpu,
 		if (is_shadow_present_pte(*spte) || spte == sptep) {
 			if (!start)
 				continue;
+#ifdef CONFIG_POPCORN_HYPE
+			/* should not be here since we've disabled pte_prefetch */
+			if (distributed_process(current)) {
+				static unsigned long kvm_pf_cnt = 0;
+				kvm_pf_cnt++;
+				EPTVPRINTK("[%d] <%d> HYPE prefetch %p - %p POPHYPE skips #%lu\n",
+							current->pid, vcpu->vcpu_id, start, spte, kvm_pf_cnt);
+				if (current->at_remote && kvm_pf_cnt > 10) {
+					dump_stack();
+				}
+				break;
+			}
+#endif
 			if (direct_pte_prefetch_many(vcpu, sp, start, spte) < 0)
 				break;
 			start = NULL;
@@ -2708,6 +2792,10 @@ static void direct_pte_prefetch(struct kvm_vcpu *vcpu, u64 *sptep)
 	__direct_pte_prefetch(vcpu, sp, sptep);
 }
 
+/***
+ * [direct] vs shadow
+ * gpa -> hpa (stored in ept), so that next gpa access will not cause ept violation
+ * create entry */
 static int __direct_map(struct kvm_vcpu *vcpu, gpa_t v, int write,
 			int map_writable, int level, gfn_t gfn, pfn_t pfn,
 			bool prefault)
@@ -2720,26 +2808,89 @@ static int __direct_map(struct kvm_vcpu *vcpu, gpa_t v, int write,
 	if (!VALID_PAGE(vcpu->arch.mmu.root_hpa))
 		return 0;
 
+	/* EPT walk - for each EPT table level entries from root_hpa */
+	/* shadow_walk_okay lookup current level EPT, get the next level EPT base */
 	for_each_shadow_entry(vcpu, (u64)gfn << PAGE_SHIFT, iterator) {
-		if (iterator.level == level) {
+		if (iterator.level == level) { /* or last - case 1 */
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+			static unsigned long dmap_cnt = 0;
+			unsigned long dmap_skip_cnt;
+			if (current->at_remote)
+				dmap_skip_cnt = REMOTE_DMAP_SKIP_CNT;
+			else
+				dmap_skip_cnt = ORIGIN_DMAP_SKIP_CNT;
+			dmap_cnt++;
+#endif
+			/* set gpa to sept - real setup
+				last level (lv 1): by mmu_set_spte()
+				inter level: by __set_spte() 			*/
 			mmu_set_spte(vcpu, iterator.sptep, ACC_ALL,
 				     write, &emulate, level, gfn, pfn,
 				     prefault, map_writable);
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef CONFIG_POPCORN_STAT
+			//if ((dmap_cnt > dmap_skip_cnt || current->at_remote ||
+			if ((dmap_cnt > dmap_skip_cnt ||
+				INTERESTED_GVA(v)) &&
+				NOTINTERESTED_GVA(v) && distributed_process(current)
+				) {
+				EPTVPRINTK("\tdmap(): [%d] <%d> gfn %llx <-> pfn %llx "
+								"%s writable %s lv %d %llx %p "
+								"(last spte done) #%lu\n",
+								current->pid, vcpu->vcpu_id,
+								gfn, pfn,
+								write ? "W" : "R",
+								map_writable ? "O" : "X",
+								level, iterator.addr,
+								iterator.sptep, dmap_cnt);
+			}
+#endif
+
+			/* TODO 0522 no prefetch for ept */
+			if (distributed_process(current)) {
+#if !DISABLE_VANILLA_DIRECT_PTE_PREFETCH
+				direct_pte_prefetch(vcpu, iterator.sptep);
+				++vcpu->stat.pf_fixed;
+#endif
+			} else { /* pophype + !distri */
+				direct_pte_prefetch(vcpu, iterator.sptep);
+				++vcpu->stat.pf_fixed;
+			}
+#else		/* !pophype */
 			direct_pte_prefetch(vcpu, iterator.sptep);
 			++vcpu->stat.pf_fixed;
+#endif
 			break;
 		}
 
+		/* If largpage pte, flush */
 		drop_large_spte(vcpu, iterator.sptep);
-		if (!is_shadow_present_pte(*iterator.sptep)) {
+		if (!is_shadow_present_pte(*iterator.sptep)) { /* case 2 */
+			/* not last level and entry !present (mmu page fault) */
 			u64 base_addr = iterator.addr;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+			//if ((current->at_remote || INTERESTED_GVA(v)) &&
+			if ((INTERESTED_GVA(v)) &&
+				NOTINTERESTED_GVA(v) && distributed_process(current)
+				) {
+				EPTVPRINTK("\t\tdmap(): [%d] <%d> base_addr %llx %p "
+						"(inter-lv spte)\n",
+						current->pid, vcpu->vcpu_id, base_addr, iterator.sptep);
+			}
+#endif
 
+			/* get the mmu page entry idx */
 			base_addr &= PT64_LVL_ADDR_MASK(iterator.level);
 			pseudo_gfn = base_addr >> PAGE_SHIFT;
+			/* allocate a page for a EPT entry (kvm_mmu_page) */
 			sp = kvm_mmu_get_page(vcpu, pseudo_gfn, iterator.addr,
 					      iterator.level - 1,
 					      1, ACC_ALL, iterator.sptep);
-
+			/* install the mmu page into the previous mmu page's pte -
+				make sptep point to sp */
+			/* link_shadow_page -> mmu_spte_set -> __set_spte (flush TLB) -
+													add next level paddr */
+			/* mmu_spte_update: update status, pfn remains */
 			link_shadow_page(iterator.sptep, sp, true);
 		}
 	}
@@ -2771,6 +2922,7 @@ static int kvm_handle_bad_page(struct kvm_vcpu *vcpu, gfn_t gfn, pfn_t pfn)
 		return 1;
 
 	if (pfn == KVM_PFN_ERR_HWPOISON) {
+		/* Send signal to user process */
 		kvm_send_hwpoison_signal(kvm_vcpu_gfn_to_hva(vcpu, gfn), current);
 		return 0;
 	}
@@ -2907,6 +3059,7 @@ static bool fast_page_fault(struct kvm_vcpu *vcpu, gva_t gva, int level,
 	if (!VALID_PAGE(vcpu->arch.mmu.root_hpa))
 		return false;
 
+	/* can be fast? */
 	if (!page_fault_can_be_fast(error_code))
 		return false;
 
@@ -2975,6 +3128,9 @@ exit:
 
 static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,
 			 gva_t gva, pfn_t *pfn, bool write, bool *writable);
+#ifdef CONFIG_POPCORN_HYPE
+			 //unsigned long real_gva, unsigned long exit_qualification);
+#endif
 static void make_mmu_pages_available(struct kvm_vcpu *vcpu);
 
 static int nonpaging_map(struct kvm_vcpu *vcpu, gva_t v, u32 error_code,
@@ -3006,7 +3162,14 @@ static int nonpaging_map(struct kvm_vcpu *vcpu, gva_t v, u32 error_code,
 	mmu_seq = vcpu->kvm->mmu_notifier_seq;
 	smp_rmb();
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* handled in previous level */
+	printk("[%d] %s: THIS IS SW TDP (no EPT)\n", current->pid, __func__);
+#endif
 	if (try_async_pf(vcpu, prefault, gfn, v, &pfn, write, &map_writable))
+#ifdef CONFIG_POPCORN_HYPE
+													// -2, -2)) // dbg
+#endif
 		return 0;
 
 	if (handle_abnormal_pfn(vcpu, v, gfn, pfn, ACC_ALL, &r))
@@ -3048,6 +3211,12 @@ static void mmu_free_roots(struct kvm_vcpu *vcpu)
 
 		spin_lock(&vcpu->kvm->mmu_lock);
 		sp = page_header(root);
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_CHECK_SANITY)
+		if (!sp) {
+			printk(KERN_ERR "hpa_t root = vcpu->arch.mmu.root_hpa %llx\n", root);
+			BUG();
+		}
+#endif
 		--sp->root_count;
 		if (!sp->root_count && sp->role.invalid) {
 			kvm_mmu_prepare_zap_page(vcpu->kvm, sp, &invalid_list);
@@ -3102,6 +3271,11 @@ static int mmu_alloc_direct_roots(struct kvm_vcpu *vcpu)
 		++sp->root_count;
 		spin_unlock(&vcpu->kvm->mmu_lock);
 		vcpu->arch.mmu.root_hpa = __pa(sp->spt);
+#ifdef CONFIG_POPCORN_HYPE
+		PHMIGRATEPRINTK("<%d> %s(): vcpu->arch.mmu.root_hpa %llx = "
+				"__pa(sp->spt) (pa is per host VM. And all vcpu shared?)\n",
+				vcpu->vcpu_id, __func__, vcpu->arch.mmu.root_hpa);
+#endif
 	} else if (vcpu->arch.mmu.shadow_root_level == PT32E_ROOT_LEVEL) {
 		for (i = 0; i < 4; ++i) {
 			hpa_t root = vcpu->arch.mmu.pae_root[i];
@@ -3118,6 +3292,10 @@ static int mmu_alloc_direct_roots(struct kvm_vcpu *vcpu)
 			spin_unlock(&vcpu->kvm->mmu_lock);
 			vcpu->arch.mmu.pae_root[i] = root | PT_PRESENT_MASK;
 		}
+#ifdef CONFIG_POPCORN_HYPE
+		printk("<%d> %s(): [NOT USED]\n",
+					vcpu->vcpu_id, __func__);
+#endif
 		vcpu->arch.mmu.root_hpa = __pa(vcpu->arch.mmu.pae_root);
 	} else
 		BUG();
@@ -3131,6 +3309,9 @@ static int mmu_alloc_shadow_roots(struct kvm_vcpu *vcpu)
 	u64 pdptr, pm_mask;
 	gfn_t root_gfn;
 	int i;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	printk("<%d> %s(): never happened\n", vcpu->vcpu_id, __func__);
+#endif
 
 	root_gfn = vcpu->arch.mmu.get_cr3(vcpu) >> PAGE_SHIFT;
 
@@ -3223,6 +3404,12 @@ static int mmu_alloc_shadow_roots(struct kvm_vcpu *vcpu)
 
 static int mmu_alloc_roots(struct kvm_vcpu *vcpu)
 {
+	// vcpu_enter_guest (arch/x86/kvm/x86.c)
+	// 	-> kvm_mmu_reload (./arch/x86/kvm/mmu.h)
+	//		-> kvm_mmu_load (arch/x86/kvm/mmu.c)
+	//			-> mmu_alloc_roots
+	//				-> mmu_alloc_direct_roots()/mmu_alloc_shadow_roots()
+	//	arch.mmu.direct_map = 1
 	if (vcpu->arch.mmu.direct_map)
 		return mmu_alloc_direct_roots(vcpu);
 	else
@@ -3364,6 +3551,7 @@ int handle_mmio_page_fault(struct kvm_vcpu *vcpu, u64 addr, bool direct)
 	u64 spte;
 	bool reserved;
 
+	/* mmio mark makes this optimization */
 	if (quickly_check_mmio_pf(vcpu, addr, direct))
 		return RET_MMIO_PF_EMULATE;
 
@@ -3400,6 +3588,15 @@ static int nonpaging_page_fault(struct kvm_vcpu *vcpu, gva_t gva,
 	gfn_t gfn;
 	int r;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		printk(KERN_ERR"%s(): pgfault <%d> gva %lx error %x "
+								"POPCORN ONLY SUPPOR TDP "
+								"THIS IS SW TDP (no EPT)\n",
+					__func__, vcpu->vcpu_id, gva, error_code);
+		BUG();
+	}
+#endif
 	pgprintk("%s: gva %lx error %x\n", __func__, gva, error_code);
 
 	if (unlikely(error_code & PFERR_RSVD_MASK)) {
@@ -3445,30 +3642,266 @@ bool kvm_can_do_async_pf(struct kvm_vcpu *vcpu)
 	return kvm_x86_ops->interrupt_allowed(vcpu);
 }
 
+#ifdef CONFIG_POPCORN_HYPE /* debug */
+extern unsigned long pop_gfn_to_hva_many(struct kvm_memory_slot *slot, gfn_t gfn, gfn_t *nr_pages, bool write);
+#ifdef CONFIG_POPCORN_STAT
+atomic64_t kvm_eptfault_ns = ATOMIC64_INIT(0);
+atomic64_t kvm_eptfault_cnt = ATOMIC64_INIT(0);
+
+char kvmaddr_hex_str[PAGE_SIZE * 10]; /* print data page overtime */
+#endif
+#endif
+/* 	ret - dont_dmap
+		false: GOOD, go to __direct_map()
+		true: BAD, return 0 from tdp_page_fault	*/
+/* pfn !!!!!! can be ERR(e.g. IO required) */
 static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,
 			 gva_t gva, pfn_t *pfn, bool write, bool *writable)
+#ifdef CONFIG_POPCORN_HYPE
+	 // unsigned long real_gva, unsigned long exit_qualification) // dbg
+#endif
 {
 	struct kvm_memory_slot *slot;
 	bool async;
+#ifdef CONFIG_POPCORN_STAT
+	ktime_t dt, kvm_eptfault_end, kvm_eptfault_start = ktime_get();
+#endif
+
+#ifdef CONFIG_POPCORN_HYPE
+#if 0
+	if (gva == 0x99000 || current->at_remote ||
+		(gva >> 12  == 0x1a0c) ||
+		INTERESTED_GVA(gva)) {
+		EPTVPRINTK("%s(): [%d] <%d> gfn %llx gva %lx %s - 1\n",
+					__func__, current->pid, vcpu->vcpu_id, gfn, gva,
+					write ? "W" : "");
+	}
+#endif
+
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	if (current->at_remote)
+		BUG_ON(prefault);
+#endif
+#endif
 
 	slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);
+#ifdef CONFIG_POPCORN_HYPE
+	//WARN_ON(!slot); /* MMIO - go emu or usr */
+#endif
 	async = false;
+	/* gfn -> hva -> pfn (!!&sync) (old) gfn_to_pfn_async() */
+	/* <3> atomic <4> async */
 	*pfn = __gfn_to_pfn_memslot(slot, gfn, false, &async, write, writable);
+	/* __gfn_to_pfn_memslot -> hva_to_pfn -> [PAGEFAULT]!! -> */
+	/* TODO: I'm currently using *pfn == REMOTE_CANNOT_DOWN_MMAP_SEM to indicate
+		a DSM fail (cannot down sem_mmap) on remote */
+
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	/* Collect info */
+	if (*pfn != REMOTE_CANNOT_DOWN_MMAP_SEM &&
+		*pfn != KVM_PFN_ERR_FAULT &&
+		*pfn != KVM_PFN_ERR_HWPOISON &&
+		*pfn != 0) { /* succ */
+		char op = write ? 'W' : 'R';
+		//unsigned long address = gva, addr = gfn;
+		unsigned long address = gva, addr = gva >> PAGE_SHIFT; /* vmcs_cr2 is gpa (x86 host is hva)! */
+		extern void dsm_traffic_collect_vcpu(unsigned long address, unsigned long addr, char op, struct kvm_vcpu *vcpu, unsigned long ns);
+		//unsigned long real_gva, unsigned long exit_qualification); //dbg
+
+		kvm_eptfault_end = ktime_get();
+		dt = ktime_sub(kvm_eptfault_end, kvm_eptfault_start);
+		atomic64_add(ktime_to_ns(dt), &kvm_eptfault_ns);
+		atomic64_inc(&kvm_eptfault_cnt);
+
+		dsm_traffic_collect_vcpu(address, addr, op, vcpu, ktime_to_ns(dt));
+									//real_gva, exit_qualification); //dbg
+
+		// periodically print page data
+		if (addr == 0x1e0d ||
+			(addr & 0xffff) ==
+				(((unsigned long)level3_kernel_pgt >> PAGE_SHIFT) & 0xffff))
+		{
+			static u64 periodic_dbg_cnt = 0;
+			if (pophype_debug && !(++periodic_dbg_cnt % 1000)) {
+				int j, ofs = 0;
+				struct page *page = pfn_to_page(*pfn);
+				unsigned char *paddr = kmap(page);
+
+				struct kvm_regs kvm_regs;
+				unsigned long rip;
+				kvm_arch_vcpu_ioctl_get_regs(vcpu, &kvm_regs);
+				rip = kvm_regs.rip;
+
+				//for (j = 0; j < PAGE_SIZE; j += sizeof(char)) {
+				for (j = 0xff0; j < PAGE_SIZE; j += sizeof(char)) {
+					ofs += sprintf(kvmaddr_hex_str + ofs,
+									// {ff(2) + (1)} * 4096
+									"%02hhx ", *(paddr + j));
+				} /* TODO _paddr unsigned long */
+				kunmap(page);
+
+				kvmaddr_hex_str[ofs] = '\n';
+				kvmaddr_hex_str[ofs + 1] = '\n';
+				kvmaddr_hex_str[ofs + 2] = '\0';
+				printk("[%c] rip %lx gpa(not gva) %lx -> hpfn %llx "
+						"kva(%p) ofs %d: %s\n",
+						write?'W':'R', rip, gva, *pfn,
+						paddr, ofs, kvmaddr_hex_str);
+				printk("\n");
+			}
+		} else {
+			// not on pgt
+		}
+
+#if POPHYPE_DEBUG_ADDR
+		/* 1e0d */
+		if (((addr & 0xfff0) != 0x1e00) &&
+			(addr & 0xfff0) !=
+				(((unsigned long)level3_kernel_pgt >> PAGE_SHIFT) & 0xfff0))
+		{
+			if (pophype_debug) {
+				struct kvm_regs kvm_regs;
+				unsigned long rip;
+				kvm_arch_vcpu_ioctl_get_regs(vcpu, &kvm_regs);
+				rip = kvm_regs.rip;
+
+				if (((rip >= 0xffffffff81199000) &&
+					(rip <= (0xffffffff81199000 + PAGE_SIZE))) ||
+					((rip >> PAGE_SHIFT) == 0xffffffff81199)) {  // right rip
+					static u64 _cnt = 0;
+					//if (pophype_debug && !(++_cnt % 1000)) {
+					if (!(++_cnt % 100)) {
+						int j, ofs = 0;
+						//printk("gpa %lx rip %lx\n", addr, rip);
+						printk("\n");
+
+						// start
+						{
+							struct page *page = pfn_to_page(*pfn);
+							unsigned char *paddr = kmap(page);
+							for (j = 0; j < PAGE_SIZE; j += sizeof(char)) {
+								ofs += sprintf(kvmaddr_hex_str + ofs,
+												// {ff(2) + (1)} * 4096
+												"%02hhx ", *(paddr + j));
+							} /* TODO _paddr unsigned long */
+							kunmap(page);
+							kvmaddr_hex_str[ofs] = '\n';
+							kvmaddr_hex_str[ofs + 1] = '\n';
+							kvmaddr_hex_str[ofs + 2] = '\0';
+							printk("[%c] rip %lx gpa(not gva) %lx -> hpfn %llx "
+									"kva(%p) ofs %d: %s\n",
+									write?'W':'R', rip, gva, *pfn, paddr,
+									ofs, kvmaddr_hex_str);
+							printk("\n");
+						}
+						//end
+
+/////////////////////////////
+
+					}
+				}
+			}
+		}
+#endif
+
+	} else { /* fail */
+	}
+#endif // end CONFIG_POPCORN_STAT
+
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_CHECK_SANITY)
+	WARN_ON(!pfn); /* -> usr exit KVM_EXIT_MMIO 6 =? !slot */
+#endif
+
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	if ((distributed_process(current) &&
+		//(current->at_remote || INTERESTED_GVA(gva))) &&
+		(INTERESTED_GVA(gva))) && NOTINTERESTED_GVA(gva)) {
+		if (pfn) {
+			if (*pfn == KVM_PFN_ERR_FAULT) { /* 7ff << 52 meaning can't handle */
+				/* if (async && vma_is_valid(vma, write_fault)) */
+				BUG_ON(!async);
+				EPTVPRINTK("\t***THIS IS A IOfault*** (like swap/dsm?)\n");
+				BUG(); /* no swap allowed */
+			} // else { our dsm fault
+			/* 1st memslot/hva_to_pfn done */
+			EPTVPRINTK("\t%s(): [%d] <%d> =1st done gfn %llx [got pfn %llx%s]",
+						//"async %s %s\n",
+						//"[slot %p] writable(%s)\n",
+						__func__, current->pid, vcpu->vcpu_id, gfn, *pfn,
+					*pfn == REMOTE_CANNOT_DOWN_MMAP_SEM ? " (dsmlkfail)" : "");
+					//async ? "true" : "false");
+					//!async ? "=(default)good_exit" : "*=try2nd/IOasync*");
+					//slot, writable ? (*writable ? "O" : "X") : "-");
+
+			/* memslot/hva_to_pfn thinks swap needed - no swap allowed */
+			BUG_ON(async);
+		} else {
+//			EPTVPRINTK("%s(): w<%d> gfn %llx gva %lx "
+//				"[[[pfn %s]]] async(%s) slot %p - 2\n",
+//				__func__, vcpu->vcpu_id, gfn, gva, "NULL", async?"O":"X", slot);
+		}
+	}
+	/* if REMOTE_CANNOT_DOWN_MMAP_SEM, async = false. */
+#endif // HYPE
 	if (!async)
 		return false; /* *pfn has correct page already */
+							/* ret false: go back and do __direct_map */
+	/* End of pophype
+	 ***************************************************/
+
+	/***************************************************
+	 *	*async==true - IO needed - not fixed yet path
+	 */
+#ifdef CONFIG_POPCORN_HYPE
+	BUG_ON(distributed_process(current)); /* Pophype should never reach here */
+#endif
 
 	if (!prefault && kvm_can_do_async_pf(vcpu)) {
 		trace_kvm_try_async_get_page(gva, gfn);
 		if (kvm_find_async_pf_gfn(vcpu, gfn)) {
 			trace_kvm_async_pf_doublefault(gva, gfn);
-			kvm_make_request(KVM_REQ_APF_HALT, vcpu);
+			kvm_make_request(KVM_REQ_APF_HALT, vcpu); /* set bit */
+#ifdef CONFIG_POPCORN_HYPE
+			if ((distributed_process(current) &&
+				//(current->at_remote || INTERESTED_GVA(gva))) &&
+				(INTERESTED_GVA(gva))) &&
+				NOTINTERESTED_GVA(gva)) {
+				EPTVPRINTK("\t%s(): ??[%d] <%d> gfn %llx [[[pfn %llx]]] "
+						"???set_bit(KVM_REQ_APF_HALT)??? don't dmap()\n",
+						__func__, current->pid, vcpu->vcpu_id, gfn, *pfn);
+			}
+#endif
 			return true;
-		} else if (kvm_arch_setup_async_pf(vcpu, gva, gfn))
+		} else if (kvm_arch_setup_async_pf(vcpu, gva, gfn)) { /* swap in */
+#ifdef CONFIG_POPCORN_HYPE
+			/* https://lists.freedesktop.org/archives/dri-devel/2016-October/122305.html */
+			if ((distributed_process(current) &&
+				//(current->at_remote || INTERESTED_GVA(gva))) &&
+				(INTERESTED_GVA(gva))) &&
+				NOTINTERESTED_GVA(gva)) {
+				EPTVPRINTK("\t%s(): !![%d] <%d> gfn %llx [[[pfn %llx]]] "
+						"***SWAP-INing*** don't dmap()\n",
+						__func__, current->pid, vcpu->vcpu_id, gfn, *pfn);
+			}
+#endif
 			return true;
+		}
 	}
 
+	/* gfn -> hva -> pfn  (!&sync) (old) gfn_to_pfn_prot() */
+	/* <3> !aomic <4> !async */
 	*pfn = __gfn_to_pfn_memslot(slot, gfn, false, NULL, write, writable);
-	return false;
+#ifdef CONFIG_POPCORN_HYPE
+	//if (gva == 0x99000) { // if (gva > xxx)
+	if ((distributed_process(current) &&
+		//(current->at_remote || INTERESTED_GVA(gva))) && NOTINTERESTED_GVA(gva)) {
+		(INTERESTED_GVA(gva))) && NOTINTERESTED_GVA(gva)) {
+		EPTVPRINTK("\t%s(): [%d] <%d> gfn %llx "
+				"- 2nd done [[[got pfn %llx]]] ENFORCE to do dmap()\n",
+				__func__, current->pid, vcpu->vcpu_id, gfn, *pfn);
+	}
+#endif
+	return false; /* go to __direct_map */
 }
 
 static bool
@@ -3481,19 +3914,40 @@ check_hugepage_cache_consistency(struct kvm_vcpu *vcpu, gfn_t gfn, int level)
 	return kvm_mtrr_check_gfn_range_consistency(vcpu, gfn, page_num);
 }
 
+/*** EPT creates new entry
+ * similar to nonpaging_page_fault(). The same table but hw/sw implementations.
+ * ret: emulate
+ */
+/*** Utilities: gfn -> hva
+ * struct kvm_memory_slot *slot = gfn_to_memslot(vcpu->kvm, gfn);
+ * unsigned long hva = gfn_to_hva_many_pub(slot, gfn, NULL, write);
+ */
+extern atomic64_t kvm_eptrefault_cnt;
+extern atomic64_t kvm_eptrefault_ns;
+extern atomic64_t kvm_eptreinv_cnt;
+extern atomic64_t kvm_eptreinv_fast_cnt;
+extern atomic64_t kvm_eptreinv_ns;
 static int tdp_page_fault(struct kvm_vcpu *vcpu, gva_t gpa, u32 error_code,
-			  bool prefault)
+	  bool prefault)
+#ifdef CONFIG_POPCORN_HYPE
+	  //unsigned long real_gva, unsigned long exit_qualification) // dbg
+#endif
 {
 	pfn_t pfn;
-	int r;
+	int r; /* emulate */
 	int level;
 	bool force_pt_level;
 	gfn_t gfn = gpa >> PAGE_SHIFT;
 	unsigned long mmu_seq;
 	int write = error_code & PFERR_WRITE_MASK;
 	bool map_writable;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT) && DEBUG_PREFETCH_EPT
+	int fetch = error_code & PFERR_FETCH_MASK;
+	int usr = error_code & PFERR_USER_MASK;
+	int present = error_code & PFERR_PRESENT_MASK;
+#endif
 
-	MMU_WARN_ON(!VALID_PAGE(vcpu->arch.mmu.root_hpa));
+	MMU_WARN_ON(!VALID_PAGE(vcpu->arch.mmu.root_hpa)); /* EPT base */
 
 	if (unlikely(error_code & PFERR_RSVD_MASK)) {
 		r = handle_mmio_page_fault(vcpu, gpa, true);
@@ -3502,12 +3956,14 @@ static int tdp_page_fault(struct kvm_vcpu *vcpu, gva_t gpa, u32 error_code,
 			return r;
 	}
 
+	/* Fill up kvm mmu slab - preven from allocating during handling faults */
 	r = mmu_topup_memory_caches(vcpu);
 	if (r)
 		return r;
 
 	force_pt_level = !check_hugepage_cache_consistency(vcpu, gfn,
 							   PT_DIRECTORY_LEVEL);
+	/* get level (mmap_sem inside, kvm_host_page_size()) */
 	level = mapping_level(vcpu, gfn, &force_pt_level);
 	if (likely(!force_pt_level)) {
 		if (level > PT_DIRECTORY_LEVEL &&
@@ -3516,32 +3972,167 @@ static int tdp_page_fault(struct kvm_vcpu *vcpu, gva_t gpa, u32 error_code,
 		gfn &= ~(KVM_PAGES_PER_HPAGE(level) - 1);
 	}
 
-	if (fast_page_fault(vcpu, gpa, level, error_code))
+	/* present && writable && !mmio && !write - walk EPT w/o mmu lock */
+	if (fast_page_fault(vcpu, gpa, level, error_code)) {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		/* not happen */
+		if (distributed_process(current)) {
+			EPTVPRINTK("\ttdp(): @@>> [%d] <%d> "
+						"gfn %llx  =fast_page_fault nails it\n",
+						current->pid, vcpu->vcpu_id, gfn);
+			trace_kvm_ept_retry(gpa, 0, 0);
+			atomic64_inc(&kvm_eptreinv_fast_cnt); /* rarely/not happen */
+		}
+#endif
 		return 0;
+	}
 
+/* pophype optimization */
+#if defined(CONFIG_POPCORN_HYPE) && EPT_RETRY_VM_OPTIMIZE
+pophype_retry:
+#endif
 	mmu_seq = vcpu->kvm->mmu_notifier_seq;
 	smp_rmb();
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* gfn -> hva -PAGEFAULT> pfn */
+	{
+		/*	__gfn_to_pfn_memslot() ~= hva_to_pfn()
+			Do two __gfn_to_pfn_memslot() = fast (tlb cache) + slow (host pte walk)
+			1st __gfn_to_pfn_memslot() arg = <3> !atomic <4> &async
+			1st __gfn_to_pfn_memslot() arg = <3> !atomic <4> NULL
+
+			try_async_pf will return the result and tell dmap or not
+			This is the ret for only try_async_pf, above it r=emulate */
+		/* 	false: GOOD, go to __direct_map()
+			true: BAD, return 0 from tdp_page_fault	*/
+		/* e.g. swapping-in return true - meaning don't map */
+#ifdef CONFIG_POPCORN_STAT
+		ktime_t dt, tdp_fault_end, tdp_fault_start = ktime_get();
+#endif
+		bool dont_dmap = try_async_pf(vcpu, prefault, gfn, gpa,
+					&pfn, write, &map_writable);
+					//real_gva, exit_qualification); // dbg
+		/* looks like something got changed durring previous step */
+
+#ifdef CONFIG_POPCORN_STAT
+#if DEBUG_PREFETCH_EPT
+		static u64 cnt = 0;
+		static u64 fetch_cnt = 0;
+		static u64 present_cnt = 0;
+		static u64 usr_cnt = 0;
+
+		cnt++;
+		if (present) { present_cnt++; }
+		if (usr) { usr_cnt++; }
+		if (fetch) { fetch_cnt++;
+			if (fetch_cnt < 100 || !(fetch_cnt % 100)) {
+				printk("pophype eptfetch - usr_cnt %llu present_cnt %llu "
+						"fetch_cnt %llu #%llu\n",
+						usr_cnt, present_cnt, fetch_cnt, cnt);
+			}
+		}
+#endif
+#endif
+
+		if (dont_dmap == true) {
+			if (distributed_process(current)) {
+				EPTVPRINTK("\ttdp(): @@ [%d] <%d> gfn %llx -> pfn [%llx] "
+							"DON'T dmap() r %d\n",
+							current->pid, vcpu->vcpu_id, gfn, pfn, r);
+				BUG_ON("pophype forces either dmap or retry");
+			}
+			return 0; /* like vanilla: don't dmap and still return 0 from tdp */
+		}
+
+		/* pophype may fail - before dmap, check my dsmfault flags */
+		if (pfn == REMOTE_CANNOT_DOWN_MMAP_SEM) { /* refault again don't fix */
+#ifdef CONFIG_POPCORN_STAT
+			tdp_fault_end = ktime_get();
+			dt = ktime_sub(tdp_fault_end, tdp_fault_start);
+			atomic64_add(ktime_to_ns(dt), &kvm_eptrefault_ns);
+			atomic64_inc(&kvm_eptrefault_cnt);
+#endif
+			/* REMOTE_CANNOT_DOWN_MMAP_SEM =
+				don't map + VM-ENTER and immediately fault (VM-EXIT) again */
+			EPTVPRINTK("\t[%d] <%d> %llx ==== Jack full hype retry ====\n",
+										current->pid, vcpu->vcpu_id, gfn);
+			/* this is for debugging(printk) - give origin room to filp game */
+			//io_schedule();
+			return 0; /* emulate (see __direct_map)
+				return to
+				(rewrite: if here=0, will return 1 to vcpu_run())
+				r = kvm_x86_ops->handle_exit(vcpu); (./arch/x86/kvm/x86.c) */
+			/* TODO: working on see if this is a VM retry BUT kvm_eptrefault_cnt is 0.......
+				handled in
+				kvm_arch_vcpu_ioctl_run {
+					r = vcpu_run(vcpu) {
+						r = vcpu_enter_guest(vcpu);
+						if (r <= 0)
+							break;
+						(r>0 (VM-entry)...)
+					}
+					goto usr space...
+				}
+			*/
+		}
+	} /* try_async_pf() done */
+#else /* !CONFIG_POPCORN_HYPE */
 	if (try_async_pf(vcpu, prefault, gfn, gpa, &pfn, write, &map_writable))
+														//-3, -3)) //dbg
 		return 0;
+#endif
 
 	if (handle_abnormal_pfn(vcpu, 0, gfn, pfn, ACC_ALL, &r))
-		return r;
+		return r; /* WRONG(is_error_pfn) return */
 
 	spin_lock(&vcpu->kvm->mmu_lock);
-	if (mmu_notifier_retry(vcpu->kvm, mmu_seq))
+	if (mmu_notifier_retry(vcpu->kvm, mmu_seq)) {
+#if defined(CONFIG_POPCORN_HYPE) && EPT_RETRY_VM_OPTIMIZE
+		/* pophype optimization */
+		if (distributed_process(current)) { /* retry w/o re-enter VM */
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+			/* It means something got changed durring previous step -
+				we should stop immediately */
+			/* See if this happens a lot. If so, record addr maybe? */
+			trace_kvm_ept_retry(0, gpa, 0);
+			atomic64_inc(&kvm_eptreinv_cnt);
+#endif
+			spin_unlock(&vcpu->kvm->mmu_lock);
+			kvm_release_pfn_clean(pfn); // 0412 test EPT_RETRY_VM_OPTIMIZE
+			goto pophype_retry;
+		}
+		/* pophype optimization */
+#endif
 		goto out_unlock;
+	}
 	make_mmu_pages_available(vcpu);
 	if (likely(!force_pt_level))
 		transparent_hugepage_adjust(vcpu, &gfn, &pfn, &level);
+	/* REAL gfn -> hfn (sw/hw collab.) */
 	r = __direct_map(vcpu, gpa, write, map_writable,
 			 level, gfn, pfn, prefault);
 	spin_unlock(&vcpu->kvm->mmu_lock);
 
+#ifdef CONFIG_POPCORN_HYPE
+//	if ((current->at_remote || INTERESTED_GVA(gpa)) &&
+//		NOTINTERESTED_GVA(gpa)) {
+//		EPTMPRINTK("\ttdp(): @@ [%d] <%d> dmap() done gfn %llx <-> pfn %llx "
+//					"%s writable %s lv %d r(emu) %d(%s)\n",
+//					current->pid, vcpu->vcpu_id, gfn, pfn,
+//					write ? "W" : "R",
+//					map_writable ? "O" : "X",
+//					level, r, r ? "Obad" : "Xgood");
+//	}
+#endif
+
 	return r;
 
 out_unlock:
 	spin_unlock(&vcpu->kvm->mmu_lock);
+#ifdef CONFIG_POPCORN_HYPE
+//out_pfn:
+#endif
 	kvm_release_pfn_clean(pfn);
 	return 0;
 }
@@ -3549,6 +4140,12 @@ out_unlock:
 static void nonpaging_init_context(struct kvm_vcpu *vcpu,
 				   struct kvm_mmu *context)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	printk(KERN_ERR "<%d> WE ARE NOT %s() THIS IS SW TDP (no EPT)\n",
+						vcpu->vcpu_id, __func__);
+	WARN_ON(1);
+#endif
+
 	context->page_fault = nonpaging_page_fault;
 	context->gva_to_gpa = nonpaging_gva_to_gpa;
 	context->sync_page = nonpaging_sync_page;
@@ -3896,6 +4493,11 @@ static void paging64_init_context_common(struct kvm_vcpu *vcpu,
 					 struct kvm_mmu *context,
 					 int level)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	printk("<%d> WE ARE NOT %s()\n", vcpu->vcpu_id, __func__);
+	WARN_ON(1);
+#endif
+
 	context->nx = is_nx(vcpu);
 	context->root_level = level;
 
@@ -3923,6 +4525,11 @@ static void paging64_init_context(struct kvm_vcpu *vcpu,
 static void paging32_init_context(struct kvm_vcpu *vcpu,
 				  struct kvm_mmu *context)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	printk("<%d> WE ARE NOT %s()\n", vcpu->vcpu_id, __func__);
+	WARN_ON(1);
+#endif
+
 	context->nx = false;
 	context->root_level = PT32_ROOT_LEVEL;
 
@@ -3950,6 +4557,20 @@ static void init_kvm_tdp_mmu(struct kvm_vcpu *vcpu)
 {
 	struct kvm_mmu *context = &vcpu->arch.mmu;
 
+#ifdef CONFIG_POPCORN_HYPE
+	VCPUPRINTK("\t\t<%d> %s(): !is_paging(vcpu) %d nonpaging_gva_to_gpa %p, "
+			"is_long_mode(vcpu) %d paging64_gva_to_gpa %p, "
+			"is_pae(vcpu) %d paging64_gva_to_gpa %p, "
+			"else paging32_gva_to_gpa %p\n",
+			vcpu->vcpu_id, __func__,
+			!is_paging(vcpu), nonpaging_gva_to_gpa,
+			is_long_mode(vcpu), paging64_gva_to_gpa,
+			is_pae(vcpu), paging64_gva_to_gpa, paging32_gva_to_gpa);
+	VCPUPRINTK("\t\t<%d> %s(): kvm_x86_ops->set_tdp_cr3 %p kvm_x86_ops->get_tdp_level() %p\n",
+			vcpu->vcpu_id, __func__, kvm_x86_ops->set_tdp_cr3, kvm_x86_ops->get_tdp_level);
+	/* remote: from kvm_set_cr4 -> kvm_mmu_reset_context */
+#endif
+
 	context->base_role.word = 0;
 	context->base_role.smm = is_smm(vcpu);
 	context->page_fault = tdp_page_fault;
@@ -3996,6 +4617,10 @@ void kvm_init_shadow_mmu(struct kvm_vcpu *vcpu)
 	bool smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);
 	struct kvm_mmu *context = &vcpu->arch.mmu;
 
+#ifdef CONFIG_POPCORN_HYPE
+	printk("<%d> %s()\n", vcpu->vcpu_id, __func__);
+#endif
+
 	MMU_WARN_ON(VALID_PAGE(context->root_hpa));
 
 	if (!is_paging(vcpu))
@@ -4023,6 +4648,11 @@ void kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly)
 {
 	struct kvm_mmu *context = &vcpu->arch.mmu;
 
+#ifdef CONFIG_POPCORN_HYPE
+	printk("<%d> WE ARE NOT %s()\n", vcpu->vcpu_id, __func__);
+	WARN_ON(1);
+#endif
+
 	MMU_WARN_ON(VALID_PAGE(context->root_hpa));
 
 	context->shadow_root_level = kvm_x86_ops->get_tdp_level();
@@ -4047,6 +4677,9 @@ static void init_kvm_softmmu(struct kvm_vcpu *vcpu)
 {
 	struct kvm_mmu *context = &vcpu->arch.mmu;
 
+#ifdef CONFIG_POPCORN_HYPE
+	printk("<%d> %s()\n", vcpu->vcpu_id, __func__);
+#endif
 	kvm_init_shadow_mmu(vcpu);
 	context->set_cr3           = kvm_x86_ops->set_cr3;
 	context->get_cr3           = get_cr3;
@@ -4105,6 +4738,9 @@ static void init_kvm_mmu(struct kvm_vcpu *vcpu)
 
 void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	VCPUPRINTK("<%d> %s()\n", vcpu->vcpu_id, __func__);
+#endif
 	kvm_mmu_unload(vcpu);
 	init_kvm_mmu(vcpu);
 }
@@ -4113,6 +4749,14 @@ EXPORT_SYMBOL_GPL(kvm_mmu_reset_context);
 int kvm_mmu_load(struct kvm_vcpu *vcpu)
 {
 	int r;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static int first = 1;
+	if (first) {
+		first = 0;
+		printk("<%d> %s(): vcpu->arch.mmu.set_cr3 %p\n",
+			vcpu->vcpu_id, __func__, vcpu->arch.mmu.set_cr3);
+	}
+#endif
 
 	r = mmu_topup_memory_caches(vcpu);
 	if (r)
@@ -4397,27 +5041,140 @@ static bool is_mmio_page_fault(struct kvm_vcpu *vcpu, gva_t addr)
 
 	return vcpu_match_mmio_gva(vcpu, addr);
 }
-
+/* return emulate
+ * 0: good???
+ * 1: bad???
+ */
 int kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gva_t cr2, u32 error_code,
-		       void *insn, int insn_len)
+		       void *insn, int insn_len,
+			   unsigned long real_gva, unsigned long exit_qualification)
 {
-	int r, emulation_type = EMULTYPE_RETRY;
+	int r, emulation_type = EMULTYPE_RETRY; /* r: emulate */
 	enum emulation_result er;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long pte_fault_cnt = 0;
+	//unsigned long pte_fault_skip = 4200; // 4200 very close
+	unsigned long pte_fault_skip = 45500; // 4200 very close
+	//static unsigned long theonly_pte_fault_cnt = 0;
+
+	//unsigned long theonly_pte_fault_skip = 50000; // origin // 47108 sipi
+	//unsigned long theonly_pte_fault_skip_remote = 0;
+	//unsigned long theonly_pte_fault_skip = 800000; // origin // < 800000 spinning
+	//unsigned long theonly_pte_fault_skip_remote = 750000; // 716118 spinning
+
+
+//	unsigned long theonly_pte_fault_skip = 1000000; // origin // < 800000 spinning
+//	unsigned long theonly_pte_fault_skip_remote = 1050000; // 716118 spinning
+	//unsigned long theonly_pte_fault_skip = 10500000; // origin // < 800000 spinning
+	// latest
+	//unsigned long theonly_pte_fault_skip = 9000000; // origin // < 800000 spinning
+	//unsigned long theonly_pte_fault_skip_remote = 8000000; // 716118 spinning
+
+	if (distributed_process(current))
+		pte_fault_cnt++;
+
+//	if ((vcpu->vcpu_id || current->at_remote || INTERESTED_GVA(cr2)) &&
+//		NOTINTERESTED_GVA(cr2)
+//		) {
+			//pte_fault_cnt++;
+			//if ((vcpu->vcpu_id || current->at_remote ||
+			if ((vcpu->vcpu_id ||
+				pte_fault_cnt < 500 ||
+				pte_fault_cnt > pte_fault_skip ||
+				INTERESTED_GVA(cr2)) &&
+				NOTINTERESTED_GVA(cr2) && distributed_process(current)
+				) {
+				/* origin pre X fetch X remote all cases*/
+				//EPTPRINTK("\n@@ EPTFAULT [%d] <%d> cr2 %lx gfn %lx "
+				//				"%s present %s fetch %s %s #%lu\n",
+				EPTPRINTK("\n@@ [%d] <%d> %lx %lx %s p %s pf %s %s#%lu\n",
+							current->pid, vcpu->vcpu_id, cr2, cr2 >> PAGE_SHIFT,
+							error_code & PFERR_WRITE_MASK ? "W" : "R",
+							error_code & PFERR_PRESENT_MASK ? "O" : "X",
+							error_code & PFERR_FETCH_MASK ? "O" : "X",
+							error_code & PFERR_RSVD_MASK ? "MMIO " : "",
+							pte_fault_cnt);
+			}
+//	}
+
+//	theonly_pte_fault_cnt++;
+//	if ((!current->at_remote && theonly_pte_fault_cnt > theonly_pte_fault_skip) ||
+//		(current->at_remote && theonly_pte_fault_cnt > theonly_pte_fault_skip_remote)) {
+		// working on
+		//EPTPRINTK("\n@@ EPTFAULT [%d] <%d> cr2 %lx gfn %lx "
+		//				"%s present %s fetch %s nid %d #%lu\n",
+//		EPTPRINTK("\n@@ [%d] <%d> %lx %lx %s %s %s %d #%lu\n",
+//		//printk("\n@@ [%d] <%d> %lx %lx %s %s %s %d #%lu\n",
+//				current->pid, vcpu->vcpu_id, cr2, cr2 >> PAGE_SHIFT,
+//				error_code & PFERR_WRITE_MASK ? "W" : "R",
+//				error_code & PFERR_PRESENT_MASK ? "O" : "X",
+//				error_code & PFERR_FETCH_MASK ? "O" : "X",
+//				popcorn_get_hnid(), theonly_pte_fault_cnt);
+//	}
 
+#endif
+
+	/* r = emulate */
+	/* tdp_page_fault */
 	r = vcpu->arch.mmu.page_fault(vcpu, cr2, error_code, false);
-	if (r < 0)
+#ifdef CONFIG_POPCORN_HYPE
+						//real_gva, exit_qualification); // dbg
+#endif
+
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	/* @@ - prefault always false */
+	if ((vcpu->vcpu_id || INTERESTED_GVA(cr2)) &&
+		NOTINTERESTED_GVA(cr2)) {
+		if (pte_fault_cnt > pte_fault_skip ||
+			pte_fault_cnt < VM_SINGLE_HANDLE_DISPLAY_CNT ||
+			vcpu->vcpu_id) {
+			EPTPRINTK("@@>>[%d] <%d> %lx emu %s\n",
+						current->pid, vcpu->vcpu_id,
+						cr2 >> PAGE_SHIFT, r ? "Obad" : "Xgood");
+		}
+	}
+
+	/* Good place to to measure # of EPT page fixed */
+	/* 1. not return for other reasons */
+	//if (!r) { /* 2. only for those do not need to emulate */
+		/* Prob here */
+		/* Pophype has probed in
+			vmx_handle_exit() at ./arch/x86/kvm/vmx.c */
+	//}
+#endif
+	if (r < 0) /* emulate < 0 = ERR */
 		goto out;
 
-	if (!r) {
-		r = 1;
+	if (!r) { /* emulate == 0 = go out */
+		r = 1; /* return 1; (<=0: user, 1: stay in kernel) */
 		goto out;
 	}
 
+	/* check vcpu->arch.mmio_gfn and gen */
 	if (is_mmio_page_fault(vcpu, cr2))
 		emulation_type = 0;
 
+#ifdef CONFIG_POPCORN_HYPE
+	EPTPRINTK("@@@@ [%d] <%d> %lx emu emulation_type %d\n",
+			current->pid, vcpu->vcpu_id, cr2 >> PAGE_SHIFT, emulation_type);
+#endif
+
 	er = x86_emulate_instruction(vcpu, cr2, emulation_type, insn, insn_len);
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	if ((distributed_remote_process(current) || INTERESTED_GVA(cr2)) &&
+		NOTINTERESTED_GVA(cr2)) {
+		goto forceprint2;
+	}
+	if (vcpu->vcpu_id || distributed_remote_process(current) ||
+		(!vcpu->vcpu_id && (cr2 < 0x10bf000 || cr2 > 0xcb40a000))
+		) {
+forceprint2:
+		EPTVPRINTK("%s():\t\temu_ins <%d> cr2 %lx [er %d](%s)\n",
+				__func__, vcpu->vcpu_id, cr2, er, !er ? "O" : "X");
+	}
+#endif
+
 	switch (er) {
 	case EMULATE_DONE:
 		return 1;
@@ -4445,6 +5202,10 @@ EXPORT_SYMBOL_GPL(kvm_mmu_invlpg);
 void kvm_enable_tdp(void)
 {
 	tdp_enabled = true;
+#ifdef CONFIG_POPCORN_HYPE
+	/* arch/x86/kvm/vmx.c */
+	printk("%s: WE ARE [[[[[[TDP enabled]]]]]\n", __func__);
+#endif
 }
 EXPORT_SYMBOL_GPL(kvm_enable_tdp);
 
@@ -4465,7 +5226,6 @@ static int alloc_mmu_pages(struct kvm_vcpu *vcpu)
 {
 	struct page *page;
 	int i;
-
 	/*
 	 * When emulating 32-bit mode, cr3 is only 32 bits even on x86_64.
 	 * Therefore we need to allocate shadow page tables in the first
@@ -4479,11 +5239,19 @@ static int alloc_mmu_pages(struct kvm_vcpu *vcpu)
 	for (i = 0; i < 4; ++i)
 		vcpu->arch.mmu.pae_root[i] = INVALID_PAGE;
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("<%d> %s(): set vcpu->arch.mmu.pae_root %p\n",
+			vcpu->vcpu_id, __func__, vcpu->arch.mmu.pae_root);
+#endif
+
 	return 0;
 }
 
 int kvm_mmu_create(struct kvm_vcpu *vcpu)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("<%d> %s()\n", vcpu->vcpu_id, __func__);
+#endif
 	vcpu->arch.walk_mmu = &vcpu->arch.mmu;
 	vcpu->arch.mmu.root_hpa = INVALID_PAGE;
 	vcpu->arch.mmu.translate_gpa = translate_gpa;
diff --git a/arch/x86/kvm/paging_tmpl.h b/arch/x86/kvm/paging_tmpl.h
index 7be8a251363e..a07947936f7a 100644
--- a/arch/x86/kvm/paging_tmpl.h
+++ b/arch/x86/kvm/paging_tmpl.h
@@ -164,6 +164,12 @@ static bool FNAME(prefetch_invalid_gpte)(struct kvm_vcpu *vcpu,
 				  struct kvm_mmu_page *sp, u64 *spte,
 				  u64 gpte)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		printk("%s(): [%d]\n", __func__, current->pid);
+	}
+#endif
+
 	if (is_rsvd_bits_set(&vcpu->arch.mmu, gpte, PT_PAGE_TABLE_LEVEL))
 		goto no_present;
 
@@ -257,6 +263,7 @@ static int FNAME(update_accessed_dirty_bits)(struct kvm_vcpu *vcpu,
 /*
  * Fetch a guest pte for a guest virtual address
  */
+/* pophype - walk guest pgt on host e.g gva_to_gpa/gfn (requires hva) */
 static int FNAME(walk_addr_generic)(struct guest_walker *walker,
 				    struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,
 				    gva_t addr, u32 access)
@@ -274,6 +281,14 @@ static int FNAME(walk_addr_generic)(struct guest_walker *walker,
 	u16 errcode = 0;
 	gpa_t real_gpa;
 	gfn_t gfn;
+#ifdef CONFIG_POPCORN_HYPE
+#if 0
+	static u64 gva_to_gfn_on_host_cnt = 0;
+	static u64 fetch_cnt = 0;
+	static u64 w_cnt = 0;
+	static u64 usr_cnt = 0;
+#endif
+#endif
 
 	trace_kvm_mmu_pagetable_walk(addr, access);
 retry_walk:
@@ -296,6 +311,45 @@ retry_walk:
 	pt_access = pte_access = ACC_ALL;
 	++walker->level;
 
+#ifdef CONFIG_POPCORN_HYPE
+#if 0
+	/* pophype - many - gva_to_gpa gva():
+		for gva gfn so that gva_to_gpa() can then just do gfn to gva */
+	{	/* This func does: gva to gfn */
+		if (write_fault) { w_cnt++; }
+		if (user_fault) { usr_cnt++; }
+		if (fetch_fault) { fetch_cnt++; }
+		gva_to_gfn_on_host_cnt++;
+		if (!(gva_to_gfn_on_host_cnt % 10000))
+			printk("%s(): [%d] gva 0x%lx "
+				"faults-[usr] %d [write] %d [fetch] %d "
+				"#%llu-%llu-%llu #%llu\n", __func__,
+				current->pid, addr,
+				user_fault, write_fault, fetch_fault,
+				usr_cnt, w_cnt, fetch_cnt, gva_to_gfn_on_host_cnt);
+		if (!(gva_to_gfn_on_host_cnt % (10000 * 10))) { dump_stack(); }
+		// 		paging64_walk_addr_generic
+		// 		paging64_gva_to_gpa
+		// 		kvm_arch_vcpu_ioctl_translate
+		// 		vm_stack_walk
+		// 		pophype_show_guest_rip_rsp !!!!!!!!!!!!!!!! wasted...
+		// 		__dsm_traffic_collect.part.22
+		// 		dsm_traffic_collect_vcpu
+		// try_async_pf
+		// tdp_page_fault
+		// kvm_mmu_page_fault
+		// handle_ept_violation [kvm_intel]
+		// vmx_handle_exit [kvm_intel]
+		// kvm_arch_vcpu_ioctl_run
+		// kvm_vcpu_ioctl
+		// do_vfs_ioctl
+		// SyS_ioctl
+		// entry_SYSCALL_64_fastpath
+	}
+	/* TODO see 10fe is input or output (by thie pgwalk)*/
+#endif
+#endif
+
 	do {
 		gfn_t real_gfn;
 		unsigned long host_addr;
@@ -340,6 +394,21 @@ retry_walk:
 			goto error;
 		walker->ptep_user[walker->level - 1] = ptep_user;
 
+#ifdef CONFIG_POPCORN_HYPE
+#if 0
+		/* pophype */
+		if (!(gva_to_gfn_on_host_cnt % 10000)) {
+			printk("%s(): [%d] gva 0x%lx walkguestinhost - "
+				"pte 0x%llx ptep_user %p pte_gpa 0x%llx #%llu\n", __func__,
+				current->pid, addr, (u64)pte, ptep_user, pte_gpa,
+				gva_to_gfn_on_host_cnt);
+				// TODO: ptep_user to guest addr?
+				//1e0dff0
+				//1e0dff8
+		}
+#endif
+#endif
+
 		trace_kvm_mmu_paging_element(pte, walker->level);
 
 		if (unlikely(!FNAME(is_present_gpte)(pte)))
@@ -458,6 +527,12 @@ FNAME(prefetch_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,
 	gfn_t gfn;
 	pfn_t pfn;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		printk("%s(): [%d]\n", __func__, current->pid);
+	}
+#endif
+
 	if (FNAME(prefetch_invalid_gpte)(vcpu, sp, spte, gpte))
 		return false;
 
@@ -471,6 +546,11 @@ FNAME(prefetch_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,
 	if (is_error_pfn(pfn))
 		return false;
 
+//#ifdef CONFIG_POPCORN_HYPE
+//	if (distributed_process(current)) {
+//		printk("%s(): [%d]\n", __func__, current->pid);
+//	}
+//#endif
 	/*
 	 * we call mmu_set_spte() with host_writable = true because
 	 * pte_prefetch_gfn_to_pfn always gets a writable pfn.
@@ -520,6 +600,12 @@ static void FNAME(pte_prefetch)(struct kvm_vcpu *vcpu, struct guest_walker *gw,
 	u64 *spte;
 	int i;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		printk("%s(): [%d]\n", __func__, current->pid);
+	}
+#endif
+
 	sp = page_header(__pa(sptep));
 
 	if (sp->role.level > PT_PAGE_TABLE_LEVEL)
@@ -558,6 +644,12 @@ static int FNAME(fetch)(struct kvm_vcpu *vcpu, gva_t addr,
 	unsigned direct_access, access = gw->pt_access;
 	int top_level, emulate = 0;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		printk("%s(): [%d]\n", __func__, current->pid);
+	}
+#endif
+
 	direct_access = gw->pte_access;
 
 	top_level = vcpu->arch.mmu.root_level;
@@ -755,7 +847,11 @@ static int FNAME(page_fault)(struct kvm_vcpu *vcpu, gva_t addr, u32 error_code,
 	smp_rmb();
 
 	if (try_async_pf(vcpu, prefault, walker.gfn, addr, &pfn, write_fault,
-			 &map_writable))
+			 &map_writable)
+#ifdef CONFIG_POPCORN_HYPE
+			 //, -1, -1) //dbg
+#endif
+		)
 		return 0;
 
 	if (handle_abnormal_pfn(vcpu, mmu_is_nested(vcpu) ? 0 : addr,
@@ -823,6 +919,12 @@ static void FNAME(invlpg)(struct kvm_vcpu *vcpu, gva_t gva)
 	int level;
 	u64 *sptep;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		printk("%s(): [%d]\n", __func__, current->pid);
+	}
+#endif
+
 	vcpu_clear_mmio_info(vcpu, gva);
 
 	/*
@@ -929,6 +1031,12 @@ static int FNAME(sync_page)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp)
 	bool host_writable;
 	gpa_t first_pte_gpa;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		printk("%s(): [%d]\n", __func__, current->pid);
+	}
+#endif
+
 	/* direct kvm_mmu_page can not be unsync. */
 	BUG_ON(sp->role.direct);
 
diff --git a/arch/x86/kvm/trace.h b/arch/x86/kvm/trace.h
index ab9ae67a80e4..5d33d6f65083 100644
--- a/arch/x86/kvm/trace.h
+++ b/arch/x86/kvm/trace.h
@@ -316,6 +316,59 @@ TRACE_EVENT(kvm_page_fault,
 		  __entry->fault_address, __entry->error_code)
 );
 
+/* AB:
+ * Tracepoint for page fault ext.
+ */
+TRACE_EVENT(kvm_page_fault_ext,
+	TP_PROTO(unsigned long rip, unsigned long fault_address, unsigned long vfault_address, unsigned int error_code),
+	TP_ARGS(rip, fault_address, vfault_address, error_code),
+
+	TP_STRUCT__entry(
+		__field(	unsigned long,	rip	)
+		__field(	unsigned long,	fault_address	)
+		__field(        unsigned long,  vfault_address  )
+		__field(	unsigned int,	error_code	)
+	),
+
+	TP_fast_assign(
+		__entry->rip	= rip;
+		__entry->fault_address	= fault_address;
+		__entry->vfault_address = vfault_address;
+		__entry->error_code	= error_code;
+	),
+
+	TP_printk("rip %lx address %lx vaddress %lx error_code %x (%c%c%c %c%c%c%c %c%c %s%s)",
+		__entry->rip, __entry->fault_address, __entry->vfault_address, __entry->error_code,
+		((__entry->error_code & 0x1) ? 'r' : '-'), ((__entry->error_code & 0x2) ? 'w' : '-'),
+		((__entry->error_code & 0x4) ? 'f' : '-'), ((__entry->error_code & 0x8) ? 'R' : '-'),
+		((__entry->error_code & 0x10) ? 'W' : '-'), ((__entry->error_code & 0x20) ? 'X' : '-'),
+		((__entry->error_code & 0x40) ? 'x' : '-'),
+		((__entry->error_code & 0x80) ? ((__entry->error_code & 0x100) ? 'p' : 't') : '-'), // last or walks
+		((__entry->error_code & 0x80) && (__entry->error_code & 0x100) ? ((__entry->error_code & 0x200) ? 'u' : 'k') : '-'),
+		((__entry->error_code & 0x80) && (__entry->error_code & 0x100) ? ((__entry->error_code & 0x400) ? "ro" : "rw") : "-"),
+		((__entry->error_code & 0x80) && (__entry->error_code & 0x100) ? ((__entry->error_code & 0x800) ? "Ex" : "Nx") : "-"))
+	/*
+		0 0x1: Set if the access causing the EPT violation was a data read.
+		1 0x2: Set if the access causing the EPT violation was a data write.
+		2 0x4: Set if the access causing the EPT violation was a data write.
+		3 0x8: The logical-AND of bit 0 in the EPT paging-structure entries used to translate the guest-physical address of the access causing the EPT violation (indicates that the guest-physical address was readable).
+		4 0x10: The logical-AND of bit 1 in the EPT paging-structure entries used to translate the guest-physical address of the access causing the EPT violation (indicates that the guest-physical address was writeable).
+		5 0x20: The logical-AND of bit 2 in the EPT paging-structure entries used to translate the guest-physical address of the access causing the EPT violation (indicates that the guest-physical address was executable).
+		6 0x40: Reserved (cleared to 0).
+		7 0x80: Set if the guest linear-address field is valid. The guest linear-address field is valid for all EPT violations except those resulting from an attempt to load the guest PDPTEs as part of the execution of the MOV CR instruction.
+		8 0x100:  If bit 7 is 1:
+			• Set if the access causing the EPT violation is to a guest-physical address that is the translation of a linear address.
+			• Clear if the access causing the EPT violation is to a paging-structure entry as part of a page walk or the update of an accessed or dirty bit. Reserved if bit 7 is 0 (cleared to 0).
+		9 0x200: If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations, this bit is 0 if the linear address is a supervisor-mode linear address and 1 if it is a user-mode linear address. (If CR0.PG = 0, the translation of every linear address is a user-mode linear address and thus this bit will be 1.) Otherwise, this bit is undefined.
+		10 0x400: If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations, this bit is 0 if paging translates the linear address to a read-only page and 1 if it translates to a read/write page. (If CR0.PG = 0, every linear address is read/write and thus this bit will be 1.) Otherwise, this bit is undefined.
+
+		11 0x800:  If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations, this bit is 0 if paging translates the linear address to an executable page and 1 if it translates to an execute-disable page. (If CR0.PG = 0, CR4.PAE = 0, or IA32_EFER.NXE = 0, every linear address is executable and thus this bit will be 0.) Otherwise, this bit is undefined.
+
+		12 0x1000: NMI unblocking due to IRET
+
+	*/
+);
+
 /*
  * Tracepoint for guest MSR access.
  */
diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index a750fc7c7458..553db9785339 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -50,6 +50,26 @@
 #include <asm/irq_remapping.h>
 #include <asm/nospec-branch.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#define VM_ALL_HANDLE_DISPLAY_CNT 50
+
+#include <popcorn/debug.h>
+#include <popcorn/types.h>
+#include <popcorn/bundle.h>
+#include <popcorn/hype_kvm.h> // for popcorn/type.h
+
+#ifdef CONFIG_POPCORN_STAT
+atomic64_t kvm_eptfault_new_ns = ATOMIC64_INIT(0);
+atomic64_t kvm_eptfault_new_cnt = ATOMIC64_INIT(0);
+atomic64_t user_gva_cnt = ATOMIC64_INIT(0);
+atomic64_t kernel_gva_cnt = ATOMIC64_INIT(0);
+atomic64_t unknow_gva_cnt = ATOMIC64_INIT(0);
+atomic64_t wrong_validity_gva_cnt = ATOMIC64_INIT(0);
+atomic64_t gva_ret_kernelspace_cnt = ATOMIC64_INIT(0);
+atomic64_t gva_ret_userspace_cnt = ATOMIC64_INIT(0);
+#endif
+#endif
+
 #include "trace.h"
 #include "pmu.h"
 
@@ -79,7 +99,15 @@ static bool __read_mostly enable_unrestricted_guest = 1;
 module_param_named(unrestricted_guest,
 			enable_unrestricted_guest, bool, S_IRUGO);
 
+//static bool __read_mostly enable_ept_ad_bits = 1;
+//static bool __read_mostly enable_ept_ad_bits = 0; /* pophype - dsm traffic - solve ept walk always cayses write fault */
+
+//#if !GUEST_KERNEL_OPTIMIZE
+#if !GUEST_KERNEL_OPTIMIZE_EPT_AD
 static bool __read_mostly enable_ept_ad_bits = 1;
+#else
+static bool __read_mostly enable_ept_ad_bits = 0; /* pophype - dsm traffic - solve ept walk always cayses write fault */
+#endif
 module_param_named(eptad, enable_ept_ad_bits, bool, S_IRUGO);
 
 static bool __read_mostly emulate_invalid_guest_state = true;
@@ -856,9 +884,13 @@ static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)
 static struct page *nested_get_page(struct kvm_vcpu *vcpu, gpa_t addr)
 {
 	struct page *page = kvm_vcpu_gfn_to_page(vcpu, addr >> PAGE_SHIFT);
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	BUG_ON("gfn_to_pfn() is a write fault"); /* pophype */
+#endif
 	if (is_error_page(page))
 		return NULL;
 
+
 	return page;
 }
 
@@ -1345,6 +1377,15 @@ static void vmcs_clear(struct vmcs *vmcs)
 
 static inline void loaded_vmcs_init(struct loaded_vmcs *loaded_vmcs)
 {
+#if defined(CONFIG_POPCORN_HYPE) && HYPEBOOTDEBUG && POPHYPE_MIGRATE_VERBOSE_DEBUG
+	static int cnt = 0;
+	PHMIGRATEVPRINTK("-------- %s(): <?>'s vmcs loaded_vmcs %p "
+				"set loaded_vmcs->cpu (host cpu) from %d to -1 #%d\n",
+				__func__, loaded_vmcs, loaded_vmcs->cpu, cnt);
+	if ((cnt++ % 100) == 0) {
+		dump_stack(); /* turn on to debug why this happens in default */
+	}
+#endif
 	vmcs_clear(loaded_vmcs->vmcs);
 	loaded_vmcs->cpu = -1;
 	loaded_vmcs->launched = 0;
@@ -1431,9 +1472,20 @@ static void loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)
 {
 	int cpu = loaded_vmcs->cpu;
 
-	if (cpu != -1)
+	if (cpu != -1) {
+#if defined(CONFIG_POPCORN_HYPE) && HYPEBOOTDEBUG && POPHYPE_MIGRATE_VERBOSE_DEBUG
+		static int cnt = 0;
+		PHMIGRATEVPRINTK("------- %s(): host cpu %d ------- #%d\n", __func__, cpu, cnt);
+		if ((cnt++ % 100) == 0) {
+			/* From ...
+				kvm_arch_vcpu_load()
+				vmx_vcpu_load() */
+			dump_stack(); /* turn on to debug why this happens in default */
+		}
+#endif
 		smp_call_function_single(cpu,
 			 __loaded_vmcs_clear, loaded_vmcs, 1);
+	}
 }
 
 static inline void vpid_sync_vcpu_single(int vpid)
@@ -1484,6 +1536,17 @@ static __always_inline unsigned long vmcs_readl(unsigned long field)
 	return value;
 }
 
+#ifdef CONFIG_POPCORN_HYPE
+unsigned long pophype_vmcs_readl(unsigned long field)
+{
+	unsigned long value;
+
+	asm volatile (__ex_clear(ASM_VMX_VMREAD_RDX_RAX, "%0")
+		      : "=a"(value) : "d"(field) : "cc");
+	return value;
+}
+#endif
+
 static __always_inline u16 vmcs_read16(unsigned long field)
 {
 	return vmcs_readl(field);
@@ -1520,6 +1583,18 @@ static void vmcs_writel(unsigned long field, unsigned long value)
 		vmwrite_error(field, value);
 }
 
+#ifdef CONFIG_POPCORN_HYPE
+static void pophype_vmcs_writel(unsigned long field, unsigned long value)
+{
+	u8 error;
+
+	asm volatile (__ex(ASM_VMX_VMWRITE_RAX_RDX) "; setna %0"
+		       : "=q"(error) : "a"(value), "d"(field) : "cc");
+	if (unlikely(error))
+		vmwrite_error(field, value);
+}
+#endif
+
 static void vmcs_write16(unsigned long field, u16 value)
 {
 	vmcs_writel(field, value);
@@ -1753,12 +1828,44 @@ static void add_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr,
 	switch (msr) {
 	case MSR_EFER:
 		if (cpu_has_load_ia32_efer) {
+#if defined(CONFIG_POPCORN_HYPE) //&& defined(CONFIG_POPCORN_STAT)
+			 PHMIGRATEPRINTK("[pophypemigrate][diff][efer] %s(): <%d> overwrite "
+					"guest/host efer guest/host val %llx %llx (before W: GUEST_IA32_EFER %lx). "
+					"This is the only place in the kernel\n",
+					__func__, vmx->vcpu.vcpu_id, guest_val, host_val, vmcs_readl(GUEST_IA32_EFER));
+#if HACK_GUEST_EFER
+			if (vmx->vcpu.vcpu_id && !my_nid && !guest_val) {
+				guest_val = 0x801;
+				printk("HACKHACKHACKHACKHACK\n");
+				printk("HACKHACKHACKHACKHACK\n");
+				printk("HACKHACKHACKHACKHACK\n");
+				printk("HACKHACKHACKHACKHACK\n");
+				printk("HACKHACKHACKHACKHACK\n");
+				printk("[pophypemigrate][diff][efer] %s(): <%d> "
+						"HACK HACK HACK overwrite guest efer GUEST_IA32_EFER\n",
+						__func__, vmx->vcpu.vcpu_id);
+				printk("HACKHACKHACKHACKHACK\n");
+				printk("HACKHACKHACKHACKHACK\n");
+				printk("HACKHACKHACKHACKHACK\n");
+				printk("HACKHACKHACKHACKHACK\n");
+				printk("HACKHACKHACKHACKHACK\n");
+			}
+#endif
+#endif
 			add_atomic_switch_msr_special(vmx,
 					VM_ENTRY_LOAD_IA32_EFER,
 					VM_EXIT_LOAD_IA32_EFER,
 					GUEST_IA32_EFER,
 					HOST_IA32_EFER,
 					guest_val, host_val);
+#if defined(CONFIG_POPCORN_HYPE) //&& defined(CONFIG_POPCORN_STAT)
+			 PHMIGRATEPRINTK("[pophypemigrate][diff][efer] %s(): <%d> overwrite "
+						"guest/host efer guest/host val "
+						"%llx %llx (after W: GUEST_IA32_EFER %lx). "
+						"This is the only place in the kernel\n",
+						__func__, vmx->vcpu.vcpu_id,
+						guest_val, host_val, vmcs_readl(GUEST_IA32_EFER));
+#endif
 			return;
 		}
 		break;
@@ -2066,10 +2173,22 @@ static void vmx_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
 	u64 phys_addr = __pa(per_cpu(vmxarea, cpu));
 
+//#if defined(CONFIG_POPCORN_HYPE) && HYPEBOOTDEBUG && POPHYPE_MIGRATE_VERBOSE_DEBUG
+#if defined(CONFIG_POPCORN_HYPE) && POPCORN_DEBUG_FT // killme replace me with the above one
+	static unsigned long cnt = 0;
+	// many nonstop
+	//if (cnt > 67289) {
+	cnt++;
+	if (!(cnt % 10000)) {
+		SIGVPRINTK("%s(): [LOAD] Jack vcpu %d vcpu->cpu %d cpu %d #%lu\n",
+				__func__, vcpu->vcpu_id, vcpu->cpu, cpu, cnt);
+	}
+#endif
+
 	if (!vmm_exclusive)
 		kvm_cpu_vmxon(phys_addr);
 	else if (vmx->loaded_vmcs->cpu != cpu)
-		loaded_vmcs_clear(vmx->loaded_vmcs);
+		loaded_vmcs_clear(vmx->loaded_vmcs); /* Looks like ft dies here */
 
 	if (per_cpu(current_vmcs, cpu) != vmx->loaded_vmcs->vmcs) {
 		per_cpu(current_vmcs, cpu) = vmx->loaded_vmcs->vmcs;
@@ -2106,6 +2225,19 @@ static void vmx_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
 		rdmsrl(MSR_IA32_SYSENTER_ESP, sysenter_esp);
 		vmcs_writel(HOST_IA32_SYSENTER_ESP, sysenter_esp); /* 22.2.3 */
 
+#if defined(CONFIG_POPCORN_HYPE) && HYPEBOOTDEBUG && POPHYPE_MIGRATE_VERBOSE_DEBUG
+		{
+			static unsigned long vmx_switch_cnt = 0;
+			PHMIGRATEVPRINTK("------- %s(): <%d>'s vmcs vmx->loaded_vmcs %p "
+							"set host cpu from %d to %d #%d\n",
+							__func__, vcpu->vcpu_id, vmx->loaded_vmcs,
+							vmx->loaded_vmcs->cpu, cpu, vmx_switch_cnt);
+			if (!(vmx_switch_cnt++ % 100)) {
+				dump_stack(); /* turn on to debug why this happens in default */
+			}
+		}
+#endif
+
 		vmx->loaded_vmcs->cpu = cpu;
 	}
 
@@ -2134,6 +2266,17 @@ static void vmx_vcpu_pi_put(struct kvm_vcpu *vcpu)
 
 static void vmx_vcpu_put(struct kvm_vcpu *vcpu)
 {
+//#if defined(CONFIG_POPCORN_HYPE) && HYPEBOOTDEBUG && POPHYPE_MIGRATE_VERBOSE_DEBUG
+#if defined(CONFIG_POPCORN_HYPE) && POPCORN_DEBUG_FT // killme replace me with the above one
+	static unsigned long cnt = 0;
+	// many nonstop
+	//if (cnt > 67289) {
+	cnt++;
+	if (!(cnt % 10000)) {
+		SIGVPRINTK("%s(): [PUT] Jack vcpu %d vcpu->cpu %d #%lu\n",
+				__func__, vcpu->vcpu_id, vcpu->cpu, cnt);
+	}
+#endif
 	vmx_vcpu_pi_put(vcpu);
 
 	__vmx_load_host_state(to_vmx(vcpu));
@@ -2382,6 +2525,9 @@ static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)
 static void setup_msrs(struct vcpu_vmx *vmx)
 {
 	int save_nmsrs, index;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_X86_64)
+	PHMSRPRINTK("%s(): <%d>\n", __func__, vmx->vcpu.vcpu_id);
+#endif
 
 	save_nmsrs = 0;
 #ifdef CONFIG_X86_64
@@ -2810,63 +2956,131 @@ static int vmx_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 {
 	struct shared_msr_entry *msr;
 
+
+#if 0 /* x86 is wrong. the real cllee is here */
+/*
+    static u32 msrs_to_save[] = {
+    MSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,
+    MSR_STAR,
+#ifdef CONFIG_X86_64
+    MSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,
+#endif
+    MSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,
+    MSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,
+};
+*/
+    pophype_msrs.entries[n++].index = MSR_IA32_APICBASE; // no
+    pophype_msrs.entries[n++].index = MSR_IA32_SYSENTER_CS;
+    pophype_msrs.entries[n++].index = MSR_IA32_SYSENTER_ESP;
+    pophype_msrs.entries[n++].index = MSR_IA32_SYSENTER_EIP;
+    pophype_msrs.entries[n++].index = MSR_IA32_CR_PAT; // no get !!!!!!!!!!watch
+    pophype_msrs.entries[n++].index = MSR_IA32_MISC_ENABLE; // no
+    pophype_msrs.entries[n++].index = MSR_IA32_TSC;
+    pophype_msrs.entries[n++].index = MSR_CSTAR;
+    pophype_msrs.entries[n++].index = MSR_STAR;
+    pophype_msrs.entries[n++].index = MSR_EFER; // no (kvm_get_msr_common in arch/x86/kvm/x86.c)
+    pophype_msrs.entries[n++].index = MSR_LSTAR;
+    pophype_msrs.entries[n++].index = MSR_GS_BASE; // no (set)
+    pophype_msrs.entries[n++].index = MSR_FS_BASE; // no (set)
+    pophype_msrs.entries[n++].index = MSR_KERNEL_GS_BASE;
+    //pophype_msrs[n++].index = MSR_IA32_FEATURE_CONTROL;
+    pophype_msrs.nmsrs = n;
+
+#endif
+
+	PHMIGRATEPRINTK("\t\t\t<%d> %s(): msr_info->index %x\n",
+			vcpu->vcpu_id, __func__, msr_info->index);
+
 	switch (msr_info->index) {
 #ifdef CONFIG_X86_64
 	case MSR_FS_BASE:
+		PHMIGRATEPRINTK("\t\t\t\t<%d> %s(): msr_info->index %x MSR_FS_BASE\n",
+				vcpu->vcpu_id, __func__, msr_info->index);
 		msr_info->data = vmcs_readl(GUEST_FS_BASE);
 		break;
 	case MSR_GS_BASE:
+		PHMIGRATEPRINTK("\t\t\t\t<%d> %s(): msr_info->index %x MSR_GS_BASE\n",
+				vcpu->vcpu_id, __func__, msr_info->index);
 		msr_info->data = vmcs_readl(GUEST_GS_BASE);
 		break;
 	case MSR_KERNEL_GS_BASE:
+		PHMIGRATEPRINTK("\t\t\t\t<%d> %s(): msr_info->index %x MSR_KERNEL_GS_BASE\n",
+				vcpu->vcpu_id, __func__, msr_info->index);
 		vmx_load_host_state(to_vmx(vcpu));
 		msr_info->data = to_vmx(vcpu)->msr_guest_kernel_gs_base;
 		break;
 #endif
 	case MSR_EFER:
+		PHMIGRATEPRINTK("\t\t\t\t<%d> %s(): msr_info->index %x MSR_EFER\n",
+				vcpu->vcpu_id, __func__, msr_info->index);
 		return kvm_get_msr_common(vcpu, msr_info);
 	case MSR_IA32_TSC:
+		PHMIGRATEPRINTK("\t\t\t\t<%d> %s(): msr_info->index %x MSR_IA32_TSC\n",
+				vcpu->vcpu_id, __func__, msr_info->index);
 		msr_info->data = guest_read_tsc(vcpu);
 		break;
 	case MSR_IA32_SYSENTER_CS:
+		PHMIGRATEPRINTK("\t\t\t\t<%d> %s(): msr_info->index %x MSR_IA32_SYSENTER_CS\n",
+				vcpu->vcpu_id, __func__, msr_info->index);
 		msr_info->data = vmcs_read32(GUEST_SYSENTER_CS);
 		break;
 	case MSR_IA32_SYSENTER_EIP:
+		PHMIGRATEPRINTK("\t\t\t\t<%d> %s(): msr_info->index %x MSR_IA32_SYSENTER_EIP\n",
+				vcpu->vcpu_id, __func__, msr_info->index);
 		msr_info->data = vmcs_readl(GUEST_SYSENTER_EIP);
 		break;
 	case MSR_IA32_SYSENTER_ESP:
+		PHMIGRATEPRINTK("\t\t\t\t<%d> %s(): msr_info->index %x MSR_IA32_SYSENTER_ESP\n",
+				vcpu->vcpu_id, __func__, msr_info->index);
 		msr_info->data = vmcs_readl(GUEST_SYSENTER_ESP);
 		break;
 	case MSR_IA32_BNDCFGS:
+		PHMIGRATEPRINTK("\t\t\t\t<%d> %s(): msr_info->index %x MSR_IA32_BNDCFGS\n",
+				vcpu->vcpu_id, __func__, msr_info->index);
 		if (!kvm_mpx_supported() ||
 		    (!msr_info->host_initiated && !guest_cpuid_has_mpx(vcpu)))
 			return 1;
 		msr_info->data = vmcs_read64(GUEST_BNDCFGS);
 		break;
 	case MSR_IA32_FEATURE_CONTROL:
+		PHMIGRATEPRINTK("\t\t\t\t<%d> %s(): "
+						"msr_info->index %x MSR_IA32_FEATURE_CONTROL\n",
+						vcpu->vcpu_id, __func__, msr_info->index);
 		if (!nested_vmx_allowed(vcpu))
 			return 1;
 		msr_info->data = to_vmx(vcpu)->nested.msr_ia32_feature_control;
 		break;
 	case MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:
+		PHMIGRATEPRINTK("\t\t\t\t<%d> %s(): msr_info->index %x MSR_IA32_VMX_BASIC ~ MSR_IA32_VMX_VMFUNC (VMX: Intel VT MSRs)\n",
+				vcpu->vcpu_id, __func__, msr_info->index);
 		if (!nested_vmx_allowed(vcpu))
 			return 1;
 		return vmx_get_vmx_msr(vcpu, msr_info->index, &msr_info->data);
 	case MSR_IA32_XSS:
+		PHMIGRATEPRINTK("\t\t\t\t<%d> %s(): msr_info->index %x MSR_IA32_XSS\n",
+				vcpu->vcpu_id, __func__, msr_info->index);
 		if (!vmx_xsaves_supported())
 			return 1;
 		msr_info->data = vcpu->arch.ia32_xss;
 		break;
 	case MSR_TSC_AUX:
+		PHMIGRATEPRINTK("\t\t\t\t<%d> %s(): msr_info->index %x MSR_TSC_AUX\n",
+				vcpu->vcpu_id, __func__, msr_info->index);
 		if (!guest_cpuid_has_rdtscp(vcpu) && !msr_info->host_initiated)
 			return 1;
 		/* Otherwise falls through */
 	default:
+		PHMIGRATEPRINTK("\t\t\t\t<%d> %s(): msr_info->index %x "
+				"default begin (check if there is a end)\n",
+				vcpu->vcpu_id, __func__, msr_info->index);
 		msr = find_msr_entry(to_vmx(vcpu), msr_info->index);
 		if (msr) {
 			msr_info->data = msr->data;
 			break;
 		}
+		PHMIGRATEPRINTK("\t\t\t\t<%d> %s(): msr_info->index %x default "
+				"(others: MSR_IA32_APICBASE 1b, PUT HERE, TODO)\n",
+				vcpu->vcpu_id, __func__, msr_info->index);
 		return kvm_get_msr_common(vcpu, msr_info);
 	}
 
@@ -2913,6 +3127,11 @@ static int vmx_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 		vmcs_writel(GUEST_SYSENTER_EIP, data);
 		break;
 	case MSR_IA32_SYSENTER_ESP:
+#ifdef CONFIG_POPCORN_HYPE
+		PHAPICPRINTK("[migration] MSR_IA32_SYSENTER_ESP "
+				"vmcs_writel val %llx (guest esp)\n", data);
+		//WARN_ON(1);
+#endif
 		vmcs_writel(GUEST_SYSENTER_ESP, data);
 		break;
 	case MSR_IA32_BNDCFGS:
@@ -3105,6 +3324,16 @@ static void vmclear_local_loaded_vmcss(void)
 	int cpu = raw_smp_processor_id();
 	struct loaded_vmcs *v, *n;
 
+#if defined(CONFIG_POPCORN_HYPE) && HYPEBOOTDEBUG
+	/* Boottime init for each host cpu */
+	//static int cnt = 0;
+	//PHMIGRATEPRINTK("--- %s() ---\n", __func__);
+	//if ((cnt++ % 100) == 0) {
+	//	dump_stack(); /* turn on to debug why this happens in default */
+	//}
+	//PHMIGRATEPRINTK("%s(): ------ %d\n", __func__, cnt);
+#endif
+
 	list_for_each_entry_safe(v, n, &per_cpu(loaded_vmcss_on_cpu, cpu),
 				 loaded_vmcss_on_cpu_link)
 		__loaded_vmcs_clear(v);
@@ -3349,6 +3578,10 @@ static struct vmcs *alloc_vmcs_cpu(int cpu)
 	vmcs = page_address(pages);
 	memset(vmcs, 0, vmcs_config.size);
 	vmcs->revision_id = vmcs_config.revision_id; /* vmcs revision id */
+#if defined(CONFIG_POPCORN_HYPE)
+	/* per vcpu */
+	PHMIGRATEPRINTK("%s(): pophype cpu %d\n", __func__, cpu);
+#endif
 	return vmcs;
 }
 
@@ -3590,6 +3823,12 @@ static void vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer)
 	if (!msr)
 		return;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_X86_64)
+	PHMIGRATEPRINTK("<%d> %s(): set vcpu->arch.efer %llx -> "
+					"%llx is_long_mode(&vmx->vcpu) %d\n",
+					vcpu->vcpu_id, __func__, vcpu->arch.efer,
+					efer, is_long_mode(&vmx->vcpu));
+#endif
 	/*
 	 * Force kernel_gs_base reloading before EFER changes, as control
 	 * of this msr depends on is_long_mode().
@@ -3615,6 +3854,10 @@ static void enter_lmode(struct kvm_vcpu *vcpu)
 
 	vmx_segment_cache_clear(to_vmx(vcpu));
 
+#if defined(CONFIG_POPCORN_HYPE)
+	PHMIGRATEPRINTK("<%d> %s():\n", vcpu->vcpu_id, __func__);
+#endif
+
 	guest_tr_ar = vmcs_read32(GUEST_TR_AR_BYTES);
 	if ((guest_tr_ar & VMX_AR_TYPE_MASK) != VMX_AR_TYPE_BUSY_64_TSS) {
 		pr_debug_ratelimited("%s: tss fixup for long mode. \n",
@@ -3628,6 +3871,9 @@ static void enter_lmode(struct kvm_vcpu *vcpu)
 
 static void exit_lmode(struct kvm_vcpu *vcpu)
 {
+#if defined(CONFIG_POPCORN_HYPE)
+	printk("<%d> %s():\n", vcpu->vcpu_id, __func__);
+#endif
 	vm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);
 	vmx_set_efer(vcpu, vcpu->arch.efer & ~EFER_LMA);
 }
@@ -3795,6 +4041,14 @@ static void vmx_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)
 	unsigned long guest_cr3;
 	u64 eptp;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static int first_cr3[4] = {0, 0, 0, 0}; /* TODO MAX_VCPU*/
+	if (first_cr3[vcpu->vcpu_id < 10]) { /* final check beore vm entry */
+		first_cr3[vcpu->vcpu_id]++;
+		PHMIGRATEPRINTK("%s(): <%d> vmcs_write64 nice!!! Never happened\n",
+									__func__, vcpu->vcpu_id);
+	}
+#endif
 	guest_cr3 = cr3;
 	if (enable_ept) {
 		eptp = construct_eptp(cr3);
@@ -3963,6 +4217,10 @@ static void vmx_set_segment(struct kvm_vcpu *vcpu,
 	vmcs_write32(sf->limit, var->limit);
 	vmcs_write16(sf->selector, var->selector);
 
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	printk("enable_unrestricted_guest %d && (seg != VCPU_SREG_LDTR) %d\n",
+			enable_unrestricted_guest, seg != VCPU_SREG_LDTR);
+#endif
 	/*
 	 *   Fix the "Accessed" bit in AR field of segment registers for older
 	 * qemu binaries.
@@ -3974,8 +4232,43 @@ static void vmx_set_segment(struct kvm_vcpu *vcpu,
 	 * tree. Newer qemu binaries with that qemu fix would not need this
 	 * kvm hack.
 	 */
-	if (enable_unrestricted_guest && (seg != VCPU_SREG_LDTR))
+	if (enable_unrestricted_guest && (seg != VCPU_SREG_LDTR)) {
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+		printk("<%d> %s(): seg = %d var->type %x |= 0x1 "
+				"(es=0, cs, ss, ds, fs, gs, tr, ldtr)\n",
+				vcpu->vcpu_id, __func__, seg, var->type);
+		/*
+    VCPU_SREG_ES=0, // !!!!
+    VCPU_SREG_CS,
+    VCPU_SREG_SS,
+    VCPU_SREG_DS=3, //!!!!
+    VCPU_SREG_FS,
+    VCPU_SREG_GS=5, // !!!!!
+    VCPU_SREG_TR,
+    VCPU_SREG_LDTR,
+		*/
+
+#endif
 		var->type |= 0x1; /* Accessed */
+#if defined(CONFIG_POPCORN_HYPE) && HACK_GUEST_DS_ES_GS_AT_ORIGIN
+		{ int hack = 0; /* type: 0 => 1 */
+			if (seg == VCPU_SREG_DS && var->type == 0x1)
+				hack = 1;
+			else if (seg == VCPU_SREG_ES && var->type == 0x1)
+				hack = 1;
+			else if (seg == VCPU_SREG_GS && var->type == 0x1)
+				hack = 1;
+			if (hack) {
+				printk("<%d> %s(): pophype HACK HACK HACK (DOESN'T WORK) "
+						"- the right way is 1. to find who set .type = 0"
+						" 2. if that one is before here, maybe this hack may work."
+						" Otherwise this hack is very dangerous\n",
+											vcpu->vcpu_id, __func__);
+				var->type = 0;
+			}
+		}
+#endif
+	}
 
 	vmcs_write32(sf->ar_bytes, vmx_segment_access_rights(var));
 
@@ -4020,6 +4313,8 @@ static bool rmode_segment_valid(struct kvm_vcpu *vcpu, int seg)
 	struct kvm_segment var;
 	u32 ar;
 
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+#endif
 	vmx_get_segment(vcpu, &var, seg);
 	var.dpl = 0x3;
 	if (seg == VCPU_SREG_CS)
@@ -4216,29 +4511,49 @@ static int init_rmode_tss(struct kvm *kvm)
 	gfn_t fn;
 	u16 data = 0;
 	int idx, r;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	int ret = 0;
+	HPPRINTK("%s: remote TSS has its own TSS vma region now\n", __func__);
+#endif
 
 	idx = srcu_read_lock(&kvm->srcu);
 	fn = kvm->arch.tss_addr >> PAGE_SHIFT;
 	r = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);
 	if (r < 0)
 		goto out;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	ret++;
+#endif
 	data = TSS_BASE_SIZE + TSS_REDIRECTION_SIZE;
 	r = kvm_write_guest_page(kvm, fn++, &data,
 			TSS_IOPB_BASE_OFFSET, sizeof(u16));
 	if (r < 0)
 		goto out;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	ret++;
+#endif
 	r = kvm_clear_guest_page(kvm, fn++, 0, PAGE_SIZE);
 	if (r < 0)
 		goto out;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	ret++;
+#endif
 	r = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);
 	if (r < 0)
 		goto out;
 	data = ~0;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	ret++;
+#endif
 	r = kvm_write_guest_page(kvm, fn, &data,
 				 RMODE_TSS_SIZE - 2 * PAGE_SIZE - 1,
 				 sizeof(u8));
 out:
 	srcu_read_unlock(&kvm->srcu, idx);
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	if (r < 0)
+		HPPRINTK("\t%s(): r %d ret %d\n", __func__, r , ret);
+#endif
 	return r;
 }
 
@@ -4314,6 +4629,11 @@ static int alloc_apic_access_page(struct kvm *kvm)
 	if (r)
 		goto out;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	printk("[%d] %s(): apic page gpa 0x%x\n",
+				current->pid, __func__, APIC_DEFAULT_PHYS_BASE);
+	//BUG_ON("gfn_to_page() is a write fault"); /* pophype - happens once */
+#endif
 	page = gfn_to_page(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);
 	if (is_error_page(page)) {
 		r = -EFAULT;
@@ -4627,6 +4947,16 @@ static void vmx_deliver_posted_interrupt(struct kvm_vcpu *vcpu, int vector)
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
 	int r;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+#if HYPE_PERF_CRITICAL_DEBUG
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT || !(cnt % 5000)) // lmany
+		printk("\t APIC_DM_FIXED -> %s(): vcpu %d vec 0x%x #%lu\n",
+								__func__, vcpu->vcpu_id, vector, cnt);
+#endif
+#endif
+
 	r = vmx_deliver_nested_posted_interrupt(vcpu, vector);
 	if (!r)
 		return;
@@ -4668,6 +4998,10 @@ static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)
 	struct desc_ptr dt;
 	unsigned long cr4;
 
+#if defined(CONFIG_POPCORN_HYPE)
+	POP_PK("%s(): \n", __func__);
+#endif
+
 	vmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  /* 22.2.3 */
 	vmcs_writel(HOST_CR3, read_cr3());  /* 22.2.3  FIXME: shadow tables */
 
@@ -4753,6 +5087,9 @@ static u32 vmx_exec_control(struct vcpu_vmx *vmx)
 static u32 vmx_secondary_exec_control(struct vcpu_vmx *vmx)
 {
 	u32 exec_control = vmcs_config.cpu_based_2nd_exec_ctrl;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	PHMIGRATEPRINTK("%s(): Jack vmx %p\n", __func__, vmx);
+#endif
 	if (!cpu_need_virtualize_apic_accesses(&vmx->vcpu))
 		exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
 	if (vmx->vpid == 0)
@@ -4789,6 +5126,11 @@ static u32 vmx_secondary_exec_control(struct vcpu_vmx *vmx)
 
 static void ept_set_mmio_spte_mask(void)
 {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	/* arch/x86/kvm/vmx.c */
+    POP_PK("%s: WE ARE [[[[[[EPT enabled]]]]] 110b mmio\n", __func__);
+	//WARN_ON(1);
+#endif
 	/*
 	 * EPT Misconfigurations can be generated if the value of bits 2:0
 	 * of an EPT paging-structure entry is 110b (write/execute).
@@ -4808,6 +5150,11 @@ static int vmx_vcpu_setup(struct vcpu_vmx *vmx)
 	unsigned long a;
 #endif
 	int i;
+#if defined(CONFIG_POPCORN_HYPE)
+	PHMIGRATEPRINTK("%s(): pophype vcpu %d host vcpu %d many vmcs_write done "
+					"(no preload...maybe I destory?) start\n",
+					__func__, vmx->vcpu.vcpu_id, vmx->vcpu.cpu);
+#endif
 
 	/* I/O */
 	vmcs_write64(IO_BITMAP_A, __pa(vmx_io_bitmap_a));
@@ -4907,6 +5254,11 @@ static int vmx_vcpu_setup(struct vcpu_vmx *vmx)
 		vmcs_write64(PML_ADDRESS, page_to_phys(vmx->pml_pg));
 		vmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);
 	}
+#if defined(CONFIG_POPCORN_HYPE)
+	PHMIGRATEPRINTK("%s(): pophype vcpu %d host vcpu %d many vmcs_write done "
+					"(no preload...maybe I destory?) end\n",
+					__func__, vmx->vcpu.vcpu_id, vmx->vcpu.cpu);
+#endif
 
 	return 0;
 }
@@ -4917,6 +5269,11 @@ static void vmx_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)
 	struct msr_data apic_base_msr;
 	u64 cr0;
 
+#if defined(CONFIG_POPCORN_HYPE)
+	POP_PK("%s(): pophype vcpu %d host vcpu %d\n",
+				__func__, vcpu->vcpu_id, vcpu->cpu);
+#endif
+
 	vmx->rmode.vm86_active = 0;
 
 	vmx->soft_vnmi_blocked = 0;
@@ -5168,8 +5525,15 @@ static int vmx_set_tss_addr(struct kvm *kvm, unsigned int addr)
 {
 	int ret;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+    DDPRINTK("%s: 3\n", __func__);
+#endif
 	ret = x86_set_memory_region(kvm, TSS_PRIVATE_MEMSLOT, addr,
 				    PAGE_SIZE * 3);
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+    DDPRINTK("%s: 4\n", __func__);
+	BUG_ON(ret); /* This happens sometimes.... (e.g. msg_layer not on) */
+#endif
 	if (ret)
 		return ret;
 	kvm->arch.tss_addr = addr;
@@ -5269,21 +5633,58 @@ static int handle_exception(struct kvm_vcpu *vcpu)
 	u32 vect_info;
 	enum emulation_result er;
 
+#if HYPE_PERF_CRITICAL_DEBUG
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	/* pophype TODO: I might have to redirect this. From VM_EXIT */
+	static unsigned long handle_except_cnt = 0;
+	if (distributed_process(current)) {
+		handle_except_cnt++;
+		printk(" $$[%d] from <%d> %s(): #%lu\n",
+				current->pid, vcpu->vcpu_id, __func__, handle_except_cnt);
+	}
+#endif
+#endif
+
 	vect_info = vmx->idt_vectoring_info;
 	intr_info = vmx->exit_intr_info;
 
-	if (is_machine_check(intr_info))
+	if (is_machine_check(intr_info)) {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		if (distributed_process(current))
+			printk("\t $$[%d] <%d> %s(): machine check handled by vcpu_run()\n",
+						current->pid, vcpu->vcpu_id, __func__);
+#endif
 		return handle_machine_check(vcpu);
+	}
 
-	if (is_nmi(intr_info))
+	if (is_nmi(intr_info)) {
+#if HYPE_PERF_CRITICAL_DEBUG
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		if (distributed_process(current))
+			printk("\t $$[%d] <%d> %s(): nmi handled by vmx_vcpu_run()\n",
+					current->pid, vcpu->vcpu_id, __func__);
+#endif
+#endif
 		return 1;  /* already handled by vmx_vcpu_run() */
+	}
 
 	if (is_no_device(intr_info)) {
 		vmx_fpu_activate(vcpu);
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		if (distributed_process(current))
+			printk("\t $$[%d] <%d> %s(): no dev\n",
+					current->pid, vcpu->vcpu_id, __func__);
+#endif
 		return 1;
 	}
 
 	if (is_invalid_opcode(intr_info)) {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		if (distributed_process(current))
+			printk("\t $$[%d] <%d> %s(): inv op\n",
+					current->pid, vcpu->vcpu_id, __func__);
+#endif
+
 		if (is_guest_mode(vcpu)) {
 			kvm_queue_exception(vcpu, UD_VECTOR);
 			return 1;
@@ -5307,6 +5708,14 @@ static int handle_exception(struct kvm_vcpu *vcpu)
 	 */
 	if ((vect_info & VECTORING_INFO_VALID_MASK) &&
 	    !(is_page_fault(intr_info) && !(error_code & PFERR_RSVD_MASK))) {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		printk("What makes 17?? simul_ev %s %s %s\n",
+					(vect_info & VECTORING_INFO_VALID_MASK)?"O":"X",
+					(is_page_fault(intr_info))?"O":"X",
+					(error_code & PFERR_RSVD_MASK)?"O":"X");
+		printk("vect_info %u intr_info %u\n",
+							vect_info, intr_info);
+#endif
 		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
 		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_SIMUL_EX;
 		vcpu->run->internal.ndata = 3;
@@ -5324,11 +5733,28 @@ static int handle_exception(struct kvm_vcpu *vcpu)
 
 		if (kvm_event_needs_reinjection(vcpu))
 			kvm_mmu_unprotect_page_virt(vcpu, cr2);
-		return kvm_mmu_page_fault(vcpu, cr2, error_code, NULL, 0);
+
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		if (distributed_process(current)) {
+			printk("\t @@ [%d] <%d> @@ from %s\n",
+					current->pid, vcpu->vcpu_id, __func__);
+		}
+#endif
+		return kvm_mmu_page_fault(vcpu, cr2, error_code, NULL, 0, 1, 1);
 	}
 
 	ex_no = intr_info & INTR_INFO_VECTOR_MASK;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	if (distributed_process(current)) {
+		static unsigned long handle_except_cnt2 = 0;
+		handle_except_cnt2++;
+		printk(" $$[%d] <%d> %s(): vect_info %x intr_info %x ex_no %x #%lu\n",
+				current->pid, vcpu->vcpu_id, __func__,
+				vect_info, intr_info, ex_no, handle_except_cnt2);
+	}
+#endif
+
 	if (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no))
 		return handle_rmode_exception(vcpu, ex_no, error_code);
 
@@ -5375,6 +5801,15 @@ static int handle_exception(struct kvm_vcpu *vcpu)
 
 static int handle_external_interrupt(struct kvm_vcpu *vcpu)
 {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt > (VM_SINGLE_HANDLE_DISPLAY_CNT + 10) &&
+			cnt < (VM_SINGLE_HANDLE_DISPLAY_CNT + 11)) {
+		VMPRINTK("\t\t|| %s(): <%d> check if handler works #%lu\n",
+								__func__, vcpu->vcpu_id, cnt);
+	}
+#endif
 	++vcpu->stat.irq_exits;
 	return 1;
 }
@@ -5391,6 +5826,28 @@ static int handle_io(struct kvm_vcpu *vcpu)
 	int size, in, string;
 	unsigned port;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	static unsigned long cnt1 = 0;
+	if (!vcpu->vcpu_id) {
+		cnt++;
+		if (cnt > 0 && cnt < VM_SINGLE_HANDLE_DISPLAY_CNT) {
+			//|| !(cnt % VM_SINGLE_HANDLE_DISPLAY_CNT)) {
+		//if (cnt > 2600 && cnt < 2700)
+			VMPRINTK("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+		}
+	} else if (vcpu->vcpu_id) {
+		cnt1++;
+		//if (cnt1 < VM_SINGLE_HANDLE_DISPLAY_CNT) {
+		//if (cnt1 > 100000 || (cnt1 > 50000 && !(cnt1 % 10000))) {
+		if ( cnt1 < VM_SINGLE_HANDLE_DISPLAY_CNT || !(cnt1 % 10000)) {
+			/* happens all the time */
+			CRITICALIOPK("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt1);
+			//VMPRINTK("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt1);
+		}
+	}
+#endif
+
 	exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
 	string = (exit_qualification & 16) != 0;
 	in = (exit_qualification & 8) != 0;
@@ -5503,12 +5960,28 @@ static int handle_cr(struct kvm_vcpu *vcpu)
 	int reg;
 	int err;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	static unsigned long cr_cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT) {
+		VMPRINTK("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+	}
+#endif
+
 	exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
 	cr = exit_qualification & 15;
 	reg = (exit_qualification >> 8) & 15;
 	switch ((exit_qualification >> 4) & 3) {
 	case 0: /* mov to cr */
 		val = kvm_register_readl(vcpu, reg);
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		cr_cnt++;
+		if (cr_cnt < VM_SINGLE_HANDLE_DISPLAY_CNT) {
+			VMPRINTK("\t\t|| %s(): <%d> val %lx #%lu\n", __func__,
+									vcpu->vcpu_id, cr_cnt, val);
+		}
+#endif
 		trace_kvm_cr_write(cr, val);
 		switch (cr) {
 		case 0:
@@ -5580,6 +6053,13 @@ static int handle_dr(struct kvm_vcpu *vcpu)
 	unsigned long exit_qualification;
 	int dr, dr7, reg;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		VMPRINTK("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
+
 	exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
 	dr = exit_qualification & DEBUG_REG_ACCESS_NUM;
 
@@ -5677,6 +6157,23 @@ static void vmx_set_dr7(struct kvm_vcpu *vcpu, unsigned long val)
 
 static int handle_cpuid(struct kvm_vcpu *vcpu)
 {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	static unsigned long cnt1 = 0;
+	if (!vcpu->vcpu_id) {
+	cnt++;
+	if (cnt > 0 && cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+	//if (cnt > 2200 && cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		VMPRINTK("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+	}
+
+	if (vcpu->vcpu_id) {
+		cnt1++;
+		if (cnt1 < VM_SINGLE_HANDLE_DISPLAY_CNT)
+			VMPRINTK("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt1);
+	}
+#endif
+
 	kvm_emulate_cpuid(vcpu);
 	return 1;
 }
@@ -5686,6 +6183,14 @@ static int handle_rdmsr(struct kvm_vcpu *vcpu)
 	u32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];
 	struct msr_data msr_info;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT) {
+		VMPRINTK("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+	}
+#endif
+
 	msr_info.index = ecx;
 	msr_info.host_initiated = false;
 	if (vmx_get_msr(vcpu, &msr_info)) {
@@ -5710,6 +6215,20 @@ static int handle_wrmsr(struct kvm_vcpu *vcpu)
 	u64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)
 		| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT) {
+		/* this is the 2nd thing AP does */
+		WRMSRPRINTK("\t\t|| %s(): <%d> ecx(reg) 0x%x data 0x%llx  #%lu\n",
+							__func__, vcpu->vcpu_id, ecx, data, cnt);
+		if (ecx >> (2 * sizeof(char)) == 0x4b564d) { // == 0x4b564dxx
+			printk ("\t\t\tlapid seting\n");
+		}
+	}
+	/* TODO: I might have to redirect this */
+#endif
+
 	msr.data = data;
 	msr.index = ecx;
 	msr.host_initiated = false;
@@ -5726,6 +6245,13 @@ static int handle_wrmsr(struct kvm_vcpu *vcpu)
 
 static int handle_tpr_below_threshold(struct kvm_vcpu *vcpu)
 {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT) {
+		VMPRINTK("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+	}
+#endif
 	kvm_make_request(KVM_REQ_EVENT, vcpu);
 	return 1;
 }
@@ -5734,6 +6260,18 @@ static int handle_interrupt_window(struct kvm_vcpu *vcpu)
 {
 	u32 cpu_based_vm_exec_control;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	if (distributed_process(current)) {
+		cnt++;
+		if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT) {
+			/* Not many but anytime */
+			CRITICALALLPK("\t\t|| %s(): <%d> #%lu\n",
+						__func__, vcpu->vcpu_id, cnt);
+		}
+	}
+#endif
+
 	/* clear pending irq */
 	cpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);
 	cpu_based_vm_exec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;
@@ -5747,23 +6285,52 @@ static int handle_interrupt_window(struct kvm_vcpu *vcpu)
 
 static int handle_halt(struct kvm_vcpu *vcpu)
 {
+#if defined(CONFIG_POPCORN_HYPE) && HYPEBOOTDEBUG
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < 50)
+		printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
 	return kvm_emulate_halt(vcpu);
 }
 
 static int handle_vmcall(struct kvm_vcpu *vcpu)
 {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT) {
+		PHMIGRATEPRINTK("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+	}
+#endif
+#if defined(CONFIG_POPCORN_HYPE)
+	return kvm_emulate_hypercall(vcpu);
+#else
 	kvm_emulate_hypercall(vcpu);
 	return 1;
+#endif
 }
 
 static int handle_invd(struct kvm_vcpu *vcpu)
 {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
 	return emulate_instruction(vcpu, 0) == EMULATE_DONE;
 }
 
 static int handle_invlpg(struct kvm_vcpu *vcpu)
 {
 	unsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
 
 	kvm_mmu_invlpg(vcpu, exit_qualification);
 	skip_emulated_instruction(vcpu);
@@ -5773,6 +6340,12 @@ static int handle_invlpg(struct kvm_vcpu *vcpu)
 static int handle_rdpmc(struct kvm_vcpu *vcpu)
 {
 	int err;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
 
 	err = kvm_rdpmc(vcpu);
 	kvm_complete_insn_gp(vcpu, err);
@@ -5782,6 +6355,17 @@ static int handle_rdpmc(struct kvm_vcpu *vcpu)
 
 static int handle_wbinvd(struct kvm_vcpu *vcpu)
 {
+
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT) {
+		VMPRINTK("\t\t|| %s(): <%d> #%lu \"CLEAR CACHE\" "
+				"EXIT_REASON_WBINVD %d is the first vmx->exit "
+				"BUT NEVENR COME TO HERE\n",
+				__func__, vcpu->vcpu_id, cnt, EXIT_REASON_WBINVD);
+	}
+#endif
 	kvm_emulate_wbinvd(vcpu);
 	return 1;
 }
@@ -5791,6 +6375,13 @@ static int handle_xsetbv(struct kvm_vcpu *vcpu)
 	u64 new_bv = kvm_read_edx_eax(vcpu);
 	u32 index = kvm_register_read(vcpu, VCPU_REGS_RCX);
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		VMPRINTK("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
+
 	if (kvm_set_xcr(vcpu, index, new_bv) == 0)
 		skip_emulated_instruction(vcpu);
 	return 1;
@@ -5812,6 +6403,12 @@ static int handle_xrstors(struct kvm_vcpu *vcpu)
 
 static int handle_apic_access(struct kvm_vcpu *vcpu)
 {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		VMPRINTK("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
 	if (likely(fasteoi)) {
 		unsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
 		int access_type, offset;
@@ -5838,6 +6435,13 @@ static int handle_apic_eoi_induced(struct kvm_vcpu *vcpu)
 	unsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
 	int vector = exit_qualification & 0xff;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
+
 	/* EOI-induced VM exit is trap-like and thus no need to adjust IP */
 	kvm_apic_set_eoi_accelerated(vcpu, vector);
 	return 1;
@@ -5847,6 +6451,22 @@ static int handle_apic_write(struct kvm_vcpu *vcpu)
 {
 	unsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
 	u32 offset = exit_qualification & 0xfff;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT) && HYPEBOOTDEBUG
+	/* TODO distributed_process(current) */
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT) {
+		/* 0x300 == ICR */
+		printk("\t\t|| %s(): <%d> offset(reg) 0x%x #%lu\n",
+				__func__, vcpu->vcpu_id, offset, cnt);
+		if (offset == APIC_DFR) { // == reg=APIC_DFR == recalculate_apic_map
+			printk("\t\t\t=>recalculate_apic_map()\n");
+		}
+	}
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	BUG_ON(in_atomic());
+#endif
+#endif
 
 	/* APIC-write VM exit is trap-like and thus no need to adjust IP */
 	kvm_apic_write_nodecode(vcpu, offset);
@@ -5862,6 +6482,14 @@ static int handle_task_switch(struct kvm_vcpu *vcpu)
 	u16 tss_selector;
 	int reason, type, idt_v, idt_index;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	//static unsigned long cnt = 0;
+	//cnt++;
+	//if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+	//	printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+	printk("\t\t|| %s(): <%d>\n", __func__, vcpu->vcpu_id);
+#endif
+
 	idt_v = (vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK);
 	idt_index = (vmx->idt_vectoring_info & VECTORING_INFO_VECTOR_MASK);
 	type = (vmx->idt_vectoring_info & VECTORING_INFO_TYPE_MASK);
@@ -5921,9 +6549,12 @@ static int handle_task_switch(struct kvm_vcpu *vcpu)
 static int handle_ept_violation(struct kvm_vcpu *vcpu)
 {
 	unsigned long exit_qualification;
-	gpa_t gpa;
+	gpa_t gpa, gla = -1;
 	u32 error_code;
 	int gla_validity;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+#endif
 
 	exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
 
@@ -5952,18 +6583,52 @@ static int handle_ept_violation(struct kvm_vcpu *vcpu)
 		vmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO, GUEST_INTR_STATE_NMI);
 
 	gpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);
-	trace_kvm_page_fault(gpa, exit_qualification);
+	if (gla_validity & 0x1)
+		gla = vmcs_readl(GUEST_LINEAR_ADDRESS); // check Table 27-7 Intel manual
+#if defined(CONFIG_POPCORN_HYPE)
+	/* AB: */
+	//trace_kvm_page_fault(gpa, exit_qualification);
+	//trace_kvm_page_fault_ext(kvm_rip_read(vcpu), gpa, gla, exit_qualification);
+	trace_kvm_page_fault_ext(kvm_get_linear_rip(vcpu), gpa, gla, exit_qualification);
+	/*
+	#define PFERR_PRESENT_BIT 0
+	#define PFERR_WRITE_BIT 1
+	#define PFERR_USER_BIT 2
+	#define PFERR_RSVD_BIT 3
+	#define PFERR_FETCH_BIT 4
+
+	#define PFERR_PRESENT_MASK (1U << PFERR_PRESENT_BIT)
+	#define PFERR_WRITE_MASK (1U << PFERR_WRITE_BIT)
+	#define PFERR_USER_MASK (1U << PFERR_USER_BIT)
+	#define PFERR_RSVD_MASK (1U << PFERR_RSVD_BIT) // MMIO fault
+	#define PFERR_FETCH_MASK (1U << PFERR_FETCH_BIT)
+	*/
+#endif
 
 	/* It is a write fault? */
 	error_code = exit_qualification & PFERR_WRITE_MASK;
 	/* It is a fetch fault? */
 	error_code |= (exit_qualification << 2) & PFERR_FETCH_MASK;
-	/* ept page table is present? */
+	/* ept page table is present? */ //PFERR_RSVD_MASK
 	error_code |= (exit_qualification >> 3) & PFERR_PRESENT_MASK;
 
 	vcpu->arch.exit_qualification = exit_qualification;
 
-	return kvm_mmu_page_fault(vcpu, gpa, error_code, NULL, 0);
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	if (distributed_process(current))
+		cnt++;
+
+	if ((distributed_process(current) && cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		// || (INTERESTED_GVA_MASK(gpa) == 0x1c75)
+		/* memcached - rarely happens */
+		) {
+		/* 1st thing BSP */
+		VMPRINTK("\t|| %s(): <%d> %llx #%lu/%d\n",
+			__func__, vcpu->vcpu_id, gpa, cnt, VM_SINGLE_HANDLE_DISPLAY_CNT);
+	}
+#endif
+
+	return kvm_mmu_page_fault(vcpu, gpa, error_code, NULL, 0, gla, exit_qualification);
 }
 
 static int handle_ept_misconfig(struct kvm_vcpu *vcpu)
@@ -5971,20 +6636,46 @@ static int handle_ept_misconfig(struct kvm_vcpu *vcpu)
 	int ret;
 	gpa_t gpa;
 
+#if defined(CONFIG_POPCORN_HYPE) && HYPEBOOTDEBUG
+	static unsigned long cnt = 0;
+	cnt++;
+	//if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+	if (distributed_process(current) && cnt > 0) {
+		MMIOPK("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+	}
+	/* TODO: I might not init here properly!!! */
+#endif
+
 	gpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);
 	if (!kvm_io_bus_write(vcpu, KVM_FAST_MMIO_BUS, gpa, 0, NULL)) {
+#if defined(CONFIG_POPCORN_HYPE) && HYPEBOOTDEBUG
+		printk("<%d> %s(): done by 0x%llu\n", vcpu->vcpu_id, __func__, gpa);
+#endif
 		skip_emulated_instruction(vcpu);
 		trace_kvm_fast_mmio(gpa);
 		return 1;
 	}
 
 	ret = handle_mmio_page_fault(vcpu, gpa, true);
+#if defined(CONFIG_POPCORN_HYPE) && HYPEBOOTDEBUG
+	MMIOPK("\t\t\t$$[%d] <%d> %s(): ret %d (see who fix it)\n",
+				current->pid, vcpu->vcpu_id, __func__, ret);
+	if (vcpu->vcpu_id == 1) {
+		printk("vcpu 1 mmio exit_reson %u %u %u(2) %llu vmx %llu\n",
+						vcpu->run->exit_reason,
+						vcpu->run->internal.suberror,
+						vcpu->run->internal.ndata,
+						vcpu->run->internal.data[0],
+						vcpu->run->internal.data[1]);
+		//dump_stack();
+	}
+#endif
 	if (likely(ret == RET_MMIO_PF_EMULATE))
 		return x86_emulate_instruction(vcpu, gpa, 0, NULL, 0) ==
 					      EMULATE_DONE;
 
 	if (unlikely(ret == RET_MMIO_PF_INVALID))
-		return kvm_mmu_page_fault(vcpu, gpa, 0, NULL, 0);
+		return kvm_mmu_page_fault(vcpu, gpa, 0, NULL, 0, 2, 2);
 
 	if (unlikely(ret == RET_MMIO_PF_RETRY))
 		return 1;
@@ -6002,6 +6693,13 @@ static int handle_nmi_window(struct kvm_vcpu *vcpu)
 {
 	u32 cpu_based_vm_exec_control;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
+
 	/* clear pending NMI */
 	cpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);
 	cpu_based_vm_exec_control &= ~CPU_BASED_VIRTUAL_NMI_PENDING;
@@ -6161,6 +6859,10 @@ static __init int hardware_setup(void)
 {
 	int r = -ENOMEM, i, msr;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	printk("%s %s(): (O) both nodes init HW vmx (ept...)\n",
+										__FILE__, __func__);
+#endif
 	rdmsrl_safe(MSR_EFER, &host_efer);
 
 	for (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i)
@@ -6240,14 +6942,39 @@ static __init int hardware_setup(void)
 	    !cpu_has_vmx_ept_4levels()) {
 		enable_ept = 0;
 		enable_unrestricted_guest = 0;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		printk("[ept]: [DISABLE] accessed and dirty flags for EPT\n");
+#endif
 		enable_ept_ad_bits = 0;
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (!cpu_has_vmx_ept_ad_bits()) {
+		printk("[ept]: [DISABLE] accessed and dirty flags for EPT\n");
+		enable_ept_ad_bits = 0;
+	}
+	printk("\n\n\n================= pophype =========================\n"
+			"Check Intel 28.2.4 Accessed and Dirty Flags for EPT\n");
+	printk("\t[ept]: accessed and dirty flags for EPT [%s]\n"
+			"======================================================\n\n\n",
+					enable_ept_ad_bits ? "ENABLE" : "DISABLE");
+#else
 	if (!cpu_has_vmx_ept_ad_bits())
 		enable_ept_ad_bits = 0;
+#endif
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	printk("%s(): Jack cpu_has_vmx_unrestricted_guest() %d enable_ept %d "
+			"enable_unrestricted_guest %d\n",
+			__func__, cpu_has_vmx_unrestricted_guest(), enable_ept,
+			enable_unrestricted_guest);
+#endif
 	if (!cpu_has_vmx_unrestricted_guest())
 		enable_unrestricted_guest = 0;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	printk("%s(): Jack enable_unrestricted_guest %d\n",
+					__func__, enable_unrestricted_guest);
+#endif
 
 	if (!cpu_has_vmx_flexpriority())
 		flexpriority_enabled = 0;
@@ -6320,6 +7047,10 @@ static __init int hardware_setup(void)
 	}
 
 	if (enable_ept) {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		printk("[ept] accessed and dirty flags for ept [%s]\n\n\n",
+					enable_ept_ad_bits ? "ENABLE" : "DISABLE");
+#endif
 		kvm_mmu_set_mask_ptes(0ull,
 			(enable_ept_ad_bits) ? VMX_EPT_ACCESS_BIT : 0ull,
 			(enable_ept_ad_bits) ? VMX_EPT_DIRTY_BIT : 0ull,
@@ -6394,6 +7125,13 @@ static __exit void hardware_unsetup(void)
  */
 static int handle_pause(struct kvm_vcpu *vcpu)
 {
+
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		VMPRINTK("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
 	if (ple_gap)
 		grow_ple_window(vcpu);
 
@@ -6411,6 +7149,13 @@ static int handle_nop(struct kvm_vcpu *vcpu)
 
 static int handle_mwait(struct kvm_vcpu *vcpu)
 {
+
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
 	printk_once(KERN_WARNING "kvm: MWAIT instruction emulated as NOP!\n");
 	return handle_nop(vcpu);
 }
@@ -6788,6 +7533,13 @@ static int handle_vmon(struct kvm_vcpu *vcpu)
 	const u64 VMXON_NEEDED_FEATURES = FEATURE_CONTROL_LOCKED
 		| FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
+
 	/* The Intel VMX Instruction Reference lists a bunch of bits that
 	 * are prerequisite to running VMXON, most notably cr4.VMXE must be
 	 * set to 1 (see vmx_set_cr4() for when we allow the guest to set this).
@@ -6942,6 +7694,12 @@ static void free_nested(struct vcpu_vmx *vmx)
 /* Emulate the VMXOFF instruction */
 static int handle_vmoff(struct kvm_vcpu *vcpu)
 {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
 	if (!nested_vmx_check_permission(vcpu))
 		return 1;
 	free_nested(to_vmx(vcpu));
@@ -6956,6 +7714,12 @@ static int handle_vmclear(struct kvm_vcpu *vcpu)
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
 	u32 zero = 0;
 	gpa_t vmptr;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
 
 	if (!nested_vmx_check_permission(vcpu))
 		return 1;
@@ -6982,12 +7746,24 @@ static int nested_vmx_run(struct kvm_vcpu *vcpu, bool launch);
 /* Emulate the VMLAUNCH instruction */
 static int handle_vmlaunch(struct kvm_vcpu *vcpu)
 {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
 	return nested_vmx_run(vcpu, true);
 }
 
 /* Emulate the VMRESUME instruction */
 static int handle_vmresume(struct kvm_vcpu *vcpu)
 {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
 
 	return nested_vmx_run(vcpu, false);
 }
@@ -7185,6 +7961,12 @@ static int handle_vmread(struct kvm_vcpu *vcpu)
 	unsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
 	u32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);
 	gva_t gva = 0;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
 
 	if (!nested_vmx_check_permission(vcpu) ||
 	    !nested_vmx_check_vmcs12(vcpu))
@@ -7236,6 +8018,13 @@ static int handle_vmwrite(struct kvm_vcpu *vcpu)
 	u64 field_value = 0;
 	struct x86_exception e;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
+
 	if (!nested_vmx_check_permission(vcpu) ||
 	    !nested_vmx_check_vmcs12(vcpu))
 		return 1;
@@ -7279,6 +8068,12 @@ static int handle_vmptrld(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
 	gpa_t vmptr;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
 
 	if (!nested_vmx_check_permission(vcpu))
 		return 1;
@@ -7330,6 +8125,12 @@ static int handle_vmptrst(struct kvm_vcpu *vcpu)
 	u32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);
 	gva_t vmcs_gva;
 	struct x86_exception e;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
 
 	if (!nested_vmx_check_permission(vcpu))
 		return 1;
@@ -7349,6 +8150,7 @@ static int handle_vmptrst(struct kvm_vcpu *vcpu)
 	return 1;
 }
 
+/* VMX-specific TLB-management instructions: INVEPT, INVVPID */
 /* Emulate the INVEPT instruction */
 static int handle_invept(struct kvm_vcpu *vcpu)
 {
@@ -7360,6 +8162,10 @@ static int handle_invept(struct kvm_vcpu *vcpu)
 	struct {
 		u64 eptp, gpa;
 	} operand;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+#endif
+
 
 	if (!(vmx->nested.nested_vmx_secondary_ctls_high &
 	      SECONDARY_EXEC_ENABLE_EPT) ||
@@ -7400,6 +8206,17 @@ static int handle_invept(struct kvm_vcpu *vcpu)
 		return 1;
 	}
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	/* good */
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> gva %lx inv cached EPT "
+				"maapings in the processor "
+				"to synchronize address translation in VM "
+					"with memory-resident EPT pages. #%lu\n",
+								__func__, vcpu->vcpu_id, gva, cnt);
+#endif
+
 	switch (type) {
 	case VMX_EPT_EXTENT_GLOBAL:
 		kvm_mmu_sync_roots(vcpu);
@@ -7425,6 +8242,15 @@ static int handle_invvpid(struct kvm_vcpu *vcpu)
 	struct x86_exception e;
 	int vpid;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> inv cached mappings of "
+			"address translation based on the VPID #%lu\n",
+								__func__, vcpu->vcpu_id, cnt);
+#endif
+
 	if (!(vmx->nested.nested_vmx_secondary_ctls_high &
 	      SECONDARY_EXEC_ENABLE_VPID) ||
 			!(vmx->nested.nested_vmx_vpid_caps & VMX_VPID_INVVPID_BIT)) {
@@ -7490,6 +8316,13 @@ static int handle_pml_full(struct kvm_vcpu *vcpu)
 {
 	unsigned long exit_qualification;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+		printk("\t\t|| %s(): <%d> #%lu\n", __func__, vcpu->vcpu_id, cnt);
+#endif
+
 	trace_kvm_pml_full(vcpu->vcpu_id);
 
 	exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
@@ -7960,6 +8793,78 @@ static void vmx_dump_dtsel(char *name, uint32_t limit)
 	       vmcs_readl(limit + GUEST_GDTR_BASE - GUEST_GDTR_LIMIT));
 }
 
+#ifdef CONFIG_POPCORN_STAT
+static unsigned long get_kvm_eptfault_new_ns(void)
+{
+	return atomic64_read(&kvm_eptfault_new_ns);
+}
+
+static unsigned long get_kvm_eptfault_new_cnt(void)
+{
+	return atomic64_read(&kvm_eptfault_new_cnt);
+}
+
+static unsigned long get_user_gva_cnt(void)
+{
+	return atomic64_read(&user_gva_cnt);
+}
+static unsigned long get_kernel_gva_cnt(void)
+{
+	return atomic64_read(&kernel_gva_cnt);
+}
+static unsigned long get_unknow_gva_cnt(void)
+{
+	return atomic64_read(&unknow_gva_cnt);
+}
+static unsigned long get_wrong_validity_gva_cnt(void)
+{
+	return atomic64_read(&wrong_validity_gva_cnt);
+}
+static unsigned long get_gva_ret_kernelspace_cnt(void)
+{
+	return atomic64_read(&gva_ret_kernelspace_cnt);
+}
+static unsigned long get_gva_ret_userspace_cnt(void)
+{
+	return atomic64_read(&gva_ret_userspace_cnt);
+}
+
+static void set_kvm_eptfault_new_ns(u64 data)
+{
+	atomic64_set(&kvm_eptfault_new_ns, data);
+}
+
+static void set_kvm_eptfault_new_cnt(u64 data)
+{
+	atomic64_set(&kvm_eptfault_new_cnt, data);
+}
+
+static void set_user_gva_cnt(u64 data)
+{
+	atomic64_set(&user_gva_cnt, data);
+}
+static void set_kernel_gva_cnt(u64 data)
+{
+	atomic64_set(&kernel_gva_cnt, data);
+}
+static void set_unknow_gva_cnt(u64 data)
+{
+	atomic64_set(&unknow_gva_cnt, data);
+}
+static void set_wrong_validity_gva_cnt(u64 data)
+{
+	atomic64_set(&wrong_validity_gva_cnt, data);
+}
+static void set_gva_ret_kernelspace_cnt(u64 data)
+{
+	atomic64_set(&gva_ret_kernelspace_cnt, data);
+}
+static void set_gva_ret_userspace_cnt(u64 data)
+{
+	atomic64_set(&gva_ret_userspace_cnt, data);
+}
+#endif
+
 static void dump_vmcs(void)
 {
 	u32 vmentry_ctl = vmcs_read32(VM_ENTRY_CONTROLS);
@@ -8099,10 +9004,99 @@ static void dump_vmcs(void)
 		       vmcs_read16(VIRTUAL_PROCESSOR_ID));
 }
 
+#ifdef CONFIG_POPCORN_HYPE
+static void pophype_check_vmcs(struct kvm_vcpu *vcpu)
+{
+#if POPHYPE_MIGRATE_DEBUG
+	struct vcpu_vmx *vmx = to_vmx(vcpu);
+	PHMIGRATEPRINTK("\n\n\n\n\n"
+			"-------- %s vmx info start <%d> smp_processor_id() %d -------\n",
+									__func__, vcpu->vcpu_id, smp_processor_id());
+	PHMIGRATEPRINTK("\t\t ------- vmx (in-kernel cache) -----\n");
+	PHMIGRATEPRINTK("TODO\n");
+
+
+	PHMIGRATEPRINTK("\t\t ------ vmx->loaded_vmcs ------\n");
+	PHMIGRATEPRINTK("\t vmx->loaded_vmcs %p ?= &vmx->vmcs01 %p\n",
+							vmx->loaded_vmcs, &vmx->vmcs01);
+	PHMIGRATEPRINTK("\t [vmx] vmx->vmcs01.cpu %d TODO\n", vmx->vmcs01.cpu);
+	PHMIGRATEPRINTK("\t [vmx] vmx->vmcs01.launched %d TODO (set when vm_exit?)\n", vmx->vmcs01.launched);
+	PHMIGRATEPRINTK("\t vmx->loaded_vmcs->cpu %d\n", vmx->loaded_vmcs->cpu);
+	PHMIGRATEPRINTK("\t vmx->loaded_vmcs->vmcs %p\n", vmx->loaded_vmcs->vmcs);
+	PHMIGRATEPRINTK("\t vmx->loaded_vmcs->launched %d\n", vmx->loaded_vmcs->launched);
+	PHMIGRATEPRINTK("\t [R] vmx->__launched %c\n", vmx->__launched ? 'O' : 'X');
+
+	/* vmx_vcpu_run */
+	PHMIGRATEPRINTK("[phmigrate] vmx->ple_window_dirty %u TODO vmx->ple_window %u\n",
+								vmx->ple_window_dirty, vmx->ple_window);
+	PHMIGRATEPRINTK("[phmigrate] vmx->host_state.vmcs_host_cr4 0x%lx same "
+			"(will be overwritten by using host cpu's cr4)\n", vmx->host_state.vmcs_host_cr4);
+	//vcpu->arch.regs[VCPU_REGS_RSP]
+	/* vmx_vcpu_run asm load */
+	PHMIGRATEPRINTK("[phmigrate] vmx->fail %u\n", vmx->fail);
+	PHMIGRATEPRINTK("[phmigrate] vmx->nested.sync_shadow_vmcs %u\n", vmx->nested.sync_shadow_vmcs);
+	PHMIGRATEPRINTK("[phmigrate] vmx->host_rsp 0x%lx TODO\n", vmx->host_rsp);
+
+
+
+	PHMIGRATEPRINTK("----0621----\n");
+	PHMIGRATEPRINTK("\t Jack vmx->idt_vectoring_info %d\n", vmx->idt_vectoring_info);
+	PHMIGRATEPRINTK("----0622----\n");
+	PHMIGRATEPRINTK("[ck][diff][efer] vmcs_readl(GUEST_IA32_EFER); %lx\n", vmcs_readl(GUEST_IA32_EFER));
+	PHMIGRATEPRINTK("----0622----\n");
+	PHMIGRATEPRINTK("<%d> %s(): vcpu->arch.mp_state %d (expect 0)\n",
+				vcpu->vcpu_id, __func__, vcpu->arch.mp_state);
+
+	//PHMIGRATEPRINTK("\t\t ---- checking now since different between nodes ---\n");
+	//PHMIGRATEPRINTK("%s(): kvm_lapic_enabled %d (!=)\n",
+	//			__func__, kvm_lapic_enabled(vcpu));     /// WRONG COMPILER
+
+
+	PHMIGRATEPRINTK("\n\n\n------ [diff !=!=!=!=!=!=!=!] VMCS  (check if in msg) ------\n");
+	PHMIGRATEPRINTK("InterruptStatus = %04x\n",
+		       vmcs_read16(GUEST_INTR_STATUS));
+
+	/* vmx_dump_sel */
+	vmx_dump_sel("DS:  ", GUEST_DS_SELECTOR);
+	vmx_dump_sel("ES:  ", GUEST_ES_SELECTOR);
+	vmx_dump_sel("GS:  ", GUEST_GS_SELECTOR);
+	vmx_dump_sel("LDTR:", GUEST_LDTR_SELECTOR);
+
+	PHMIGRATEPRINTK("VMEntry: intr_info=%08x errcode=%08x ilen=%08x\n",
+	       vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),
+	       vmcs_read32(VM_ENTRY_EXCEPTION_ERROR_CODE),
+	       vmcs_read32(VM_ENTRY_INSTRUCTION_LEN));
+	PHMIGRATEPRINTK("VMExit: intr_info=%08x errcode=%08x ilen=%08x\n",
+	       vmcs_read32(VM_EXIT_INTR_INFO),
+	       vmcs_read32(VM_EXIT_INTR_ERROR_CODE),
+	       vmcs_read32(VM_EXIT_INSTRUCTION_LEN));
+	PHMIGRATEPRINTK("        reason=%08x qualification=%016lx\n",
+	       vmcs_read32(VM_EXIT_REASON), vmcs_readl(EXIT_QUALIFICATION));
+	PHMIGRATEPRINTK("TSC Offset = 0x%016lx\n", vmcs_readl(TSC_OFFSET));
+	PHMIGRATEPRINTK("EPT pointer = 0x%016lx (cr3, eptp)\n", vmcs_readl(EPT_POINTER));
+	PHMIGRATEPRINTK("------ [diff !=!=!=!=!=!=!=!] VMCS  (check if in msg) end ------\n\n");
+/*
+[  573.292149] VMEntry: intr_info=00000000 errcode=00000014 ilen=00000000
+[  573.298823] VMExit: intr_info=00000000 errcode=00000000 ilen=00000003
+[  573.305409]         reason=00000012 qualification=0000000000000000
+...
+[  573.317192] TSC Offset = 0xffffd9992cb2a064
+...
+[  573.332923] EPT pointer = 0x00000017789b501e
+*/
+
+	PHMIGRATEPRINTK("-------- %s() vmx info end <%d> smp_processor_id() %d -------\n\n",
+									__func__, vcpu->vcpu_id, smp_processor_id());
+	PHMIGRATEPRINTK("\n\n\n\n\n\n");
+#endif
+}
+#endif
+
 /*
  * The guest has exited.  See if we can fix it or if we need userspace
  * assistance.
  */
+/* From arch/x86/kvm/x86.c vcpu_enter_guest() */
 static int vmx_handle_exit(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
@@ -8137,6 +9131,22 @@ static int vmx_handle_exit(struct kvm_vcpu *vcpu)
 		vcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;
 		vcpu->run->fail_entry.hardware_entry_failure_reason
 			= exit_reason;
+#if defined(CONFIG_POPCORN_HYPE) //&& defined(CONFIG_POPCORN_STAT)
+		printk("\n\n\n"
+				"========================\n"
+				"============================\n"
+				"================================\n"
+				"======================================\n"
+				"================================================\n"
+				"pophype: [back_migrate not happen] <%d> reason 0x%llx\n"
+				"================================================\n"
+				"======================================\n"
+				"================================\n"
+				"============================\n"
+				"========================\n\n\n",
+				vcpu->vcpu_id,
+				vcpu->run->fail_entry.hardware_entry_failure_reason);
+#endif
 		return 0;
 	}
 
@@ -8144,6 +9154,12 @@ static int vmx_handle_exit(struct kvm_vcpu *vcpu)
 		vcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;
 		vcpu->run->fail_entry.hardware_entry_failure_reason
 			= vmcs_read32(VM_INSTRUCTION_ERROR);
+#if defined(CONFIG_POPCORN_HYPE) //&& defined(CONFIG_POPCORN_STAT)
+		printk("[back_migrate BUG] <%d> vmx->fail %d "
+				"vmvmcs_read32(VM_INSTRUCTION_ERROR) 0x%llx\n",
+				vcpu->vcpu_id, vmx->fail,
+				vcpu->run->fail_entry.hardware_entry_failure_reason);
+#endif
 		return 0;
 	}
 
@@ -8159,6 +9175,14 @@ static int vmx_handle_exit(struct kvm_vcpu *vcpu)
 			exit_reason != EXIT_REASON_EPT_VIOLATION &&
 			exit_reason != EXIT_REASON_PML_FULL &&
 			exit_reason != EXIT_REASON_TASK_SWITCH)) {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		static unsigned long deliver_ev_cnt = 0;
+		deliver_ev_cnt++;
+		if (deliver_ev_cnt < VM_SINGLE_HANDLE_DISPLAY_CNT)
+			printk("%s(): <%d> What makes 17?? deliver_ev vmx->reason %u "
+					"vector (%s)\n", __func__, vcpu->vcpu_id, exit_reason,
+					(vectoring_info & VECTORING_INFO_VALID_MASK)?"O":"X");
+#endif
 		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
 		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;
 		vcpu->run->internal.ndata = 2;
@@ -8188,9 +9212,82 @@ static int vmx_handle_exit(struct kvm_vcpu *vcpu)
 	}
 
 	if (exit_reason < kvm_vmx_max_exit_handlers
-	    && kvm_vmx_exit_handlers[exit_reason])
-		return kvm_vmx_exit_handlers[exit_reason](vcpu);
-	else {
+	    && kvm_vmx_exit_handlers[exit_reason]) {
+		int ret;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		ktime_t dt, kvm_eptfault_end, kvm_eptfault_start;
+		if (exit_reason == EXIT_REASON_EPT_VIOLATION) {
+			kvm_eptfault_start = ktime_get();
+		}
+#endif
+		ret = kvm_vmx_exit_handlers[exit_reason](vcpu);
+							/* e.g. handle_ept_violation */
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		if (exit_reason == EXIT_REASON_EPT_VIOLATION) {
+			/* EXIT_REASON_EPT_VIOLATION's ret = emulate */
+			kvm_eptfault_end = ktime_get();
+			dt = ktime_sub(kvm_eptfault_end, kvm_eptfault_start);
+			atomic64_add(ktime_to_ns(dt), &kvm_eptfault_new_ns);
+			atomic64_inc(&kvm_eptfault_new_cnt);
+
+			{	/* Making it also the best place to probe */
+				unsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
+				//unsigned long rip = kvm_rip_read(vcpu); // where touch the gla
+				int gla_validity;
+				gla_validity = (exit_qualification >> 7) & 0x3;
+				if (gla_validity == 0x3 || gla_validity == 0x1
+										|| gla_validity == 0) {
+					if (gla_validity & 0x1) { // ept page table present
+						gpa_t gla = vmcs_readl(GUEST_LINEAR_ADDRESS); // check Table 27-7 Intel manual // cr2
+						/* ./Documentation/x86/x86_64/mm.txt */
+						if (gla > 0x0000000000000000 && gla < 0x00007fffffffffff) {
+							atomic64_inc(&user_gva_cnt);
+						} else if (gla > 0xffff800000000000) {
+							atomic64_inc(&kernel_gva_cnt);
+						} else {
+							atomic64_inc(&unknow_gva_cnt);
+						}
+						
+						/* Returns 1: stay in the host kernel
+									0: return to the host userspace. */
+						if (ret) { // gva_ret_kernelspace_cnt
+							atomic64_inc(&gva_ret_kernelspace_cnt);
+						} else { // gva_ret_userspace_cnt
+							atomic64_inc(&gva_ret_userspace_cnt);
+						}
+					} else { // ept page table not present
+						/* especially 0x3 & 0x0 */
+						atomic64_inc(&wrong_validity_gva_cnt);
+					}
+				}
+			}
+		}
+#endif
+#if HYPE_PERF_CRITICAL_DEBUG
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		if (exit_reason == EXIT_REASON_EXCEPTION_NMI)
+			printk("[%d] handle_exception(): ret %d\n", current->pid, ret);
+
+		/* handle ret and exit_reason outside */
+		/*
+		// r = kvm_x86_ops->handle_exit(vcpu); (./arch/x86/kvm/x86.c)
+		// | r = vcpu_enter_guest(vcpu);
+				while (1) {
+					if (r <= 0)
+						break;
+				}
+				return r;
+			Returns 1 to let vcpu_run() continue the guest execution loop without
+			exiting to the userspace.  Otherwise, the value will be returned to the
+			userspace.
+		//  | r = vcpu_run(vcpu); (arch/x86/kvm/x86.c)
+		//   | r = kvm_arch_vcpu_ioctl_run(vcpu, vcpu->run); (virt/kvm/kvm_main.c)
+		// exit_reason: #define EXIT_REASON_POPHYPE_MIGRATE     78
+		*/
+#endif
+#endif
+		return ret;
+	} else {
 		WARN_ONCE(1, "vmx: unexpected exit reason 0x%x\n", exit_reason);
 		kvm_queue_exception(vcpu, UD_VECTOR);
 		return 1;
@@ -8562,11 +9659,64 @@ static void atomic_switch_perf_msrs(struct vcpu_vmx *vmx)
 					msrs[i].host);
 }
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+//static unsigned long io_exit_cnt = 0;
+static unsigned long exit_ext_int_cnt[MAX_POPCORN_NODES] = {0};
+static unsigned long enter_ext_int_cnt[MAX_POPCORN_NODES] = {0};
+static unsigned long exit_ept_cnt[MAX_POPCORN_NODES] = {0};
+static unsigned long enter_ept_cnt[MAX_POPCORN_NODES] = {0};
+static unsigned long exit_io_ist_cnt[MAX_POPCORN_NODES] = {0};
+static unsigned long enter_io_ist_cnt[MAX_POPCORN_NODES] = {0};
+static unsigned long exit_cpuid_cnt[MAX_POPCORN_NODES] = {0};
+static unsigned long enter_cpuid_cnt[MAX_POPCORN_NODES] = {0};
+static unsigned long exit_dr_cnt[MAX_POPCORN_NODES] = {0};
+static unsigned long enter_dr_cnt[MAX_POPCORN_NODES] = {0};
+static unsigned long exit_pinst_cnt[MAX_POPCORN_NODES] = {0};
+static unsigned long enter_pinst_cnt[MAX_POPCORN_NODES] = {0};
+//EXIT_REASON_IO_INSTRUCTION
+#endif
 static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
 	unsigned long debugctlmsr, cr4;
 
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	//static int first[32] = 1; /* TODO MAX_VCPU*/
+	static int first[4] = {1, 1, 1, 1}; /* TODO MAX_VCPU*/
+	static int first_ckpt1[4] = {1, 1, 1, 1}; /* TODO MAX_VCPU*/
+	static int first_exit[4] = {1, 1, 1, 1}; /* TODO MAX_VCPU*/
+
+	HPPRINTK("<%d> %s: 6 (too verbose)\n", current->pid, __func__);
+#endif
+
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	if (first_ckpt1[vcpu->vcpu_id]) { /* first check after vm exit */
+		first_ckpt1[vcpu->vcpu_id] = 0;
+		printk("--------------------------------------------------------\n");
+		printk("--------------------------------------------------------\n");
+		printk("-------- <%d> %s %s(): first_ckpt1 start --------\n",
+					vcpu->vcpu_id, __FILE__, __func__);
+		printk("--------------------------------------------------------\n");
+		printk("--------------------------------------------------------\n");
+		printk("vmx->emulation_required %d\n", vmx->emulation_required);
+		printk("vmx->ple_window_dirty %d\n", vmx->ple_window_dirty);
+		printk("vmx->nested.sync_shadow_vmcs %d\n", vmx->nested.sync_shadow_vmcs);
+		printk("test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty) %d\n",
+				test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty));
+		printk("test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty) %d\n",
+				test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty));
+		printk("cr4 != vmx->host_state.vmcs_host_cr4 %d\n", cr4_read_shadow() != vmx->host_state.vmcs_host_cr4);
+		printk("vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP %lx\n", vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP);
+		printk("--------------------------------------------------------\n");
+		printk("--------------------------------------------------------\n");
+		printk("----------- <%d> %s %s(): first_ckpt1 end -----------\n",
+							vcpu->vcpu_id, __FILE__, __func__);
+		printk("--------------------------------------------------------\n");
+		printk("--------------------------------------------------------\n");
+		printk("\n\n");
+	}
+#endif
+
 	/* Record the guest's net vcpu time for enforced NMI injections. */
 	if (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))
 		vmx->entry_time = ktime_get();
@@ -8596,6 +9746,72 @@ static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)
 		vmcs_writel(HOST_CR4, cr4);
 		vmx->host_state.vmcs_host_cr4 = cr4;
 	}
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	if (vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI) { // 0
+		VMPRINTK("\t[%d] %s(): %s<%d>%s vmx->exit %u "
+					"re-enter EXT_INT#%lu EPT#%lu IO_IST#%lu CPUID#%lu\n",
+					current->pid, __func__,
+					vcpu->vcpu_id ? "**":"",
+					vcpu->vcpu_id ? 1:0,
+					vcpu->vcpu_id ? "**":"",
+					vmx->exit_reason, enter_ext_int_cnt[vcpu->vcpu_id],
+					enter_ept_cnt[vcpu->vcpu_id],
+					enter_io_ist_cnt[vcpu->vcpu_id],
+					enter_cpuid_cnt[vcpu->vcpu_id]);
+	} else {
+		if (!current->mm->remote) {
+			if (vmx->exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT) { //1
+				enter_ext_int_cnt[vcpu->vcpu_id]++;
+				//dump_stack();
+			} else if (vmx->exit_reason == EXIT_REASON_EPT_VIOLATION) { // 48
+				enter_ept_cnt[vcpu->vcpu_id]++;
+				if (enter_ept_cnt[vcpu->vcpu_id] < VM_SINGLE_HANDLE_DISPLAY_CNT) // only show 3
+					goto show;
+			} else if (vmx->exit_reason == EXIT_REASON_IO_INSTRUCTION) {
+				enter_io_ist_cnt[vcpu->vcpu_id]++;
+			} else if (vmx->exit_reason == EXIT_REASON_CPUID) { // 10
+				enter_cpuid_cnt[vcpu->vcpu_id]++;
+			} else if (vmx->exit_reason == EXIT_REASON_DR_ACCESS) { // 29
+				enter_dr_cnt[vcpu->vcpu_id]++;
+			} else if (vmx->exit_reason == EXIT_REASON_PENDING_INTERRUPT) { // 7
+			} else if (vmx->exit_reason == EXIT_REASON_APIC_ACCESS) { // 44
+			} else if (vmx->exit_reason == EXIT_REASON_CR_ACCESS) { // 28
+			} else if (vmx->exit_reason == EXIT_REASON_MSR_READ) { // 31
+			} else if (vmx->exit_reason == EXIT_REASON_APIC_WRITE) { // 56
+			} else if (vmx->exit_reason == EXIT_REASON_HLT) { // 12
+			} else if (vmx->exit_reason == EXIT_REASON_PAUSE_INSTRUCTION) { // 40 (before AP boots)
+				enter_pinst_cnt[vcpu->vcpu_id]++;
+			} else {
+show:
+				VMPRINTK("\t[%d] %s(): %s<%d>%s vmx->exit %u "
+						"re-enter EXT_INT#%lu EPT#%lu "
+						"IO_IST#%lu CPUID#%lu PINST#%lu\n",
+							current->pid, __func__,
+							vcpu->vcpu_id ? "**":"",
+							vcpu->vcpu_id ? 1:0,
+							vcpu->vcpu_id ? "**":"",
+						vmx->exit_reason, enter_ext_int_cnt[vcpu->vcpu_id],
+					enter_ept_cnt[vcpu->vcpu_id], enter_io_ist_cnt[vcpu->vcpu_id],
+					enter_cpuid_cnt[vcpu->vcpu_id], enter_pinst_cnt[vcpu->vcpu_id]);
+			}
+		} else {
+			/* popcorn - any first VM_SINGLE_HANDLE_DISPLAY_CNT */
+			//if (current->at_remote) {
+				static unsigned long remote_enter_vmx_reason = 0;
+				remote_enter_vmx_reason++;
+				if ((remote_enter_vmx_reason < 30)
+						|| (remote_enter_vmx_reason > 2200 &&
+							remote_enter_vmx_reason < 2300)) {
+					//printk("\t[%d] %s(): <%d><remote> re-entering "
+					VMPRINTK("\t[%d] %s(): <%d> re-enter "
+							"vmx->exit %d #%lu\n",
+							current->pid, __func__, vcpu->vcpu_id,
+							vmx->exit_reason, remote_enter_vmx_reason);
+				}
+			//}
+		}
+	}
+#endif
 
 	/* When single-stepping over STI and MOV SS, we must clear the
 	 * corresponding interruptibility bits in the guest state. Otherwise
@@ -8608,6 +9824,56 @@ static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)
 	atomic_switch_perf_msrs(vmx);
 	debugctlmsr = get_debugctlmsr();
 
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	if (first[vcpu->vcpu_id]) { /* final check beore vm entry */
+	//if (first && vcpu->vcpu_id) { /* final check beore vm entry */
+		//first = 0;
+		first[vcpu->vcpu_id] = 0;
+		{ int z;
+			printk("\n\n\n\n\n\n\n");
+			printk("====================================================\n");
+			printk("====================================================\n");
+			printk("n=====[debug] <%d> %s %s(): "
+					"last check before 1st vm-entry start [debug]=====\n",
+					vcpu->vcpu_id, __FILE__, __func__);
+			printk("====================================================\n");
+			printk("====================================================\n");
+			for (z = 0; z < 10; z++) {
+				printk("--- last check before 1st vm-entry start - vcpu_run vcpu <%d> %p vcpu->cpu %d "
+						"smp_processor_id %d vmx %p ---\n",
+						vcpu->vcpu_id, vcpu, vcpu->cpu, smp_processor_id(), vmx);
+			}
+			printk("============[debug] last check before 1st vm-entry start [debug]=================\n\n");
+		}
+		printk("[pophypemigrate] ****** <%d> vcpu->run->apic_base %llx ******\n", vcpu->vcpu_id, vcpu->run->apic_base);
+		if (vcpu->vcpu_id && !my_nid && !vcpu->run->apic_base) {
+			printk("HACK HACK HACK[[ophypemigrate] ****** <%d> vcpu->run->apic_base %llx ******\n", vcpu->vcpu_id, vcpu->run->apic_base);
+			vcpu->run->apic_base = 0xfee00800;
+		}
+		printk("[pophypemigrate] ****** <%d> vcpu->run->apic_base %llx ******\n", vcpu->vcpu_id, vcpu->run->apic_base);
+		printk("[ck]:[diff][efer] vcpu->arch.efer %llx\n", vcpu->arch.efer);
+		pophype_check_vmcs(vcpu);
+		PHMIGRATEPRINTK("\n-------------- last check before 1st VMENTRY dump_vmcs <%d> start ---------------\n", vcpu->vcpu_id);
+		dump_vmcs();
+		PHMIGRATEPRINTK("-------------- last check before 1st VMENTRY dump_vmcs <%d> end ---------------\n\n", vcpu->vcpu_id);
+		{ int z;
+			for (z = 0; z < 10; z++) {
+				printk("%s(): vcpu_run vcpu <%d> vcpu->cpu %d RUN!!! "
+						"in_atomic(): %d smp_processor_id %d end\n", __func__,
+						vcpu->vcpu_id, vcpu->cpu, in_atomic(), smp_processor_id());
+			}
+			printk("====================================================\n");
+			printk("====================================================\n");
+			printk("=======[debug] last check before vm-entry end [debug]======\n");
+			printk("====================================================\n");
+			printk("====================================================\n");
+			printk("\n\n\n");
+
+		}
+	}
+
+	/* save host info. load vmcs guest reg. */
+#endif
 	vmx->__launched = vmx->loaded_vmcs->launched;
 	asm(
 		/* Store host registers */
@@ -8726,6 +9992,7 @@ static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)
 #endif
 	      );
 
+
 	/* Eliminate branch target predictions from guest mode */
 	vmexit_fill_RSB();
 
@@ -8759,6 +10026,71 @@ static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)
 
 	vmx->exit_reason = vmcs_read32(VM_EXIT_REASON);
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+///////////////////////////////////////////////////////////////
+	BUG_ON(distributed_remote_process(current) &&
+						vcpu->vcpu_id && !my_nid);
+///////////////////////////////////////////////////////////////
+	if (!current->mm->remote) {
+		if (vmx->exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT) { //1
+			exit_ext_int_cnt[vcpu->vcpu_id]++;
+			//dump_stack();
+		} else if (vmx->exit_reason == EXIT_REASON_EPT_VIOLATION) {
+			exit_ept_cnt[vcpu->vcpu_id]++;
+			if (exit_ept_cnt[vcpu->vcpu_id] < 10)
+				goto show_exit;
+		} else if (vmx->exit_reason == EXIT_REASON_IO_INSTRUCTION) {
+			exit_io_ist_cnt[vcpu->vcpu_id]++;
+		} else if (vmx->exit_reason == EXIT_REASON_CPUID) {
+			exit_cpuid_cnt[vcpu->vcpu_id]++;
+		} else if (vmx->exit_reason == EXIT_REASON_DR_ACCESS) { // 29
+			exit_dr_cnt[vcpu->vcpu_id]++;
+		} else if (vmx->exit_reason == EXIT_REASON_PENDING_INTERRUPT) { // 7
+		} else if (vmx->exit_reason == EXIT_REASON_APIC_ACCESS) { // 44
+		} else if (vmx->exit_reason == EXIT_REASON_CR_ACCESS) { // 28
+		} else if (vmx->exit_reason == EXIT_REASON_MSR_READ) { // 31
+		} else if (vmx->exit_reason == EXIT_REASON_APIC_WRITE) { // 56
+		} else if (vmx->exit_reason == EXIT_REASON_HLT) { // 12
+		} else if (vmx->exit_reason == EXIT_REASON_PAUSE_INSTRUCTION) { // 40 (before AP boots)
+			exit_pinst_cnt[vcpu->vcpu_id]++;
+		} else {
+show_exit:
+			VMPRINTK("\t[%d] %s(): %s<%d>%s vmx->exit %u "
+						"exit EXT_INT#%lu EPT#%lu IO_IST#%lu "
+						"CPUID#%lu PINST#%lu\n",
+						current->pid, __func__,
+						vcpu->vcpu_id ? "**":"",
+						vcpu->vcpu_id ? 1:0,
+						vcpu->vcpu_id ? "**":"",
+						vmx->exit_reason, exit_ext_int_cnt[vcpu->vcpu_id],
+						exit_ept_cnt[vcpu->vcpu_id],
+						exit_io_ist_cnt[vcpu->vcpu_id],
+						exit_cpuid_cnt[vcpu->vcpu_id],
+						exit_pinst_cnt[vcpu->vcpu_id]);
+		}
+	} else {
+			/* popcorn - any first VM_SINGLE_HANDLE_DISPLAY_CNT at remote */
+		if (current->at_remote) {
+			static unsigned long remote_exit_vmx_reason = 0;
+			remote_exit_vmx_reason++;
+			if (remote_exit_vmx_reason < VM_ALL_HANDLE_DISPLAY_CNT)
+				VMPRINTK("\t[%d] %s(): <%d><remote> exit vmx->exit_reason %u "
+						"first#%lu\n",
+						current->pid, __func__, vcpu->vcpu_id,
+						vmx->exit_reason, remote_exit_vmx_reason);
+		}
+	}
+#endif
+
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	if (first_exit[vcpu->vcpu_id]) { /* first check after vm exit */
+		first_exit[vcpu->vcpu_id] = 0;
+		PHMIGRATEPRINTK("\n-------------- after 1st VMEXIT check dump_vmcs <%d> start ---------------\n", vcpu->vcpu_id);
+		dump_vmcs();
+		PHMIGRATEPRINTK("-------------- after 1st VMEXIT check dump_vmcs <%d> end ---------------\n\n", vcpu->vcpu_id);
+	}
+#endif
+
 	/*
 	 * the KVM_REQ_EVENT optimization bit is only on for one entry, and if
 	 * we did not inject a still-pending event to L1 now because of
@@ -8832,7 +10164,12 @@ static struct kvm_vcpu *vmx_create_vcpu(struct kvm *kvm, unsigned int id)
 
 	vmx->vpid = allocate_vpid();
 
-	err = kvm_vcpu_init(&vmx->vcpu, kvm, id);
+#if defined(CONFIG_POPCORN_HYPE) //&& defined(CONFIG_POPCORN_STAT)
+	VCPUPRINTK("%s: vcpu_vmx(vmx) %p (per-cpu) -> vcpu %p & "
+				"->vpid %d (vcpu id from 1)\n",
+				__func__, vmx, &vmx->vcpu, vmx->vpid);
+#endif
+	err = kvm_vcpu_init(&vmx->vcpu, kvm, id); /* lots in-kernel states */
 	if (err)
 		goto free_vcpu;
 
@@ -8845,11 +10182,17 @@ static struct kvm_vcpu *vmx_create_vcpu(struct kvm *kvm, unsigned int id)
 	 * for the guest, etc.
 	 */
 	if (enable_pml) {
+#if defined(CONFIG_POPCORN_HYPE) //&& defined(CONFIG_POPCORN_STAT)
+		HPPRINTK("[arch] %s: enable_pml ON\n", __func__);
+#endif
 		vmx->pml_pg = alloc_page(GFP_KERNEL | __GFP_ZERO);
 		if (!vmx->pml_pg)
 			goto uninit_vcpu;
 	}
 
+#if defined(CONFIG_POPCORN_HYPE) //&& defined(CONFIG_POPCORN_STAT)
+	HPPRINTK("%s: vmx->guest_msrs\n", __func__);
+#endif
 	vmx->guest_msrs = kmalloc(PAGE_SIZE, GFP_KERNEL);
 	BUILD_BUG_ON(ARRAY_SIZE(vmx_msr_index) * sizeof(vmx->guest_msrs[0])
 		     > PAGE_SIZE);
@@ -8873,15 +10216,26 @@ static struct kvm_vcpu *vmx_create_vcpu(struct kvm *kvm, unsigned int id)
 	err = vmx_vcpu_setup(vmx);
 	vmx_vcpu_put(&vmx->vcpu);
 	put_cpu();
+#if defined(CONFIG_POPCORN_HYPE) //&& defined(CONFIG_POPCORN_STAT)
+	HPPRINTK("%s: vmx->vcpu.cpu [[%d]]\n", __func__, vmx->vcpu.cpu);
+#endif
 	if (err)
 		goto free_vmcs;
+
 	if (cpu_need_virtualize_apic_accesses(&vmx->vcpu)) {
+#if defined(CONFIG_POPCORN_HYPE) //&& defined(CONFIG_POPCORN_STAT)
+		HPPRINTK("[arch][*/?] %s: enable_vapic_access ON -> vm_mmap()\n",
+															__func__);
+#endif
 		err = alloc_apic_access_page(kvm);
 		if (err)
 			goto free_vmcs;
 	}
 
 	if (enable_ept) {
+#if defined(CONFIG_POPCORN_HYPE) //&& defined(CONFIG_POPCORN_STAT)
+		HPPRINTK("[arch][*/?] %s: enable_ept ON\n", __func__);
+#endif
 		if (!kvm->arch.ept_identity_map_addr)
 			kvm->arch.ept_identity_map_addr =
 				VMX_EPT_IDENTITY_PAGETABLE_ADDR;
@@ -8891,6 +10245,9 @@ static struct kvm_vcpu *vmx_create_vcpu(struct kvm *kvm, unsigned int id)
 	}
 
 	if (nested) {
+#if defined(CONFIG_POPCORN_HYPE) //&& defined(CONFIG_POPCORN_STAT)
+		HPPRINTK("[arch][ /?] %s: nested ON\n", __func__);
+#endif
 		nested_vmx_setup_ctls_msrs(vmx);
 		vmx->nested.vpid02 = allocate_vpid();
 	}
@@ -8913,6 +10270,18 @@ uninit_vcpu:
 free_vcpu:
 	free_vpid(vmx->vpid);
 	kmem_cache_free(kvm_vcpu_cache, vmx);
+#if defined(CONFIG_POPCORN_HYPE) //&& defined(CONFIG_POPCORN_STAT)
+	if (err < 0) {
+		printk("\n**********************************\n"
+				"**********************************\n"
+				"\t\t[[[[[[[vcpu_id %d failed to create ret %d ]]]]]]]\n"
+				"**********************************\n"
+				"**********************************\n",
+				id, err);
+	} else {
+		printk("%s(): all DONE created\n", __func__);
+	}
+#endif
 	return ERR_PTR(err);
 }
 
@@ -9080,6 +10449,10 @@ static unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu)
 
 static void nested_ept_init_mmu_context(struct kvm_vcpu *vcpu)
 {
+#if defined(CONFIG_POPCORN_HYPE)
+	printk(KERN_ERR "pophype doesn't support nested vm\n");
+	WARN_ON(1);
+#endif
 	WARN_ON(mmu_is_nested(vcpu));
 	kvm_init_shadow_ept_mmu(vcpu,
 			to_vmx(vcpu)->nested.nested_vmx_ept_caps &
@@ -9591,6 +10964,9 @@ static void prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)
 	vmx_set_rflags(vcpu, vmcs12->guest_rflags);
 	vmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS,
 		vmcs12->guest_pending_dbg_exceptions);
+#ifdef CONFIG_POPCORN_HYPE
+	printk("[migration] pophype should not be here\n");
+#endif
 	vmcs_writel(GUEST_SYSENTER_ESP, vmcs12->guest_sysenter_esp);
 	vmcs_writel(GUEST_SYSENTER_EIP, vmcs12->guest_sysenter_eip);
 
@@ -9765,7 +11141,7 @@ static void prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)
 	/* vmcs12's VM_ENTRY_LOAD_IA32_EFER and VM_ENTRY_IA32E_MODE are
 	 * emulated by vmx_set_efer(), below.
 	 */
-	vm_entry_controls_init(vmx, 
+	vm_entry_controls_init(vmx,
 		(vmcs12->vm_entry_controls & ~VM_ENTRY_LOAD_IA32_EFER &
 			~VM_ENTRY_IA32E_MODE) |
 		(vmcs_config.vmentry_ctrl & ~VM_ENTRY_IA32E_MODE));
@@ -10423,6 +11799,10 @@ static void load_vmcs12_host_state(struct kvm_vcpu *vcpu,
 	}
 
 
+#ifdef CONFIG_POPCORN_HYPE
+	printk("[migration] pophype should not be here\n");
+	WARN_ON(1);
+#endif
 	vmcs_write32(GUEST_SYSENTER_CS, vmcs12->host_ia32_sysenter_cs);
 	vmcs_writel(GUEST_SYSENTER_ESP, vmcs12->host_ia32_sysenter_esp);
 	vmcs_writel(GUEST_SYSENTER_EIP, vmcs12->host_ia32_sysenter_eip);
@@ -10630,6 +12010,15 @@ static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
 	nested_vmx_succeed(vcpu);
 	if (enable_shadow_vmcs)
 		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
+#if defined(CONFIG_POPCORN_HYPE) //&& defined(CONFIG_POPCORN_STAT)
+		printk("\n\n\n"
+				"[ERROR] ========================\n"
+				"[ERROR] ================================================\n"
+				"[ERROR] pophype: BUG(we are not nested VM) <%d> 0x%lx\n"
+				"[ERROR] ================================================\n"
+				"[ERROR] ========================\n\n\n",
+				vcpu->vcpu_id, qualification);
+#endif
 }
 
 static int vmx_check_intercept(struct kvm_vcpu *vcpu,
@@ -10986,12 +12375,40 @@ static struct kvm_x86_ops vmx_x86_ops = {
 	.pmu_ops = &intel_pmu_ops,
 
 	.update_pi_irte = vmx_update_pi_irte,
+#ifdef CONFIG_POPCORN_HYPE
+	/* arch/x86/include/asm/kvm_host.h */
+	.dump_vmcs = dump_vmcs, /* pophype_dump_vmcs() arch/x86/kvm/x86.c */
+	.pophype_check_vmcs = pophype_check_vmcs, /* used in arch/x86/kvm/x86.c */
+	.pophype_vmcs_readl = pophype_vmcs_readl, /* used in arch/x86/kvm/x86.c */
+	.pophype_vmcs_writel = pophype_vmcs_writel, /* used in arch/x86/kvm/x86.c */
+#if defined(CONFIG_POPCORN_STAT)
+	.get_kvm_eptfault_new_ns = get_kvm_eptfault_new_ns,
+	.get_kvm_eptfault_new_cnt = get_kvm_eptfault_new_cnt,
+	.get_user_gva_cnt = get_user_gva_cnt,
+	.get_kernel_gva_cnt = get_kernel_gva_cnt,
+	.get_unknow_gva_cnt = get_unknow_gva_cnt,
+	.get_wrong_validity_gva_cnt = get_wrong_validity_gva_cnt,
+	.get_gva_ret_kernelspace_cnt = get_gva_ret_kernelspace_cnt,
+	.get_gva_ret_userspace_cnt = get_gva_ret_userspace_cnt,
+	.set_kvm_eptfault_new_ns = set_kvm_eptfault_new_ns,
+	.set_kvm_eptfault_new_cnt = set_kvm_eptfault_new_cnt,
+	.set_user_gva_cnt = set_user_gva_cnt,
+	.set_kernel_gva_cnt = set_kernel_gva_cnt,
+	.set_unknow_gva_cnt = set_unknow_gva_cnt,
+	.set_wrong_validity_gva_cnt = set_wrong_validity_gva_cnt,
+	.set_gva_ret_kernelspace_cnt = set_gva_ret_kernelspace_cnt,
+	.set_gva_ret_userspace_cnt = set_gva_ret_userspace_cnt,
+#endif
+#endif
 };
 
 static int __init vmx_init(void)
 {
 	int r = kvm_init(&vmx_x86_ops, sizeof(struct vcpu_vmx),
                      __alignof__(struct vcpu_vmx), THIS_MODULE);
+#ifdef CONFIG_POPCORN_HYPE
+	printk("%s(): r %d\n", __func__, r);
+#endif
 	if (r)
 		return r;
 
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 9cea09597d66..6d488d545aef 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -68,6 +68,21 @@
 #include <asm/div64.h>
 #include <asm/irq_remapping.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/hype.h>
+#include <popcorn/debug.h>
+#include <popcorn/vma_server.h>
+#include <popcorn/process_server.h>
+#include <popcorn/hype_kvm.h>
+#endif
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+static unsigned long vblock = 0;
+#endif
+//#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+#if defined(CONFIG_POPCORN_HYPE) && (POPHYPE_MIGRATE_DEBUG || HYPEBOOTDEBUG)
+#define VCPU_BLOCK_SHOW_LIMIT 100
+#endif
+
 #define MAX_IO_MSRS 256
 #define KVM_MAX_MCE_BANKS 32
 #define KVM_MCE_CAP_SUPPORTED (MCG_CTL_P | MCG_SER_P)
@@ -287,6 +302,11 @@ static void drop_user_return_notifiers(void)
 
 u64 kvm_get_apic_base(struct kvm_vcpu *vcpu)
 {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	// many
+	//printk("[diff] <%d> %s(): GET vcpu->arch.apic_base %lx\n",
+	//				__func__, vcpu->vcpu_id, vcpu->arch.apic_base);
+#endif
 	return vcpu->arch.apic_base;
 }
 EXPORT_SYMBOL_GPL(kvm_get_apic_base);
@@ -300,6 +320,12 @@ int kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 	u64 reserved_bits = ((~0ULL) << cpuid_maxphyaddr(vcpu)) |
 		0x2ff | (guest_cpuid_has_x2apic(vcpu) ? 0 : X2APIC_ENABLE);
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	PHAPICPRINTK("[diff] <%d> %s(): SET (msr_data) host_initiated %d index %x data %llx\n",
+				vcpu->vcpu_id, __func__, msr_info->host_initiated,
+				msr_info->index, msr_info->data);
+	//dump_stack();
+#endif
 	if (!msr_info->host_initiated &&
 	    ((msr_info->data & reserved_bits) != 0 ||
 	     new_state == X2APIC_ENABLE ||
@@ -780,6 +806,15 @@ EXPORT_SYMBOL_GPL(kvm_set_cr4);
 
 int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)
 {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	static int first[4] = {0, 0, 0, 0}; /* TODO MAX_VCPU*/
+	if (first[vcpu->vcpu_id < 10]) {
+		first[vcpu->vcpu_id]++;
+		PHMIGRATEPRINTK("%s(): <%d> set_cr3 (eptp) cr3 %lx nice!!!\n",
+									__func__, vcpu->vcpu_id, cr3);
+	}
+#endif
+
 #ifdef CONFIG_X86_64
 	cr3 &= ~CR3_PCID_INVD;
 #endif
@@ -1052,6 +1087,10 @@ int kvm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)
 	switch (msr->index) {
 	case MSR_FS_BASE:
 	case MSR_GS_BASE:
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+		PHMIGRATEPRINTK("[hopeimhere] <%d> %s(): set MSR_FS_BASE/MSR_GS_BASE "
+				"(but where is it saved?) \n", vcpu->vcpu_id, __func__);
+#endif
 	case MSR_KERNEL_GS_BASE:
 	case MSR_CSTAR:
 	case MSR_LSTAR:
@@ -1086,9 +1125,14 @@ static int do_get_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)
 	struct msr_data msr;
 	int r;
 
+	PHMIGRATEPRINTK("\t\t<%d> %s(): index %x\n",
+			vcpu->vcpu_id, __func__, index);
+
 	msr.index = index;
 	msr.host_initiated = true;
 	r = kvm_get_msr(vcpu, &msr);
+	PHMIGRATEPRINTK("\t\t\t\t\t<%d> %s(): r %x\n",
+						vcpu->vcpu_id, __func__, r);
 	if (r)
 		return r;
 
@@ -1725,6 +1769,17 @@ static int kvm_guest_time_update(struct kvm_vcpu *v)
 	struct pvclock_vcpu_time_info guest_hv_clock;
 	u8 pvclock_flags;
 	bool use_master_clock;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+#if HYPE_PERF_CRITICAL_DEBUG
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt <= 5) { /* This is host. I don't expect anything */
+		KVMCLOCKPK("pophype: [kvm-clock]: false-sharing: vcpu->hv_clock %p #%lu\n",
+														&vcpu->hv_clock, cnt);
+	}
+	/* I guess this will happen extremely frequently */
+#endif
+#endif
 
 	kernel_ns = 0;
 	host_tsc = 0;
@@ -2120,6 +2175,11 @@ int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 		u64 gpa_offset;
 		struct kvm_arch *ka = &vcpu->kvm->arch;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		printk("\t%s(): set MSR_KVM_SYSTEM_TIME - "
+				"Me HOST trying to serve GUEST's kvmclock\n", __func__);
+#endif
+
 		kvmclock_reset(vcpu);
 
 		if (vcpu->vcpu_id == 0 && !msr_info->host_initiated) {
@@ -2255,6 +2315,7 @@ EXPORT_SYMBOL_GPL(kvm_set_msr_common);
  */
 int kvm_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)
 {
+	/* vmx_get_msr */
 	return kvm_x86_ops->get_msr(vcpu, msr);
 }
 EXPORT_SYMBOL_GPL(kvm_get_msr);
@@ -2348,6 +2409,12 @@ int kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 		break;
 	case MSR_IA32_APICBASE:
 		msr_info->data = kvm_get_apic_base(vcpu);
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+		PHMIGRATEPRINTK("[hopeimhere] <%d> %s(): MSR_IA32_APICBASE - "
+				"get apic_base from vcp "
+				"from kvm_get_msr_common()\n",
+				vcpu->vcpu_id, __func__);
+#endif
 		break;
 	case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:
 		return kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);
@@ -2359,6 +2426,11 @@ int kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 		msr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;
 		break;
 	case MSR_IA32_MISC_ENABLE:
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+		PHMIGRATEPRINTK("[hopeimhere] <%d> %s(): get misc_enable_msr from "
+				"arch.ia32_misc_enable_msr kvm_get_msr_common()\n",
+				vcpu->vcpu_id, __func__);
+#endif
 		msr_info->data = vcpu->arch.ia32_misc_enable_msr;
 		break;
 	case MSR_IA32_SMBASE:
@@ -2373,6 +2445,9 @@ int kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 		msr_info->data |= (((uint64_t)4ULL) << 40);
 		break;
 	case MSR_EFER:
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+		PHMIGRATEPRINTK("[hopeimhere] <%d> %s(): get efer from arch.efer from kvm_get_msr_common()\n", vcpu->vcpu_id, __func__);
+#endif
 		msr_info->data = vcpu->arch.efer;
 		break;
 	case MSR_KVM_WALL_CLOCK:
@@ -2493,8 +2568,12 @@ static int msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs __user *user_msrs,
 	unsigned size;
 
 	r = -EFAULT;
-	if (copy_from_user(&msrs, user_msrs, sizeof msrs))
+	if (copy_from_user(&msrs, user_msrs, sizeof msrs)) {
+#ifdef CONFIG_POPCORN_HYPE
+		WARN_ON("if so, rewrite a kernel version. THIS HAPPENS");
+#endif
 		goto out;
+	}
 
 	r = -E2BIG;
 	if (msrs.nmsrs >= MAX_IO_MSRS)
@@ -2512,8 +2591,12 @@ static int msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs __user *user_msrs,
 		goto out_free;
 
 	r = -EFAULT;
-	if (writeback && copy_to_user(user_msrs->entries, entries, size))
+	if (writeback && copy_to_user(user_msrs->entries, entries, size)) {
+#ifdef CONFIG_POPCORN_HYPE
+		WARN_ON("if so, rewrite a kernel version");
+#endif
 		goto out_free;
+	}
 
 	r = n;
 
@@ -2625,6 +2708,7 @@ int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)
 
 }
 
+/* from vcpu->kvm->sys_fd (kvm_dev_ioctl (default)) */
 long kvm_arch_dev_ioctl(struct file *filp,
 			unsigned int ioctl, unsigned long arg)
 {
@@ -2636,6 +2720,7 @@ long kvm_arch_dev_ioctl(struct file *filp,
 		struct kvm_msr_list __user *user_msr_list = argp;
 		struct kvm_msr_list msr_list;
 		unsigned n;
+		HPPRINTK("%s: KVM_GET_MSR_INDEX_LIST\n", __func__);
 
 		r = -EFAULT;
 		if (copy_from_user(&msr_list, user_msr_list, sizeof msr_list))
@@ -2659,9 +2744,18 @@ long kvm_arch_dev_ioctl(struct file *filp,
 		break;
 	}
 	case KVM_GET_SUPPORTED_CPUID:
+#if defined(CONFIG_POPCORN_HYPE)
+		HPPRINTK("%s: KVM_GET_SUPPORTED_CPUID\n", __func__);
+		PHMIGRATEPRINTK("%s: KVM_GET_SUPPORTED_CPUID\n", __func__);
+#endif
+
 	case KVM_GET_EMULATED_CPUID: {
 		struct kvm_cpuid2 __user *cpuid_arg = argp;
 		struct kvm_cpuid2 cpuid;
+#if defined(CONFIG_POPCORN_HYPE)
+		HPPRINTK("%s: KVM_GET_EMULATED_CPUID\n", __func__);
+		PHMIGRATEPRINTK("%s: KVM_GET_EMULATED_CPUID\n", __func__);
+#endif
 
 		r = -EFAULT;
 		if (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))
@@ -2680,6 +2774,7 @@ long kvm_arch_dev_ioctl(struct file *filp,
 	}
 	case KVM_X86_GET_MCE_CAP_SUPPORTED: {
 		u64 mce_cap;
+		HPPRINTK("%s: KVM_X86_GET_MCE_CAP_SUPPORTED\n", __func__);
 
 		mce_cap = KVM_MCE_CAP_SUPPORTED;
 		r = -EFAULT;
@@ -2769,6 +2864,16 @@ static int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,
 	kvm_x86_ops->sync_pir_to_irr(vcpu);
 	memcpy(s->regs, vcpu->arch.apic->regs, sizeof *s);
 
+#if 0 /* checked[100] - good */
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	{ int i;
+		for (i = 0; i < 100; ++i) { // 1024 total
+			printk("<%d> %s() lapic->regs[%d] %x\n",
+				vcpu->vcpu_id, __func__, i, s->regs[i]);
+		}
+	}
+#endif
+#endif
 	return 0;
 }
 
@@ -3066,6 +3171,9 @@ static void fill_xsave(u8 *dest, struct kvm_vcpu *vcpu)
 	u64 xstate_bv = xsave->header.xfeatures;
 	u64 valid;
 
+#if defined(CONFIG_POPCORN_HYPE)
+	PHMIGRATEPRINTK("<%d> %s(): KVM_GET_XSAVE\n", vcpu->vcpu_id, __func__);
+#endif
 	/*
 	 * Copy legacy XSAVE area, to avoid complications with CPUID
 	 * leaves 0 and 1 in the loop below.
@@ -3103,6 +3211,9 @@ static void load_xsave(struct kvm_vcpu *vcpu, u8 *src)
 	u64 xstate_bv = *(u64 *)(src + XSAVE_HDR_OFFSET);
 	u64 valid;
 
+#if defined(CONFIG_POPCORN_HYPE)
+	PHMIGRATEPRINTK("%s(): KVM_SET_XSAVE\n", __func__);
+#endif
 	/*
 	 * Copy legacy XSAVE area, to avoid complications with CPUID
 	 * leaves 0 and 1 in the loop below.
@@ -3138,6 +3249,10 @@ static void load_xsave(struct kvm_vcpu *vcpu, u8 *src)
 static void kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu,
 					 struct kvm_xsave *guest_xsave)
 {
+#if defined(CONFIG_POPCORN_HYPE)
+	PHMIGRATEPRINTK("<%d> %s(): KVM_GET_XSAVE cpu_has_xsave %d\n",
+						vcpu->vcpu_id, __func__, cpu_has_xsave);
+#endif
 	if (cpu_has_xsave) {
 		memset(guest_xsave, 0, sizeof(struct kvm_xsave));
 		fill_xsave((u8 *) guest_xsave->region, vcpu);
@@ -3159,6 +3274,9 @@ static int kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu,
 		*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)];
 	u32 mxcsr = *(u32 *)&guest_xsave->region[XSAVE_MXCSR_OFFSET / sizeof(u32)];
 
+#if defined(CONFIG_POPCORN_HYPE)
+	PHMIGRATEPRINTK("%s(): KVM_SET_XSAVE cpu_has_xsave %d\n", __func__, cpu_has_xsave);
+#endif
 	if (cpu_has_xsave) {
 		/*
 		 * Here we allow setting states that are not present in
@@ -3191,6 +3309,11 @@ static void kvm_vcpu_ioctl_x86_get_xcrs(struct kvm_vcpu *vcpu,
 	guest_xcrs->flags = 0;
 	guest_xcrs->xcrs[0].xcr = XCR_XFEATURE_ENABLED_MASK;
 	guest_xcrs->xcrs[0].value = vcpu->arch.xcr0;
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	PHMIGRATEPRINTK("[pophypemigrate] <%d> %s(): xcr %x val %llx\n",
+			vcpu->vcpu_id, __func__,
+			guest_xcrs->xcrs[0].xcr, guest_xcrs->xcrs[0].value);
+#endif
 }
 
 static int kvm_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu,
@@ -3204,6 +3327,11 @@ static int kvm_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu,
 	if (guest_xcrs->nr_xcrs > KVM_MAX_XCRS || guest_xcrs->flags)
 		return -EINVAL;
 
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	PHMIGRATEPRINTK("[pophypemigrate] <%d> %s(): xcr %x val %llx\n",
+			vcpu->vcpu_id, __func__,
+			guest_xcrs->xcrs[0].xcr, guest_xcrs->xcrs[0].value);
+#endif
 	for (i = 0; i < guest_xcrs->nr_xcrs; i++)
 		/* Only support XCR0 currently */
 		if (guest_xcrs->xcrs[i].xcr == XCR_XFEATURE_ENABLED_MASK) {
@@ -3244,6 +3372,14 @@ long kvm_arch_vcpu_ioctl(struct file *filp,
 		void *buffer;
 	} u;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (ioctl == KVM_GET_MSRS) {
+	}
+#endif
+
+#ifdef CONFIG_POPCORN_HYPE
+	/* never had a look */
+#endif
 	u.buffer = NULL;
 	switch (ioctl) {
 	case KVM_GET_LAPIC: {
@@ -3306,6 +3442,11 @@ long kvm_arch_vcpu_ioctl(struct file *filp,
 		struct kvm_cpuid2 __user *cpuid_arg = argp;
 		struct kvm_cpuid2 cpuid;
 
+#if defined(CONFIG_POPCORN_HYPE)
+		HPPRINTK("%s: KVM_SET_CPUID2\n", __func__);
+		PHMIGRATEPRINTK("<%d> %s: KVM_SET_CPUID2 (pophypemigration)\n",
+										vcpu->vcpu_id, __func__);
+#endif
 		r = -EFAULT;
 		if (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))
 			goto out;
@@ -3331,9 +3472,15 @@ long kvm_arch_vcpu_ioctl(struct file *filp,
 		break;
 	}
 	case KVM_GET_MSRS:
+#if defined(CONFIG_POPCORN_HYPE)
+		PHMIGRATEPRINTK("<%d> %s(): KVM_GET_MSRS\n", vcpu->vcpu_id, __func__);
+#endif
 		r = msr_io(vcpu, argp, do_get_msr, 1);
 		break;
 	case KVM_SET_MSRS:
+#if defined(CONFIG_POPCORN_HYPE)
+		PHMIGRATEPRINTK("<%d> %s(): KVM_SET_MSRS\n", vcpu->vcpu_id, __func__);
+#endif
 		r = msr_io(vcpu, argp, do_set_msr, 0);
 		break;
 	case KVM_TPR_ACCESS_REPORTING: {
@@ -3434,6 +3581,10 @@ long kvm_arch_vcpu_ioctl(struct file *filp,
 		if (!u.xsave)
 			break;
 
+#if defined(CONFIG_POPCORN_HYPE)
+		PHMIGRATEPRINTK("<%d> %s(): KVM_GET_XSAVE\n",
+							vcpu->vcpu_id, __func__);
+#endif
 		kvm_vcpu_ioctl_x86_get_xsave(vcpu, u.xsave);
 
 		r = -EFAULT;
@@ -3447,6 +3598,9 @@ long kvm_arch_vcpu_ioctl(struct file *filp,
 		if (IS_ERR(u.xsave))
 			return PTR_ERR(u.xsave);
 
+#if defined(CONFIG_POPCORN_HYPE)
+		PHMIGRATEPRINTK("<%d> %s(): KVM_SET_XSAVE\n", vcpu->vcpu_id, __func__);
+#endif
 		r = kvm_vcpu_ioctl_x86_set_xsave(vcpu, u.xsave);
 		break;
 	}
@@ -3456,6 +3610,9 @@ long kvm_arch_vcpu_ioctl(struct file *filp,
 		if (!u.xcrs)
 			break;
 
+#if defined(CONFIG_POPCORN_HYPE)
+		PHMIGRATEPRINTK("<%d> %s(): KVM_GET_XCRS\n", vcpu->vcpu_id, __func__);
+#endif
 		kvm_vcpu_ioctl_x86_get_xcrs(vcpu, u.xcrs);
 
 		r = -EFAULT;
@@ -3515,8 +3672,14 @@ static int kvm_vm_ioctl_set_tss_addr(struct kvm *kvm, unsigned long addr)
 {
 	int ret;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+    DDPRINTK("%s: 1\n", __func__);
+#endif
 	if (addr > (unsigned int)(-3 * PAGE_SIZE))
 		return -EINVAL;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+    DDPRINTK("%s: 2\n", __func__);
+#endif
 	ret = kvm_x86_ops->set_tss_addr(kvm, addr);
 	return ret;
 }
@@ -3766,6 +3929,7 @@ split_irqchip_unlock:
 	return r;
 }
 
+/* from cpu->kvm->vm_fd */
 long kvm_arch_vm_ioctl(struct file *filp,
 		       unsigned int ioctl, unsigned long arg)
 {
@@ -3783,12 +3947,21 @@ long kvm_arch_vm_ioctl(struct file *filp,
 		struct kvm_pit_config pit_config;
 	} u;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+    HPPRINTK("%s: 0x%x\n", __func__, ioctl);
+#endif
+
 	switch (ioctl) {
 	case KVM_SET_TSS_ADDR:
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		KVMCLOCKPK("\t%s(): KVM_SET_TSS_ADDR addr %lx\n",
+						__func__, (unsigned long)arg);
+#endif
 		r = kvm_vm_ioctl_set_tss_addr(kvm, arg);
 		break;
 	case KVM_SET_IDENTITY_MAP_ADDR: {
 		u64 ident_addr;
+		HPPRINTK("\t%s(): KVM_SET_IDENTITY_MAP_ADDR\n", __func__);
 
 		r = -EFAULT;
 		if (copy_from_user(&ident_addr, argp, sizeof ident_addr))
@@ -3797,13 +3970,16 @@ long kvm_arch_vm_ioctl(struct file *filp,
 		break;
 	}
 	case KVM_SET_NR_MMU_PAGES:
+		HPPRINTK("\t%s(): KVM_SET_NR_MMU_PAGES\n", __func__);
 		r = kvm_vm_ioctl_set_nr_mmu_pages(kvm, arg);
 		break;
 	case KVM_GET_NR_MMU_PAGES:
+		HPPRINTK("\t%s(): KVM_GET_NR_MMU_PAGES\n", __func__);
 		r = kvm_vm_ioctl_get_nr_mmu_pages(kvm);
 		break;
 	case KVM_CREATE_IRQCHIP: {
 		struct kvm_pic *vpic;
+		HPPRINTK("\t%s(): KVM_CREATE_IRQCHIP\n", __func__);
 
 		mutex_lock(&kvm->lock);
 		r = -EEXIST;
@@ -3813,9 +3989,12 @@ long kvm_arch_vm_ioctl(struct file *filp,
 		if (atomic_read(&kvm->online_vcpus))
 			goto create_irqchip_unlock;
 		r = -ENOMEM;
-		vpic = kvm_create_pic(kvm);
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		KVMCLOCKPK("%s(): KVM_CREATE_IRQCHIP 8259 virtual controller\n", __func__);
+#endif
+		vpic = kvm_create_pic(kvm); /* create 8259 virtual controller */
 		if (vpic) {
-			r = kvm_ioapic_init(kvm);
+			r = kvm_ioapic_init(kvm); /* create ioapic virtual controller */
 			if (r) {
 				mutex_lock(&kvm->slots_lock);
 				kvm_destroy_pic(vpic);
@@ -3842,18 +4021,32 @@ long kvm_arch_vm_ioctl(struct file *filp,
 		break;
 	}
 	case KVM_CREATE_PIT:
+		HPPRINTK("\t%s(): KVM_CREATE_PIT i8254\n", __func__);
 		u.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;
 		goto create_pit;
 	case KVM_CREATE_PIT2:
+		HPPRINTK("\t%s(): KVM_CREATE_PIT2 i8254\n", __func__);
 		r = -EFAULT;
 		if (copy_from_user(&u.pit_config, argp,
-				   sizeof(struct kvm_pit_config)))
+				   sizeof(struct kvm_pit_config))) {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+			HPPRINTK("\t%s(): 1 r %d\n", __func__, r);
+#endif
 			goto out;
+		}
 	create_pit:
 		mutex_lock(&kvm->slots_lock);
 		r = -EEXIST;
-		if (kvm->arch.vpit)
+		if (kvm->arch.vpit) {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+			KVMCLOCKPK("\t%s(): !!kvm->arch.vpit (already created) skip r %d\n",
+																__func__, r);
+#endif
 			goto create_pit_unlock;
+		}
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		KVMCLOCKPK("\t%s(): create PIT\n", __func__);
+#endif
 		r = -ENOMEM;
 		kvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);
 		if (kvm->arch.vpit)
@@ -3864,6 +4057,7 @@ long kvm_arch_vm_ioctl(struct file *filp,
 	case KVM_GET_IRQCHIP: {
 		/* 0: PIC master, 1: PIC slave, 2: IOAPIC */
 		struct kvm_irqchip *chip;
+		HPPRINTK("\t%s(): KVM_GET_IRQCHIP\n", __func__);
 
 		chip = memdup_user(argp, sizeof(*chip));
 		if (IS_ERR(chip)) {
@@ -3888,6 +4082,7 @@ long kvm_arch_vm_ioctl(struct file *filp,
 	case KVM_SET_IRQCHIP: {
 		/* 0: PIC master, 1: PIC slave, 2: IOAPIC */
 		struct kvm_irqchip *chip;
+		HPPRINTK("\t%s(): KVM_SET_IRQCHIP\n", __func__);
 
 		chip = memdup_user(argp, sizeof(*chip));
 		if (IS_ERR(chip)) {
@@ -3907,6 +4102,7 @@ long kvm_arch_vm_ioctl(struct file *filp,
 		break;
 	}
 	case KVM_GET_PIT: {
+		HPPRINTK("\t%s(): KVM_GET_PIT\n", __func__);
 		r = -EFAULT;
 		if (copy_from_user(&u.ps, argp, sizeof(struct kvm_pit_state)))
 			goto out;
@@ -3923,6 +4119,7 @@ long kvm_arch_vm_ioctl(struct file *filp,
 		break;
 	}
 	case KVM_SET_PIT: {
+		HPPRINTK("\t%s(): KVM_SET_PIT\n", __func__);
 		r = -EFAULT;
 		if (copy_from_user(&u.ps, argp, sizeof u.ps))
 			goto out;
@@ -3933,6 +4130,7 @@ long kvm_arch_vm_ioctl(struct file *filp,
 		break;
 	}
 	case KVM_GET_PIT2: {
+		HPPRINTK("\t%s(): KVM_GET_PIT2\n", __func__);
 		r = -ENXIO;
 		if (!kvm->arch.vpit)
 			goto out;
@@ -3946,6 +4144,7 @@ long kvm_arch_vm_ioctl(struct file *filp,
 		break;
 	}
 	case KVM_SET_PIT2: {
+		HPPRINTK("\t%s(): KVM_SET_PIT2\n", __func__);
 		r = -EFAULT;
 		if (copy_from_user(&u.ps2, argp, sizeof(u.ps2)))
 			goto out;
@@ -3957,6 +4156,7 @@ long kvm_arch_vm_ioctl(struct file *filp,
 	}
 	case KVM_REINJECT_CONTROL: {
 		struct kvm_reinject_control control;
+		HPPRINTK("\t%s(): KVM_REINJECT_CONTROL\n", __func__);
 		r =  -EFAULT;
 		if (copy_from_user(&control, argp, sizeof(control)))
 			goto out;
@@ -3964,16 +4164,45 @@ long kvm_arch_vm_ioctl(struct file *filp,
 		break;
 	}
 	case KVM_SET_BOOT_CPU_ID:
+		HPPRINTK("\t%s(): KVM_SET_BOOT_CPU_ID online_vcpus %d\n",
+				__func__, atomic_read(&kvm->online_vcpus));
+		KVMCLOCKPK("\t%s(): KVM_SET_BOOT_CPU_ID online_vcpus %d\n",
+				__func__, atomic_read(&kvm->online_vcpus));
 		r = 0;
 		mutex_lock(&kvm->lock);
 		if (atomic_read(&kvm->online_vcpus) != 0)
 			r = -EBUSY;
-		else
+		else {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+			/* Cannot create any vcpu before calling this */
+			//int vcpu_id;
+#endif
 			kvm->arch.bsp_vcpu_id = arg;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+			//BUG_ON(copy_from_user(&vcpu_id, argp, sizeof(vcpu_id)));
+			//if (copy_from_user(&vcpu_id, argp, sizeof(vcpu_id))) {
+			//	KVMCLOCKPK(KERN_ERR "ERROR:  KVM_SET_BOOT_CPU_ID\n");
+			//	goto out;
+			//}
+			KVMCLOCKPK("\t==================================\n");
+			KVMCLOCKPK("\t====== KVM_SET_BOOT_CPU_ID ========\n");
+			KVMCLOCKPK("\t==================================\n");
+			//KVMCLOCKPK("\t%s(): BSP is ***** %u *****\n",
+						//__func__, kvm->arch.bsp_vcpu_id);
+			KVMCLOCKPK("\t%s(): BSP is ***** %d *****\n",
+						//__func__, vcpu_id);
+						__func__, kvm->arch.bsp_vcpu_id);
+			KVMCLOCKPK("\t==================================\n");
+			KVMCLOCKPK("\t==================================\n");
+			BUG_ON(current->at_remote &&
+				(kvm->arch.bsp_vcpu_id == 0 || kvm->arch.bsp_vcpu_id == 1) );
+#endif
+		}
 		mutex_unlock(&kvm->lock);
 		break;
 	case KVM_XEN_HVM_CONFIG: {
 		struct kvm_xen_hvm_config xhc;
+		HPPRINTK("\t%s(): KVM_XEN_HVM_CONFIG\n", __func__);
 		r = -EFAULT;
 		if (copy_from_user(&xhc, argp, sizeof(xhc)))
 			goto out;
@@ -3988,6 +4217,7 @@ long kvm_arch_vm_ioctl(struct file *filp,
 		struct kvm_clock_data user_ns;
 		u64 now_ns;
 		s64 delta;
+		HPPRINTK("\t%s(): KVM_SET_CLOCK\n", __func__);
 
 		r = -EFAULT;
 		if (copy_from_user(&user_ns, argp, sizeof(user_ns)))
@@ -4009,6 +4239,7 @@ long kvm_arch_vm_ioctl(struct file *filp,
 	case KVM_GET_CLOCK: {
 		struct kvm_clock_data user_ns;
 		u64 now_ns;
+		HPPRINTK("\t%s(): KVM_GET_CLOCK\n", __func__);
 
 		local_irq_disable();
 		now_ns = get_kernel_ns();
@@ -4025,6 +4256,7 @@ long kvm_arch_vm_ioctl(struct file *filp,
 	}
 	case KVM_ENABLE_CAP: {
 		struct kvm_enable_cap cap;
+		HPPRINTK("\t%s(): KVM_ENABLE_CAP\n", __func__);
 
 		r = -EFAULT;
 		if (copy_from_user(&cap, argp, sizeof(cap)))
@@ -4036,6 +4268,9 @@ long kvm_arch_vm_ioctl(struct file *filp,
 		r = kvm_vm_ioctl_assigned_device(kvm, ioctl, arg);
 	}
 out:
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+    KVMCLOCKPK("%s: 0x%x return %d\n", __func__, ioctl, r);
+#endif
 	return r;
 }
 
@@ -4578,6 +4813,9 @@ static int emulator_cmpxchg_emulated(struct x86_emulate_ctxt *ctxt,
 	if (((gpa + bytes - 1) & PAGE_MASK) != (gpa & PAGE_MASK))
 		goto emul_write;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_CHECK_SANITY)
+	BUG_ON("gfn_to_pfn() is a write fault"); /* pophype */
+#endif
 	page = kvm_vcpu_gfn_to_page(vcpu, gpa >> PAGE_SHIFT);
 	if (is_error_page(page))
 		goto emul_write;
@@ -4620,6 +4858,9 @@ emul_write:
 static int kernel_pio(struct kvm_vcpu *vcpu, void *pd)
 {
 	int r = 0, i;
+#ifdef CONFIG_POPCORN_HYPE
+	/* Many. Cannot boot */
+#endif
 
 	for (i = 0; i < vcpu->arch.pio.count; i++) {
 		if (vcpu->arch.pio.in)
@@ -4850,6 +5091,12 @@ static bool emulator_get_segment(struct x86_emulate_ctxt *ctxt, u16 *selector,
 {
 	struct kvm_segment var;
 
+#if defined(CONFIG_POPCORN_HYPE)
+	// many but acceptable
+	//KVMCLOCKPK("%s(): seg %d pophype doesn't expect this\n", __func__, seg);
+	//WARN_ON(1);
+#endif
+
 	kvm_get_segment(emul_to_vcpu(ctxt), &var, seg);
 	*selector = var.selector;
 
@@ -4886,6 +5133,16 @@ static void emulator_set_segment(struct x86_emulate_ctxt *ctxt, u16 selector,
 {
 	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);
 	struct kvm_segment var;
+#if defined(CONFIG_POPCORN_HYPE)
+	{
+		static int cnt = 0;
+		cnt++;
+		KVMCLOCKPK("%s(): pophype doesn't expect this but vanilla qemu #%d\n",
+																__func__, cnt);
+		if (cnt == 1 || !(cnt % 10))
+			WARN_ON(1);
+	}
+#endif
 
 	var.selector = selector;
 	var.base = get_desc_base(desc);
@@ -5199,6 +5456,12 @@ static bool reexecute_instruction(struct kvm_vcpu *vcpu, gva_t cr2,
 	 * instruction -> ...
 	 */
 	pfn = gfn_to_pfn(vcpu->kvm, gpa_to_gfn(gpa));
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	dump_stack();
+	printk("cr2 0x%lx\n", cr2);
+	BUG_ON("gfn_to_pfn() is a write fault"); /* pophype -
+													it happends on remote */
+#endif
 
 	/*
 	 * If the instruction failed on the error pfn, it can not be fixed,
@@ -5843,6 +6106,11 @@ int kvm_arch_init(void *opaque)
 		goto out;
 	}
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	KVMCLOCKPK("pophype: false-sharing: shared_msrs %p (if target, TODO.)\n",
+															shared_msrs);
+#endif
+
 	r = kvm_mmu_module_init();
 	if (r)
 		goto out_free_percpu;
@@ -5893,6 +6161,19 @@ void kvm_arch_exit(void)
 
 int kvm_vcpu_halt(struct kvm_vcpu *vcpu)
 {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT) && HYPEBOOTDEBUG
+	static int vcpu_halt_cnt = 0;
+	if (vcpu->vcpu_id && vcpu_halt_cnt < VCPU_BLOCK_SHOW_LIMIT) {
+		vcpu_halt_cnt++;
+		PHMIGRATEPRINTK("<%d> %s(): #%d/%d\n",
+				vcpu->vcpu_id, __func__, vcpu_halt_cnt, VCPU_BLOCK_SHOW_LIMIT);
+#if POPHYPE_MIGRATE_DEBUG
+		//if (vcpu_halt_cnt == VCPU_BLOCK_SHOW_LIMIT)
+		if (vcpu_halt_cnt == 1)
+			dump_stack();
+#endif
+	}
+#endif
 	++vcpu->stat.halt_exits;
 	if (lapic_in_kernel(vcpu)) {
 		vcpu->arch.mp_state = KVM_MP_STATE_HALTED;
@@ -5969,6 +6250,44 @@ int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)
 		kvm_pv_kick_cpu_op(vcpu->kvm, a0, a1);
 		ret = 0;
 		break;
+#ifdef CONFIG_POPCORN_HYPE
+	case KVM_HC_POPHYPE_MIGRATE:
+		PHMIGRATEPRINTK("[hypercall] %s(): case KVM_HC_POPHYPE_MIGRATE "
+						"a0 = %lu a1 = %lu\n", __func__, a0, a1);
+		vcpu->run->a0 = a0;
+		vcpu->run->a1 = a1;
+
+		ret = 0;
+		r = KVM_RET_POPHYPE_MIGRATE; /* 1:vm otherwise: guest */
+		/* let user does it */
+		break;
+#if POPHYPE_NET_OPTIMIZE
+	case KVM_HC_POPHYPE_NET_DELEGATE:
+		{
+			//struct sk_buff *skb = (struct sk_buff *)a0; /* ATTENTION: guest ptr */
+			struct pophype_skb __user *pskb_gva = (struct pophype_skb *)a0; /* ATTENTION: guest ptr */
+			int pskb_size = a1;
+			/* 1. pass skb from guest to host a0 a1
+			   2. send all to origin */
+			VHOSTNET_OPTIMIZE_PK("got hypercall KVM_HC_POPHYPE_NET_DELEGATE pophypejack Jack - "
+								"pskb_gva %p pskb_size %d\n", pskb_gva, pskb_size);
+			BUG_ON(!my_nid);
+			delegate_skb_tx(pskb_gva, pskb_size);
+		}
+		break;
+	case KVM_HC_POPHYPE_NET_MSG_DELEGATE:
+		{
+			struct pophype_msghdr __user *pmsghdr = (struct pophype_msghdr *)a0; /* ATTENTION: guest ptr */
+			int pmsghdr_size = (int)a1;
+
+			VHOSTNET_OPTIMIZE_PK("got hypercall KVM_HC_POPHYPE_NET_MSG_DELEGATE pophypejack Jack - "
+								"(usr)pmsghdr %p pmsghdr_size %d\n", pmsghdr, pmsghdr_size);
+			BUG_ON(!my_nid);
+			delegate_net_msg_tx(pmsghdr, pmsghdr_size);
+		}
+		break;
+#endif
+#endif
 	default:
 		ret = -KVM_ENOSYS;
 		break;
@@ -6353,6 +6672,10 @@ static void process_smi(struct kvm_vcpu *vcpu)
 	if (guest_cpuid_has_longmode(vcpu))
 		kvm_x86_ops->set_efer(vcpu, 0);
 
+#if defined(CONFIG_POPCORN_HYPE)
+	KVMCLOCKPK("<%d> %s():\n", vcpu->vcpu_id, __func__);
+#endif
+
 	kvm_update_cpuid(vcpu);
 	kvm_mmu_reset_context(vcpu);
 }
@@ -6389,6 +6712,11 @@ void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)
 	if (!kvm_x86_ops->set_apic_access_page_addr)
 		return;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	VCPUPRINTK("[%d] <%d> %s(): apic page gpa 0x%x\n",
+			current->pid, vcpu->vcpu_id, __func__, APIC_DEFAULT_PHYS_BASE);
+	//BUG_ON("gfn_to_page() is a write fault"); /* pophype - happens once */
+#endif
 	page = gfn_to_page(vcpu->kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);
 	if (is_error_page(page))
 		return;
@@ -6427,6 +6755,20 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 
 	bool req_immediate_exit = false;
 
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	static int first[4] = {1, 1, 1, 1}; /* TODO MAX_VCPU*/
+	static int first_start_mm_reload[4] = {1, 1, 1, 1}; /* TODO MAX_VCPU*/
+	static int first_end_mm_reload[4] = {1, 1, 1, 1}; /* TODO MAX_VCPU*/
+
+	if (first[vcpu->vcpu_id]) {
+		first[vcpu->vcpu_id] = 0;
+		PHMIGRATEPRINTK(" [ck]%s %s(): <%d>:\n",
+						__FILE__, __func__, vcpu->vcpu_id);
+		//PHMIGRATEPRINTK("vcpu->arch.mmu.pae_root %p\n", vcpu->arch.mmu.pae_root); // don't care pae_root
+		PHMIGRATEPRINTK("vcpu->arch.mmu.root_hpa %llx\n", vcpu->arch.mmu.root_hpa);
+	}
+#endif
+
 	if (vcpu->requests) {
 		if (kvm_check_request(KVM_REQ_MMU_RELOAD, vcpu))
 			kvm_mmu_unload(vcpu);
@@ -6502,8 +6844,35 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 			r = 0;
 			goto out;
 		}
+#ifdef CONFIG_POPCORN_HYPE
+////////////////////////////////////////////////////////////////////////
+		if (kvm_check_request(KVM_REQ_VCPU_MIGRATION, vcpu)) {
+			SIGVPRINTK("\t\t[%d] %s(): goin to vm exit vcpu<%d> "
+						"with KVM_EXIT_REQ_POPHYPE_MIGRATE\n",
+							current->pid, __func__, vcpu->vcpu_id);
+			vcpu->run->exit_reason = KVM_EXIT_REQ_POPHYPE_MIGRATE;
+			//vcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;
+			r = 0; // 0: to user space 1: to kernel space
+			goto out;
+		}
+////////////////////////////////////////////////////////////////////////
+#endif
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+////////////////////////////////////////////////////////////////////////
+	if (kvm_check_request(KVM_REQ_VCPU_MIGRATION, vcpu)) {
+		SIGVPRINTK("\t\ttesting or here [%d] %s(): goin to vm exit vcpu<%d> "
+					"with KVM_EXIT_REQ_POPHYPE_MIGRATE\n",
+						current->pid, __func__, vcpu->vcpu_id);
+		vcpu->run->exit_reason = KVM_EXIT_REQ_POPHYPE_MIGRATE;
+		//vcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;
+		r = 0; // 0: to user space 1: to kernel space
+		goto out;
+	}
+////////////////////////////////////////////////////////////////////////
+#endif
+
 	/*
 	 * KVM_REQ_EVENT is not set when posted interrupts are set by
 	 * VT-d hardware, so we have to update RVI unconditionally.
@@ -6525,6 +6894,11 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 			goto out;
 		}
 
+#ifdef CONFIG_POPCORN_HYPE
+		// check above, inject below
+#endif
+
+		/* check if a INT comes */
 		if (inject_pending_event(vcpu, req_int_win) != 0)
 			req_immediate_exit = true;
 		/* enable NMI/IRQ window open exits if needed */
@@ -6540,6 +6914,14 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 			kvm_lapic_sync_to_vapic(vcpu);
 		}
 	}
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	if (first_start_mm_reload[vcpu->vcpu_id]) {
+		first_start_mm_reload[vcpu->vcpu_id] = 0;
+		PHMIGRATEPRINTK(" === %s %s(): <%d> ckpt kvm_mmu_reload start (load guest cr3)\n",
+											__FILE__, __func__, vcpu->vcpu_id);
+		PHMIGRATEPRINTK("%s(): CR3 = 0x%016lx\n", __func__, kvm_x86_ops->pophype_vmcs_readl(GUEST_CR3));
+	}
+#endif
 
 	r = kvm_mmu_reload(vcpu);
 	if (unlikely(r)) {
@@ -6548,6 +6930,23 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 
 	preempt_disable();
 
+#if defined(CONFIG_POPCORN_HYPE)  && POPHYPE_MIGRATE_DEBUG
+	if (first_end_mm_reload[vcpu->vcpu_id]) {
+		first_end_mm_reload[vcpu->vcpu_id] = 0;
+		PHMIGRATEPRINTK(" === %s %s(): <%d> ckpt kvm_mmu_reload done (load guest cr3)\n",
+											__FILE__, __func__, vcpu->vcpu_id);
+		PHMIGRATEPRINTK("%s(): CR3 = 0x%016lx\n", __func__, kvm_x86_ops->pophype_vmcs_readl(GUEST_CR3));
+	}
+	/* prepare to guest mode - save host state:
+		vmx_save_host_state() in arch/x86/kvm/vmx.c
+		vmx->* = kvm
+		vmx->* = host_states e.g., segments fs/gs/ds/es
+			e.g. savesegment(gs, vmx->host_state.gs_sel);
+					-> save segments to vmx->host_state.gs_sel
+		vmcs_writel();
+		Note: opposiete = vmx_load_host_state()
+	*/
+#endif
 	kvm_x86_ops->prepare_guest_switch(vcpu);
 	if (vcpu->fpu_active)
 		kvm_load_guest_fpu(vcpu);
@@ -6592,6 +6991,15 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 		vcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_RELOAD;
 	}
 
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	{	/* vmx_vcpu_run */
+		static unsigned long cnt = 0;
+		cnt++;
+		if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT || !(cnt % 100000))
+			HPPRINTK("[%d] %s: kvm_x86_ops->run (too verbose) #%lu\n",
+										current->pid, __func__, cnt);
+	}
+#endif
 	kvm_x86_ops->run(vcpu);
 
 	/*
@@ -6659,7 +7067,17 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 	if (vcpu->arch.apic_attention)
 		kvm_lapic_sync_from_vapic(vcpu);
 
-	r = kvm_x86_ops->handle_exit(vcpu);
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	{	/* vmx_handle_exit */
+		static unsigned long cnt = 0;
+		cnt++;
+		if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT || !(cnt % 100000)) {
+			HPPRINTK("[%d] %s: 8 kvm_x86_ops->handle_exit "
+				"(too verbose) #%lu\n", current->pid, __func__, cnt);
+		}
+	}
+#endif
+	r = kvm_x86_ops->handle_exit(vcpu); /* 48 ept fault 1:good */
 	return r;
 
 cancel_injection:
@@ -6670,6 +7088,103 @@ out:
 	return r;
 }
 
+#if defined(CONFIG_POPCORN_HYPE)
+/* debug */
+int pophype_peek_vcpu_enter_guest(struct kvm_vcpu *vcpu)
+{
+	printk("\n\n%s(): ------- before-enter peek start -------\n", __func__);
+	printk("%s(): vcpu->requests %lu\n", __func__, vcpu->requests);
+
+	printk("\t\t KVM_REQ_MMU_RELOAD %d\n",
+						kvm_check_request(KVM_REQ_MMU_RELOAD, vcpu));
+	printk("\t\t KVM_REQ_MIGRATE_TIMER %d (=!)\n",
+			kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu));
+	printk("\t\t KVM_REQ_MASTERCLOCK_UPDATE %d (=!)\n",
+			kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu));
+	printk("\t\t KVM_REQ_GLOBAL_CLOCK_UPDATE %d (=!)\n",
+			kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu));
+	printk("\t\t KVM_REQ_CLOCK_UPDATE %d (!=)\n",
+			kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu));
+	printk("\t\t KVM_REQ_MMU_SYNC %d\n",
+			kvm_check_request(KVM_REQ_MMU_SYNC, vcpu));
+	printk("\t\t KVM_REQ_TLB_FLUSH %d\n",
+			kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu));
+	printk("\t\t KVM_REQ_REPORT_TPR_ACCESS %d\n",
+			kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu));
+	printk("\t\t KVM_REQ_TRIPLE_FAULT %d\n",
+			kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu));
+	printk("\t\t KVM_REQ_DEACTIVATE_FPU %d\n",
+			kvm_check_request(KVM_REQ_DEACTIVATE_FPU, vcpu));
+	printk("\t\t KVM_REQ_APF_HALT %d\n",
+			kvm_check_request(KVM_REQ_APF_HALT, vcpu));
+	printk("\t\t KVM_REQ_STEAL_UPDATE %d (!=)\n",
+			kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu));
+	printk("\t\t KVM_REQ_SMI %d\n",
+			kvm_check_request(KVM_REQ_SMI, vcpu));
+	printk("\t\t KVM_REQ_NMI %d\n",
+			kvm_check_request(KVM_REQ_NMI, vcpu));
+	printk("\t\t KVM_REQ_PMU %d\n",
+			kvm_check_request(KVM_REQ_PMU, vcpu));
+	printk("\t\t KVM_REQ_PMI %d\n",
+			kvm_check_request(KVM_REQ_PMI, vcpu));
+	printk("\t\t KVM_REQ_IOAPIC_EOI_EXIT %d\n",
+			kvm_check_request(KVM_REQ_IOAPIC_EOI_EXIT, vcpu));
+	printk("\t\t pending_ioapic_eoi %d\n",
+			test_bit(vcpu->arch.pending_ioapic_eoi,
+				 (void *) vcpu->arch.eoi_exit_bitmap));
+	printk("\t\t KVM_REQ_SCAN_IOAPIC %d (!=)\n",
+			kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu));
+	printk("\t\t KVM_REQ_APIC_PAGE_RELOAD %d (!=)\n",
+			kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu));
+	printk("\t\t KVM_REQ_HV_CRASH %d\n",
+			kvm_check_request(KVM_REQ_HV_CRASH, vcpu));
+	printk("\t\t KVM_REQ_HV_RESET %d\n",
+			kvm_check_request(KVM_REQ_HV_RESET, vcpu));
+	printk("\n");
+
+
+	printk("%s(): kvm_lapic_enabled %d (!=) = "
+			"kvm_apic_present(vcpu) %d && "
+			"kvm_apic_sw_enabled(vcpu->arch.apic) %d\n",
+			__func__, kvm_lapic_enabled(vcpu),
+			kvm_apic_present(vcpu), kvm_apic_sw_enabled(vcpu->arch.apic));
+	printk("%s(): kvm_apic_present(vcpu) = kvm_vcpu_has_lapic(vcpu) %d "
+			"&& kvm_apic_hw_enabled(vcpu->arch.apic) %d\n", __func__,
+			kvm_vcpu_has_lapic(vcpu), kvm_apic_hw_enabled(vcpu->arch.apic));
+	printk("\n");
+
+	{
+	bool req_int_win = dm_request_for_irq_injection(vcpu) && kvm_cpu_accept_dm_intr(vcpu);
+	printk("%s(): KVM_REQ_EVENT %d || req_int_win %d = %d (!=)\n", __func__,
+										kvm_check_request(KVM_REQ_EVENT, vcpu), req_int_win,
+										kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win);
+	}
+	printk("\t\t vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED %d\n",
+										vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED);
+	printk("\t\t TODO int\n");
+	printk("\t\t TODO nmi\n");
+	printk("\t\t TODO lapic_enable\n");
+	printk("\n");
+
+
+	printk("%s(): kvm_mmu_reload\n", __func__);
+	printk("%s(): kvm_x86_ops->prepare_guest_switch(vcpu);\n", __func__);
+	printk("\n");
+
+
+	printk("%s(): TODO\n", __func__);
+#if 0
+	printk("\t\t %d\n",
+	printk("\t\t %d\n",
+	printk("%s(): \n", __func__, );
+	printk("%s(): \n", __func__, );
+#endif
+
+	printk("%s(): ------- before-enter peek end -------\n\n", __func__);
+	return 0;
+}
+#endif
+
 static inline int vcpu_block(struct kvm *kvm, struct kvm_vcpu *vcpu)
 {
 	if (!kvm_arch_vcpu_runnable(vcpu) &&
@@ -6685,16 +7200,47 @@ static inline int vcpu_block(struct kvm *kvm, struct kvm_vcpu *vcpu)
 			return 1;
 	}
 
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+//	// <0> many, so only count for remote
+//	if (distributed_remote_process(current))
+//		vblock++;
+#endif
 	kvm_apic_accept_events(vcpu);
 	switch(vcpu->arch.mp_state) {
 	case KVM_MP_STATE_HALTED:
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+		// 0 a lot
+		if (vcpu->vcpu_id && vblock < VCPU_BLOCK_SHOW_LIMIT) {
+			vblock++; // for testing vanilla (stop printing)
+			PHMIGRATEPRINTK("<%d> %s(): KVM_MP_STATE_HALTED "
+					"(vcpu->arch.pv.pv_unhalted %d =w> false) #%lu/%d\n",
+					vcpu->vcpu_id, __func__, vcpu->arch.pv.pv_unhalted,
+					vblock, VCPU_BLOCK_SHOW_LIMIT);
+		}
+#endif
 		vcpu->arch.pv.pv_unhalted = false;
 		vcpu->arch.mp_state =
 			KVM_MP_STATE_RUNNABLE;
 	case KVM_MP_STATE_RUNNABLE:
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+		// 0 a lot
+		if (vcpu->vcpu_id && vblock < VCPU_BLOCK_SHOW_LIMIT) {
+			vblock++; // for testing vanilla (stop printing)
+			PHMIGRATEPRINTK("<%d> %s(): KVM_MP_STATE_RUNNABLE #%lu/%d\n",
+					vcpu->vcpu_id, __func__, vblock, VCPU_BLOCK_SHOW_LIMIT);
+		}
+#endif
 		vcpu->arch.apf.halted = false;
 		break;
 	case KVM_MP_STATE_INIT_RECEIVED:
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+		// 0 a lot
+		if (vcpu->vcpu_id && vblock < VCPU_BLOCK_SHOW_LIMIT) {
+			vblock++; // for testing vanilla
+			PHMIGRATEPRINTK("<%d> %s(): KVM_MP_STATE_INIT_RECEIVED #%lu/%d\n",
+					vcpu->vcpu_id, __func__, vblock, VCPU_BLOCK_SHOW_LIMIT);
+		}
+#endif
 		break;
 	default:
 		return -EINTR;
@@ -6709,17 +7255,38 @@ static inline bool kvm_vcpu_running(struct kvm_vcpu *vcpu)
 		!vcpu->arch.apf.halted);
 }
 
+#if defined(CONFIG_POPCORN_HYPE) // used in vma_server
+int first[MAX_POPCORN_NODES] = { 1 };
+#endif
 static int vcpu_run(struct kvm_vcpu *vcpu)
 {
 	int r;
 	struct kvm *kvm = vcpu->kvm;
 
+	/* atomic start */
 	vcpu->srcu_idx = srcu_read_lock(&kvm->srcu);
 
 	for (;;) {
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+//		if (first[vcpu->vcpu_id]) {
+//			first[vcpu->vcpu_id] = 0;
+//		}
+#endif
 		if (kvm_vcpu_running(vcpu)) {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+			static unsigned long cnt = 0;
+			cnt++;
+			if (cnt < VM_SINGLE_HANDLE_DISPLAY_CNT || !(cnt % 100000)) {
+				HPPRINTK("[%d] %s: vcpu_enter_guest (too verbose) #%lu\n",
+											current->pid, __func__, cnt);
+			}
+#endif
 			r = vcpu_enter_guest(vcpu);
+#ifdef CONFIG_POPCORN_HYPE
+			/* vm-exit */
+#endif
 		} else {
+			/* run may also blocks */
 			r = vcpu_block(kvm, vcpu);
 		}
 
@@ -6754,6 +7321,7 @@ static int vcpu_run(struct kvm_vcpu *vcpu)
 	}
 
 	srcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);
+	/* atomic end */
 
 	return r;
 }
@@ -6839,7 +7407,6 @@ static int complete_emulated_mmio(struct kvm_vcpu *vcpu)
 	return 0;
 }
 
-
 int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)
 {
 	struct fpu *fpu = &current->thread.fpu;
@@ -6848,17 +7415,34 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)
 
 	fpu__activate_curr(fpu);
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	//HPPRINTK("<%d> %s: 2-0\n", current->pid, __func__);
+#endif
 	if (vcpu->sigset_active)
 		sigprocmask(SIG_SETMASK, &vcpu->sigset, &sigsaved);
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	//HPPRINTK("<%d> %s: 2-1 remote thread 88\n", current->pid, __func__);
+#endif
 	if (unlikely(vcpu->arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		KVMCLOCKPK("(run)\t\t#kvm_once [%d]<%d>: I'm an AP - IN blocking\n",
+											current->pid, vcpu->vcpu_id);
+#endif
 		kvm_vcpu_block(vcpu);
-		kvm_apic_accept_events(vcpu);
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		KVMCLOCKPK("(run)\t\t#kvm_once [%d]<%d>: I'm an AP - OUT got kicked out\n",
+												current->pid, vcpu->vcpu_id);
+#endif
+		kvm_apic_accept_events(vcpu); // got injected int here
 		clear_bit(KVM_REQ_UNHALT, &vcpu->requests);
 		r = -EAGAIN;
 		goto out;
 	}
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	//HPPRINTK("<%d> %s: 2-2\n", current->pid, __func__);
+#endif
 	/* re-sync apic's tpr */
 	if (!lapic_in_kernel(vcpu)) {
 		if (kvm_set_cr8(vcpu, kvm_run->cr8) != 0) {
@@ -6876,13 +7460,153 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)
 	} else
 		WARN_ON(vcpu->arch.pio.count || vcpu->mmio_needed);
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	//HPPRINTK("<%d> %s: 3 vcpu_run\n", current->pid, __func__);
+#endif
 	r = vcpu_run(vcpu);
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* Better to put on cacller's end - this place is arch specific */
+
+	/* My original thought - remote BSP exit path */
+
+	/* Convert VM_EXIT negative (cannot handle) to exit_reason
+									for userspace to handle it */
+	/* Moved r == KVM_RET_POPHYPE_MIGRATE to the end since pophype migration */
+
+
+
+
+#ifdef CONFIG_POPCORN_STAT
+	/* remote dbg */
+	if (current->at_remote) {
+		static unsigned int remote_first_300 = 0;
+		remote_first_300++;
+		if (remote_first_300 < 10) {
+			printk("\t[%d/%d] <%d> remote first exit_reason %u #%u\n", // 2 printf
+						current->at_remote ? 1:0,
+						current->pid, vcpu->vcpu_id,
+						vcpu->run->exit_reason, remote_first_300);
+		} else if (vcpu->run->exit_reason != KVM_EXIT_IO && current->at_remote) { // 2 (e.g. printf)
+			if (vcpu->run->exit_reason == KVM_EXIT_INTERNAL_ERROR) { //17-3 KVM_INTERNAL_ERROR_DELIVERY_EV
+				static unsigned int exit_17_cnt = 0;
+				exit_17_cnt++;
+				if (exit_17_cnt < 150) {
+					//printk("\t<%d/%d/%d> vcpu->run [[[%p]]] "
+					printk("\t[%d/%d]<%d> "
+							"remote exit_reason %u-%u-%llu(deliver_ev) #%u\n",
+							current->pid, current->at_remote ? 1:0, vcpu->vcpu_id,
+							//vcpu->run,
+							vcpu->run->exit_reason,
+							vcpu->run->internal.suberror,
+							vcpu->run->internal.data[1],
+							exit_17_cnt);
+				}
+				/* testing enforce to touch uaddr mem */
+			} else if (vcpu->run->exit_reason != KVM_EXIT_POPHYPE_MIGRATE) {
+				static unsigned int exit_remote_not_2_17_cnt = 0;
+				exit_remote_not_2_17_cnt++;
+				if (exit_remote_not_2_17_cnt < 150) {
+					printk("\t[%d/%d]<%d> remote exit %u #%u\n",
+								current->pid, current->at_remote ? 1:0, vcpu->vcpu_id,
+								vcpu->run->exit_reason, exit_remote_not_2_17_cnt);
+				}
+			}
+		}
+	} /* remote dbg done */
+
+	/* Vanilla */
+	if (!current->mm->remote && vcpu->vcpu_id) { /* homo vcpu1 */
+		static unsigned int exit_homo_cnt = 0;
+		exit_homo_cnt++;
+		if (exit_homo_cnt > 0 && exit_homo_cnt < 300) {
+			//printk("\t<%d/%d/%d> vcpu->run [[[%p]]] ->run->exit_reason %u #%u\n",
+			printk("\t[%d/%d]<%d> ->run->exit_reason %u #%u\n",
+					current->pid, current->at_remote ? 1:0, vcpu->vcpu_id,
+					//vcpu->run,
+					vcpu->run->exit_reason, exit_homo_cnt);
+		}
+	}
+#endif
+#endif
 out:
 	post_kvm_run_save(vcpu);
 	if (vcpu->sigset_active)
 		sigprocmask(SIG_SETMASK, &sigsaved, NULL);
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* Pophype migrate: overwirte reason */
+	/* save and transfer vCPU kernel states
+		and use userspace migration to finish the migration */
+	if (r == KVM_RET_POPHYPE_MIGRATE) {
+		vcpu->run->exit_reason = KVM_EXIT_POPHYPE_MIGRATE; // pophype migration
+		{ int z;
+			PHMIGRATEPRINTK("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
+			for (z = 0; z < 5; z++)
+				PHMIGRATEPRINTK("=============== "
+							"[debug] KVM_EXIT_POPHYPE_MIGRATE start [debug] "
+							"==========================\n");
+			PHMIGRATEPRINTK("\n\n");
+		}
+
+		/******/
+		/* save state for pophype migration */
+		/******/
+		/* uhype states */
+		pophype_save_vcpu_states(vcpu); // pophype migration
+
+		/* check state */
+		kvm_x86_ops->pophype_check_vmcs(vcpu);
+		pophype_dump_vmcs(); // debug TODO remove when done
+		PHMIGRATEPRINTK("%s(): kvm_lapic_enabled %d (!=) = "
+				"kvm_apic_present(vcpu) %d && "
+				"kvm_apic_sw_enabled(vcpu->arch.apic) %d\n",
+				__func__, kvm_lapic_enabled(vcpu),
+				kvm_apic_present(vcpu), kvm_apic_sw_enabled(vcpu->arch.apic));
+		PHMIGRATEPRINTK("%s(): kvm_apic_present(vcpu) = kvm_vcpu_has_lapic(vcpu) %d "
+				"&& kvm_apic_hw_enabled(vcpu->arch.apic) %d\n", __func__,
+				kvm_vcpu_has_lapic(vcpu), kvm_apic_hw_enabled(vcpu->arch.apic));
+
+		PHMIGRATEPRINTK("[pophypemigrate] ****** "
+						"<%d> vcpu->run->apic_base %llx ******\n",
+						vcpu->vcpu_id, vcpu->run->apic_base);
+
+		PHMIGRATEPRINTK("[ck]:[diff][efer] vcpu->arch.efer %llx\n", vcpu->arch.efer);
+		PHMIGRATEPRINTK("[ck]:[segreg] rax 0x%lx rbx 0x%lx rcx 0x%lx rdx 0x%lx rsi 0x%lx "
+				"rdi 0x%lx rsp 0x%lx rbp 0x%lx    "
+#ifdef CONFIG_X86_64
+				"r8 0x%lx r9 0x%lx r10 0x%lx"
+#endif
+				"\n",
+				kvm_register_read(vcpu, VCPU_REGS_RAX),
+				kvm_register_read(vcpu, VCPU_REGS_RBX),
+				kvm_register_read(vcpu, VCPU_REGS_RCX),
+				kvm_register_read(vcpu, VCPU_REGS_RDX),
+				kvm_register_read(vcpu, VCPU_REGS_RSI),
+				kvm_register_read(vcpu, VCPU_REGS_RDI),
+				kvm_register_read(vcpu, VCPU_REGS_RSP),
+				kvm_register_read(vcpu, VCPU_REGS_RBP),
+#ifdef CONFIG_X86_64
+				kvm_register_read(vcpu, VCPU_REGS_R8),
+				kvm_register_read(vcpu, VCPU_REGS_R9),
+				kvm_register_read(vcpu, VCPU_REGS_R10)
+#endif
+		);
+		PHMIGRATEPRINTK("I don't think post_kvm_run_save() is important\n");
+		popcorn_show_gcpu_table();
+		{ int z;
+			for (z = 0; z < 5; z++) {
+				PHMIGRATEPRINTK("================= "
+								"[debug] KVM_EXIT_POPHYPE_MIGRATE end [debug] "
+								"=========================\n");
+			}
+		}
+		PHMIGRATEPRINTK("================= "
+						"[debug] KVM_EXIT_POPHYPE_MIGRATE end [debug] "
+						"=========================\n\n\n\n\n\n\n\n");
+	}
+#endif
+
 	return r;
 }
 
@@ -6929,6 +7653,11 @@ int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
 	vcpu->arch.emulate_regs_need_sync_from_vcpu = true;
 	vcpu->arch.emulate_regs_need_sync_to_vcpu = false;
 
+#ifdef CONFIG_POPCORN_HYPE
+	PHMIGRATEPRINTK("%s(): vcpu %d vcpu->cpu %d\n",
+					__func__, vcpu->vcpu_id, vcpu->cpu);
+#endif
+
 	kvm_register_write(vcpu, VCPU_REGS_RAX, regs->rax);
 	kvm_register_write(vcpu, VCPU_REGS_RBX, regs->rbx);
 	kvm_register_write(vcpu, VCPU_REGS_RCX, regs->rcx);
@@ -6948,9 +7677,18 @@ int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
 	kvm_register_write(vcpu, VCPU_REGS_R15, regs->r15);
 #endif
 
+#ifdef CONFIG_POPCORN_HYPE
+	PHMIGRATEPRINTK("%s(): vcpu %d vcpu->cpu %d general buffer regs "
+			"(except rip and glags) done\n",
+			__func__, vcpu->vcpu_id, vcpu->cpu);
+#endif
 	kvm_rip_write(vcpu, regs->rip);
 	kvm_set_rflags(vcpu, regs->rflags | X86_EFLAGS_FIXED);
-
+#ifdef CONFIG_POPCORN_HYPE
+	PHMIGRATEPRINTK("%s(): vcpu %d vcpu->cpu %d kvm_register_write & "
+			"kvm_x86_ops->set_rflags done\n",
+			__func__, vcpu->vcpu_id, vcpu->cpu);
+#endif
 	vcpu->arch.exception.pending = false;
 
 	kvm_make_request(KVM_REQ_EVENT, vcpu);
@@ -7004,6 +7742,178 @@ int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,
 		set_bit(vcpu->arch.interrupt.nr,
 			(unsigned long *)sregs->interrupt_bitmap);
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	PHMIGRATEPRINTK("\n---------- %s(): save sregs start ----------\n", __func__);
+	PHMIGRATEPRINTK("[save] get sregs->idt 0x%llx [size %d] gdt 0x%llx [size %d]\n",
+					sregs->idt.base, sregs->idt.limit,
+					sregs->gdt.base, sregs->gdt.limit);
+
+	PHMIGRATEPRINTK("[save] get sregs->cr2 0x%llx sregs->cr3 0x%llx sregs->cr8 0x%llx\n",
+						sregs->cr2, sregs->cr3, sregs->cr8);
+	PHMIGRATEPRINTK("[save] get sregs->efer 0x%llx", sregs->efer);
+	PHMIGRATEPRINTK("[save] get sregs->apic_base 0x%llx\n", sregs->apic_base);
+	PHMIGRATEPRINTK("[save] get sregs->cr0 0x%llx sregs->cr4 0x%llx\n",
+						sregs->cr0, sregs->cr4);
+
+
+	PHMIGRATEPRINTK("(done) get sregs->cs 0x%llx ds 0x%llx es 0x%llx "
+					"fs 0x%llx gs 0x%llx ss 0x%llx     "
+					"tr 0x%llx ldt 0x%llx\n",
+					sregs->cs.base, sregs->ds.base, sregs->es.base,
+					sregs->fs.base, sregs->gs.base, sregs->ss.base,
+					sregs->tr.base, sregs->ldt.base);
+
+	PHMIGRATEPRINTK("[!saved/cached] (vcpu) %s(): <%d> "
+					"vcpu->arch.apic_base 0x%llx\n",
+					__func__, vcpu->vcpu_id, vcpu->arch.apic_base);
+	PHMIGRATEPRINTK("[!saved/cached] (vcpu) %s(): <%d> get vcpu->arch.mp_state %d\n",
+						__func__, vcpu->vcpu_id, vcpu->arch.mp_state);
+	// TODO interrupt_bitmap
+	PHMIGRATEPRINTK("[!saved/cached] (vcpu) %s(): <%d> get vcpu->arch.interrupt.pending %d\n",
+						__func__, vcpu->vcpu_id, vcpu->arch.interrupt.pending);
+	PHMIGRATEPRINTK("---------- %s(): save sregs end ----------\n\n", __func__);
+#endif
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	PHMIGRATEPRINTK("[seg] set base 64 cs 0x%llx ds 0x%llx es 0x%llx "
+					"fs 0x%llx gs 0x%llx ss 0x%llx     "
+					"tr 0x%llx ldt 0x%llx (done)\n",
+					sregs->cs.base, sregs->ds.base, sregs->es.base,
+					sregs->fs.base, sregs->gs.base, sregs->ss.base,
+					sregs->tr.base, sregs->ldt.base);
+	PHMIGRATEPRINTK("[seg] set limit 32 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.limit,
+					sregs->ds.limit,
+					sregs->es.limit,
+					sregs->fs.limit,
+					sregs->gs.limit,
+					sregs->ss.limit,
+					sregs->tr.limit,
+					sregs->ldt.limit);
+	PHMIGRATEPRINTK("[seg] set selector 16 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.selector,
+					sregs->ds.selector,
+					sregs->es.selector,
+					sregs->fs.selector,
+					sregs->gs.selector,
+					sregs->ss.selector,
+					sregs->tr.selector,
+					sregs->ldt.selector);
+	PHMIGRATEPRINTK("[seg] set type 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.type,
+					sregs->ds.type,
+					sregs->es.type,
+					sregs->fs.type,
+					sregs->gs.type,
+					sregs->ss.type,
+					sregs->tr.type,
+					sregs->ldt.type);
+	PHMIGRATEPRINTK("[seg] set unusable 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.unusable,
+					sregs->ds.unusable,
+					sregs->es.unusable,
+					sregs->fs.unusable,
+					sregs->gs.unusable,
+					sregs->ss.unusable,
+					sregs->tr.unusable,
+					sregs->ldt.unusable);
+	PHMIGRATEPRINTK("[seg] set padding 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.padding,
+					sregs->ds.padding,
+					sregs->es.padding,
+					sregs->fs.padding,
+					sregs->gs.padding,
+					sregs->ss.padding,
+					sregs->tr.padding,
+					sregs->ldt.padding);
+	PHMIGRATEPRINTK("[seg] set present 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.present,
+					sregs->ds.present,
+					sregs->es.present,
+					sregs->fs.present,
+					sregs->gs.present,
+					sregs->ss.present,
+					sregs->tr.present,
+					sregs->ldt.present);
+	PHMIGRATEPRINTK("[seg] set dpl 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.dpl,
+					sregs->ds.dpl,
+					sregs->es.dpl,
+					sregs->fs.dpl,
+					sregs->gs.dpl,
+					sregs->ss.dpl,
+					sregs->tr.dpl,
+					sregs->ldt.dpl);
+	PHMIGRATEPRINTK("[seg] set db 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.db,
+					sregs->ds.db,
+					sregs->es.db,
+					sregs->fs.db,
+					sregs->gs.db,
+					sregs->ss.db,
+					sregs->tr.db,
+					sregs->ldt.db);
+	PHMIGRATEPRINTK("[seg] set s 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.s,
+					sregs->ds.s,
+					sregs->es.s,
+					sregs->fs.s,
+					sregs->gs.s,
+					sregs->ss.s,
+					sregs->tr.s,
+					sregs->ldt.s);
+	PHMIGRATEPRINTK("[seg] set l 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.l,
+					sregs->ds.l,
+					sregs->es.l,
+					sregs->fs.l,
+					sregs->gs.l,
+					sregs->ss.l,
+					sregs->tr.l,
+					sregs->ldt.l);
+	PHMIGRATEPRINTK("[seg] set g 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.g,
+					sregs->ds.g,
+					sregs->es.g,
+					sregs->fs.g,
+					sregs->gs.g,
+					sregs->ss.g,
+					sregs->tr.g,
+					sregs->ldt.g);
+	PHMIGRATEPRINTK("[seg] set avl 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.avl,
+					sregs->ds.avl,
+					sregs->es.avl,
+					sregs->fs.avl,
+					sregs->gs.avl,
+					sregs->ss.avl,
+					sregs->tr.avl,
+					sregs->ldt.avl);
+#endif
+
 	return 0;
 }
 
@@ -7036,8 +7946,13 @@ int kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu,
 	if (mp_state->mp_state == KVM_MP_STATE_SIPI_RECEIVED) {
 		vcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;
 		set_bit(KVM_APIC_SIPI, &vcpu->arch.apic->pending_events);
-	} else
+	} else {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		PHMIGRATEPRINTK("<%d> %s(): vcpu->arch.mp_state %d =w> %d\n",
+			vcpu->vcpu_id, __func__, vcpu->arch.mp_state, mp_state->mp_state);
+#endif
 		vcpu->arch.mp_state = mp_state->mp_state;
+	}
 	kvm_make_request(KVM_REQ_EVENT, vcpu);
 	return 0;
 }
@@ -7047,6 +7962,10 @@ int kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,
 {
 	struct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;
 	int ret;
+#if defined(CONFIG_POPCORN_HYPE)
+	PHMIGRATEPRINTK("<%d> %s(): maybe important for pophype migration\n",
+				vcpu->vcpu_id, __func__);
+#endif
 
 	init_emulate_ctxt(vcpu);
 
@@ -7071,9 +7990,33 @@ int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
 	int pending_vec, max_bits, idx;
 	struct desc_ptr dt;
 
-	if (!guest_cpuid_has_xsave(vcpu) && (sregs->cr4 & X86_CR4_OSXSAVE))
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	PHMIGRATEPRINTK("\n---------- %s(): SET start ----------\n", __func__);
+    VCPUPRINTK("(vcpu) %s: <%d> (vcpu->cpu %d) set sregs for vcpu "
+				"!guest_cpuid_has_xsave(vcpu) %s && "
+				"(sregs->cr4 & X86_CR4_OSXSAVE) %s\n",
+				__func__, vcpu->vcpu_id, vcpu->cpu,
+				!guest_cpuid_has_xsave(vcpu) ? "O" : "X",
+				(sregs->cr4 & X86_CR4_OSXSAVE) ? "O" : "X");
+	//dump_stack(); /* debug */
+#endif
+
+	if (!guest_cpuid_has_xsave(vcpu) && (sregs->cr4 & X86_CR4_OSXSAVE)) {
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+		VCPUPRINTK("(vcpu) %s:%d: ERROR !guest_cpuid_has_xsave(vcpu) %c\n",
+				__FILE__, __LINE__, !guest_cpuid_has_xsave(vcpu)? 'O' : 'X');
+		WARN_ON(-1);
+#endif
 		return -EINVAL;
+	}
 
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	VCPUPRINTK("(vcpu) %s(): <%d> setup sreg dtable\n",
+								__func__, vcpu->vcpu_id);
+	PHMIGRATEPRINTK("set idt 0x%llx [size %d] gdt 0x%llx [size %d]\n",
+						sregs->idt.base, sregs->idt.limit,
+						sregs->gdt.base, sregs->gdt.limit);
+#endif
 	dt.size = sregs->idt.limit;
 	dt.address = sregs->idt.base;
 	kvm_x86_ops->set_idt(vcpu, &dt);
@@ -7081,6 +8024,22 @@ int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
 	dt.address = sregs->gdt.base;
 	kvm_x86_ops->set_gdt(vcpu, &dt);
 
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	VCPUPRINTK("(vcpu) %s(): <%d> setup sreg cr\n",
+								__func__, vcpu->vcpu_id);
+	PHMIGRATEPRINTK("set cr2 0x%llx cr3 0x%llx cr8 0x%llx\n",
+						sregs->cr2, sregs->cr3, sregs->cr8);
+
+	PHMIGRATEPRINTK("(vcpu) %s(): <%d> check-1 mmu_reset_needed %d "
+				"kvm_read_cr3(vcpu) 0x%lx sregs->cr3 0x%llx\n",
+				__func__, vcpu->vcpu_id, mmu_reset_needed,
+				kvm_read_cr3(vcpu), sregs->cr3);
+
+	if (!my_nid) {
+		PHMIGRATEPRINTK("(vcpu) %s(): <%d> TODO THIS IS A testing cr3 read %lx = vcpu %lx = sregs %llx\n",
+					__func__, vcpu->vcpu_id, kvm_read_cr3(vcpu), vcpu->arch.cr3, sregs->cr3);
+	}
+#endif
 	vcpu->arch.cr2 = sregs->cr2;
 	mmu_reset_needed |= kvm_read_cr3(vcpu) != sregs->cr3;
 	vcpu->arch.cr3 = sregs->cr3;
@@ -7088,16 +8047,67 @@ int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
 
 	kvm_set_cr8(vcpu, sregs->cr8);
 
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	if (!my_nid) {
+		PHMIGRATEPRINTK("(vcpu) %s(): <%d> cr3 written read %lx = vcpu %lx = sregs %llx\n",
+					__func__, vcpu->vcpu_id, kvm_read_cr3(vcpu), vcpu->arch.cr3, sregs->cr3);
+	}
+
+	PHMIGRATEPRINTK("(vcpu) %s(): <%d> check-2 mmu_reset_needed %d "
+				"vcpu->arch.efer 0x%llx sregs->efer 0x%llx\n",
+				__func__, vcpu->vcpu_id, mmu_reset_needed,
+							vcpu->arch.efer, sregs->efer);
+#endif
 	mmu_reset_needed |= vcpu->arch.efer != sregs->efer;
 	kvm_x86_ops->set_efer(vcpu, sregs->efer);
 	apic_base_msr.data = sregs->apic_base;
 	apic_base_msr.host_initiated = true;
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	VCPUPRINTK("(vcpu) %s(): <%d> set apic\n",
+							__func__, vcpu->vcpu_id);
+	PHMIGRATEPRINTK("<%d> set efer 0x%llx",
+					vcpu->vcpu_id, sregs->efer);
+	PHMIGRATEPRINTK("<%d> set apic_base 0x%llx\n",
+					vcpu->vcpu_id, sregs->apic_base);
+#endif
 	kvm_set_apic_base(vcpu, &apic_base_msr);
 
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	PHMIGRATEPRINTK("(vcpu) %s(): <%d> setup sreg cr\n",
+								__func__, vcpu->vcpu_id);
+	PHMIGRATEPRINTK("set cr0 0x%llx cr4 0x%llx\n",
+						sregs->cr0, sregs->cr4);
+
+	PHMIGRATEPRINTK("(vcpu) %s(): <%d> check-3 mmu_reset_needed %d "
+				" kvm_read_cr0(vcpu) 0x%lx sregs->cr0 0x%llx\n",
+				__func__, vcpu->vcpu_id, mmu_reset_needed,
+				kvm_read_cr0(vcpu), sregs->cr0);
+#endif
 	mmu_reset_needed |= kvm_read_cr0(vcpu) != sregs->cr0;
 	kvm_x86_ops->set_cr0(vcpu, sregs->cr0);
 	vcpu->arch.cr0 = sregs->cr0;
 
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	// TODO BUG BUG BUG start
+	if (!my_nid) {
+		PHMIGRATEPRINTK("(vcpu) %s(): <%d> TODO THIS IS A HACK1 testing cr4 read %lx = vcpu %lx = sregs %llx\n",
+						__func__, vcpu->vcpu_id, kvm_read_cr4(vcpu), vcpu->arch.cr4, sregs->cr4);
+#if 0
+		vcpu->arch.cr4 = sregs->cr4;
+		PHMIGRATEPRINTK("(vcpu) %s(): <%d> TODO THIS IS A HACK2 testing cr4 %lx = %lx = %lx\n",
+							__func__, vcpu->vcpu_id, kvm_read_cr4(vcpu), vcpu->arch.cr4, sregs->cr4);
+		kvm_x86_ops->set_cr4(vcpu, sregs->cr4);
+		PHMIGRATEPRINTK("(vcpu) %s(): <%d> TODO THIS IS A HACK3 testing cr4 %lx = %lx = %lx\n",
+							__func__, vcpu->vcpu_id, kvm_read_cr4(vcpu), vcpu->arch.cr4, sregs->cr4);
+#endif
+	}
+	// TODO BUG BUG BUG end
+
+	PHMIGRATEPRINTK("(vcpu) %s(): <%d> check-4 mmu_reset_needed %d "
+				"vm_read_cr4(vcpu) 0x%lx sregs->cr4 0x%llx\n",
+				__func__, vcpu->vcpu_id, mmu_reset_needed,
+				kvm_read_cr4(vcpu), sregs->cr4);
+#endif
 	mmu_reset_needed |= kvm_read_cr4(vcpu) != sregs->cr4;
 	kvm_x86_ops->set_cr4(vcpu, sregs->cr4);
 	if (sregs->cr4 & X86_CR4_OSXSAVE)
@@ -7107,11 +8117,23 @@ int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
 	if (!is_long_mode(vcpu) && is_pae(vcpu)) {
 		load_pdptrs(vcpu, vcpu->arch.walk_mmu, kvm_read_cr3(vcpu));
 		mmu_reset_needed = 1;
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+		PHMIGRATEPRINTK("(vcpu) %s(): <%d> check-4.5 mmu_reset_needed [[%d]]\n",
+							__func__, vcpu->vcpu_id, mmu_reset_needed);
+#endif
 	}
 	srcu_read_unlock(&vcpu->kvm->srcu, idx);
 
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	PHMIGRATEPRINTK("(vcpu) %s(): <%d> check-5 mmu_reset_needed %d\n",
+								__func__, vcpu->vcpu_id, mmu_reset_needed);
+#endif
 	if (mmu_reset_needed)
 		kvm_mmu_reset_context(vcpu);
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	VCPUPRINTK("(vcpu) %s(): <%d> kvm_mmu_reset_context \"%s\"\n",
+		__func__, vcpu->vcpu_id, mmu_reset_needed ? "PASS" : "SKIP");
+#endif
 
 	max_bits = KVM_NR_INTERRUPTS;
 	pending_vec = find_first_bit(
@@ -7121,6 +8143,12 @@ int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
 		pr_debug("Set back pending irq %d\n", pending_vec);
 	}
 
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	PHMIGRATEPRINTK("(vcpu) %s(): <%d> pending_vec %d <? max_bits %d\n",
+				__func__, vcpu->vcpu_id, pending_vec, max_bits);
+	VCPUPRINTK("(vcpu) %s(): <%d> setup segment\n",
+							__func__, vcpu->vcpu_id);
+#endif
 	kvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);
 	kvm_set_segment(vcpu, &sregs->ds, VCPU_SREG_DS);
 	kvm_set_segment(vcpu, &sregs->es, VCPU_SREG_ES);
@@ -7130,16 +8158,187 @@ int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
 
 	kvm_set_segment(vcpu, &sregs->tr, VCPU_SREG_TR);
 	kvm_set_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG // 144 ds es gs
+	PHMIGRATEPRINTK("[seg] set base 64 cs 0x%llx ds 0x%llx es 0x%llx "
+					"fs 0x%llx gs 0x%llx ss 0x%llx     "
+					"tr 0x%llx ldt 0x%llx (done)\n",
+					sregs->cs.base, sregs->ds.base, sregs->es.base,
+					sregs->fs.base, sregs->gs.base, sregs->ss.base,
+					sregs->tr.base, sregs->ldt.base);
+	PHMIGRATEPRINTK("[seg] set limit 32 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.limit,
+					sregs->ds.limit,
+					sregs->es.limit,
+					sregs->fs.limit,
+					sregs->gs.limit,
+					sregs->ss.limit,
+					sregs->tr.limit,
+					sregs->ldt.limit);
+	PHMIGRATEPRINTK("[seg] set selector 16 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.selector,
+					sregs->ds.selector,
+					sregs->es.selector,
+					sregs->fs.selector,
+					sregs->gs.selector,
+					sregs->ss.selector,
+					sregs->tr.selector,
+					sregs->ldt.selector);
+	PHMIGRATEPRINTK("[seg] set type 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.type,
+					sregs->ds.type,
+					sregs->es.type,
+					sregs->fs.type,
+					sregs->gs.type,
+					sregs->ss.type,
+					sregs->tr.type,
+					sregs->ldt.type);
+	PHMIGRATEPRINTK("[seg] set unusable 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.unusable,
+					sregs->ds.unusable,
+					sregs->es.unusable,
+					sregs->fs.unusable,
+					sregs->gs.unusable,
+					sregs->ss.unusable,
+					sregs->tr.unusable,
+					sregs->ldt.unusable);
+	PHMIGRATEPRINTK("[seg] set padding 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.padding,
+					sregs->ds.padding,
+					sregs->es.padding,
+					sregs->fs.padding,
+					sregs->gs.padding,
+					sregs->ss.padding,
+					sregs->tr.padding,
+					sregs->ldt.padding);
+	PHMIGRATEPRINTK("[seg] set present 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.present,
+					sregs->ds.present,
+					sregs->es.present,
+					sregs->fs.present,
+					sregs->gs.present,
+					sregs->ss.present,
+					sregs->tr.present,
+					sregs->ldt.present);
+	PHMIGRATEPRINTK("[seg] set dpl 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.dpl,
+					sregs->ds.dpl,
+					sregs->es.dpl,
+					sregs->fs.dpl,
+					sregs->gs.dpl,
+					sregs->ss.dpl,
+					sregs->tr.dpl,
+					sregs->ldt.dpl);
+	PHMIGRATEPRINTK("[seg] set db 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.db,
+					sregs->ds.db,
+					sregs->es.db,
+					sregs->fs.db,
+					sregs->gs.db,
+					sregs->ss.db,
+					sregs->tr.db,
+					sregs->ldt.db);
+	PHMIGRATEPRINTK("[seg] set s 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.s,
+					sregs->ds.s,
+					sregs->es.s,
+					sregs->fs.s,
+					sregs->gs.s,
+					sregs->ss.s,
+					sregs->tr.s,
+					sregs->ldt.s);
+	PHMIGRATEPRINTK("[seg] set l 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.l,
+					sregs->ds.l,
+					sregs->es.l,
+					sregs->fs.l,
+					sregs->gs.l,
+					sregs->ss.l,
+					sregs->tr.l,
+					sregs->ldt.l);
+	PHMIGRATEPRINTK("[seg] set g 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.g,
+					sregs->ds.g,
+					sregs->es.g,
+					sregs->fs.g,
+					sregs->gs.g,
+					sregs->ss.g,
+					sregs->tr.g,
+					sregs->ldt.g);
+	PHMIGRATEPRINTK("[seg] set avl 8 cs 0x%x ds 0x%x es 0x%x "
+					"fs 0x%x gs 0x%x ss 0x%x     "
+					"tr 0x%x ldt 0x%x (done)\n",
+					sregs->cs.avl,
+					sregs->ds.avl,
+					sregs->es.avl,
+					sregs->fs.avl,
+					sregs->gs.avl,
+					sregs->ss.avl,
+					sregs->tr.avl,
+					sregs->ldt.avl);
+	// TODO
+#if 0
+struct kvm_segment {
+    __u64 base;
+    __u32 limit;
+    __u16 selector;
+    __u8  type;
+    __u8  present, dpl, db, s, l, g, avl;
+    __u8  unusable;
+    __u8  padding;
+};
+#endif
+#endif
 
 	update_cr8_intercept(vcpu);
 
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	VCPUPRINTK("(vcpu) %s(): setup init state for vcpu %d\n",
+									__func__, vcpu->vcpu_id);
+#endif
 	/* Older userspace won't unhalt the vcpu on reset. */
 	if (kvm_vcpu_is_bsp(vcpu) && kvm_rip_read(vcpu) == 0xfff0 &&
-	    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&
-	    !is_protmode(vcpu))
+		sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&
+		!is_protmode(vcpu)) {
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+		VCPUPRINTK("(vcpu) %s(): \t\tset vcpu %d as the BSP on this node\n",
+												__func__, vcpu->vcpu_id);
+		BUG_ON(distributed_remote_process(current));
+#endif
 		vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;
+	}
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	PHMIGRATEPRINTK("(vcpu) %s(): <%d> get vcpu->arch.mp_state %d\n",
+						__func__, vcpu->vcpu_id, vcpu->arch.mp_state);
+#endif
 
 	kvm_make_request(KVM_REQ_EVENT, vcpu);
+#if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+	PHMIGRATEPRINTK("(vcpu) %s(): <%d> ALL DONE\n",
+						__func__, vcpu->vcpu_id);
+	PHMIGRATEPRINTK("---------- %s(): SET end ----------\n\n", __func__);
+#endif
 
 	return 0;
 }
@@ -7593,6 +8792,17 @@ int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)
 	BUG_ON(vcpu->kvm == NULL);
 	kvm = vcpu->kvm;
 
+#if defined(CONFIG_POPCORN_HYPE) //&& defined(CONFIG_POPCORN_STAT)
+	VCPUPRINTK("(vcpu) [%d] %s: vcpu_id %d\n",
+				current->pid, __func__, vcpu->vcpu_id);
+	VCPUPRINTK("(vcpu) [%d] %s: !irqchip_in_kernel(kvm) ***%s*** || "
+				"kvm_vcpu_is_reset_bsp(vcpu) ***%s***\n",
+				current->pid, __func__,
+				!irqchip_in_kernel(kvm) ? "YES" : "NO",
+				kvm_vcpu_is_reset_bsp(vcpu) ? "YES" : "NO");
+	WARN_ON(current->at_remote && kvm_vcpu_is_reset_bsp(vcpu));
+#endif
+
 	vcpu->arch.pv.pv_unhalted = false;
 	vcpu->arch.emulate_ctxt.ops = &emulate_ops;
 	if (!irqchip_in_kernel(kvm) || kvm_vcpu_is_reset_bsp(vcpu))
@@ -7689,6 +8899,7 @@ int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
 	if (type)
 		return -EINVAL;
 
+
 	INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);
 	INIT_LIST_HEAD(&kvm->arch.active_mmu_pages);
 	INIT_LIST_HEAD(&kvm->arch.zapped_obsolete_pages);
@@ -7707,6 +8918,9 @@ int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
 
 	pvclock_update_vm_gtod_copy(kvm);
 
+#ifdef CONFIG_POPCORN_HYP
+	printk("[kvm_clock]: %s \n", __func__);
+#endif
 	INIT_DELAYED_WORK(&kvm->arch.kvmclock_update_work, kvmclock_update_fn);
 	INIT_DELAYED_WORK(&kvm->arch.kvmclock_sync_work, kvmclock_sync_fn);
 
@@ -7768,13 +8982,30 @@ int __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)
 	if (size) {
 		if (WARN_ON(slot->npages))
 			return -EEXIST;
-
 		/*
 		 * MAP_SHARED to prevent internal slot pages from being moved
 		 * by fork()/COW.
 		 */
+#ifndef CONFIG_POPCORN /* TODO: shouldn't be POPHYPE not POPCORN? */
 		hva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,
 			      MAP_SHARED | MAP_ANONYMOUS, 0);
+#else
+#ifdef CONFIG_POPCORN_HYPE
+#if POPHYPE_PRIVATE_TSS
+		/* serialize in userspace */
+		hva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,
+							  MAP_SHARED | MAP_ANONYMOUS, 0);
+		KVMCLOCKPK("%s(): -> vm_mmap(NULL) id %d gpa 0x%llx size %u => hva %lx\n",
+											__func__, id, gpa, size, hva);
+#else
+		//hva = vma_server_mmap_remote(NULL, 0, size, PROT_READ | PROT_WRITE,
+		//									MAP_SHARED | MAP_ANONYMOUS, 0);
+		BUG();
+		hva = pophype_vm_mmap_anon(size, PROT_READ | PROT_WRITE,
+										  MAP_SHARED | MAP_ANONYMOUS);
+#endif
+#endif
+#endif
 		if (IS_ERR((void *)hva))
 			return PTR_ERR((void *)hva);
 	} else {
@@ -8141,6 +9372,9 @@ void kvm_arch_async_page_ready(struct kvm_vcpu *vcpu, struct kvm_async_pf *work)
 		return;
 
 	vcpu->arch.mmu.page_fault(vcpu, work->gva, 0, true);
+#ifdef CONFIG_POPCORN_HYPE
+						//-2, -2); // dbg
+#endif
 }
 
 static inline u32 kvm_async_pf_hash_fn(gfn_t gfn)
@@ -8369,11 +9603,304 @@ int kvm_arch_update_irqfd_routing(struct kvm *kvm, unsigned int host_irq,
 
 	return kvm_x86_ops->update_pi_irte(kvm, host_irq, guest_irq, set);
 }
+#ifdef CONFIG_POPCORN_HYPE /* pophype migrate */
+/* define in ./include/linux/kvm_host.h */
+void pophype_dump_vmcs()
+{
+#if POPHYPE_MIGRATE_DEBUG
+	/* arch/x86/kvm/vmx.c */
+	PHMIGRATEPRINTK("\n------ %s(): ----- arch/x86/kvm/vmx.c "
+					"START START START -----\n", __func__);
+	kvm_x86_ops->dump_vmcs();
+	/* pophype save vmcs */
+	PHMIGRATEPRINTK("\n------ %s(): ----- arch/x86/kvm/vmx.c "
+					"END END END -----\n\n\n\n\n", __func__);
+#endif
+}
+
+unsigned long pophype_get_kvm_eptfault_new_ns()
+{
+	return kvm_x86_ops->get_kvm_eptfault_new_ns();
+}
+
+unsigned long pophype_get_kvm_eptfault_new_cnt()
+{
+	return kvm_x86_ops->get_kvm_eptfault_new_cnt();
+}
+
+unsigned long pophype_get_user_gva_cnt()
+{
+	return kvm_x86_ops->get_user_gva_cnt();
+}
+unsigned long pophype_get_kernel_gva_cnt()
+{
+	return kvm_x86_ops->get_kernel_gva_cnt();
+}
+unsigned long pophype_get_unknow_gva_cnt()
+{
+	return kvm_x86_ops->get_unknow_gva_cnt();
+}
+unsigned long pophype_get_wrong_validity_gva_cnt()
+{
+	return kvm_x86_ops->get_wrong_validity_gva_cnt();
+}
+unsigned long pophype_get_gva_ret_kernelspace_cnt()
+{
+	return kvm_x86_ops->get_gva_ret_kernelspace_cnt();
+}
+unsigned long pophype_get_gva_ret_userspace_cnt()
+{
+	return kvm_x86_ops->get_gva_ret_userspace_cnt();
+}
+
+void pophype_set_kvm_eptfault_new_ns(u64 data)
+{
+	kvm_x86_ops->set_kvm_eptfault_new_ns(data);
+}
+
+void pophype_set_kvm_eptfault_new_cnt(u64 data)
+{
+	kvm_x86_ops->set_kvm_eptfault_new_cnt(data);
+}
+
+void pophype_set_user_gva_cnt(u64 data)
+{
+	kvm_x86_ops->set_user_gva_cnt(data);
+}
+void pophype_set_kernel_gva_cnt(u64 data)
+{
+	kvm_x86_ops->set_kernel_gva_cnt(data);
+}
+void pophype_set_unknow_gva_cnt(u64 data)
+{
+	kvm_x86_ops->set_unknow_gva_cnt(data);
+}
+void pophype_set_wrong_validity_gva_cnt(u64 data)
+{
+	kvm_x86_ops->set_wrong_validity_gva_cnt(data);
+}
+void pophype_set_gva_ret_kernelspace_cnt(u64 data)
+{
+	kvm_x86_ops->set_gva_ret_kernelspace_cnt(data);
+}
+void pophype_set_gva_ret_userspace_cnt(u64 data)
+{
+	kvm_x86_ops->set_gva_ret_userspace_cnt(data);
+}
+
+/* TODO per vcpu so that no problem, 1 migration 1 data set*/
+//#define MAX_MSR_ENTRIES 25
+//struct pophype_msrs_t {
+//	struct kvm_msrs info;
+//	struct kvm_msr_entry entries[MAX_MSR_ENTRIES];
+//}; //msr_data;
+#include "../../../kernel/popcorn/types.h"
+//struct kvm_msr_entry *pophype_msrs = msr_data.entries;
+/* pophype migrate state cache */
+static struct kvm_mp_state pophype_mp_state[MAX_POPCORN_VCPU];
+static struct kvm_regs pophype_regs[MAX_POPCORN_VCPU];
+static struct kvm_sregs pophype_sregs[MAX_POPCORN_VCPU];
+static struct kvm_fpu pophype_fpu[MAX_POPCORN_VCPU];
+static struct kvm_xcrs pophype_xcrs[MAX_POPCORN_VCPU];
+static struct kvm_lapic_state pophype_lapic[MAX_POPCORN_VCPU];
+static struct kvm_xsave pophype_xsave[MAX_POPCORN_VCPU];
+static struct kvm_vcpu_events pophype_vcpu_events[MAX_POPCORN_VCPU];
+//static struct kvm_data pophype_msrs; // ./arch/x86/include/uapi/asm/kvm.h
+//static struct pophype_msrs_t pophype_msrs; // ./arch/x86/include/uapi/asm/kvm.h
+static struct pophype_kvm_msrs pophype_msrs[MAX_POPCORN_VCPU]; // ./arch/x86/include/uapi/asm/kvm.h
+//void pophype_update_vmcs(struct pophype_migrate_update_info *info, int overwrite)
+//{
+//	/* arch/x86/kvm/vmx.c */
+//	kvm_x86_ops->update_vmcs(info, overwrite);
+//}
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+bool is_saved_vcpu = false; // TODO This is not perfect
+#endif
+void pophype_save_vcpu_states(struct kvm_vcpu *vcpu)
+{
+	int r = 0, n = 0;
+
+	PHMIGRATEPRINTK("\n================ %s(): ===================\n", __func__);
+	PHMIGRATEPRINTK("%s(): pophypemigrate saves vcpu states START\n", __func__);
+	PHMIGRATEPRINTK("================== %s(): ===================\n", __func__);
+
+	/* Let's assume ckpt/vcpu migration  change */
+	PHMIGRATEPRINTK("%s(): [ck] <%d> BUG_ON if vcpu_running %d "
+					"vcpu->arch.mp_state %d (0) vcpu->arch.apf.halted %d (1)\n",
+					__func__, vcpu->vcpu_id, kvm_vcpu_running(vcpu),
+					vcpu->arch.mp_state, vcpu->arch.apf.halted);
+	if (kvm_vcpu_running(vcpu)) {
+		printk(KERN_ERR "BUG: %s(): <%d> BUG_ON if vcpu_running %d = 1 || "
+					"expect vcpu->arch.mp_state %d (0) "
+					"vcpu->arch.apf.halted %d (1) BUT NOT!!!\n",
+					__func__, vcpu->vcpu_id, kvm_vcpu_running(vcpu),
+					vcpu->arch.mp_state, vcpu->arch.apf.halted);
+		printk(KERN_ERR "TODO: fix it here - chage the states\n");
+		//BUG();
+	}
+	// solution: change it here?
+	// It's better to check this again after
+
+	/* define the list of required MSRs */
+	PHMIGRATEPRINTK("TODO: check msrs_to_save %s\n", __FILE__);
+/*
+	static u32 msrs_to_save[] = {
+	MSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,
+	MSR_STAR,
+#ifdef CONFIG_X86_64
+	MSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,
+#endif
+	MSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,
+	MSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,
+};
+*/
+	pophype_msrs[vcpu->vcpu_id].entries[n++].index = MSR_IA32_APICBASE; // no
+	pophype_msrs[vcpu->vcpu_id].entries[n++].index = MSR_IA32_SYSENTER_CS;
+	pophype_msrs[vcpu->vcpu_id].entries[n++].index = MSR_IA32_SYSENTER_ESP;
+	pophype_msrs[vcpu->vcpu_id].entries[n++].index = MSR_IA32_SYSENTER_EIP;
+	pophype_msrs[vcpu->vcpu_id].entries[n++].index = MSR_IA32_CR_PAT;
+	pophype_msrs[vcpu->vcpu_id].entries[n++].index = MSR_IA32_MISC_ENABLE; // no
+	pophype_msrs[vcpu->vcpu_id].entries[n++].index = MSR_IA32_TSC;
+	pophype_msrs[vcpu->vcpu_id].entries[n++].index = MSR_CSTAR;
+	pophype_msrs[vcpu->vcpu_id].entries[n++].index = MSR_STAR;
+	pophype_msrs[vcpu->vcpu_id].entries[n++].index = MSR_EFER; // no (kvm_get_msr_common)
+	pophype_msrs[vcpu->vcpu_id].entries[n++].index = MSR_LSTAR;
+	pophype_msrs[vcpu->vcpu_id].entries[n++].index = MSR_GS_BASE; // no (set)
+	pophype_msrs[vcpu->vcpu_id].entries[n++].index = MSR_FS_BASE; // no (set)
+	pophype_msrs[vcpu->vcpu_id].entries[n++].index = MSR_KERNEL_GS_BASE;
+	//pophype_msrs[vcpu->vcpu_id][n++].index = MSR_IA32_FEATURE_CONTROL;
+	pophype_msrs[vcpu->vcpu_id].nmsrs = n;
+
+
+	kvm_arch_vcpu_ioctl_get_mpstate(vcpu, &pophype_mp_state[vcpu->vcpu_id]); // ./virt/kvm/kvm_main.c
+	kvm_arch_vcpu_ioctl_get_sregs(vcpu, &pophype_sregs[vcpu->vcpu_id]); // ./virt/kvm/kvm_main.c
+	kvm_arch_vcpu_ioctl_get_regs(vcpu, &pophype_regs[vcpu->vcpu_id]); // ./virt/kvm/kvm_main.c
+	PHMIGRATEPRINTK("%s(): ckpt1\n", __func__);
+	//r = msr_io(vcpu, &pophype_msrs, do_get_msr, 1); // KVM_GET_MSRS // TODO argp
+	pophype_msr_io(vcpu, &pophype_msrs[vcpu->vcpu_id], do_get_msr, 1); // KVM_GET_MSRS // TODO argp
+	kvm_vcpu_ioctl_x86_get_xcrs(vcpu, &pophype_xcrs[vcpu->vcpu_id]); // KVM_GET_XCRS (usr)
+	r = kvm_vcpu_ioctl_get_lapic(vcpu, &pophype_lapic[vcpu->vcpu_id]); // KVM_GET_LAPIC
+	WARN_ON(r);
+	kvm_arch_vcpu_ioctl_get_fpu(vcpu, &pophype_fpu[vcpu->vcpu_id]); // ./virt/kvm/kvm_main.c
+	kvm_vcpu_ioctl_x86_get_xsave(vcpu, &pophype_xsave[vcpu->vcpu_id]); // KVM_GET_XSAVE (usr)
+	kvm_vcpu_ioctl_x86_get_vcpu_events(vcpu, &pophype_vcpu_events[vcpu->vcpu_id]); //KVM_GET_VCPU_EVENTS
+	//kvm_arch_vcpu_ioctl_get_mpstate(vcpu, &pophype_mp_state[vcpu->vcpu_id]); // ./virt/kvm/kvm_main.c // qemu ./target/i386/kvm.c (order)
+
+	//int r = 0;
+	//r += msr_io(vcpu, argp, do_set_msr, 0); // KVM_SET_MSRS
+	//r += kvm_vcpu_ioctl_x86_set_xcrs(vcpu, xcrs); // KVM_SET_XCRS
+	//r += kvm_vcpu_ioctl_set_lapic(vcpu, u.lapic); // KVM_SET_LAPIC
+	//r += kvm_vcpu_ioctl_x86_set_xsave(vcpu, u.xsave); // KVM_SET_XSAVE
+	//r += kvm_vcpu_ioctl_x86_set_vcpu_events(vcpu, &events); KVM_SET_VCPU_EVENTS
+	//WARN_ON(r);
+	PHMIGRATEPRINTK("%s(): [rip %llx]\n", __func__,
+					pophype_regs[vcpu->vcpu_id].rip);
+	PHMIGRATEPRINTK("%s(): [cr0 %llx]\n", __func__,
+					pophype_sregs[vcpu->vcpu_id].cr0);
+	PHMIGRATEPRINTK("%s(): [msrs.nmsrs %d]\n", __func__,
+						pophype_msrs[vcpu->vcpu_id].nmsrs);
+	PHMIGRATEPRINTK("%s(): [mp_state %u]\n", __func__,
+				pophype_mp_state[vcpu->vcpu_id].mp_state);
+	PHMIGRATEPRINTK("================ %s(): ===================\n", __func__);
+	PHMIGRATEPRINTK("%s(): pophypemigrate saves vcpu states END\n", __func__);
+	PHMIGRATEPRINTK("================== %s(): ===================\n\n", __func__);
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	is_saved_vcpu = true;
+#endif
+}
+
+struct kvm_mp_state* pophype_get_mp_state(int vcpu_id) { return &pophype_mp_state[vcpu_id]; }
+struct kvm_regs* pophype_get_regs(int vcpu_id) { return &pophype_regs[vcpu_id]; }
+struct kvm_sregs* pophype_get_sregs(int vcpu_id) { return &pophype_sregs[vcpu_id]; }
+struct kvm_fpu* pophype_get_fpu(int vcpu_id) { return &pophype_fpu[vcpu_id]; }
+struct kvm_xcrs* pophype_get_xcrs(int vcpu_id) { return &pophype_xcrs[vcpu_id]; }
+struct kvm_lapic_state* pophype_get_lapic(int vcpu_id) { return &pophype_lapic[vcpu_id]; }
+struct kvm_xsave* pophype_get_xsave(int vcpu_id) { return &pophype_xsave[vcpu_id]; }
+struct kvm_vcpu_events* pophype_get_vcpu_event(int vcpu_id) { return &pophype_vcpu_events[vcpu_id]; }
+//struct kvm_msrs* pophype_get_msrs(int vcpu_id) { return &pophype_msrs; }
+//struct pophype_msrs_t* pophype_get_msrs(int vcpu_id) { return &pophype_msrs; }
+struct pophype_kvm_msrs* pophype_get_msrs(int vcpu_id) { return &pophype_msrs[vcpu_id]; }
+
+void pophype_vcpu_check_vmcs(struct kvm_vcpu *vcpu) {
+	kvm_x86_ops->pophype_check_vmcs(vcpu);
+}
+//int pophype_msr_io(struct kvm_vcpu *vcpu, argp, do_set_msr, 0) {
+//	return msr_io(vcpu, argp, do_set_msr, 0)
+//}
+int pophype_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu, struct kvm_xcrs *xcrs) {
+	return kvm_vcpu_ioctl_x86_set_xcrs(vcpu, xcrs);
+}
+int pophype_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu, struct kvm_lapic_state *lapic) {
+	return kvm_vcpu_ioctl_set_lapic(vcpu, lapic);
+}
+int pophype_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu, struct kvm_xsave *xsave) {
+	return kvm_vcpu_ioctl_x86_set_xsave(vcpu, xsave);
+}
+int pophype_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu, struct kvm_vcpu_events *vcpu_events) {
+	return kvm_vcpu_ioctl_x86_set_vcpu_events(vcpu, vcpu_events);
+}
+int pophype_do_set_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data) {
+	return do_set_msr(vcpu, index, data);
+}
+
+/* See msr_io */
+int pophype_msr_io(struct kvm_vcpu *vcpu, struct pophype_kvm_msrs *msrs,
+//int pophype_msr_io(struct kvm_vcpu *vcpu, struct pophype_msrs_t *msrs,
+//int pophype_msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
+//		    struct kvm_msr_entry *entries,
+			int (*pophype_do_get_set_msr)(struct kvm_vcpu *vcpu, unsigned index, u64 *data),
+			int writeback) {
+	struct kvm_msr_entry *entries;
+	unsigned size;
+	int r;
+	PHMIGRATEPRINTK("<%d> %s(): \"%s\" BUGON(msrs->nmsrs %d >= MAX_IO_MSRS %d);\n",
+			vcpu->vcpu_id, __func__,
+			writeback ? "READ" : "WRITE", msrs->nmsrs, MAX_IO_MSRS);
+
+	BUG_ON(msrs->nmsrs >= MAX_IO_MSRS);
+	size = sizeof(struct kvm_msr_entry) * msrs->nmsrs;
+
+	entries = kmalloc(size, GFP_KERNEL);
+	BUG_ON (IS_ERR(entries));
+	BUG_ON (!entries);
+	memcpy(entries, msrs->entries, size);
+
+	//r = __msr_io(vcpu, msrs, msrs->entries, do_set_msr); // TODO try this w/o alloc
+	//r = __msr_io(vcpu, (struct kvm_msrs*)msrs, entries, do_set_msr);
+	/* pophype_do_get_set_msr is caller specified. Rename it. */
+	r = __msr_io(vcpu, (struct kvm_msrs*)msrs, entries, pophype_do_get_set_msr);
+	// either 	1. static int do_get_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)
+	// or 		2. static int do_set_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)
+	BUG_ON(r < 0);
+
+	if (writeback) { // 1:READ 0: WRITE
+		memcpy(msrs->entries, entries, size);
+	}
+
+	kfree(entries);
+	return 0;
+}
+
+int pophype_read_sysenter_states(struct kvm_vcpu *vcpu)
+{
+	PHMIGRATEPRINTK("[local] Sysenter RSP=%016lx CS:RIP=%04x:%016lx\n",
+			kvm_x86_ops->pophype_vmcs_readl(GUEST_SYSENTER_ESP),
+			(u32)kvm_x86_ops->pophype_vmcs_readl(GUEST_SYSENTER_CS),
+			kvm_x86_ops->pophype_vmcs_readl(GUEST_SYSENTER_EIP));
+	//vmcs_readl(GUEST_SYSENTER_ESP), vmcs_read32(GUEST_SYSENTER_CS), vmcs_readl(GUEST_SYSENTER_EIP);
+
+//	kvm_x86_ops->pophype_vmcs_writel(GUEST_SYSENTER_ESP, val);
+//	kvm_x86_ops->pophype_vmcs_writel(GUEST_SYSENTER_CS, val);
+//	kvm_x86_ops->pophype_vmcs_writel(GUEST_SYSENTER_EIP, val);
+	return 0;
+}
+#endif
 
 EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_exit);
 EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_fast_mmio);
 EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_inj_virq);
 EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_page_fault);
+EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_page_fault_ext);
 EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_msr);
 EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_cr);
 EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmrun);
diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
index fa565913ab65..2268eba2260f 100644
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@ -1269,12 +1269,21 @@ good_area:
 	 * that we made any progress. Handle this case first.
 	 */
 	if (unlikely(fault & VM_FAULT_RETRY)) {
+		// Jack; we rollback RETRY here
 		/* Retry at most once */
 		if (flags & FAULT_FLAG_ALLOW_RETRY) {
 			flags &= ~FAULT_FLAG_ALLOW_RETRY;
 			flags |= FAULT_FLAG_TRIED;
-			if (!fatal_signal_pending(tsk))
+			if (!fatal_signal_pending(tsk)) {
+#ifdef CONFIG_POPCORN_HYPE
+				//if (distributed_process(tsk) && INTERESTED_GVA(address)) {
+				if (distributed_process(tsk) && NOTINTERESTED_GVA(address)) {
+					EPTVPRINTK("[%d] outside retry %lx\n", current->pid, address);
+				}
+				//BUG_ON(fault & VM_FAULT_HYPE_RETRY); /* WRONG: it's a superset */
+#endif
 				goto retry;
+			}
 		}
 
 		/* User mode? Just return to handle the fatal exception */
diff --git a/arch/x86/mm/gup.c b/arch/x86/mm/gup.c
index ae9a37bf1371..c2492d98e21a 100644
--- a/arch/x86/mm/gup.c
+++ b/arch/x86/mm/gup.c
@@ -12,6 +12,44 @@
 
 #include <asm/pgtable.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/types.h>
+int io_gup_cnt = 0;
+int dsm_shortage_cnt = 0;
+int nr_pages_mismatch_cnt = 0;
+
+#ifdef CONFIG_POPCORN_STAT
+atomic64_t iogup_ns = ATOMIC64_INIT(0);
+atomic64_t iogup_cnt = ATOMIC64_INIT(0);
+atomic64_t kvm_eptrefault_ns = ATOMIC64_INIT(0); /* arch/x86/kvm/mmu.c */
+atomic64_t kvm_eptrefault_cnt = ATOMIC64_INIT(0); /* arch/x86/kvm/mmu.c */
+atomic64_t kvm_eptreinv_ns = ATOMIC64_INIT(0); /* arch/x86/kvm/mmu.c */
+atomic64_t kvm_eptreinv_cnt = ATOMIC64_INIT(0); /* arch/x86/kvm/mmu.c */
+atomic64_t kvm_eptreinv_fast_cnt = ATOMIC64_INIT(0); /* arch/x86/kvm/mmu.c */
+#endif
+#if POPHYPE_HOST_KERNEL
+int is_host_kernel = 1;
+#else
+int is_host_kernel = 0;
+#endif
+
+#else // CONFIG_POPCORN_HYPE
+/* */
+#include <popcorn/types.h>
+int is_host_kernel = 1;
+int io_gup_cnt = 0;
+int dsm_shortage_cnt = 0;
+int nr_pages_mismatch_cnt = 0;
+atomic64_t iogup_ns = ATOMIC64_INIT(0);
+atomic64_t iogup_cnt = ATOMIC64_INIT(0);
+atomic64_t kvm_eptrefault_ns = ATOMIC64_INIT(0); /* arch/x86/kvm/mmu.c */
+atomic64_t kvm_eptrefault_cnt = ATOMIC64_INIT(0); /* arch/x86/kvm/mmu.c */
+atomic64_t kvm_eptreinv_ns = ATOMIC64_INIT(0); /* arch/x86/kvm/mmu.c */
+atomic64_t kvm_eptreinv_cnt = ATOMIC64_INIT(0); /* arch/x86/kvm/mmu.c */
+atomic64_t kvm_eptreinv_fast_cnt = ATOMIC64_INIT(0); /* arch/x86/kvm/mmu.c */
+#endif
+
+
 static inline pte_t gup_get_pte(pte_t *ptep)
 {
 #ifndef CONFIG_X86_PAE
@@ -270,6 +308,12 @@ int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
 					(void __user *)start, len)))
 		return 0;
 
+#ifdef CONFIG_POPCORN_HYPE
+    if (distributed_process(current) && INTERESTED_GVA(start)) {
+        GUPFASTPRINTK(" fast[%d] %lx arch/x86/mm/gup.c\n", current->pid, start);
+    }
+#endif
+
 	/*
 	 * XXX: batch / limit 'nr', to avoid large irq off latency
 	 * needs some instrumenting to determine the common sizes used by
@@ -323,6 +367,10 @@ int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
 int get_user_pages_fast(unsigned long start, int nr_pages, int write,
 			struct page **pages)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	/* Never happen in pophype */
+	static int cnt = 0;
+#endif
 	struct mm_struct *mm = current->mm;
 	unsigned long addr, len, end;
 	unsigned long next;
@@ -386,9 +434,113 @@ slow_irqon:
 		start += nr << PAGE_SHIFT;
 		pages += nr;
 
+#ifdef CONFIG_POPCORN_HYPE
+		/* since both this func get_user_pages_fast() and
+			get_user_pages_unlocked() return pages_done,
+			we can implment here or outside of this func (iov_iter_get_pages()).
+
+			Here I'm checking where should I do it, if there are too many here,
+			I can implemente here for general. Otherwise, I just implement
+			outside because only tx uses it. This will also make code more
+			easy to read.
+
+			It turns out only iov_iter_get_pages() use it. I will move the code
+			to iov_iter_get_pages;
+
+			Note the sentence above: "Direct-IO is the main guy that
+										batches up lots of get_user_pages."
+		*/
+		cnt++;
+		if (distributed_process(current)) { /* from tx */
+			/* pophype io_gup_single_page */
+			unsigned long new_nr_pages = (end - start) >> PAGE_SHIFT;
+#ifdef CONFIG_POPCORN_STAT
+			ktime_t dt, iogup_end, iogup_start = ktime_get();
+#endif
+#ifdef CONFIG_POPCORN_STAT
+			io_gup_cnt += new_nr_pages;
+#endif
+			/* Attention: nr_pages (func input) new_nr_pages (calced in func) */
+			DSMPATCHPK("%s %s(): nr_pages %d (func in) new_nr_pages %lu #%d\n",
+							__FILE__, __func__, nr_pages, new_nr_pages, cnt);
+			if (nr_pages != new_nr_pages) {
+				/* This happens but I believe new_nr_pages is correct */
+				//WARN_ON(-1);
+#ifdef CONFIG_POPCORN_STAT
+				/* real fetch - who's input? */
+				nr_pages_mismatch_cnt += new_nr_pages - nr_pages;
+#endif
+				DSMPATCHPK("\n\nnr_pages (%d) != new_nr_pages (%lu)\n\n",
+													nr_pages, new_nr_pages);
+			}
+#define POPHYPE_TX_MULTIPAGE_BUT_PATCH 1
+#if POPHYPE_TX_MULTIPAGE_BUT_PATCH
+			if (new_nr_pages > 1) { // multi-page but pophype doesn't support so
+								// break it down to be individual
+				int pg_left = new_nr_pages;
+#ifdef CONFIG_POPCORN_STAT
+				dsm_shortage_cnt += pg_left;
+#endif
+				while (pg_left) {
+					DSMPATCHPK("pophype %s %s(): my patch for dsm shortage "
+						"%d/%lu\n", __FILE__, __func__, pg_left, new_nr_pages);
+					ret = get_user_pages_unlocked(current, mm, start, 1,
+									  write, 0, pages);
+					// TODO: what should I do for ret and new_nr_pages & nr !!!!
+					// 1. check ret
+					// 2. ret eventually return ret so ret = new_nr_pages
+					// 3. nr
+					BUG_ON(ret != 1); /* dsm shortage + error (-) detection */
+
+					pg_left--;
+
+					/* next - ptr/value moves on */
+					start += PAGE_SIZE; // = addr
+					pages++; // struct page *pages[MAX_SKB_FRAGS];
+				}
+				DSMPATCHPK("pophype %s %s(): my patch DONE!\n",
+											__FILE__, __func__);
+				// 2
+				// 3 nr is a vanilla product
+				ret = new_nr_pages + nr; /* new_nr_pages = vanilla ret. nr =  */
+				return ret; /* my own path */
+			} else { // normal single page
+				ret = get_user_pages_unlocked(current, mm, start,
+							  (end - start) >> PAGE_SHIFT, /* pophype: <= 1 */
+							  write, 0, pages);
+				/* fall through */
+			}
+#endif
+
+#if !POPHYPE_TX_MULTIPAGE_BUT_PATCH
+		/* need to remove */
 		ret = get_user_pages_unlocked(current, mm, start,
 					      (end - start) >> PAGE_SHIFT,
 					      write, 0, pages);
+#endif
+#ifdef CONFIG_POPCORN_STAT
+		iogup_end = ktime_get();
+		dt = ktime_sub(iogup_end, iogup_start);
+		atomic64_add(ktime_to_ns(dt), &iogup_ns);
+		//atomic64_inc(&iogup_cnt);
+		atomic64_add(new_nr_pages, &iogup_cnt); /* 0515 - iogup_cnt=0 */
+#endif
+		} else {
+			ret = get_user_pages_unlocked(current, mm, start,
+							  (end - start) >> PAGE_SHIFT,
+							  write, 0, pages);
+
+		}
+#else /* vanilla io_gup_pages*/
+#if defined(CONFIG_POPCORN_STAT)
+		if (!is_host_kernel) {
+			atomic64_add((end - start) >> PAGE_SHIFT, &iogup_cnt);
+		}
+#endif
+		ret = get_user_pages_unlocked(current, mm, start,
+					      (end - start) >> PAGE_SHIFT,
+					      write, 0, pages);
+#endif
 
 		/* Have to be a bit careful with return values */
 		if (nr > 0) {
@@ -398,6 +550,66 @@ slow_irqon:
 				ret += nr;
 		}
 
-		return ret;
+		return ret; /* succ: return pages_done */
+	}
+}
+
+/***
+ * Pophype
+ */
+void pophype_net_gup(struct seq_file *seq, void *v)
+{
+#ifdef CONFIG_POPCORN_STAT
+    if (seq) {
+		/* memcached only */
+		seq_printf(seq, "%s %d (test - redundant)\n", /* # of single page fault from net */
+					"io_gup_cnt (total)", io_gup_cnt);
+		/* in ./arch/x86/kvm/mmu.c */
+		seq_printf(seq, "%10s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+                    "iogup", (atomic64_read(&iogup_ns) / 1000) / MICROSECOND,
+                            (atomic64_read(&iogup_ns) / 1000)  % MICROSECOND,
+                    "cnt", atomic64_read(&iogup_cnt),
+                    "per", atomic64_read(&iogup_cnt) ?
+								 atomic64_read(&iogup_ns) /
+									atomic64_read(&iogup_cnt) / 1000 : 0);
+		/* ept retry info in ./arch/x86/kvm/mmu.c */
+		seq_printf(seq, "%10s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+					"eptrefault", (atomic64_read(&kvm_eptrefault_ns) / 1000) / MICROSECOND,
+							(atomic64_read(&kvm_eptrefault_ns) / 1000)  % MICROSECOND,
+					"cnt", atomic64_read(&kvm_eptrefault_cnt),
+					"per", atomic64_read(&kvm_eptrefault_cnt) ?
+					 atomic64_read(&kvm_eptrefault_ns) / atomic64_read(&kvm_eptrefault_cnt) / 1000 : 0);
+		seq_printf(seq, "%10s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+					"eptreinv", (atomic64_read(&kvm_eptreinv_ns) / 1000) / MICROSECOND,
+							(atomic64_read(&kvm_eptreinv_ns) / 1000)  % MICROSECOND,
+					"cnt", atomic64_read(&kvm_eptreinv_cnt),
+					"per", atomic64_read(&kvm_eptreinv_cnt) ?
+					 atomic64_read(&kvm_eptreinv_ns) / atomic64_read(&kvm_eptreinv_cnt) / 1000 : 0);
+		seq_printf(seq, "%12s  %10d.%06d (s)  %3s %-10ld   %3s %-6d (us)\n",
+					"eptreinvfast", 0, 0,
+					"cnt", atomic64_read(&kvm_eptreinv_fast_cnt),
+					"per", 0);
+
+
+
+		seq_printf(seq, "%s %d\n", /* These # of pages are handled by pophype */
+					"dsm_shortage_cnt", dsm_shortage_cnt);
+		seq_printf(seq, "%s %d\n",
+					"nr_pages_mismatch_cnt", nr_pages_mismatch_cnt);
+	} else { /* clear */
+		io_gup_cnt = 0;
+		//seq_printf(seq, "is_host_kernel (%c)", is_host_kernel ? 'O' : 'X');
+		atomic64_set(&iogup_cnt, 0);
+        atomic64_set(&iogup_ns, 0);
+
+		atomic64_set(&kvm_eptrefault_ns, 0);
+		atomic64_set(&kvm_eptrefault_cnt, 0);
+		atomic64_set(&kvm_eptreinv_ns, 0);
+		atomic64_set(&kvm_eptreinv_cnt, 0);
+		atomic64_set(&kvm_eptreinv_fast_cnt, 0);
+
+		dsm_shortage_cnt = 0;
+		nr_pages_mismatch_cnt = 0;
 	}
+#endif
 }
diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c
index 7cad01af6dcd..c94023ce24df 100644
--- a/arch/x86/mm/tlb.c
+++ b/arch/x86/mm/tlb.c
@@ -15,6 +15,11 @@
 #include <asm/uv/uv.h>
 #include <asm/kaiser.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#include <popcorn/types.h>
+#endif
+
 /*
  *	TLB flushing, formerly SMP-only
  *		c/o Linus Torvalds.
@@ -289,6 +294,15 @@ void native_flush_tlb_others(const struct cpumask *cpumask,
 								&info, 1);
 		return;
 	}
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	if (distributed_process(current)) {
+		static int cnt = 0;
+		cnt++;
+		printk("%s(): #%d", __func__, cnt);
+	}
+#endif
+#endif
 	smp_call_function_many(cpumask, flush_tlb_func, &info, 1);
 }
 
diff --git a/arch/x86/platform/intel-mid/intel-mid.c b/arch/x86/platform/intel-mid/intel-mid.c
index 1bbc21e2e4ae..cf2b10b898b7 100644
--- a/arch/x86/platform/intel-mid/intel-mid.c
+++ b/arch/x86/platform/intel-mid/intel-mid.c
@@ -83,6 +83,9 @@ static unsigned long __init intel_mid_calibrate_tsc(void)
 
 static void __init intel_mid_setup_bp_timer(void)
 {
+#ifdef CONFIG_POPCORN_HYPE
+    POP_PK("\t\tpophype_init: %s(): [%d]\n", __func__, current->pid);
+#endif
 	apbt_time_init();
 	setup_boot_APIC_clock();
 }
diff --git a/block/blk-core.c b/block/blk-core.c
index f5f1a55703ae..75b0559aebbb 100644
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@ -37,6 +37,11 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/block.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+//#include <popcorn/bundle.h>
+#include <popcorn/debug.h>
+#endif
+
 #include "blk.h"
 #include "blk-mq.h"
 
@@ -2030,6 +2035,11 @@ blk_qc_t generic_make_request(struct bio *bio)
 	 */
 	struct bio_list bio_list_on_stack[2];
 	blk_qc_t ret = BLK_QC_T_NONE;
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	GSMPBSPPRINTK("\t<%d> %s(): 1\n", smp_processor_id(), __func__);
+#endif
+#endif
 
 	if (!generic_make_request_checks(bio))
 		goto out;
@@ -2101,6 +2111,11 @@ blk_qc_t generic_make_request(struct bio *bio)
 	current->bio_list = NULL; /* deactivate */
 
 out:
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	GSMPBSPPRINTK("\t<%d> %s(): 2\n", smp_processor_id(), __func__);
+#endif
+#endif
 	return ret;
 }
 EXPORT_SYMBOL(generic_make_request);
@@ -2148,6 +2163,11 @@ blk_qc_t submit_bio(int rw, struct bio *bio)
 				count);
 		}
 	}
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	GSMPBSPPRINTK("\t<%d> %s():\n", smp_processor_id(), __func__);
+#endif
+#endif
 
 	return generic_make_request(bio);
 }
diff --git a/build.sh b/build.sh
new file mode 100755
index 000000000000..b8b586cb6cd2
--- /dev/null
+++ b/build.sh
@@ -0,0 +1,51 @@
+#!/bin/bash
+
+echo -e "\n\nTHIS FILE IS FROM MIR* OR MIR\n\n"
+echo "0: skip \$make"
+echo "Input counts: $#"
+echo "First arg: $1"
+if [ "$1" = "0" ];
+then
+    echo "skiped \$make"
+else
+    echo "make -j32"
+	make -j32
+fi
+
+KERNEL_PATH=~/kh
+echo "restore #define POPHYPE_HOST_KERNEL 1 in $KERNEL_PATH/include/popcorn/debug.h"
+sed -i 's/#define POPHYPE_HOST_KERNEL 0/#define POPHYPE_HOST_KERNEL 1/g' $KERNEL_PATH/include/popcorn/debug.h
+
+make -j32 -C msg_layer
+ret=$?
+if [[ $ret != 0 ]]; then
+	exit -1
+fi
+make modules -j32 && \
+sudo make modules_install && \
+sudo make install
+
+#echo "\n\n\n\n\n\n"
+#sudo make modules_install -j32 -C /home/jackchuang/share/popcorn-rack
+
+#echo "\n\n\n\n\n\n"
+#sudo make install -C /home/jackchuang/share/popcorn-rack
+#sudo grub-set-default 1
+
+#ssh echo5 "make -C /mnt/popcorn-rack -j99"
+#ssh echo5 "sudo make modules_install -j99"
+#for i in {5..6..1}
+#do
+#	ssh echo$i "sudo make install -C /mnt/popcorn-rack"
+#	ssh echo$i "sudo reboot"
+#
+#    for j in {1..10..1}
+#    do
+#        echo "done on echo$i"
+#    done
+#
+#	sleep 5
+#	sudo ipmitool -I lanplus -H ipmi$i -U ADMIN -P ADMIN chassis power cycle
+#done
+ret=$?
+exit $ret
diff --git a/config_pophype b/config_pophype
new file mode 100644
index 000000000000..a06747afb1f8
--- /dev/null
+++ b/config_pophype
@@ -0,0 +1,3362 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/x86 4.4.137 Kernel Configuration
+#
+CONFIG_64BIT=y
+CONFIG_X86_64=y
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_PERF_EVENTS_INTEL_UNCORE=y
+CONFIG_OUTPUT_FORMAT="elf64-x86-64"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/x86_64_defconfig"
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+CONFIG_ZONE_DMA32=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_HAVE_INTEL_TXT=y
+CONFIG_X86_64_SMP=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PGTABLE_LEVELS=4
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION="-pop-hype"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KERNEL_XZ=y
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_FHANDLE=y
+CONFIG_USELIB=y
+CONFIG_AUDIT=y
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_EXPEDITE_BOOT is not set
+CONFIG_BUILD_BIN2C=y
+CONFIG_IKCONFIG=m
+# CONFIG_IKCONFIG_PROC is not set
+CONFIG_LOG_BUF_SHIFT=21
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
+CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH=y
+CONFIG_ARCH_SUPPORTS_INT128=y
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_PIDS is not set
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_PAGE_COUNTER=y
+CONFIG_MEMCG=y
+# CONFIG_MEMCG_KMEM is not set
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+CONFIG_CGROUP_WRITEBACK=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_RD_LZ4=y
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_HAVE_PCSPKR_PLATFORM=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+CONFIG_SGETMASK_SYSCALL=y
+CONFIG_SYSFS_SYSCALL=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_BPF_SYSCALL is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_USERFAULTFD is not set
+CONFIG_PCI_QUIRKS=y
+CONFIG_MEMBARRIER=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_KEXEC_CORE=y
+# CONFIG_OPROFILE is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_OPROFILE_NMI_TIMER=y
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+CONFIG_OPTPROBES=y
+CONFIG_KPROBES_ON_FTRACE=y
+CONFIG_UPROBES=y
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_KRETPROBES=y
+CONFIG_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_KPROBES_ON_FTRACE=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_ARCH_WANT_OLD_COMPAT_IPC=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR_NONE is not set
+CONFIG_CC_STACKPROTECTOR_REGULAR=y
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_HAVE_ARCH_HUGE_VMAP=y
+CONFIG_HAVE_ARCH_SOFT_DIRTY=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_COPY_THREAD_TLS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_BLK_DEV_THROTTLING=y
+# CONFIG_BLK_CMDLINE_PARSER is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+# CONFIG_CMDLINE_PARTITION is not set
+CONFIG_BLOCK_COMPAT=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_PREEMPT_NOTIFIERS=y
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_ARCH_USE_QUEUED_SPINLOCKS=y
+CONFIG_QUEUED_SPINLOCKS=y
+CONFIG_ARCH_USE_QUEUED_RWLOCKS=y
+CONFIG_QUEUED_RWLOCKS=y
+CONFIG_FREEZER=y
+
+#
+# Popcorn Distributed Execution Support
+#
+CONFIG_ARCH_SUPPORTS_POPCORN=y
+CONFIG_POPCORN=y
+CONFIG_POPCORN_HYPE=y
+CONFIG_POPCORN_DEBUG=y
+CONFIG_POPCORN_DEBUG_PROCESS_SERVER=y
+CONFIG_POPCORN_DEBUG_PAGE_SERVER=y
+CONFIG_POPCORN_DEBUG_VMA_SERVER=y
+CONFIG_POPCORN_DEBUG_VERBOSE=y
+CONFIG_POPCORN_DEBUG_HYPE=y
+CONFIG_POPCORN_DEBUG_HYPE_EPT=y
+CONFIG_POPCORN_DEBUG_HYPE_EPT_VERBOSE=y
+CONFIG_POPCORN_DEBUG_DEBUG=y
+CONFIG_POPCORN_CHECK_SANITY=y
+# CONFIG_POPCORN_REMOTE_INFO is not set
+CONFIG_POPCORN_STAT=y
+CONFIG_POPCORN_STAT_PGFAULTS=y
+# CONFIG_POPCORN_STAT_MSG is not set
+CONFIG_POPCORN_KMSG=y
+CONFIG_POPCORN_KMSG_SOCKET=m
+CONFIG_POPCORN_KMSG_RDMA=m
+CONFIG_POPCORN_KMSG_TEST=m
+CONFIG_POPCORN_DEBUG_MSG_LAYER=y
+
+#
+# Processor type and features
+#
+CONFIG_ZONE_DMA=y
+CONFIG_SMP=y
+CONFIG_X86_FEATURE_NAMES=y
+CONFIG_X86_X2APIC=y
+CONFIG_X86_MPPARSE=y
+CONFIG_RETPOLINE=y
+# CONFIG_X86_EXTENDED_PLATFORM is not set
+CONFIG_X86_INTEL_LPSS=y
+# CONFIG_X86_AMD_PLATFORM_DEVICE is not set
+CONFIG_IOSF_MBI=m
+# CONFIG_IOSF_MBI_DEBUG is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+CONFIG_HYPERVISOR_GUEST=y
+CONFIG_PARAVIRT=y
+# CONFIG_PARAVIRT_DEBUG is not set
+# CONFIG_PARAVIRT_SPINLOCKS is not set
+CONFIG_XEN=y
+CONFIG_XEN_DOM0=y
+CONFIG_XEN_PVHVM=y
+CONFIG_XEN_512GB=y
+CONFIG_XEN_SAVE_RESTORE=y
+# CONFIG_XEN_DEBUG_FS is not set
+CONFIG_XEN_PVH=y
+CONFIG_KVM_GUEST=y
+# CONFIG_KVM_DEBUG_FS is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+CONFIG_PARAVIRT_CLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MK8 is not set
+# CONFIG_MPSC is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MATOM is not set
+CONFIG_GENERIC_CPU=y
+CONFIG_X86_INTERNODE_CACHE_SHIFT=6
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=64
+CONFIG_X86_DEBUGCTLMSR=y
+# CONFIG_PROCESSOR_SELECT is not set
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+CONFIG_GART_IOMMU=y
+CONFIG_CALGARY_IOMMU=y
+CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT=y
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_MAXSMP is not set
+CONFIG_NR_CPUS=512
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_X86_MCE_THRESHOLD=y
+# CONFIG_X86_MCE_INJECT is not set
+CONFIG_X86_THERMAL_VECTOR=y
+# CONFIG_VM86 is not set
+CONFIG_X86_16BIT=y
+CONFIG_X86_ESPFIX64=y
+CONFIG_X86_VSYSCALL_EMULATION=y
+# CONFIG_I8K is not set
+CONFIG_MICROCODE=y
+CONFIG_MICROCODE_INTEL=y
+CONFIG_MICROCODE_AMD=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+# CONFIG_X86_MSR is not set
+# CONFIG_X86_CPUID is not set
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_X86_DIRECT_GBPAGES=y
+CONFIG_NUMA=y
+CONFIG_AMD_NUMA=y
+CONFIG_X86_64_ACPI_NUMA=y
+CONFIG_NODES_SPAN_OTHER_NODES=y
+CONFIG_NUMA_EMU=y
+CONFIG_NODES_SHIFT=6
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_ARCH_DISCARD_MEMBLOCK=y
+CONFIG_MEMORY_ISOLATION=y
+# CONFIG_MOVABLE_NODE is not set
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+# CONFIG_MEMORY_HOTPLUG is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK=y
+CONFIG_MEMORY_BALLOON=y
+# CONFIG_COMPACTION is not set
+# CONFIG_MIGRATION is not set
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_MMU_NOTIFIER=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_MEMORY_FAILURE=y
+# CONFIG_HWPOISON_INJECT is not set
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CMA is not set
+CONFIG_MEM_SOFT_DIRTY=y
+# CONFIG_ZPOOL is not set
+CONFIG_ZBUD=y
+CONFIG_ZSMALLOC=y
+# CONFIG_PGTABLE_MAPPING is not set
+# CONFIG_ZSMALLOC_STAT is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+CONFIG_ARCH_SUPPORTS_DEFERRED_STRUCT_PAGE_INIT=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_X86_PMEM_LEGACY is not set
+# CONFIG_X86_CHECK_BIOS_CORRUPTION is not set
+CONFIG_X86_RESERVE_LOW=64
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_ARCH_RANDOM=y
+CONFIG_X86_SMAP=y
+# CONFIG_X86_INTEL_MPX is not set
+CONFIG_EFI=y
+CONFIG_EFI_STUB=y
+CONFIG_EFI_MIXED=y
+CONFIG_SECCOMP=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+# CONFIG_RANDOMIZE_BASE is not set
+CONFIG_PHYSICAL_ALIGN=0x200000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_BOOTPARAM_HOTPLUG_CPU0 is not set
+# CONFIG_DEBUG_HOTPLUG_CPU0 is not set
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_LEGACY_VSYSCALL_NATIVE is not set
+CONFIG_LEGACY_VSYSCALL_EMULATE=y
+# CONFIG_LEGACY_VSYSCALL_NONE is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MODIFY_LDT_SYSCALL=y
+CONFIG_HAVE_LIVEPATCH=y
+# CONFIG_LIVEPATCH is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_USE_PERCPU_NUMA_NODE_ID=y
+
+#
+# Power management and ACPI options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+CONFIG_HIBERNATE_CALLBACKS=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+# CONFIG_PM_TEST_SUSPEND is not set
+CONFIG_PM_SLEEP_DEBUG=y
+# CONFIG_DPM_WATCHDOG is not set
+# CONFIG_PM_TRACE_RTC is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_LEGACY_TABLES_LOOKUP=y
+CONFIG_ARCH_MIGHT_HAVE_ACPI_PDC=y
+CONFIG_ACPI_SYSTEM_POWER_STATES_SUPPORT=y
+# CONFIG_ACPI_DEBUGGER is not set
+CONFIG_ACPI_SLEEP=y
+# CONFIG_ACPI_PROCFS_POWER is not set
+CONFIG_ACPI_REV_OVERRIDE_POSSIBLE=y
+# CONFIG_ACPI_EC_DEBUGFS is not set
+# CONFIG_ACPI_AC is not set
+# CONFIG_ACPI_BATTERY is not set
+CONFIG_ACPI_BUTTON=m
+# CONFIG_ACPI_FAN is not set
+CONFIG_ACPI_DOCK=y
+CONFIG_ACPI_CPU_FREQ_PSS=y
+CONFIG_ACPI_PROCESSOR_IDLE=y
+CONFIG_ACPI_PROCESSOR=m
+# CONFIG_ACPI_IPMI is not set
+CONFIG_ACPI_HOTPLUG_CPU=y
+CONFIG_ACPI_PROCESSOR_AGGREGATOR=m
+# CONFIG_ACPI_THERMAL is not set
+CONFIG_ACPI_NUMA=y
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+CONFIG_ACPI_INITRD_TABLE_OVERRIDE=y
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_PCI_SLOT=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_ACPI_HOTPLUG_IOAPIC=y
+# CONFIG_ACPI_SBS is not set
+CONFIG_ACPI_HED=y
+# CONFIG_ACPI_CUSTOM_METHOD is not set
+CONFIG_ACPI_BGRT=y
+# CONFIG_ACPI_REDUCED_HARDWARE_ONLY is not set
+# CONFIG_ACPI_NFIT is not set
+CONFIG_HAVE_ACPI_APEI=y
+CONFIG_HAVE_ACPI_APEI_NMI=y
+CONFIG_ACPI_APEI=y
+CONFIG_ACPI_APEI_GHES=y
+CONFIG_ACPI_APEI_PCIEAER=y
+CONFIG_ACPI_APEI_MEMORY_FAILURE=y
+# CONFIG_ACPI_APEI_EINJ is not set
+# CONFIG_ACPI_APEI_ERST_DEBUG is not set
+CONFIG_ACPI_EXTLOG=y
+# CONFIG_PMIC_OPREGION is not set
+CONFIG_SFI=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+# CONFIG_CPU_FREQ_STAT is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# CPU frequency scaling drivers
+#
+CONFIG_X86_INTEL_PSTATE=y
+# CONFIG_X86_PCC_CPUFREQ is not set
+# CONFIG_X86_ACPI_CPUFREQ is not set
+# CONFIG_X86_SPEEDSTEP_CENTRINO is not set
+# CONFIG_X86_P4_CLOCKMOD is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+CONFIG_INTEL_IDLE=y
+
+#
+# Memory power savings
+#
+# CONFIG_I7300_IDLE is not set
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCI_XEN=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_HOTPLUG_PCI_PCIE=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIEAER_INJECT is not set
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PME=y
+CONFIG_PCI_BUS_ADDR_T_64BIT=y
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+# CONFIG_PCI_DEBUG is not set
+CONFIG_PCI_REALLOC_ENABLE_AUTO=y
+# CONFIG_PCI_STUB is not set
+# CONFIG_XEN_PCIDEV_FRONTEND is not set
+CONFIG_HT_IRQ=y
+CONFIG_PCI_ATS=y
+CONFIG_PCI_IOV=y
+CONFIG_PCI_PRI=y
+CONFIG_PCI_PASID=y
+CONFIG_PCI_LABEL=y
+
+#
+# PCI host controller drivers
+#
+CONFIG_ISA_DMA_API=y
+CONFIG_AMD_NB=y
+# CONFIG_PCCARD is not set
+CONFIG_HOTPLUG_PCI=y
+CONFIG_HOTPLUG_PCI_ACPI=y
+# CONFIG_HOTPLUG_PCI_ACPI_IBM is not set
+CONFIG_HOTPLUG_PCI_CPCI=y
+# CONFIG_HOTPLUG_PCI_CPCI_ZT5550 is not set
+# CONFIG_HOTPLUG_PCI_CPCI_GENERIC is not set
+CONFIG_HOTPLUG_PCI_SHPC=m
+# CONFIG_RAPIDIO is not set
+# CONFIG_X86_SYSFB is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=m
+CONFIG_COREDUMP=y
+CONFIG_IA32_EMULATION=y
+CONFIG_IA32_AOUT=y
+CONFIG_X86_X32=y
+CONFIG_COMPAT=y
+CONFIG_COMPAT_FOR_U64_ALIGNMENT=y
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_X86_DEV_DMA_OPS=y
+CONFIG_PMC_ATOM=y
+CONFIG_NET=y
+CONFIG_NET_INGRESS=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+CONFIG_XFRM_SUB_POLICY=y
+CONFIG_XFRM_MIGRATE=y
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_TRIE_STATS=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_NET_IP_TUNNEL is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_SYN_COOKIES=y
+# CONFIG_NET_UDP_TUNNEL is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_UDP_DIAG=y
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+# CONFIG_TCP_CONG_DCTCP is not set
+# CONFIG_TCP_CONG_CDG is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+CONFIG_IPV6_MIP6=y
+# CONFIG_IPV6_ILA is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_BEET is not set
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+# CONFIG_IPV6_SIT is not set
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_GRE is not set
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IPV6_PIMSM_V2=y
+# CONFIG_NETLABEL is not set
+CONFIG_NETWORK_SECMARK=y
+CONFIG_NET_PTP_CLASSIFY=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+# CONFIG_BRIDGE_NETFILTER is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_INGRESS=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NF_CONNTRACK is not set
+# CONFIG_NF_TABLES is not set
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+# CONFIG_NETFILTER_XT_TARGET_LOG is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_SECMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_BPF is not set
+# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ECN is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HL is not set
+# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
+# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
+# CONFIG_NETFILTER_XT_MATCH_L2TP is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+# CONFIG_NETFILTER_XT_MATCH_LIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+# CONFIG_NF_DUP_IPV4 is not set
+# CONFIG_NF_LOG_ARP is not set
+# CONFIG_NF_LOG_IPV4 is not set
+# CONFIG_NF_REJECT_IPV4 is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV6 is not set
+# CONFIG_NF_DUP_IPV6 is not set
+# CONFIG_NF_REJECT_IPV6 is not set
+# CONFIG_NF_LOG_IPV6 is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+CONFIG_STP=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+# CONFIG_NET_SCH_FQ is not set
+# CONFIG_NET_SCH_HHF is not set
+# CONFIG_NET_SCH_PIE is not set
+# CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_PLUG is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+# CONFIG_NET_CLS_BPF is not set
+# CONFIG_NET_CLS_FLOWER is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+# CONFIG_NET_EMATCH_U32 is not set
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_ACT_VLAN is not set
+# CONFIG_NET_ACT_BPF is not set
+CONFIG_NET_SCH_FIFO=y
+CONFIG_DCB=y
+CONFIG_DNS_RESOLVER=m
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+CONFIG_NETLINK_DIAG=y
+CONFIG_MPLS=y
+CONFIG_NET_MPLS_GSO=y
+# CONFIG_MPLS_ROUTING is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_CGROUP_NET_CLASSID=y
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+CONFIG_BPF_JIT=y
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+# CONFIG_NET_9P_RDMA is not set
+# CONFIG_NET_9P_DEBUG is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_LWTUNNEL is not set
+# CONFIG_DST_CACHE is not set
+CONFIG_HAVE_BPF_JIT=y
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+# CONFIG_DEVTMPFS_MOUNT is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_GENERIC_CPU_VULNERABILITIES=y
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_FENCE_TRACE is not set
+
+#
+# Bus devices
+#
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_OF is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG_MESSAGES is not set
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_ZRAM is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_SKD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_XEN_BLKDEV_FRONTEND is not set
+CONFIG_VIRTIO_BLK=y
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+# CONFIG_BLK_DEV_NVME is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_INTEL_MEI=m
+CONFIG_INTEL_MEI_ME=m
+# CONFIG_INTEL_MEI_TXE is not set
+# CONFIG_VMWARE_VMCI is not set
+
+#
+# Intel MIC Bus Driver
+#
+# CONFIG_INTEL_MIC_BUS is not set
+
+#
+# SCIF Bus Driver
+#
+# CONFIG_SCIF_BUS is not set
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+# CONFIG_GENWQE is not set
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_KERNEL_API is not set
+# CONFIG_CXL_EEH is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=m
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=m
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_MQ_DEFAULT is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_SCSI_ESAS2R is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT3SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_VMWARE_PVSCSI is not set
+# CONFIG_XEN_SCSI_FRONTEND is not set
+# CONFIG_SCSI_SNIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_ISCI is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_WD719X is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_VIRTIO is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=m
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_ZPODD=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI=m
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+# CONFIG_ATA_SFF is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_BCACHE is not set
+# CONFIG_BLK_DEV_DM is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+# CONFIG_IFB is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+CONFIG_TUN=y
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_VETH is not set
+CONFIG_VIRTIO_NET=y
+# CONFIG_NLMON is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+# CONFIG_VHOST_NET is not set
+# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+CONFIG_ETHERNET=y
+CONFIG_MDIO=m
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_CX_ECAT is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_HP is not set
+CONFIG_NET_VENDOR_INTEL=y
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IXGB is not set
+CONFIG_IXGBE=m
+CONFIG_IXGBE_HWMON=y
+CONFIG_IXGBE_DCA=y
+CONFIG_IXGBE_DCB=y
+# CONFIG_IXGBEVF is not set
+# CONFIG_I40E is not set
+# CONFIG_I40EVF is not set
+# CONFIG_FM10K is not set
+CONFIG_NET_VENDOR_I825XX=y
+# CONFIG_JME is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+CONFIG_MLX5_CORE=m
+CONFIG_MLX5_CORE_EN=y
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_SFC is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_NET_SB1000 is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Host-side USB support is needed for USB Network Adapter support
+#
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_XEN_NETDEV_FRONTEND is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_FUJITSU_ES is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
+CONFIG_SERIO_I8042=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVMEM is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DMA=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_RSA=y
+# CONFIG_SERIAL_8250_FSL is not set
+# CONFIG_SERIAL_8250_DW is not set
+# CONFIG_SERIAL_8250_RT288X is not set
+# CONFIG_SERIAL_8250_FINTEK is not set
+# CONFIG_SERIAL_8250_MID is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_TTY_PRINTK is not set
+CONFIG_HVC_DRIVER=y
+# CONFIG_HVC_XEN is not set
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_IPMI_HANDLER=m
+# CONFIG_IPMI_PANIC_EVENT is not set
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+# CONFIG_IPMI_SI_PROBE_DEFAULTS is not set
+# CONFIG_IPMI_SSIF is not set
+CONFIG_IPMI_WATCHDOG=m
+CONFIG_IPMI_POWEROFF=m
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_VIA=y
+CONFIG_HW_RANDOM_VIRTIO=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_MWAVE is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_HPET=y
+CONFIG_HPET_MMAP=y
+CONFIG_HPET_MMAP_DEFAULT=y
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_MUX=m
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=m
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+CONFIG_I2C_I801=m
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_ISMT is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# ACPI drivers
+#
+# CONFIG_I2C_SCMI is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+# CONFIG_NTP_PPS is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=m
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_CHERRYVIEW is not set
+# CONFIG_PINCTRL_BROXTON is not set
+# CONFIG_PINCTRL_SUNRISEPOINT is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_APPLESMC is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_DELL_SMM is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_G762 is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_IBMAEM is not set
+# CONFIG_SENSORS_IBMPEX is not set
+# CONFIG_SENSORS_I5500 is not set
+CONFIG_SENSORS_CORETEMP=m
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_POWR1220 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LTC2945 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4222 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4260 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MAX31790 is not set
+# CONFIG_SENSORS_HTU21 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_NCT6683 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_NCT7802 is not set
+# CONFIG_SENSORS_NCT7904 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SHTC1 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_ADC128D818 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_TC74 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP103 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+
+#
+# ACPI drivers
+#
+CONFIG_SENSORS_ACPI_POWER=m
+# CONFIG_SENSORS_ATK0110 is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_THERMAL_GOV_BANG_BANG=y
+CONFIG_THERMAL_GOV_USER_SPACE=y
+# CONFIG_THERMAL_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_EMULATION is not set
+CONFIG_INTEL_POWERCLAMP=m
+CONFIG_X86_PKG_TEMP_THERMAL=m
+# CONFIG_INTEL_SOC_DTS_THERMAL is not set
+# CONFIG_INT340X_THERMAL is not set
+# CONFIG_INTEL_PCH_THERMAL is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_ACQUIRE_WDT is not set
+# CONFIG_ADVANTECH_WDT is not set
+# CONFIG_ALIM1535_WDT is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_F71808E_WDT is not set
+# CONFIG_SP5100_TCO is not set
+# CONFIG_SBC_FITPC2_WATCHDOG is not set
+# CONFIG_EUROTECH_WDT is not set
+# CONFIG_IB700_WDT is not set
+# CONFIG_IBMASR is not set
+# CONFIG_WAFER_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_IE6XX_WDT is not set
+CONFIG_ITCO_WDT=m
+CONFIG_ITCO_VENDOR_SUPPORT=y
+# CONFIG_IT8712F_WDT is not set
+# CONFIG_IT87_WDT is not set
+# CONFIG_HP_WATCHDOG is not set
+# CONFIG_SC1200_WDT is not set
+# CONFIG_PC87413_WDT is not set
+# CONFIG_NV_TCO is not set
+# CONFIG_60XX_WDT is not set
+# CONFIG_CPU5_WDT is not set
+# CONFIG_SMSC_SCH311X_WDT is not set
+# CONFIG_SMSC37B787_WDT is not set
+# CONFIG_VIA_WDT is not set
+# CONFIG_W83627HF_WDT is not set
+# CONFIG_W83877F_WDT is not set
+# CONFIG_W83977F_WDT is not set
+# CONFIG_MACHZ_WDT is not set
+# CONFIG_SBC_EPX_C3_WATCHDOG is not set
+# CONFIG_BCM7038_WDT is not set
+# CONFIG_XEN_WDT is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=m
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_INTEL_QUARK_I2C_GPIO is not set
+CONFIG_LPC_ICH=m
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_INTEL_LPSS_ACPI is not set
+# CONFIG_MFD_INTEL_LPSS_PCI is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RTSX_USB is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_AGP is not set
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_VGA_SWITCHEROO=y
+CONFIG_DRM=m
+CONFIG_DRM_KMS_HELPER=m
+CONFIG_DRM_KMS_FB_HELPER=y
+CONFIG_DRM_FBDEV_EMULATION=y
+CONFIG_DRM_LOAD_EDID_FIRMWARE=y
+
+#
+# I2C encoder or helper chips
+#
+# CONFIG_DRM_I2C_ADV7511 is not set
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I2C_NXP_TDA998X is not set
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_AMDGPU is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_I915 is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_DRM_VGEM is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_GMA500 is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_MGAG200 is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_QXL is not set
+# CONFIG_DRM_BOCHS is not set
+# CONFIG_DRM_VIRTIO_GPU is not set
+CONFIG_DRM_BRIDGE=y
+
+#
+# Display Interface Bridges
+#
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+CONFIG_FB_CMDLINE=y
+# CONFIG_FB_DDC is not set
+CONFIG_FB_BOOT_VESA_SUPPORT=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_VGA16 is not set
+CONFIG_FB_VESA=y
+CONFIG_FB_EFI=y
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_XEN_FBDEV_FRONTEND=y
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SM712 is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+CONFIG_HDMI=y
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=25
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=m
+# CONFIG_HID_BATTERY_STRENGTH is not set
+CONFIG_HIDRAW=y
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=m
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=m
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=m
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=m
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=m
+CONFIG_USB_XHCI_PCI=m
+# CONFIG_USB_XHCI_PLATFORM is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_PCI=m
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+# CONFIG_USB_STORAGE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+# CONFIG_USB_CHAOSKEY is not set
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_USB_PHY is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_INFINIBAND=m
+CONFIG_INFINIBAND_USER_MAD=m
+CONFIG_INFINIBAND_USER_ACCESS=m
+CONFIG_INFINIBAND_USER_MEM=y
+CONFIG_INFINIBAND_ON_DEMAND_PAGING=y
+CONFIG_INFINIBAND_ADDR_TRANS=y
+# CONFIG_INFINIBAND_MTHCA is not set
+# CONFIG_INFINIBAND_QIB is not set
+# CONFIG_MLX4_INFINIBAND is not set
+CONFIG_MLX5_INFINIBAND=m
+# CONFIG_INFINIBAND_NES is not set
+# CONFIG_INFINIBAND_OCRDMA is not set
+# CONFIG_INFINIBAND_USNIC is not set
+CONFIG_INFINIBAND_IPOIB=m
+CONFIG_INFINIBAND_IPOIB_CM=y
+# CONFIG_INFINIBAND_IPOIB_DEBUG is not set
+# CONFIG_INFINIBAND_SRP is not set
+# CONFIG_INFINIBAND_ISER is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_EDAC=y
+CONFIG_EDAC_LEGACY_SYSFS=y
+# CONFIG_EDAC_DEBUG is not set
+# CONFIG_EDAC_DECODE_MCE is not set
+CONFIG_EDAC_MM_EDAC=m
+# CONFIG_EDAC_E752X is not set
+# CONFIG_EDAC_I82975X is not set
+# CONFIG_EDAC_I3000 is not set
+# CONFIG_EDAC_I3200 is not set
+# CONFIG_EDAC_IE31200 is not set
+# CONFIG_EDAC_X38 is not set
+# CONFIG_EDAC_I5400 is not set
+# CONFIG_EDAC_I7CORE is not set
+# CONFIG_EDAC_I5000 is not set
+# CONFIG_EDAC_I5100 is not set
+# CONFIG_EDAC_I7300 is not set
+CONFIG_EDAC_SBRIDGE=m
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12057 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_ACPI=y
+# CONFIG_INTEL_IDMA64 is not set
+CONFIG_INTEL_IOATDMA=m
+# CONFIG_DW_DMAC is not set
+# CONFIG_DW_DMAC_PCI is not set
+
+#
+# DMA Clients
+#
+CONFIG_ASYNC_TX_DMA=y
+# CONFIG_DMATEST is not set
+CONFIG_DMA_ENGINE_RAID=y
+CONFIG_DCA=m
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VFIO is not set
+CONFIG_IRQ_BYPASS_MANAGER=y
+CONFIG_VIRT_DRIVERS=y
+CONFIG_VIRTIO=y
+
+#
+# Virtio drivers
+#
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO_PCI_LEGACY=y
+CONFIG_VIRTIO_BALLOON=y
+# CONFIG_VIRTIO_INPUT is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_HYPERV is not set
+
+#
+# Xen driver support
+#
+# CONFIG_XEN_BALLOON is not set
+# CONFIG_XEN_DEV_EVTCHN is not set
+# CONFIG_XEN_BACKEND is not set
+# CONFIG_XENFS is not set
+# CONFIG_XEN_SYS_HYPERVISOR is not set
+CONFIG_XEN_XENBUS_FRONTEND=y
+# CONFIG_XEN_GNTDEV is not set
+# CONFIG_XEN_GRANT_DEV_ALLOC is not set
+CONFIG_SWIOTLB_XEN=y
+CONFIG_XEN_PRIVCMD=m
+# CONFIG_XEN_ACPI_PROCESSOR is not set
+# CONFIG_XEN_MCE_LOG is not set
+CONFIG_XEN_HAVE_PVMMU=y
+CONFIG_XEN_EFI=y
+CONFIG_XEN_AUTO_XLATE=y
+CONFIG_XEN_ACPI=y
+CONFIG_XEN_HAVE_VPMU=y
+# CONFIG_STAGING is not set
+CONFIG_X86_PLATFORM_DEVICES=y
+# CONFIG_ACERHDF is not set
+# CONFIG_DELL_WMI is not set
+# CONFIG_DELL_WMI_AIO is not set
+# CONFIG_DELL_SMO8800 is not set
+# CONFIG_FUJITSU_TABLET is not set
+# CONFIG_HP_ACCEL is not set
+# CONFIG_HP_WIRELESS is not set
+# CONFIG_HP_WMI is not set
+# CONFIG_SENSORS_HDAPS is not set
+CONFIG_ACPI_WMI=m
+# CONFIG_TOPSTAR_LAPTOP is not set
+# CONFIG_TOSHIBA_BT_RFKILL is not set
+# CONFIG_TOSHIBA_HAPS is not set
+# CONFIG_TOSHIBA_WMI is not set
+# CONFIG_ACPI_CMPC is not set
+# CONFIG_INTEL_IPS is not set
+# CONFIG_IBM_RTL is not set
+CONFIG_MXM_WMI=m
+# CONFIG_SAMSUNG_Q10 is not set
+# CONFIG_INTEL_RST is not set
+# CONFIG_INTEL_SMARTCONNECT is not set
+# CONFIG_PVPANIC is not set
+# CONFIG_INTEL_PMC_IPC is not set
+# CONFIG_SURFACE_PRO3_BUTTON is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_PXA is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKEVT_I8253=y
+CONFIG_I8253_LOCK=y
+CONFIG_CLKBLD_I8253=y
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_API=y
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Generic IOMMU Pagetable Support
+#
+CONFIG_IOMMU_IOVA=y
+CONFIG_AMD_IOMMU=y
+# CONFIG_AMD_IOMMU_STATS is not set
+CONFIG_AMD_IOMMU_V2=y
+CONFIG_DMAR_TABLE=y
+CONFIG_INTEL_IOMMU=y
+# CONFIG_INTEL_IOMMU_SVM is not set
+# CONFIG_INTEL_IOMMU_DEFAULT_ON is not set
+CONFIG_INTEL_IOMMU_FLOPPY_WA=y
+CONFIG_IRQ_REMAP=y
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+CONFIG_PM_DEVFREQ=y
+
+#
+# DEVFREQ Governors
+#
+# CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND is not set
+# CONFIG_DEVFREQ_GOV_PERFORMANCE is not set
+# CONFIG_DEVFREQ_GOV_POWERSAVE is not set
+# CONFIG_DEVFREQ_GOV_USERSPACE is not set
+
+#
+# DEVFREQ Drivers
+#
+# CONFIG_PM_DEVFREQ_EVENT is not set
+# CONFIG_EXTCON is not set
+CONFIG_MEMORY=y
+# CONFIG_IIO is not set
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_PWM is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+CONFIG_POWERCAP=y
+CONFIG_INTEL_RAPL=m
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_RAS=y
+# CONFIG_THUNDERBOLT is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_STM_DUMMY is not set
+# CONFIG_STM_SOURCE_CONSOLE is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+CONFIG_FIRMWARE_MEMMAP=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+CONFIG_DMI_SYSFS=y
+CONFIG_DMI_SCAN_MACHINE_NON_EFI_FALLBACK=y
+# CONFIG_ISCSI_IBFT_FIND is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# EFI (Extensible Firmware Interface) Support
+#
+# CONFIG_EFI_VARS is not set
+CONFIG_EFI_ESRT=y
+CONFIG_EFI_RUNTIME_MAP=y
+# CONFIG_EFI_FAKE_MEMMAP is not set
+CONFIG_EFI_RUNTIME_WRAPPERS=y
+CONFIG_UEFI_CPER=y
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT2=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_ENCRYPTION is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_FS_DAX is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+# CONFIG_FANOTIFY_ACCESS_PERMISSIONS is not set
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+CONFIG_PRINT_QUOTA_WARNING=y
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTACTL=y
+CONFIG_QUOTACTL_COMPAT=y
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_PROC_CHILDREN=y
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_EFIVAR_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_PSTORE=y
+# CONFIG_PSTORE_CONSOLE is not set
+# CONFIG_PSTORE_PMSG is not set
+# CONFIG_PSTORE_FTRACE is not set
+# CONFIG_PSTORE_RAM is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+# CONFIG_NFS_V2 is not set
+# CONFIG_NFS_V3 is not set
+CONFIG_NFS_V4=m
+CONFIG_NFS_SWAP=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_PNFS_FILE_LAYOUT=m
+CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN="kernel.org"
+# CONFIG_NFS_V4_1_MIGRATION is not set
+CONFIG_NFS_V4_SECURITY_LABEL=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_NFS_DEBUG=y
+# CONFIG_NFSD is not set
+CONFIG_GRACE_PERIOD=m
+CONFIG_LOCKD=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+CONFIG_SUNRPC_GSS=m
+CONFIG_SUNRPC_BACKCHANNEL=y
+CONFIG_SUNRPC_SWAP=y
+CONFIG_SUNRPC_DEBUG=y
+# CONFIG_SUNRPC_XPRT_RDMA is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_9P_FS=y
+# CONFIG_9P_FS_POSIX_ACL is not set
+# CONFIG_9P_FS_SECURITY is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_INFO_SPLIT is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+# CONFIG_GDB_SCRIPTS is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=2048
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_READABLE_ASM is not set
+CONFIG_UNUSED_SYMBOLS=y
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x01b6
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+CONFIG_HAVE_ARCH_KASAN=y
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_HARDLOCKUP_DETECTOR=y
+# CONFIG_BOOTPARAM_HARDLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE=0
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=60
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHED_INFO=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+CONFIG_TIMER_STATS=y
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+CONFIG_DEBUG_RT_MUTEXES=y
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_MUTEXES=y
+CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y
+CONFIG_DEBUG_LOCK_ALLOC=y
+CONFIG_PROVE_LOCKING=y
+CONFIG_LOCKDEP=y
+CONFIG_LOCK_STAT=y
+CONFIG_DEBUG_LOCKDEP=y
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+CONFIG_TRACE_IRQFLAGS=y
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+CONFIG_PROVE_RCU=y
+# CONFIG_PROVE_RCU_REPEATEDLY is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS=y
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_FENTRY=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACER_MAX_TRACE=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_TRACER_SNAPSHOT=y
+# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+CONFIG_STACK_TRACER=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_KPROBE_EVENT=y
+CONFIG_UPROBE_EVENT=y
+CONFIG_PROBE_EVENTS=y
+CONFIG_DYNAMIC_FTRACE=y
+CONFIG_DYNAMIC_FTRACE_WITH_REGS=y
+# CONFIG_FUNCTION_PROFILER is not set
+CONFIG_FTRACE_MCOUNT_RECORD=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+# CONFIG_MMIOTRACE is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_TRACE_ENUM_MAP_FILE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_UDELAY is not set
+CONFIG_MEMTEST=y
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+CONFIG_EARLY_PRINTK_EFI=y
+# CONFIG_X86_PTDUMP_CORE is not set
+# CONFIG_X86_PTDUMP is not set
+# CONFIG_EFI_PGT_DUMP is not set
+CONFIG_DEBUG_RODATA=y
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_WX is not set
+CONFIG_DEBUG_SET_MODULE_RONX=y
+# CONFIG_DEBUG_NX_TEST is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_DEBUG_TLBFLUSH is not set
+# CONFIG_IOMMU_DEBUG is not set
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+# CONFIG_X86_DECODER_SELFTEST is not set
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_IO_DELAY_0X80=y
+# CONFIG_IO_DELAY_0XED is not set
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+# CONFIG_DEBUG_BOOT_PARAMS is not set
+# CONFIG_CPA_DEBUG is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_ENTRY is not set
+# CONFIG_DEBUG_NMI_SELFTEST is not set
+# CONFIG_X86_DEBUG_STATIC_CPU_HAS is not set
+CONFIG_X86_DEBUG_FPU=y
+# CONFIG_PUNIT_ATOM_DEBUG is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_COMPAT=y
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+CONFIG_PAGE_TABLE_ISOLATION=y
+CONFIG_SECURITYFS=y
+# CONFIG_SECURITY_NETWORK is not set
+# CONFIG_SECURITY_PATH is not set
+# CONFIG_INTEL_TXT is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_APPARMOR is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_INTEGRITY is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+# CONFIG_CRYPTO_RSA is not set
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRC32_PCLMUL is not set
+CONFIG_CRYPTO_CRCT10DIF=y
+# CONFIG_CRYPTO_CRCT10DIF_PCLMUL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_POLY1305_X86_64 is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA1_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256_SSSE3 is not set
+# CONFIG_CRYPTO_SHA512_SSSE3 is not set
+# CONFIG_CRYPTO_SHA1_MB is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_X86_64 is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_BLOWFISH_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAMELLIA_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST5_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_CAST6_AVX_X86_64 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_DES3_EDE_X86_64 is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_X86_64 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_CHACHA20_X86_64 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SERPENT_SSE2_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64 is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64_3WAY is not set
+# CONFIG_CRYPTO_TWOFISH_AVX_X86_64 is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_DRBG_MENU is not set
+# CONFIG_CRYPTO_JITTERENTROPY is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
+CONFIG_HAVE_KVM=y
+CONFIG_HAVE_KVM_IRQCHIP=y
+CONFIG_HAVE_KVM_IRQFD=y
+CONFIG_HAVE_KVM_IRQ_ROUTING=y
+CONFIG_HAVE_KVM_EVENTFD=y
+CONFIG_KVM_APIC_ARCHITECTURE=y
+CONFIG_KVM_MMIO=y
+CONFIG_KVM_ASYNC_PF=y
+CONFIG_HAVE_KVM_MSI=y
+CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT=y
+CONFIG_KVM_VFIO=y
+CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT=y
+CONFIG_KVM_COMPAT=y
+CONFIG_HAVE_KVM_IRQ_BYPASS=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_KVM_INTEL=m
+# CONFIG_KVM_AMD is not set
+# CONFIG_KVM_MMU_AUDIT is not set
+# CONFIG_KVM_DEVICE_ASSIGNMENT is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_ARCH_HAS_FAST_MULTIPLIER=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_CHECK_SIGNATURE=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_OID_REGISTRY=m
+CONFIG_UCS2_STRING=y
+CONFIG_FONT_SUPPORT=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_SG_SPLIT is not set
+CONFIG_ARCH_HAS_SG_CHAIN=y
+CONFIG_ARCH_HAS_PMEM_API=y
+CONFIG_ARCH_HAS_MMIO_FLUSH=y
diff --git a/config_pophype_systor20_echo5_200510 b/config_pophype_systor20_echo5_200510
new file mode 100644
index 000000000000..0452d13886c0
--- /dev/null
+++ b/config_pophype_systor20_echo5_200510
@@ -0,0 +1,3512 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/x86 4.4.137 Kernel Configuration
+#
+CONFIG_64BIT=y
+CONFIG_X86_64=y
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_PERF_EVENTS_INTEL_UNCORE=y
+CONFIG_OUTPUT_FORMAT="elf64-x86-64"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/x86_64_defconfig"
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+CONFIG_ZONE_DMA32=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_HAVE_INTEL_TXT=y
+CONFIG_X86_64_SMP=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PGTABLE_LEVELS=4
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION="-pop-hype"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KERNEL_XZ=y
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_FHANDLE=y
+CONFIG_USELIB=y
+CONFIG_AUDIT=y
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_VIRT_CPU_ACCOUNTING=y
+# CONFIG_TICK_CPU_ACCOUNTING is not set
+CONFIG_VIRT_CPU_ACCOUNTING_GEN=y
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_CONTEXT_TRACKING=y
+# CONFIG_CONTEXT_TRACKING_FORCE is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_EXPEDITE_BOOT is not set
+CONFIG_BUILD_BIN2C=y
+CONFIG_IKCONFIG=m
+# CONFIG_IKCONFIG_PROC is not set
+CONFIG_LOG_BUF_SHIFT=21
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
+CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH=y
+CONFIG_ARCH_SUPPORTS_INT128=y
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_PAGE_COUNTER=y
+CONFIG_MEMCG=y
+# CONFIG_MEMCG_KMEM is not set
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+CONFIG_CGROUP_WRITEBACK=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_RD_LZ4=y
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_HAVE_PCSPKR_PLATFORM=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+CONFIG_SGETMASK_SYSCALL=y
+CONFIG_SYSFS_SYSCALL=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_BPF_SYSCALL is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_USERFAULTFD is not set
+CONFIG_PCI_QUIRKS=y
+CONFIG_MEMBARRIER=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_KEXEC_CORE=y
+# CONFIG_OPROFILE is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_OPROFILE_NMI_TIMER=y
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+CONFIG_OPTPROBES=y
+CONFIG_KPROBES_ON_FTRACE=y
+CONFIG_UPROBES=y
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_KRETPROBES=y
+CONFIG_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_KPROBES_ON_FTRACE=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_ARCH_WANT_OLD_COMPAT_IPC=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR_NONE is not set
+CONFIG_CC_STACKPROTECTOR_REGULAR=y
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_HAVE_ARCH_HUGE_VMAP=y
+CONFIG_HAVE_ARCH_SOFT_DIRTY=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_COPY_THREAD_TLS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_BLK_DEV_THROTTLING=y
+# CONFIG_BLK_CMDLINE_PARSER is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+# CONFIG_CMDLINE_PARTITION is not set
+CONFIG_BLOCK_COMPAT=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_PREEMPT_NOTIFIERS=y
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_ARCH_USE_QUEUED_SPINLOCKS=y
+CONFIG_QUEUED_SPINLOCKS=y
+CONFIG_ARCH_USE_QUEUED_RWLOCKS=y
+CONFIG_QUEUED_RWLOCKS=y
+CONFIG_FREEZER=y
+
+#
+# Popcorn Distributed Execution Support
+#
+CONFIG_ARCH_SUPPORTS_POPCORN=y
+CONFIG_POPCORN=y
+CONFIG_POPCORN_HYPE=y
+# CONFIG_POPCORN_DEBUG is not set
+# CONFIG_POPCORN_CHECK_SANITY is not set
+# CONFIG_POPCORN_REMOTE_INFO is not set
+# CONFIG_POPCORN_STAT is not set
+CONFIG_POPCORN_KMSG=y
+CONFIG_POPCORN_KMSG_SOCKET=m
+CONFIG_POPCORN_KMSG_RDMA=m
+CONFIG_POPCORN_KMSG_TEST=m
+
+#
+# Processor type and features
+#
+CONFIG_ZONE_DMA=y
+CONFIG_SMP=y
+CONFIG_X86_FEATURE_NAMES=y
+CONFIG_X86_X2APIC=y
+CONFIG_X86_MPPARSE=y
+CONFIG_RETPOLINE=y
+# CONFIG_X86_EXTENDED_PLATFORM is not set
+CONFIG_X86_INTEL_LPSS=y
+# CONFIG_X86_AMD_PLATFORM_DEVICE is not set
+CONFIG_IOSF_MBI=m
+# CONFIG_IOSF_MBI_DEBUG is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+CONFIG_HYPERVISOR_GUEST=y
+CONFIG_PARAVIRT=y
+# CONFIG_PARAVIRT_DEBUG is not set
+# CONFIG_PARAVIRT_SPINLOCKS is not set
+CONFIG_XEN=y
+CONFIG_XEN_DOM0=y
+CONFIG_XEN_PVHVM=y
+CONFIG_XEN_512GB=y
+CONFIG_XEN_SAVE_RESTORE=y
+# CONFIG_XEN_DEBUG_FS is not set
+CONFIG_XEN_PVH=y
+CONFIG_KVM_GUEST=y
+# CONFIG_KVM_DEBUG_FS is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+CONFIG_PARAVIRT_CLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MK8 is not set
+# CONFIG_MPSC is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MATOM is not set
+CONFIG_GENERIC_CPU=y
+CONFIG_X86_INTERNODE_CACHE_SHIFT=6
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=64
+CONFIG_X86_DEBUGCTLMSR=y
+# CONFIG_PROCESSOR_SELECT is not set
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+CONFIG_GART_IOMMU=y
+CONFIG_CALGARY_IOMMU=y
+CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT=y
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_MAXSMP is not set
+CONFIG_NR_CPUS=64
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_X86_MCE_THRESHOLD=y
+# CONFIG_X86_MCE_INJECT is not set
+CONFIG_X86_THERMAL_VECTOR=y
+# CONFIG_VM86 is not set
+CONFIG_X86_16BIT=y
+CONFIG_X86_ESPFIX64=y
+CONFIG_X86_VSYSCALL_EMULATION=y
+# CONFIG_I8K is not set
+CONFIG_MICROCODE=y
+CONFIG_MICROCODE_INTEL=y
+CONFIG_MICROCODE_AMD=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+# CONFIG_X86_MSR is not set
+# CONFIG_X86_CPUID is not set
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_X86_DIRECT_GBPAGES=y
+CONFIG_NUMA=y
+CONFIG_AMD_NUMA=y
+CONFIG_X86_64_ACPI_NUMA=y
+CONFIG_NODES_SPAN_OTHER_NODES=y
+CONFIG_NUMA_EMU=y
+CONFIG_NODES_SHIFT=6
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_ARCH_DISCARD_MEMBLOCK=y
+CONFIG_MEMORY_ISOLATION=y
+# CONFIG_MOVABLE_NODE is not set
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+# CONFIG_MEMORY_HOTPLUG is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK=y
+CONFIG_MEMORY_BALLOON=y
+# CONFIG_COMPACTION is not set
+# CONFIG_MIGRATION is not set
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_MMU_NOTIFIER=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_MEMORY_FAILURE=y
+# CONFIG_HWPOISON_INJECT is not set
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CMA is not set
+CONFIG_MEM_SOFT_DIRTY=y
+# CONFIG_ZPOOL is not set
+CONFIG_ZBUD=y
+CONFIG_ZSMALLOC=y
+# CONFIG_PGTABLE_MAPPING is not set
+# CONFIG_ZSMALLOC_STAT is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+CONFIG_ARCH_SUPPORTS_DEFERRED_STRUCT_PAGE_INIT=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_X86_PMEM_LEGACY is not set
+# CONFIG_X86_CHECK_BIOS_CORRUPTION is not set
+CONFIG_X86_RESERVE_LOW=64
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_ARCH_RANDOM=y
+CONFIG_X86_SMAP=y
+# CONFIG_X86_INTEL_MPX is not set
+CONFIG_EFI=y
+CONFIG_EFI_STUB=y
+CONFIG_EFI_MIXED=y
+CONFIG_SECCOMP=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+# CONFIG_RANDOMIZE_BASE is not set
+CONFIG_PHYSICAL_ALIGN=0x200000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_BOOTPARAM_HOTPLUG_CPU0 is not set
+# CONFIG_DEBUG_HOTPLUG_CPU0 is not set
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_LEGACY_VSYSCALL_NATIVE is not set
+CONFIG_LEGACY_VSYSCALL_EMULATE=y
+# CONFIG_LEGACY_VSYSCALL_NONE is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MODIFY_LDT_SYSCALL=y
+CONFIG_HAVE_LIVEPATCH=y
+# CONFIG_LIVEPATCH is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_USE_PERCPU_NUMA_NODE_ID=y
+
+#
+# Power management and ACPI options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+CONFIG_HIBERNATE_CALLBACKS=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+# CONFIG_PM_TEST_SUSPEND is not set
+CONFIG_PM_SLEEP_DEBUG=y
+# CONFIG_DPM_WATCHDOG is not set
+# CONFIG_PM_TRACE_RTC is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_LEGACY_TABLES_LOOKUP=y
+CONFIG_ARCH_MIGHT_HAVE_ACPI_PDC=y
+CONFIG_ACPI_SYSTEM_POWER_STATES_SUPPORT=y
+# CONFIG_ACPI_DEBUGGER is not set
+CONFIG_ACPI_SLEEP=y
+# CONFIG_ACPI_PROCFS_POWER is not set
+CONFIG_ACPI_REV_OVERRIDE_POSSIBLE=y
+# CONFIG_ACPI_EC_DEBUGFS is not set
+# CONFIG_ACPI_AC is not set
+# CONFIG_ACPI_BATTERY is not set
+CONFIG_ACPI_BUTTON=m
+# CONFIG_ACPI_FAN is not set
+CONFIG_ACPI_DOCK=y
+CONFIG_ACPI_CPU_FREQ_PSS=y
+CONFIG_ACPI_PROCESSOR_IDLE=y
+CONFIG_ACPI_PROCESSOR=m
+# CONFIG_ACPI_IPMI is not set
+CONFIG_ACPI_HOTPLUG_CPU=y
+CONFIG_ACPI_PROCESSOR_AGGREGATOR=m
+# CONFIG_ACPI_THERMAL is not set
+CONFIG_ACPI_NUMA=y
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+CONFIG_ACPI_INITRD_TABLE_OVERRIDE=y
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_PCI_SLOT=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_ACPI_HOTPLUG_IOAPIC=y
+# CONFIG_ACPI_SBS is not set
+CONFIG_ACPI_HED=y
+# CONFIG_ACPI_CUSTOM_METHOD is not set
+CONFIG_ACPI_BGRT=y
+# CONFIG_ACPI_REDUCED_HARDWARE_ONLY is not set
+# CONFIG_ACPI_NFIT is not set
+CONFIG_HAVE_ACPI_APEI=y
+CONFIG_HAVE_ACPI_APEI_NMI=y
+CONFIG_ACPI_APEI=y
+CONFIG_ACPI_APEI_GHES=y
+CONFIG_ACPI_APEI_PCIEAER=y
+CONFIG_ACPI_APEI_MEMORY_FAILURE=y
+# CONFIG_ACPI_APEI_EINJ is not set
+# CONFIG_ACPI_APEI_ERST_DEBUG is not set
+CONFIG_ACPI_EXTLOG=y
+# CONFIG_PMIC_OPREGION is not set
+CONFIG_SFI=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+# CONFIG_CPU_FREQ_STAT is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# CPU frequency scaling drivers
+#
+CONFIG_X86_INTEL_PSTATE=y
+# CONFIG_X86_PCC_CPUFREQ is not set
+# CONFIG_X86_ACPI_CPUFREQ is not set
+# CONFIG_X86_SPEEDSTEP_CENTRINO is not set
+# CONFIG_X86_P4_CLOCKMOD is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+CONFIG_INTEL_IDLE=y
+
+#
+# Memory power savings
+#
+# CONFIG_I7300_IDLE is not set
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCI_XEN=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_HOTPLUG_PCI_PCIE=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIEAER_INJECT is not set
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PME=y
+CONFIG_PCI_BUS_ADDR_T_64BIT=y
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+# CONFIG_PCI_DEBUG is not set
+CONFIG_PCI_REALLOC_ENABLE_AUTO=y
+# CONFIG_PCI_STUB is not set
+# CONFIG_XEN_PCIDEV_FRONTEND is not set
+CONFIG_HT_IRQ=y
+CONFIG_PCI_ATS=y
+CONFIG_PCI_IOV=y
+CONFIG_PCI_PRI=y
+CONFIG_PCI_PASID=y
+CONFIG_PCI_LABEL=y
+
+#
+# PCI host controller drivers
+#
+CONFIG_ISA_DMA_API=y
+CONFIG_AMD_NB=y
+# CONFIG_PCCARD is not set
+CONFIG_HOTPLUG_PCI=y
+CONFIG_HOTPLUG_PCI_ACPI=y
+# CONFIG_HOTPLUG_PCI_ACPI_IBM is not set
+CONFIG_HOTPLUG_PCI_CPCI=y
+# CONFIG_HOTPLUG_PCI_CPCI_ZT5550 is not set
+# CONFIG_HOTPLUG_PCI_CPCI_GENERIC is not set
+CONFIG_HOTPLUG_PCI_SHPC=m
+# CONFIG_RAPIDIO is not set
+# CONFIG_X86_SYSFB is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=m
+CONFIG_COREDUMP=y
+CONFIG_IA32_EMULATION=y
+CONFIG_IA32_AOUT=y
+CONFIG_X86_X32=y
+CONFIG_COMPAT=y
+CONFIG_COMPAT_FOR_U64_ALIGNMENT=y
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_X86_DEV_DMA_OPS=y
+CONFIG_PMC_ATOM=y
+CONFIG_NET=y
+CONFIG_NET_INGRESS=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+CONFIG_XFRM_SUB_POLICY=y
+CONFIG_XFRM_MIGRATE=y
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_TRIE_STATS=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_NET_IP_TUNNEL is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_SYN_COOKIES=y
+# CONFIG_NET_UDP_TUNNEL is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_UDP_DIAG=y
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+# CONFIG_TCP_CONG_DCTCP is not set
+# CONFIG_TCP_CONG_CDG is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+CONFIG_IPV6_MIP6=y
+# CONFIG_IPV6_ILA is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_BEET is not set
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+# CONFIG_IPV6_SIT is not set
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_GRE is not set
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IPV6_PIMSM_V2=y
+# CONFIG_NETLABEL is not set
+CONFIG_NETWORK_SECMARK=y
+CONFIG_NET_PTP_CLASSIFY=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=m
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_INGRESS=y
+CONFIG_NETFILTER_NETLINK=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+# CONFIG_NF_CONNTRACK_MARK is not set
+# CONFIG_NF_CONNTRACK_SECMARK is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CT_NETLINK is not set
+# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+# CONFIG_NF_NAT_AMANDA is not set
+# CONFIG_NF_NAT_FTP is not set
+# CONFIG_NF_NAT_IRC is not set
+# CONFIG_NF_NAT_SIP is not set
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NF_NAT_REDIRECT is not set
+CONFIG_NF_TABLES=y
+CONFIG_NF_TABLES_INET=y
+CONFIG_NF_TABLES_NETDEV=y
+CONFIG_NFT_EXTHDR=y
+# CONFIG_NFT_META is not set
+# CONFIG_NFT_CT is not set
+# CONFIG_NFT_RBTREE is not set
+# CONFIG_NFT_HASH is not set
+# CONFIG_NFT_COUNTER is not set
+# CONFIG_NFT_LOG is not set
+# CONFIG_NFT_LIMIT is not set
+# CONFIG_NFT_MASQ is not set
+# CONFIG_NFT_REDIR is not set
+# CONFIG_NFT_NAT is not set
+# CONFIG_NFT_REJECT is not set
+# CONFIG_NFT_REJECT_INET is not set
+CONFIG_NFT_COMPAT=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+# CONFIG_NETFILTER_XT_CONNMARK is not set
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+# CONFIG_NETFILTER_XT_TARGET_LOG is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+CONFIG_NETFILTER_XT_NAT=y
+# CONFIG_NETFILTER_XT_TARGET_NETMAP is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_REDIRECT is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
+# CONFIG_NETFILTER_XT_TARGET_SECMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y
+# CONFIG_NETFILTER_XT_MATCH_BPF is not set
+# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ECN is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+CONFIG_NETFILTER_XT_MATCH_HL=y
+# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_IPVS=y
+# CONFIG_NETFILTER_XT_MATCH_L2TP is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+CONFIG_NETFILTER_XT_MATCH_RECENT=y
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+# CONFIG_NETFILTER_XT_MATCH_STATE is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_IP_SET is not set
+CONFIG_IP_VS=y
+# CONFIG_IP_VS_IPV6 is not set
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+# CONFIG_IP_VS_PROTO_TCP is not set
+# CONFIG_IP_VS_PROTO_UDP is not set
+# CONFIG_IP_VS_PROTO_AH_ESP is not set
+# CONFIG_IP_VS_PROTO_ESP is not set
+# CONFIG_IP_VS_PROTO_AH is not set
+# CONFIG_IP_VS_PROTO_SCTP is not set
+
+#
+# IPVS scheduler
+#
+# CONFIG_IP_VS_RR is not set
+# CONFIG_IP_VS_WRR is not set
+# CONFIG_IP_VS_LC is not set
+# CONFIG_IP_VS_WLC is not set
+# CONFIG_IP_VS_FO is not set
+# CONFIG_IP_VS_OVF is not set
+# CONFIG_IP_VS_LBLC is not set
+# CONFIG_IP_VS_LBLCR is not set
+# CONFIG_IP_VS_DH is not set
+# CONFIG_IP_VS_SH is not set
+# CONFIG_IP_VS_SED is not set
+# CONFIG_IP_VS_NQ is not set
+
+#
+# IPVS SH scheduler
+#
+CONFIG_IP_VS_SH_TAB_BITS=8
+
+#
+# IPVS application helper
+#
+# CONFIG_IP_VS_NFCT is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_NF_TABLES_IPV4=y
+CONFIG_NFT_CHAIN_ROUTE_IPV4=y
+# CONFIG_NFT_REJECT_IPV4 is not set
+# CONFIG_NFT_DUP_IPV4 is not set
+CONFIG_NF_TABLES_ARP=y
+# CONFIG_NF_DUP_IPV4 is not set
+# CONFIG_NF_LOG_ARP is not set
+# CONFIG_NF_LOG_IPV4 is not set
+# CONFIG_NF_REJECT_IPV4 is not set
+CONFIG_NF_NAT_IPV4=y
+CONFIG_NFT_CHAIN_NAT_IPV4=y
+CONFIG_NF_NAT_MASQUERADE_IPV4=y
+# CONFIG_NF_NAT_PPTP is not set
+# CONFIG_NF_NAT_H323 is not set
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+CONFIG_IP_NF_FILTER=y
+# CONFIG_IP_NF_TARGET_REJECT is not set
+# CONFIG_IP_NF_TARGET_SYNPROXY is not set
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+# CONFIG_IP_NF_TARGET_NETMAP is not set
+# CONFIG_IP_NF_TARGET_REDIRECT is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_SECURITY is not set
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+# CONFIG_IP_NF_ARP_MANGLE is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV6 is not set
+# CONFIG_NF_CONNTRACK_IPV6 is not set
+CONFIG_NF_TABLES_IPV6=y
+# CONFIG_NFT_CHAIN_ROUTE_IPV6 is not set
+# CONFIG_NFT_REJECT_IPV6 is not set
+# CONFIG_NFT_DUP_IPV6 is not set
+# CONFIG_NF_DUP_IPV6 is not set
+# CONFIG_NF_REJECT_IPV6 is not set
+# CONFIG_NF_LOG_IPV6 is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_NF_TABLES_BRIDGE is not set
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+CONFIG_STP=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+# CONFIG_NET_SCH_FQ is not set
+# CONFIG_NET_SCH_HHF is not set
+# CONFIG_NET_SCH_PIE is not set
+# CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_PLUG is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+# CONFIG_NET_CLS_BPF is not set
+# CONFIG_NET_CLS_FLOWER is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+# CONFIG_NET_EMATCH_U32 is not set
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_ACT_VLAN is not set
+# CONFIG_NET_ACT_BPF is not set
+CONFIG_NET_SCH_FIFO=y
+CONFIG_DCB=y
+CONFIG_DNS_RESOLVER=m
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+CONFIG_NETLINK_DIAG=y
+CONFIG_MPLS=y
+CONFIG_NET_MPLS_GSO=y
+# CONFIG_MPLS_ROUTING is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_CGROUP_NET_CLASSID=y
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+CONFIG_BPF_JIT=y
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+# CONFIG_NET_9P_RDMA is not set
+# CONFIG_NET_9P_DEBUG is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_LWTUNNEL is not set
+# CONFIG_DST_CACHE is not set
+CONFIG_HAVE_BPF_JIT=y
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_GENERIC_CPU_VULNERABILITIES=y
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_FENCE_TRACE is not set
+
+#
+# Bus devices
+#
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_OF is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG_MESSAGES is not set
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_ZRAM is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_SKD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=18874368
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_XEN_BLKDEV_FRONTEND is not set
+CONFIG_VIRTIO_BLK=y
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+# CONFIG_BLK_DEV_NVME is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_INTEL_MEI=m
+CONFIG_INTEL_MEI_ME=m
+# CONFIG_INTEL_MEI_TXE is not set
+# CONFIG_VMWARE_VMCI is not set
+
+#
+# Intel MIC Bus Driver
+#
+# CONFIG_INTEL_MIC_BUS is not set
+
+#
+# SCIF Bus Driver
+#
+# CONFIG_SCIF_BUS is not set
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+# CONFIG_GENWQE is not set
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_KERNEL_API is not set
+# CONFIG_CXL_EEH is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=m
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=m
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_MQ_DEFAULT is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_SCSI_ESAS2R is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT3SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_VMWARE_PVSCSI is not set
+# CONFIG_XEN_SCSI_FRONTEND is not set
+# CONFIG_SCSI_SNIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_ISCI is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_WD719X is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_VIRTIO is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=m
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_ZPODD=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI=m
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+# CONFIG_ATA_SFF is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_BCACHE is not set
+# CONFIG_BLK_DEV_DM is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+# CONFIG_IFB is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+CONFIG_TUN=y
+# CONFIG_TUN_VNET_CROSS_LE is not set
+CONFIG_VETH=y
+CONFIG_VIRTIO_NET=y
+# CONFIG_NLMON is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_VHOST_NET=y
+CONFIG_VHOST_RING=y
+CONFIG_VHOST=y
+# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+CONFIG_ETHERNET=y
+CONFIG_MDIO=m
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_CX_ECAT is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_HP is not set
+CONFIG_NET_VENDOR_INTEL=y
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IXGB is not set
+CONFIG_IXGBE=m
+CONFIG_IXGBE_HWMON=y
+CONFIG_IXGBE_DCA=y
+CONFIG_IXGBE_DCB=y
+# CONFIG_IXGBEVF is not set
+# CONFIG_I40E is not set
+# CONFIG_I40EVF is not set
+# CONFIG_FM10K is not set
+CONFIG_NET_VENDOR_I825XX=y
+# CONFIG_JME is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+CONFIG_MLX5_CORE=m
+CONFIG_MLX5_CORE_EN=y
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_SFC is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_NET_SB1000 is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Host-side USB support is needed for USB Network Adapter support
+#
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_XEN_NETDEV_FRONTEND is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_FUJITSU_ES is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
+CONFIG_SERIO_I8042=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVMEM is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DMA=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_RSA=y
+# CONFIG_SERIAL_8250_FSL is not set
+# CONFIG_SERIAL_8250_DW is not set
+# CONFIG_SERIAL_8250_RT288X is not set
+# CONFIG_SERIAL_8250_FINTEK is not set
+# CONFIG_SERIAL_8250_MID is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+CONFIG_TTY_PRINTK=y
+CONFIG_HVC_DRIVER=y
+# CONFIG_HVC_XEN is not set
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_IPMI_HANDLER=m
+# CONFIG_IPMI_PANIC_EVENT is not set
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+# CONFIG_IPMI_SI_PROBE_DEFAULTS is not set
+# CONFIG_IPMI_SSIF is not set
+CONFIG_IPMI_WATCHDOG=m
+CONFIG_IPMI_POWEROFF=m
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_VIA=y
+CONFIG_HW_RANDOM_VIRTIO=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_MWAVE is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_HPET=y
+CONFIG_HPET_MMAP=y
+CONFIG_HPET_MMAP_DEFAULT=y
+CONFIG_HANGCHECK_TIMER=y
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_MUX=m
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=m
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+CONFIG_I2C_I801=m
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_ISMT is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# ACPI drivers
+#
+# CONFIG_I2C_SCMI is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+# CONFIG_NTP_PPS is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=m
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_CHERRYVIEW is not set
+# CONFIG_PINCTRL_BROXTON is not set
+# CONFIG_PINCTRL_SUNRISEPOINT is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_APPLESMC is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_DELL_SMM is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_G762 is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_IBMAEM is not set
+# CONFIG_SENSORS_IBMPEX is not set
+# CONFIG_SENSORS_I5500 is not set
+CONFIG_SENSORS_CORETEMP=m
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_POWR1220 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LTC2945 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4222 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4260 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MAX31790 is not set
+# CONFIG_SENSORS_HTU21 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_NCT6683 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_NCT7802 is not set
+# CONFIG_SENSORS_NCT7904 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SHTC1 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_ADC128D818 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_TC74 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP103 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+
+#
+# ACPI drivers
+#
+CONFIG_SENSORS_ACPI_POWER=m
+# CONFIG_SENSORS_ATK0110 is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_THERMAL_GOV_BANG_BANG=y
+CONFIG_THERMAL_GOV_USER_SPACE=y
+# CONFIG_THERMAL_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_EMULATION is not set
+CONFIG_INTEL_POWERCLAMP=m
+CONFIG_X86_PKG_TEMP_THERMAL=m
+# CONFIG_INTEL_SOC_DTS_THERMAL is not set
+# CONFIG_INT340X_THERMAL is not set
+# CONFIG_INTEL_PCH_THERMAL is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_ACQUIRE_WDT is not set
+# CONFIG_ADVANTECH_WDT is not set
+# CONFIG_ALIM1535_WDT is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_F71808E_WDT is not set
+# CONFIG_SP5100_TCO is not set
+# CONFIG_SBC_FITPC2_WATCHDOG is not set
+# CONFIG_EUROTECH_WDT is not set
+# CONFIG_IB700_WDT is not set
+# CONFIG_IBMASR is not set
+# CONFIG_WAFER_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_IE6XX_WDT is not set
+CONFIG_ITCO_WDT=m
+CONFIG_ITCO_VENDOR_SUPPORT=y
+# CONFIG_IT8712F_WDT is not set
+# CONFIG_IT87_WDT is not set
+# CONFIG_HP_WATCHDOG is not set
+# CONFIG_SC1200_WDT is not set
+# CONFIG_PC87413_WDT is not set
+# CONFIG_NV_TCO is not set
+# CONFIG_60XX_WDT is not set
+# CONFIG_CPU5_WDT is not set
+# CONFIG_SMSC_SCH311X_WDT is not set
+# CONFIG_SMSC37B787_WDT is not set
+# CONFIG_VIA_WDT is not set
+# CONFIG_W83627HF_WDT is not set
+# CONFIG_W83877F_WDT is not set
+# CONFIG_W83977F_WDT is not set
+# CONFIG_MACHZ_WDT is not set
+# CONFIG_SBC_EPX_C3_WATCHDOG is not set
+# CONFIG_BCM7038_WDT is not set
+# CONFIG_XEN_WDT is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=m
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_INTEL_QUARK_I2C_GPIO is not set
+CONFIG_LPC_ICH=m
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_INTEL_LPSS_ACPI is not set
+# CONFIG_MFD_INTEL_LPSS_PCI is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RTSX_USB is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_AGP is not set
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_VGA_SWITCHEROO=y
+CONFIG_DRM=m
+CONFIG_DRM_KMS_HELPER=m
+CONFIG_DRM_KMS_FB_HELPER=y
+CONFIG_DRM_FBDEV_EMULATION=y
+CONFIG_DRM_LOAD_EDID_FIRMWARE=y
+
+#
+# I2C encoder or helper chips
+#
+# CONFIG_DRM_I2C_ADV7511 is not set
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I2C_NXP_TDA998X is not set
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_AMDGPU is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_I915 is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_DRM_VGEM is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_GMA500 is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_MGAG200 is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_QXL is not set
+# CONFIG_DRM_BOCHS is not set
+# CONFIG_DRM_VIRTIO_GPU is not set
+CONFIG_DRM_BRIDGE=y
+
+#
+# Display Interface Bridges
+#
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+CONFIG_FB_CMDLINE=y
+# CONFIG_FB_DDC is not set
+CONFIG_FB_BOOT_VESA_SUPPORT=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_VGA16 is not set
+CONFIG_FB_VESA=y
+CONFIG_FB_EFI=y
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_XEN_FBDEV_FRONTEND=y
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SM712 is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+CONFIG_HDMI=y
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=25
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=m
+# CONFIG_HID_BATTERY_STRENGTH is not set
+CONFIG_HIDRAW=y
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=m
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=m
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=m
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=m
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=m
+CONFIG_USB_XHCI_PCI=m
+# CONFIG_USB_XHCI_PLATFORM is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_PCI=m
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+# CONFIG_USB_STORAGE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+# CONFIG_USB_CHAOSKEY is not set
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_USB_PHY is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_INFINIBAND=m
+CONFIG_INFINIBAND_USER_MAD=m
+CONFIG_INFINIBAND_USER_ACCESS=m
+CONFIG_INFINIBAND_USER_MEM=y
+CONFIG_INFINIBAND_ON_DEMAND_PAGING=y
+CONFIG_INFINIBAND_ADDR_TRANS=y
+# CONFIG_INFINIBAND_MTHCA is not set
+# CONFIG_INFINIBAND_QIB is not set
+# CONFIG_MLX4_INFINIBAND is not set
+CONFIG_MLX5_INFINIBAND=m
+# CONFIG_INFINIBAND_NES is not set
+# CONFIG_INFINIBAND_OCRDMA is not set
+# CONFIG_INFINIBAND_USNIC is not set
+CONFIG_INFINIBAND_IPOIB=m
+CONFIG_INFINIBAND_IPOIB_CM=y
+# CONFIG_INFINIBAND_IPOIB_DEBUG is not set
+# CONFIG_INFINIBAND_SRP is not set
+# CONFIG_INFINIBAND_ISER is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_EDAC=y
+CONFIG_EDAC_LEGACY_SYSFS=y
+# CONFIG_EDAC_DEBUG is not set
+# CONFIG_EDAC_DECODE_MCE is not set
+CONFIG_EDAC_MM_EDAC=m
+# CONFIG_EDAC_E752X is not set
+# CONFIG_EDAC_I82975X is not set
+# CONFIG_EDAC_I3000 is not set
+# CONFIG_EDAC_I3200 is not set
+# CONFIG_EDAC_IE31200 is not set
+# CONFIG_EDAC_X38 is not set
+# CONFIG_EDAC_I5400 is not set
+# CONFIG_EDAC_I7CORE is not set
+# CONFIG_EDAC_I5000 is not set
+# CONFIG_EDAC_I5100 is not set
+# CONFIG_EDAC_I7300 is not set
+CONFIG_EDAC_SBRIDGE=m
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12057 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_ACPI=y
+# CONFIG_INTEL_IDMA64 is not set
+CONFIG_INTEL_IOATDMA=m
+# CONFIG_DW_DMAC is not set
+# CONFIG_DW_DMAC_PCI is not set
+
+#
+# DMA Clients
+#
+CONFIG_ASYNC_TX_DMA=y
+# CONFIG_DMATEST is not set
+CONFIG_DMA_ENGINE_RAID=y
+CONFIG_DCA=m
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VFIO is not set
+CONFIG_IRQ_BYPASS_MANAGER=y
+CONFIG_VIRT_DRIVERS=y
+CONFIG_VIRTIO=y
+
+#
+# Virtio drivers
+#
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO_PCI_LEGACY=y
+CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_INPUT=y
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_HYPERV is not set
+
+#
+# Xen driver support
+#
+# CONFIG_XEN_BALLOON is not set
+# CONFIG_XEN_DEV_EVTCHN is not set
+# CONFIG_XEN_BACKEND is not set
+# CONFIG_XENFS is not set
+# CONFIG_XEN_SYS_HYPERVISOR is not set
+CONFIG_XEN_XENBUS_FRONTEND=y
+# CONFIG_XEN_GNTDEV is not set
+# CONFIG_XEN_GRANT_DEV_ALLOC is not set
+CONFIG_SWIOTLB_XEN=y
+CONFIG_XEN_PRIVCMD=m
+# CONFIG_XEN_ACPI_PROCESSOR is not set
+# CONFIG_XEN_MCE_LOG is not set
+CONFIG_XEN_HAVE_PVMMU=y
+CONFIG_XEN_EFI=y
+CONFIG_XEN_AUTO_XLATE=y
+CONFIG_XEN_ACPI=y
+CONFIG_XEN_HAVE_VPMU=y
+# CONFIG_STAGING is not set
+CONFIG_X86_PLATFORM_DEVICES=y
+# CONFIG_ACERHDF is not set
+# CONFIG_DELL_WMI is not set
+# CONFIG_DELL_WMI_AIO is not set
+# CONFIG_DELL_SMO8800 is not set
+# CONFIG_FUJITSU_TABLET is not set
+# CONFIG_HP_ACCEL is not set
+# CONFIG_HP_WIRELESS is not set
+# CONFIG_HP_WMI is not set
+# CONFIG_SENSORS_HDAPS is not set
+CONFIG_ACPI_WMI=m
+# CONFIG_TOPSTAR_LAPTOP is not set
+# CONFIG_TOSHIBA_BT_RFKILL is not set
+# CONFIG_TOSHIBA_HAPS is not set
+# CONFIG_TOSHIBA_WMI is not set
+# CONFIG_ACPI_CMPC is not set
+# CONFIG_INTEL_IPS is not set
+# CONFIG_IBM_RTL is not set
+CONFIG_MXM_WMI=m
+# CONFIG_SAMSUNG_Q10 is not set
+# CONFIG_INTEL_RST is not set
+# CONFIG_INTEL_SMARTCONNECT is not set
+# CONFIG_PVPANIC is not set
+# CONFIG_INTEL_PMC_IPC is not set
+# CONFIG_SURFACE_PRO3_BUTTON is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_PXA is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKEVT_I8253=y
+CONFIG_I8253_LOCK=y
+CONFIG_CLKBLD_I8253=y
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_API=y
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Generic IOMMU Pagetable Support
+#
+CONFIG_IOMMU_IOVA=y
+CONFIG_AMD_IOMMU=y
+# CONFIG_AMD_IOMMU_STATS is not set
+CONFIG_AMD_IOMMU_V2=y
+CONFIG_DMAR_TABLE=y
+CONFIG_INTEL_IOMMU=y
+# CONFIG_INTEL_IOMMU_SVM is not set
+# CONFIG_INTEL_IOMMU_DEFAULT_ON is not set
+CONFIG_INTEL_IOMMU_FLOPPY_WA=y
+CONFIG_IRQ_REMAP=y
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+CONFIG_PM_DEVFREQ=y
+
+#
+# DEVFREQ Governors
+#
+# CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND is not set
+# CONFIG_DEVFREQ_GOV_PERFORMANCE is not set
+# CONFIG_DEVFREQ_GOV_POWERSAVE is not set
+# CONFIG_DEVFREQ_GOV_USERSPACE is not set
+
+#
+# DEVFREQ Drivers
+#
+# CONFIG_PM_DEVFREQ_EVENT is not set
+# CONFIG_EXTCON is not set
+CONFIG_MEMORY=y
+# CONFIG_IIO is not set
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_PWM is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+CONFIG_POWERCAP=y
+CONFIG_INTEL_RAPL=m
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_RAS=y
+# CONFIG_THUNDERBOLT is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_STM_DUMMY is not set
+# CONFIG_STM_SOURCE_CONSOLE is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+CONFIG_FIRMWARE_MEMMAP=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+CONFIG_DMI_SYSFS=y
+CONFIG_DMI_SCAN_MACHINE_NON_EFI_FALLBACK=y
+# CONFIG_ISCSI_IBFT_FIND is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# EFI (Extensible Firmware Interface) Support
+#
+# CONFIG_EFI_VARS is not set
+CONFIG_EFI_ESRT=y
+CONFIG_EFI_RUNTIME_MAP=y
+# CONFIG_EFI_FAKE_MEMMAP is not set
+CONFIG_EFI_RUNTIME_WRAPPERS=y
+CONFIG_UEFI_CPER=y
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_ENCRYPTION is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+CONFIG_BTRFS_FS=y
+# CONFIG_BTRFS_FS_POSIX_ACL is not set
+# CONFIG_BTRFS_FS_CHECK_INTEGRITY is not set
+# CONFIG_BTRFS_FS_RUN_SANITY_TESTS is not set
+# CONFIG_BTRFS_DEBUG is not set
+# CONFIG_BTRFS_ASSERT is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_FS_DAX is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+# CONFIG_FANOTIFY_ACCESS_PERMISSIONS is not set
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+CONFIG_PRINT_QUOTA_WARNING=y
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTACTL=y
+CONFIG_QUOTACTL_COMPAT=y
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+CONFIG_OVERLAY_FS=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_PROC_CHILDREN=y
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_EFIVAR_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_PSTORE=y
+# CONFIG_PSTORE_CONSOLE is not set
+# CONFIG_PSTORE_PMSG is not set
+# CONFIG_PSTORE_FTRACE is not set
+# CONFIG_PSTORE_RAM is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+# CONFIG_NFS_V2 is not set
+# CONFIG_NFS_V3 is not set
+CONFIG_NFS_V4=m
+CONFIG_NFS_SWAP=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_PNFS_FILE_LAYOUT=m
+CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN="kernel.org"
+# CONFIG_NFS_V4_1_MIGRATION is not set
+CONFIG_NFS_V4_SECURITY_LABEL=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_NFS_DEBUG=y
+# CONFIG_NFSD is not set
+CONFIG_GRACE_PERIOD=m
+CONFIG_LOCKD=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+CONFIG_SUNRPC_GSS=m
+CONFIG_SUNRPC_BACKCHANNEL=y
+CONFIG_SUNRPC_SWAP=y
+CONFIG_SUNRPC_DEBUG=y
+# CONFIG_SUNRPC_XPRT_RDMA is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_9P_FS=y
+# CONFIG_9P_FS_POSIX_ACL is not set
+# CONFIG_9P_FS_SECURITY is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_INFO_SPLIT is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+# CONFIG_GDB_SCRIPTS is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=8192
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_READABLE_ASM is not set
+CONFIG_UNUSED_SYMBOLS=y
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x01b6
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+CONFIG_HAVE_ARCH_KASAN=y
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_HARDLOCKUP_DETECTOR=y
+# CONFIG_BOOTPARAM_HARDLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE=0
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=60
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHED_INFO=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+CONFIG_TIMER_STATS=y
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS=y
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_FENTRY=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACER_MAX_TRACE=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_TRACER_SNAPSHOT=y
+# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+CONFIG_STACK_TRACER=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_KPROBE_EVENT=y
+CONFIG_UPROBE_EVENT=y
+CONFIG_PROBE_EVENTS=y
+CONFIG_DYNAMIC_FTRACE=y
+CONFIG_DYNAMIC_FTRACE_WITH_REGS=y
+# CONFIG_FUNCTION_PROFILER is not set
+CONFIG_FTRACE_MCOUNT_RECORD=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+# CONFIG_MMIOTRACE is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_TRACE_ENUM_MAP_FILE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_UDELAY is not set
+CONFIG_MEMTEST=y
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+CONFIG_EARLY_PRINTK_EFI=y
+# CONFIG_X86_PTDUMP_CORE is not set
+# CONFIG_X86_PTDUMP is not set
+# CONFIG_EFI_PGT_DUMP is not set
+CONFIG_DEBUG_RODATA=y
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_WX is not set
+CONFIG_DEBUG_SET_MODULE_RONX=y
+# CONFIG_DEBUG_NX_TEST is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_DEBUG_TLBFLUSH is not set
+# CONFIG_IOMMU_DEBUG is not set
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+# CONFIG_X86_DECODER_SELFTEST is not set
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_IO_DELAY_0X80=y
+# CONFIG_IO_DELAY_0XED is not set
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+# CONFIG_DEBUG_BOOT_PARAMS is not set
+# CONFIG_CPA_DEBUG is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_ENTRY is not set
+# CONFIG_DEBUG_NMI_SELFTEST is not set
+# CONFIG_X86_DEBUG_STATIC_CPU_HAS is not set
+CONFIG_X86_DEBUG_FPU=y
+# CONFIG_PUNIT_ATOM_DEBUG is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_COMPAT=y
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+CONFIG_PAGE_TABLE_ISOLATION=y
+CONFIG_SECURITYFS=y
+# CONFIG_SECURITY_NETWORK is not set
+# CONFIG_SECURITY_PATH is not set
+# CONFIG_INTEL_TXT is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_APPARMOR is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_INTEGRITY is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_XOR_BLOCKS=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+# CONFIG_CRYPTO_RSA is not set
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRC32_PCLMUL is not set
+CONFIG_CRYPTO_CRCT10DIF=y
+# CONFIG_CRYPTO_CRCT10DIF_PCLMUL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_POLY1305_X86_64 is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA1_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256_SSSE3 is not set
+# CONFIG_CRYPTO_SHA512_SSSE3 is not set
+# CONFIG_CRYPTO_SHA1_MB is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_X86_64 is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_BLOWFISH_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAMELLIA_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST5_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_CAST6_AVX_X86_64 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_DES3_EDE_X86_64 is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_X86_64 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_CHACHA20_X86_64 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SERPENT_SSE2_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64 is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64_3WAY is not set
+# CONFIG_CRYPTO_TWOFISH_AVX_X86_64 is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_DRBG_MENU is not set
+# CONFIG_CRYPTO_JITTERENTROPY is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
+CONFIG_HAVE_KVM=y
+CONFIG_HAVE_KVM_IRQCHIP=y
+CONFIG_HAVE_KVM_IRQFD=y
+CONFIG_HAVE_KVM_IRQ_ROUTING=y
+CONFIG_HAVE_KVM_EVENTFD=y
+CONFIG_KVM_APIC_ARCHITECTURE=y
+CONFIG_KVM_MMIO=y
+CONFIG_KVM_ASYNC_PF=y
+CONFIG_HAVE_KVM_MSI=y
+CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT=y
+CONFIG_KVM_VFIO=y
+CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT=y
+CONFIG_KVM_COMPAT=y
+CONFIG_HAVE_KVM_IRQ_BYPASS=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_KVM_INTEL=m
+# CONFIG_KVM_AMD is not set
+# CONFIG_KVM_MMU_AUDIT is not set
+# CONFIG_KVM_DEVICE_ASSIGNMENT is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_RAID6_PQ=y
+CONFIG_BITREVERSE=y
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_ARCH_HAS_FAST_MULTIPLIER=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_CHECK_SIGNATURE=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_OID_REGISTRY=m
+CONFIG_UCS2_STRING=y
+CONFIG_FONT_SUPPORT=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_SG_SPLIT is not set
+CONFIG_ARCH_HAS_SG_CHAIN=y
+CONFIG_ARCH_HAS_PMEM_API=y
+CONFIG_ARCH_HAS_MMIO_FLUSH=y
diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index a641cf3ccad6..6b4fb93c4350 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -26,6 +26,11 @@
 #include <linux/pm_runtime.h>
 #include <linux/pinctrl/devinfo.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/hype_kvm.h>
+#include <popcorn/debug.h>
+#endif
+
 #include "base.h"
 #include "power/power.h"
 
@@ -416,6 +421,17 @@ int driver_probe_device(struct device_driver *drv, struct device *dev)
 {
 	int ret = 0;
 
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	/* put all device drivers' init on vcpu0 (host) */
+	POP_PK("\t\t<%d> %s(): pophype: drv %p dev %p pophype setaffinity cpu 0\n",
+							smp_processor_id(), __func__, drv, dev);
+	pophype_set_cpu0();
+	POP_PK("\t\t<%d> %s(): pophype: drv %p dev %p pophype setaffinity cpu 0 done\n",
+									smp_processor_id(), __func__, drv, dev);
+#endif
+#endif
+
 	if (!device_is_registered(dev))
 		return -ENODEV;
 
diff --git a/drivers/block/virtio_blk.c b/drivers/block/virtio_blk.c
index 1e5cd39d0cc2..451af79ac894 100644
--- a/drivers/block/virtio_blk.c
+++ b/drivers/block/virtio_blk.c
@@ -17,6 +17,8 @@
 #define PART_BITS 4
 #define VQ_NAME_LEN 16
 
+#include <popcorn/types.h>
+
 static int major;
 static DEFINE_IDA(vd_index_ida);
 
@@ -573,6 +575,16 @@ static int virtblk_probe(struct virtio_device *vdev)
 	u16 min_io_size;
 	u8 physical_block_exp, alignment_offset;
 
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	printk("\n\n\t\t[%d] %s: vdev %p\n\n",
+			current->pid, __func__, vdev);
+	printk("=========================\n");
+	dump_stack();
+	printk("=========================\n");
+#endif
+#endif
+
 	if (!vdev->config->get) {
 		dev_err(&vdev->dev, "%s failure: config access disabled\n",
 			__func__);
diff --git a/drivers/dio/dio.c b/drivers/dio/dio.c
index 55dd88d82d6d..4eeef18fd2da 100644
--- a/drivers/dio/dio.c
+++ b/drivers/dio/dio.c
@@ -34,6 +34,10 @@
 #include <asm/uaccess.h>
 #include <asm/io.h>                             /* readb() */
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/hype_kvm.h>
+#endif
+
 struct dio_bus dio_bus = {
 	.resources = {
 		/* DIO range */
@@ -175,6 +179,10 @@ static int __init dio_init(void)
 	struct dio_dev *dev;
 	int error;
 
+#if !POPHYPE_HOST_KERNEL
+    printk("%s %s(): (potential problematic point)\n", __FILE__, __func__);
+	pophype_set_cpu0();
+#endif
 	if (!MACH_IS_HP300)
 		return 0;
 
diff --git a/drivers/irqchip/irq-gic.c b/drivers/irqchip/irq-gic.c
index cebd8efe651a..bc9165a3af61 100644
--- a/drivers/irqchip/irq-gic.c
+++ b/drivers/irqchip/irq-gic.c
@@ -1159,6 +1159,9 @@ void __init gic_init(unsigned int gic_nr, int irq_start,
 	 * Non-DT/ACPI systems won't run a hypervisor, so let's not
 	 * bother with these...
 	 */
+#ifdef CONFIG_POPCORN_HYPE
+	printk("[pophype irq][%d] %s():\n", current->pid, __func__);
+#endif
 	static_key_slow_dec(&supports_deactivate);
 	__gic_init_bases(gic_nr, irq_start, dist_base, cpu_base, 0, NULL);
 }
diff --git a/drivers/irqchip/irq-i8259.c b/drivers/irqchip/irq-i8259.c
index 6b304eb39bd2..068b9a3b3379 100644
--- a/drivers/irqchip/irq-i8259.c
+++ b/drivers/irqchip/irq-i8259.c
@@ -112,6 +112,9 @@ void make_8259A_irq(unsigned int irq)
 	disable_irq_nosync(irq);
 	irq_set_chip_and_handler(irq, &i8259A_chip, handle_level_irq);
 	enable_irq(irq);
+#ifdef CONFIG_POPCORN_HYPE
+	IRQCHIPPRINTK("%s(): pop_irqchip8259\n", __func__);
+#endif
 }
 
 /*
@@ -286,6 +289,9 @@ static void init_8259A(int auto_eoi)
 	outb(cached_slave_mask, PIC_SLAVE_IMR);	  /* restore slave IRQ mask */
 
 	raw_spin_unlock_irqrestore(&i8259A_lock, flags);
+#ifdef CONFIG_POPCORN_HYPE
+	IRQCHIPPRINTK("%s(): %s: pop_irqchip8259\n", __func__, __FILE__);
+#endif
 }
 
 /*
@@ -316,6 +322,9 @@ static int i8259A_irq_domain_map(struct irq_domain *d, unsigned int virq,
 {
 	irq_set_chip_and_handler(virq, &i8259A_chip, handle_level_irq);
 	irq_set_probe(virq);
+#ifdef CONFIG_POPCORN_HYPE
+	IRQCHIPPRINTK("%s(): pop_irqchip8259\n", __func__);
+#endif
 	return 0;
 }
 
diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index 50bfded6d7ef..2b8219dbbfb5 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -74,6 +74,8 @@
 
 #include <asm/uaccess.h>
 
+#include <linux/tcp.h>
+
 /* Uncomment to enable debugging */
 /* #define TUN_DEBUG 1 */
 
@@ -448,7 +450,20 @@ static u16 tun_select_queue(struct net_device *dev, struct sk_buff *skb,
 	rcu_read_lock();
 	numqueues = ACCESS_ONCE(tun->numqueues);
 
-	txq = skb_get_hash(skb);
+	//txq = skb_get_hash(skb);
+	txq = __skb_get_hash_symmetric(skb);
+//#if 1 // DEBUGGING
+#if POPHYPE_NET_OPTIMIZE_TMP_DEBUG // DEBUGGING
+	static u64 cnt = 0;
+	cnt++;
+	if (((cnt > 70 && cnt < 100) || !(cnt % 1000)) && txq) {
+		POP_PK("(host) pophype: vhost-net: <%d> %s(): "
+				"skb %p dev \"%s\" "
+				"rxq #%d hash(rxq) #%d (inside) #%llu (%s)\n",
+				smp_processor_id(), __func__,
+				skb, dev->name, txq, tun_hashfn(txq), cnt, __FILE__);
+	}
+#endif
 	if (txq) {
 		e = tun_flow_find(&tun->flows[tun_hashfn(txq)], txq);
 		if (e) {
@@ -463,6 +478,42 @@ static u16 tun_select_queue(struct net_device *dev, struct sk_buff *skb,
 			txq -= numqueues;
 	}
 
+#if defined(CONFIG_POPCORN_HYPE)
+{
+	struct tcphdr *tcph = (struct tcphdr *)skb_transport_header(skb);
+	int dstp = ntohs(tcph->dest);
+	//if (dstp < 0)
+	//	dstp = 0;
+	txq = dstp % tun->numqueues;
+	//return txq;
+	switch(dstp) {
+		case 5052:
+			txq = 0;
+		break;
+		case 5053:
+			txq = 1;
+		break;
+		case 5054:
+			txq = 2;
+		break;
+		case 5055:
+			txq = 3;
+		break;
+	}
+	//txq = __skb_get_hash_symmetric(skb);
+}
+//#else
+
+//&& POPHYPE_NET_OPTIMIZE_TMP_DEBUG // DEBUGGING
+	do {
+		struct tcphdr *tcph = (struct tcphdr *)skb_transport_header(skb);
+		int srcp = ntohs(tcph->source);
+		int dstp = ntohs(tcph->dest);
+		trace_printk("%d -> %d: queue = %d\n", srcp, dstp, txq);
+		//tun->numqueues
+	} while(0);
+#endif
+
 	rcu_read_unlock();
 	return txq;
 }
@@ -488,6 +539,11 @@ static void tun_disable_queue(struct tun_struct *tun, struct tun_file *tfile)
 	tfile->detached = tun;
 	list_add_tail(&tfile->next, &tun->disabled);
 	++tun->numdisabled;
+#if POPHYPE_NET_OPTIMIZE_TMP_DEBUG
+	printk("%s %s(): \"%s\" tun->numqueues %d tun->numdisabled++ (%u)\n",
+			__FILE__, __func__, tun->dev->name,
+				tun->numqueues, tun->numdisabled);
+#endif
 }
 
 static struct tun_struct *tun_enable_queue(struct tun_file *tfile)
@@ -497,6 +553,11 @@ static struct tun_struct *tun_enable_queue(struct tun_file *tfile)
 	tfile->detached = NULL;
 	list_del_init(&tfile->next);
 	--tun->numdisabled;
+#if POPHYPE_NET_OPTIMIZE_TMP_DEBUG
+	printk("%s %s(): \"%s\" tun->numqueues %d tun->numdisabled-- (%u)\n",
+			__FILE__, __func__, tun->dev->name,
+				tun->numqueues, tun->numdisabled);
+#endif
 	return tun;
 }
 
@@ -534,6 +595,15 @@ static void __tun_detach(struct tun_file *tfile, bool clean)
 		/* Drop read queue */
 		tun_queue_purge(tfile);
 		tun_set_real_num_queues(tun);
+#if POPHYPE_NET_OPTIMIZE_TMP_DEBUG
+		printk("%s %s(): \"%s\" tun->numqueues-- (%d) tun->numdisabled %u "
+				"tun->tfiles[0] %p tun->tfiles[1] %p "
+				"tun->tfiles[2] %p tun->tfiles[3] %p\n",
+				__FILE__, __func__, tun->dev->name,
+					tun->numqueues, tun->numdisabled,
+						tun->tfiles[0], tun->tfiles[1],
+						tun->tfiles[2], tun->tfiles[3]);
+#endif
 	} else if (tfile->detached && clean) {
 		tun = tun_enable_queue(tfile);
 		sock_put(&tfile->sk);
@@ -571,6 +641,15 @@ static void tun_detach_all(struct net_device *dev)
 		tfile->socket.sk->sk_data_ready(tfile->socket.sk);
 		RCU_INIT_POINTER(tfile->tun, NULL);
 		--tun->numqueues;
+#if POPHYPE_NET_OPTIMIZE_TMP_DEBUG
+		printk("%s %s(): \"%s\" tun->numqueues-- (%d) tun->numdisabled %u "
+				"tun->tfiles[0] %p tun->tfiles[1] %p "
+				"tun->tfiles[2] %p tun->tfiles[3] %p\n",
+				__FILE__, __func__, tun->dev->name,
+					tun->numqueues, tun->numdisabled,
+						tun->tfiles[0], tun->tfiles[1],
+						tun->tfiles[2], tun->tfiles[3]);
+#endif
 	}
 	list_for_each_entry(tfile, &tun->disabled, next) {
 		tfile->socket.sk->sk_shutdown = RCV_SHUTDOWN;
@@ -645,6 +724,16 @@ static int tun_attach(struct tun_struct *tun, struct file *file, bool skip_filte
 	 * refcnt.
 	 */
 
+#if POPHYPE_NET_OPTIMIZE_TMP_DEBUG
+	printk("%s %s(): \"%s\" tun->numqueues++ (%d) tun->numdisabled %u "
+			"tun->tfiles[0] %p tun->tfiles[1] %p "
+			"tun->tfiles[2] %p tun->tfiles[3] %p\n",
+			__FILE__, __func__, tun->dev->name,
+				tun->numqueues, tun->numdisabled,
+					tun->tfiles[0], tun->tfiles[1],
+					tun->tfiles[2], tun->tfiles[3]);
+	dump_stack();
+#endif
 out:
 	return err;
 }
@@ -814,10 +903,45 @@ static netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)
 	struct tun_file *tfile;
 	u32 numqueues = 0;
 
+//#if defined(CONFIG_POPCORN_HYPE) && HYPE_PERF_NET_DEBUG
+//#if 1 // DEBUGGING
+#if POPHYPE_NET_OPTIMIZE_TMP_DEBUG // DEBUGGING
+	static u64 cnt = 0;
+	cnt++;
+	/* host kernel */
+	CRITICALNETPK("(host) pophype: vhost-net: <%d> %s: %s(): <(inject)- #%llu\n",
+								smp_processor_id(), __FILE__, __func__, cnt);
+//	if (cnt < 300)
+//		dump_stack();
+	if ((cnt > 70 && cnt < 100) || !(cnt % 1000)) {
+		POP_PK("(host) pophype: vhost-net: <%d> %s(): "
+				"skb %p dev \"%s\" rxq #%d #%llu (%s)\n",
+				smp_processor_id(), __func__,
+				skb, dev->name, txq, cnt, __FILE__);
+		POP_PK("(host) pophype: vhost-net: <%d> %s(): "
+				"tun->tfiles[0] %p tun->tfiles[1] %p "
+				"tun->tfiles[2] %p tun->tfiles[3] %p\n",
+				smp_processor_id(), __func__,
+				tun->tfiles[0], tun->tfiles[1],
+				tun->tfiles[2], tun->tfiles[3]);
+	}
+#endif
+
 	rcu_read_lock();
 	tfile = rcu_dereference(tun->tfiles[txq]);
 	numqueues = ACCESS_ONCE(tun->numqueues);
 
+//#if 1 // DEBUGGING
+#if POPHYPE_NET_OPTIMIZE_TMP_DEBUG // DEBUGGING
+	//if ((cnt > 70 && cnt < 100) || !(cnt % 1000)) {
+	if ((cnt < 200) || !(cnt % 1000)) {
+		POP_PK("(host) pophype: vhost-net: <%d> %s(): "
+				"dev \"%s\" tun->numqueues %d #%llu\n",
+				smp_processor_id(), __func__, dev->name, tun->numqueues, cnt);
+
+	}
+#endif
+
 	/* Drop packet if interface is not attached */
 	if (txq >= numqueues)
 		goto drop;
@@ -833,6 +957,24 @@ static netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)
 			struct tun_flow_entry *e;
 			e = tun_flow_find(&tun->flows[tun_hashfn(rxhash)],
 					rxhash);
+//#if 1 // DEBUGGING
+#if POPHYPE_NET_OPTIMIZE_TMP_DEBUG // DEBUGGING
+		if ((cnt > 70 && cnt < 100) || !(cnt % 1000)) {
+			if (e) {
+				POP_PK("(host) pophype: <%d> %s(): "
+						"dev \"%s\" e->queue_index %d rxhash 0x%x [NEVER]\n",
+						smp_processor_id(), __func__,
+						dev->name, e->queue_index, rxhash);
+			} else {
+				POP_PK("(host) pophype: <%d> %s(): "
+						"dev \"%s\" e %p rxhash 0x%x "
+						"tfile->socket.sk->sk_data_ready %p "
+						"(sock_def_readable in ./net/core/sock.c)\n",
+						smp_processor_id(), __func__,
+						dev->name, e, rxhash, tfile->socket.sk->sk_data_ready);
+			}
+		}
+#endif
 			if (e)
 				tun_flow_save_rps_rxhash(e, rxhash);
 		}
@@ -880,6 +1022,13 @@ static netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)
 	/* Notify and wake up reader process */
 	if (tfile->flags & TUN_FASYNC)
 		kill_fasync(&tfile->fasync, SIGIO, POLL_IN);
+#if defined(CONFIG_POPCORN_HYPE)
+	/* Asynchronously notify userspace (above)*/
+
+	/* Wake up blocking process (below)
+		-> sock_def_readable -> wake_up_interruptible_sync_poll
+				in ./net/core/sock.c */
+#endif
 	tfile->socket.sk->sk_data_ready(tfile->socket.sk);
 
 	rcu_read_unlock();
@@ -1097,11 +1246,41 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 	u32 rxhash;
 	ssize_t n;
 
+#if 1
+	{
+		static u64 cnt = 0;
+		cnt++;
+		if ((cnt > 70 && cnt < 100) || !(cnt % 1000)) {
+			VHOSTNET_OPTIMIZE_PK("%s(): (tun->flags & IFF_NO_PI) %d "
+								"(tun->flags & IFF_VNET_HDR) %d\n",
+								__func__, tun->flags & IFF_NO_PI,
+								tun->flags & IFF_VNET_HDR);
+			VHOSTNET_OPTIMIZE_PK("%s(): [cmp] vanilla at origin (from=msg) "
+									"msg->type %d\n", __func__, from->type);
+		}
+	}
+#endif
+
 	if (!(tun->flags & IFF_NO_PI)) {
-		if (len < sizeof(pi))
+		if (len < sizeof(pi)) {
+#if POPHYPE_NET_OPTIMIZE
+			printk("%s(): 1 (not here)\n", __func__);
+#endif
 			return -EINVAL;
+		}
 		len -= sizeof(pi);
 
+#if POPHYPE_NET_OPTIMIZE
+		{
+			static u64 cnt = 0;
+			cnt++;
+			if ((cnt > 70 && cnt < 100) || cnt > 1000) {
+					//!(cnt % 1000) ) {
+				printk("%s(): 1 - 1 there is a copy_from_iter "
+						"so the ptr moved (testing)\n", __func__);
+			}
+		}
+#endif
 		n = copy_from_iter(&pi, sizeof(pi), from);
 		if (n != sizeof(pi))
 			return -EFAULT;
@@ -1110,8 +1289,12 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 	if (tun->flags & IFF_VNET_HDR) {
 		int vnet_hdr_sz = READ_ONCE(tun->vnet_hdr_sz);
 
-		if (len < vnet_hdr_sz)
+		if (len < vnet_hdr_sz) {
+#if POPHYPE_NET_OPTIMIZE
+			printk("%s(): 2 (not here)\n", __func__);
+#endif
 			return -EINVAL;
+		}
 		len -= vnet_hdr_sz;
 
 		n = copy_from_iter(&gso, sizeof(gso), from);
@@ -1122,16 +1305,61 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 		    tun16_to_cpu(tun, gso.csum_start) + tun16_to_cpu(tun, gso.csum_offset) + 2 > tun16_to_cpu(tun, gso.hdr_len))
 			gso.hdr_len = cpu_to_tun16(tun, tun16_to_cpu(tun, gso.csum_start) + tun16_to_cpu(tun, gso.csum_offset) + 2);
 
-		if (tun16_to_cpu(tun, gso.hdr_len) > len)
+#if POPHYPE_NET_OPTIMIZE
+		{
+			static u64 cnt = 0;
+			cnt++;
+			if ((cnt > 70 && cnt < 100) || !(cnt % 1000)) {
+				printk("%s(): [ck] gso.hdr_len %d, "
+						"tun16_to_cpu(tun, gso.hdr_len) %d > len %lu, "
+						"sizeof(pi) %lu sizeof(gso) %lu [remove me for perf]\n",
+						__func__, gso.hdr_len, tun16_to_cpu(tun, gso.hdr_len),
+						len, sizeof(pi), sizeof(gso));
+				printk("%s(): [ck] gso.hdr_len %d = cpu_to_tun16("
+					"tun16_to_cpu(tun, gso.csum_start) %d (%d) + "
+						"tun16_to_cpu(tun, gso.csum_offset) %d (%d) + 2)  %d"
+					"\n",
+					__func__, gso.hdr_len,
+					tun16_to_cpu(tun, gso.csum_start), gso.csum_start,
+					tun16_to_cpu(tun, gso.csum_offset), gso.csum_offset,
+					cpu_to_tun16(tun, tun16_to_cpu(tun, gso.csum_start) +
+									tun16_to_cpu(tun, gso.csum_offset) + 2));
+			}
+		}
+#endif
+		if (tun16_to_cpu(tun, gso.hdr_len) > len) {
+#if POPHYPE_NET_OPTIMIZE
+			printk("%s(): 333 - gso.hdr_len %d, "
+					"tun16_to_cpu(tun, gso.hdr_len) %d > "
+								"len %lu (WRONG), sizeof(pi) %lu "
+								"sizeof(gso) %lu\n",
+								__func__, gso.hdr_len,
+								tun16_to_cpu(tun, gso.hdr_len),
+								len, sizeof(pi), sizeof(gso)); // pi:4 gso:10
+			printk("%s(): [ck] gso.hdr_len %d = cpu_to_tun16("
+					"tun16_to_cpu(tun, gso.csum_start) %d (%d) + "
+						"tun16_to_cpu(tun, gso.csum_offset) %d (%d) + 2)  %d"
+					"\n",
+					__func__, gso.hdr_len,
+					tun16_to_cpu(tun, gso.csum_start), gso.csum_start,
+					tun16_to_cpu(tun, gso.csum_offset), gso.csum_offset,
+					cpu_to_tun16(tun, tun16_to_cpu(tun, gso.csum_start) +
+									tun16_to_cpu(tun, gso.csum_offset) + 2));
+#endif
 			return -EINVAL;
+		}
 		iov_iter_advance(from, vnet_hdr_sz - sizeof(gso));
 	}
 
 	if ((tun->flags & TUN_TYPE_MASK) == IFF_TAP) {
 		align += NET_IP_ALIGN;
 		if (unlikely(len < ETH_HLEN ||
-			     (gso.hdr_len && tun16_to_cpu(tun, gso.hdr_len) < ETH_HLEN)))
+			     (gso.hdr_len && tun16_to_cpu(tun, gso.hdr_len) < ETH_HLEN))) {
+#if POPHYPE_NET_OPTIMIZE
+			printk("%s(): 4\n", __func__);
+#endif
 			return -EINVAL;
+		}
 	}
 
 	good_linear = SKB_MAX_HEAD(align);
@@ -1167,6 +1395,9 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 		return PTR_ERR(skb);
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* I think I have passed this line */
+#endif
 	if (zerocopy)
 		err = zerocopy_sg_from_iter(skb, from);
 	else {
@@ -1180,6 +1411,9 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 	if (err) {
 		tun->dev->stats.rx_dropped++;
 		kfree_skb(skb);
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK(KERN_ERR "pophype: dbg %s():\n", __func__);
+#endif
 		return -EFAULT;
 	}
 
@@ -1188,6 +1422,9 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 					  tun16_to_cpu(tun, gso.csum_offset))) {
 			tun->dev->stats.rx_frame_errors++;
 			kfree_skb(skb);
+#if POPHYPE_NET_OPTIMIZE
+			printk("%s(): 5\n", __func__);
+#endif
 			return -EINVAL;
 		}
 	}
@@ -1207,6 +1444,9 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 			default:
 				tun->dev->stats.rx_dropped++;
 				kfree_skb(skb);
+#if POPHYPE_NET_OPTIMIZE
+				printk("%s(): 6\n", __func__);
+#endif
 				return -EINVAL;
 			}
 		}
@@ -1235,6 +1475,9 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 		default:
 			tun->dev->stats.rx_frame_errors++;
 			kfree_skb(skb);
+#if POPHYPE_NET_OPTIMIZE
+			printk("%s(): 7\n", __func__);
+#endif
 			return -EINVAL;
 		}
 
@@ -1245,6 +1488,9 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 		if (skb_shinfo(skb)->gso_size == 0) {
 			tun->dev->stats.rx_frame_errors++;
 			kfree_skb(skb);
+#if POPHYPE_NET_OPTIMIZE
+			printk("%s(): 8\n", __func__);
+#endif
 			return -EINVAL;
 		}
 
@@ -1269,6 +1515,10 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 	tun->dev->stats.rx_packets++;
 	tun->dev->stats.rx_bytes += len;
 
+#if POPCORN_STAT_MQ_INFO
+	//= tun->dev->stats.rx_packets
+#endif
+
 	tun_flow_update(tun, rxhash, tfile);
 	return total_len;
 }
@@ -1511,6 +1761,89 @@ static int tun_sendmsg(struct socket *sock, struct msghdr *m, size_t total_len)
 	struct tun_file *tfile = container_of(sock, struct tun_file, socket);
 	struct tun_struct *tun = __tun_get(tfile);
 
+#if defined(CONFIG_POPCORN_HYPE) && HYPE_PERF_NET_DEBUG
+	static u64 cnt = 0;
+	cnt++;
+	/* host kernel */
+	CRITICALNETPK("\tpophype: vhost-net: <%d> %s: %s(): -> #%llu\n",
+							smp_processor_id(), __FILE__, __func__, cnt);
+//	if (cnt < 300)
+//		dump_stack();
+#endif
+
+#if POPHYPE_NET_OPTIMIZE
+	{
+		/* (m->msg_controllen && m->msg_control): occasionally happens */
+		static u64 cnt = 0, zcopy_cnt = 1;
+		cnt++;
+		if ((m->msg_controllen && m->msg_control)) {
+			//zcopy_cnt++;
+				/* comment out for disabling printking !msg_control
+						I think zcopy doesn't happen for nginx/ab test */
+		}
+		if ((cnt > 70 && cnt < 100) || !(cnt % 1000) || !(zcopy_cnt % 10) ||
+								m->msg_iter.count == 233) { // check at origin host
+			int pos = 1;
+			struct kvec *iov = (struct kvec*)m->msg_iter.iov;
+			POP_PK("\tpophype: vhost-net: opti: vanilla: <%d> %s: %s(): "
+					"m->msg_namelen %d m->msg_iter[meta_data].iov %p (iov is from vq) "
+					"m->msg_control %p m->msg_controllen %lu (zcopy_used related happens) "
+					"msg->msg_iter.iov->iov_base %p "
+					"msg->msg_iter.[nr_segs] %lu "
+					"msg->msg_iter.[count] %lu (total) "
+					"msg->msg_iter.[iov_offset] %lu "
+					"msg->msg_iter.[iov]->iov_len %lu "
+					"msg->msg_iter.type %d "
+					"[[[sock %p]]] %lu #%llu #%llu\n",
+					smp_processor_id(), __FILE__, __func__,
+					m->msg_namelen, m->msg_iter.iov,
+					m->msg_control, m->msg_controllen,
+					m->msg_iter.iov->iov_base,
+					m->msg_iter.nr_segs,
+					m->msg_iter.count,
+					m->msg_iter.iov_offset,
+					m->msg_iter.iov->iov_len,
+					m->msg_iter.type,
+					sock, total_len,
+					cnt, zcopy_cnt);
+			if (!(zcopy_cnt % 10)) { /* prevent from many printk */
+				zcopy_cnt++;
+			}
+			while (m->msg_iter.nr_segs > pos) {
+				iov++;
+				pos++;
+				printk("\t\tiov[#%d] -> iov_base %p iov_len %lu\n",
+								pos, iov->iov_base, iov->iov_len);
+			}
+#if 0
+			if (!(cnt % 1000)) {
+				ssize_t n;
+				struct virtio_net_hdr gso = { 0 };
+				struct iov_iter *from = &m->msg_iter;
+				int len = m->msg_iter.count;
+				n = copy_from_iter(&gso, sizeof(gso), from);
+				BUG_ON(n != sizeof(gso));
+				printk("[ck][RIGHT] copy_from_iter -> "
+						"tun16_to_cpu(tun, gso.hdr_len) be %d le %d > len %d (WRONG) sizeof(gso) %lu\n",
+											//tun16_to_cpu(tun, gso.hdr_len), len);
+											be16_to_cpu((__force __be16)gso.hdr_len),
+											le16_to_cpu((__force __le16)gso.hdr_len),
+											len, sizeof(gso));
+			}
+#endif
+		}
+		/* happens a lot (not sure from vcpu0/1)!!!!!!!!!
+				Actually controllen=8 but control=null..... */
+		//if (m->msg_controllen) {
+		//	/* happens (8) when ssh into VM */
+		//	POP_PK("\t(BAD) pophype: vhost-net-opti: "
+		//			"<%d> %s: %s(): m->msg_control %p m->msg_controllen %d\n",
+		//			smp_processor_id(), __FILE__, __func__,
+		//			m->msg_control, m->msg_controllen);
+		//}
+	}
+#endif
+
 	if (!tun)
 		return -EBADFD;
 
@@ -1527,6 +1860,16 @@ static int tun_recvmsg(struct socket *sock, struct msghdr *m, size_t total_len,
 	struct tun_struct *tun = __tun_get(tfile);
 	int ret;
 
+#if defined(CONFIG_POPCORN_HYPE) && HYPE_PERF_NET_DEBUG
+	static u64 cnt = 0;
+	cnt++;
+	/* kernel host */
+	CRITICALNETPK("\tpophype: vhost-net: <%d> %s(): <- #%llu\n",
+								smp_processor_id(), __func__, cnt);
+//	if (cnt < 300)
+//		dump_stack();
+#endif
+
 	if (!tun)
 		return -EBADFD;
 
@@ -1678,6 +2021,10 @@ static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)
 		if (*ifr->ifr_name)
 			name = ifr->ifr_name;
 
+#if defined(CONFIG_POPCORN_HYPE)
+		POP_PK("%s(): at %s ->alloc_netdev_mqs()\n",
+						__func__, __FILE__);
+#endif
 		dev = alloc_netdev_mqs(sizeof(struct tun_struct), name,
 				       NET_NAME_UNKNOWN, tun_setup, queues,
 				       queues);
@@ -1915,6 +2262,23 @@ static long __tun_chr_ioctl(struct file *file, unsigned int cmd,
 	rtnl_lock();
 
 	tun = __tun_get(tfile);
+#if POPHYPE_NET_OPTIMIZE_TMP_DEBUG
+	if (tun) {
+		if (tun->dev) {
+			printk("%s %s(): \"%s\" cmd 0x%x "
+					"[from ioctl() -> do_vfs_ioctl()]\n",
+					__FILE__, __func__, tun->dev->name, cmd);
+		} else {
+			printk("%s %s(): tun->dev %p cmd 0x%x "
+					"[from ioctl() -> do_vfs_ioctl()]\n",
+					__FILE__, __func__, tun->dev, cmd);
+		}
+	} else {
+		printk("%s %s(): tun %p cmd 0x%x "
+				"[from ioctl() -> do_vfs_ioctl()]\n",
+				__FILE__, __func__, tun, cmd);
+	}
+#endif
 	if (cmd == TUNSETIFF && !tun) {
 		ifr.ifr_name[IFNAMSIZ-1] = '\0';
 
@@ -2238,6 +2602,11 @@ static int tun_chr_open(struct inode *inode, struct file * file)
 	tfile->socket.file = file;
 	tfile->socket.ops = &tun_socket_ops;
 
+#if defined(CONFIG_POPCORN_HYPE)
+	POP_PK("%s(): at %s -> sock_init_data()\n",
+								__func__, __FILE__);
+	/* ./net/core/sock.c */
+#endif
 	sock_init_data(&tfile->socket, &tfile->sk);
 
 	tfile->sk.sk_write_space = tun_sock_write_space;
@@ -2367,7 +2736,6 @@ static const struct ethtool_ops tun_ethtool_ops = {
 	.get_ts_info	= ethtool_op_get_ts_info,
 };
 
-
 static int __init tun_init(void)
 {
 	int ret = 0;
@@ -2386,6 +2754,8 @@ static int __init tun_init(void)
 		pr_err("Can't register misc device %d\n", TUN_MINOR);
 		goto err_misc;
 	}
+
+	//pr_info("\nDone\n\n");
 	return  0;
 err_misc:
 	rtnl_link_unregister(&tun_link_ops);
diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index 2759d386ade7..ced20a383f6f 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -15,7 +15,7 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
-//#define DEBUG
+//#define DEBUG /* For some reasons host ignores this but guest kenel takes it... */
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/ethtool.h>
@@ -29,6 +29,11 @@
 #include <linux/average.h>
 #include <net/busy_poll.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/hype_kvm.h>
+#include <popcorn/debug.h>
+#endif
+
 static int napi_weight = NAPI_POLL_WEIGHT;
 module_param(napi_weight, int, 0444);
 
@@ -772,6 +777,10 @@ static int virtnet_poll(struct napi_struct *napi, int budget)
 
 	received = virtnet_receive(rq, budget);
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* This may be the guest polling RX vq */
+#endif
+
 	/* Out of packets? */
 	if (received < budget) {
 		r = virtqueue_enable_cb_prepare(rq->vq);
@@ -867,7 +876,10 @@ static int xmit_skb(struct send_queue *sq, struct sk_buff *skb)
 	unsigned hdr_len = vi->hdr_len;
 	bool can_push;
 
-	pr_debug("%s: xmit %p %pM\n", vi->dev->name, skb, dest);
+	pr_debug("%s: %s(): %s: <%d> xmit %p %pM\n",
+			__FILE__, __func__, vi->dev->name, smp_processor_id(), skb, dest);
+	CRITICALNETPK("(test)%s: %s(): %s: <%d> xmit %p %pM\n", /* guest vm */
+			__FILE__, __func__, vi->dev->name, smp_processor_id(), skb, dest);
 
 	can_push = vi->any_header_sg &&
 		!((unsigned long)skb->data & (__alignof__(*hdr) - 1)) &&
@@ -921,12 +933,18 @@ static int xmit_skb(struct send_queue *sq, struct sk_buff *skb)
 		/* Pull header back to avoid skew in tx bytes calculations. */
 		__skb_pull(skb, hdr_len);
 	} else {
+#ifdef CONFIG_POPCORN_HYPE
+		/* put header and skb to sg list */
+#endif
 		sg_set_buf(sq->sg, hdr, hdr_len);
 		num_sg = skb_to_sgvec(skb, sq->sg + 1, 0, skb->len);
 		if (unlikely(num_sg < 0))
 			return num_sg;
 		num_sg++;
 	}
+#ifdef CONFIG_POPCORN_HYPE
+		/* put sg to avail ring */
+#endif
 	return virtqueue_add_outbuf(sq->vq, sq->sg, num_sg, skb, GFP_ATOMIC);
 }
 
@@ -934,6 +952,20 @@ static netdev_tx_t start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct virtnet_info *vi = netdev_priv(dev);
 	int qnum = skb_get_queue_mapping(skb);
+#if 1 // TESTING MY OPTIMIZATION
+#define TESTING_GUEST_TX_PINNED 0
+#if TESTING_GUEST_TX_PINNED
+    /* Popcorn overwrites */
+    if (smp_processor_id() < 2) { /* Hardcode */
+		//int queue_index;
+        //queue_index = smp_processor_id();
+		qnum = smp_processor_id();
+		skb_set_queue_mapping(skb, qnum);
+        /* Remember to overwrite skb */
+        //sk_tx_queue_set(skb, queue_index);
+    }
+#endif
+#endif
 	struct send_queue *sq = &vi->sq[qnum];
 	int err;
 	struct netdev_queue *txq = netdev_get_tx_queue(dev, qnum);
@@ -945,8 +977,114 @@ static netdev_tx_t start_xmit(struct sk_buff *skb, struct net_device *dev)
 	/* timestamp packet in software */
 	skb_tx_timestamp(skb);
 
+#if 1 // DEBUGGING
+	{
+		static u64 cnt = 0;
+		cnt++;
+
+		if ((cnt > 70 && cnt < 200) || !(cnt % 1000)) {
+			POP_PK("(guest) pophype: vhost-net: <%d> %s: %s(): "
+					"skb %p sock %p (net_device) dev %p \"%s\" in_atomic() %d gso %d txq #%d #%llu\n",
+					smp_processor_id(), __FILE__, __func__,
+					skb, skb->sk, dev, dev->name, in_atomic(), skb_is_gso(skb), qnum, cnt);
+			//VHOSTNET_OPTIMIZE_PK("\t\t [[[(guest) %s(): <%d>]]] BUG_ON{ "
+            //            "offset(skb->csum_start %d - skb->data %lu - skb->head %lu)) [[[%d]]]"
+            //            " >= skb_headlen(skb->len %d - skb->data_len %d) [[[%d]]]} csum_offset %u [[csum=%d]] csum %d\n",
+            //            __func__, smp_processor_id(),
+            //            skb->csum_start, (unsigned long)skb->data, (unsigned long)skb->head,
+            //                skb_checksum_start_offset(skb),
+            //            skb->len, skb->data_len,
+            //                skb_headlen(skb),
+            //            skb->csum_offset,
+			//			skb_checksum(skb, skb_checksum_start_offset(skb), skb->len - skb_checksum_start_offset(skb), 0),
+			//			skb->csum);
+			/* At least moment, skb */
+		}
+	}
+#endif
+
+#if POPHYPE_GUEST_NET_OPTIMIZE
+	{
+		static u64 cnt = 0;
+		cnt++;
+#if 0
+		if (cnt > 100 && cnt < 130) {
+			POP_PK("\tpophype: vhost-net: <%d> %s: %s(): "
+					"dump_stack() #%llu\n",
+					smp_processor_id(), __FILE__, __func__, cnt);
+			dump_stack();
+		}
+#endif
+		if ((cnt > 70 && cnt < 200) || !(cnt % 1000)) {
+			POP_PK("\t(guest) pophype: vhost-net: <%d> %s: %s(): "
+					"skb %p sock %p (net_device) dev %p \"%s\" in_atomic() %d gso %d txq #%d #%llu\n",
+					smp_processor_id(), __FILE__, __func__,
+					skb, skb->sk, dev, dev->name, in_atomic(), skb_is_gso(skb), qnum, cnt);
+			//VHOSTNET_OPTIMIZE_PK("\t\t [[[(guest) %s(): <%d>]]] BUG_ON{ "
+            //            "offset(skb->csum_start %d - skb->data %lu - skb->head %lu)) [[[%d]]]"
+            //            " >= skb_headlen(skb->len %d - skb->data_len %d) [[[%d]]]} csum_offset %u [[csum=%d]] csum %d\n",
+            //            __func__, smp_processor_id(),
+            //            skb->csum_start, (unsigned long)skb->data, (unsigned long)skb->head,
+            //                skb_checksum_start_offset(skb),
+            //            skb->len, skb->data_len,
+            //                skb_headlen(skb),
+            //            skb->csum_offset,
+			//			skb_checksum(skb, skb_checksum_start_offset(skb), skb->len - skb_checksum_start_offset(skb), 0),
+			//			skb->csum);
+			/* At least moment, skb */
+		}
+
+		if (smp_processor_id() && !strcmp(dev->name, "eth0") /* perf critical? */
+						&& cnt > 1000) { // debug
+						// TODO only forwar
+						//(cnt > 1000 && cnt < 1100)) {
+			static u64 cnt2 = 0;
+			// ###############################################
+#if 0
+			struct pophype_skb *pskb = guest_skb_to_pophype_skb(skb);
+			int headerlen = skb_headroom(skb);
+			int head_data_len = headerlen + skb->len;
+			/* If skb is linear (i.e., skb->data_len == 0), the length of skb->data is skb->len.
+			If skb is not linear (i.e., skb->data_len != 0),
+					the length of skb->data is (skb->len) - (skb->data_len) for the head ONLY. */
+			int pskb_size = head_data_len + sizeof(*pskb) + 100; // HACK: I'm not using the 100$ right size
+			/* I can tell from here that our implementation copying head + data */
+			//int pskb_size = sizeof(*pskb) + skb->len;
+			cnt2++;
+			VHOSTNET_OPTIMIZE_PK("%s(): <%d> Jack TEST START "
+					"dev \"%s\" skb->dev \"%s\" "
+					"skb %p pskb %p headerlen %d head_data_len %d pskb_size %d (HACKED) gso %d "
+					"#%llu #%llu\n",
+					__func__, smp_processor_id(),
+					dev->name, skb->dev->name,
+					skb, pskb, headerlen, head_data_len, pskb_size, skb_is_gso(skb), cnt, cnt2);
+			BUG_ON(smp_processor_id() > 1); // TODO: HACK FIX THIS IN THE HOST KERNEL // has fixed but in case
+
+
+			/* 1. pophype */
+			//delegate_skb_tx_hypercall(pskb, pskb_size);
+			err = 0;
+#endif
+			/* 2. Vanilla */
+			err = xmit_skb(sq, skb);
+
+			/* Don't wait up for transmitted skbs to be freed. */
+			skb_orphan(skb);
+			nf_reset(skb);
+
+			/* TODO - check outside to match skb syntax */
+			/* TODO - check outside to match skb syntax */
+			/* TODO - check outside to match skb syntax */
+			return NETDEV_TX_OK;
+		} else {
+			/* Try to transmit */
+			err = xmit_skb(sq, skb);
+		}
+	}
+#else
 	/* Try to transmit */
 	err = xmit_skb(sq, skb);
+#endif
 
 	/* This should not happen! */
 	if (unlikely(err)) {
@@ -1590,8 +1728,24 @@ static int virtnet_find_vqs(struct virtnet_info *vi)
 		sprintf(vi->sq[i].name, "output.%d", i);
 		names[rxq2vq(i)] = vi->rq[i].name;
 		names[txq2vq(i)] = vi->sq[i].name;
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("\t(guest) pophype: virtio-net-driver: net: %s(): "
+				"vi->sq[%d] %p \"%s\" vi->rq[%d] %p \"%s\" #%d/%d\n", __func__,
+				i, &vi->sq[i], vi->sq[i].name,
+				i, &vi->rq[i], vi->rq[i].name,
+				i, vi->max_queue_pairs);
+		POP_PK("\t(guest) pophype: virtio-net-driver: net: %s(): "
+				"just wanna check curr_queue_pairs %d (debug)\n", __func__,
+				vi->curr_queue_pairs);
+#endif
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t (guest) pophype: virtio-net-driver: net: pci: %s(): "
+			"callee = vp_find_vqs (drivers/virtio/virtio_pci_common.c): "
+			"create virtqueue data struct and addresses "
+			"& tell the addresses to the back end\n", __func__);
+#endif
 	ret = vi->vdev->config->find_vqs(vi->vdev, total_vqs, vqs, callbacks,
 					 names);
 	if (ret)
@@ -1646,6 +1800,16 @@ static int virtnet_alloc_queues(struct virtnet_info *vi)
 		ewma_pkt_len_init(&vi->rq[i].mrg_avg_pkt_len);
 		sg_init_table(vi->sq[i].sg, ARRAY_SIZE(vi->sq[i].sg));
 	}
+#ifdef CONFIG_POPCORN_HYPE
+    POP_PK("\n\n================ vnet vq ======================\n"
+			"\t(guest)(single) pophype: virtio-net-driver: net: %s %s(): "
+			"create NET DEV (MQ) all start from here - "
+			"vi->max_queue_pairs %d &vi->sq[0] %p &vi->rq[0] %p "
+			"vi->dev %p \"%s\"\n"
+			"================================================\n\n",
+			__FILE__, __func__, vi->max_queue_pairs, vi->sq,
+			vi->rq, vi->dev, vi->dev->name);
+#endif
 
 	return 0;
 
@@ -1659,6 +1823,11 @@ static int init_vqs(struct virtnet_info *vi)
 {
 	int ret;
 
+#ifdef CONFIG_POPCORN_HYPE
+    POP_PK("\t(guest) pophype: virtio-net-driver: "
+								"pci: net: %s():\n", __func__);
+#endif
+
 	/* Allocate send & receive queues */
 	ret = virtnet_alloc_queues(vi);
 	if (ret)
@@ -1748,6 +1917,19 @@ static int virtnet_probe(struct virtio_device *vdev)
 	struct virtnet_info *vi;
 	u16 max_queue_pairs;
 
+#ifdef CONFIG_POPCORN_HYPE
+	//if (smp_processor_id()) { dump_stack(); }
+    POP_PK("\t(guest) pophype: virtio-net-driver: pci: net: %s(): <%d> "
+			"vdev %p - "
+			"ALL START from here\n", __func__, smp_processor_id(), vdev);
+    POP_PK("\t(guest) pophype: virtio-net-driver: pci: net: %s(): <%d> - 1\n",
+												__func__, smp_processor_id());
+	pophype_set_cpu0(); /* Although this , */
+    POP_PK("\t(guest) pophype: virtio-net-driver: pci: net: %s(): <%d> - 2 "
+			"(pophype_set_cpu 0)\n", __func__, smp_processor_id());
+
+#endif
+
 	if (!vdev->config->get) {
 		dev_err(&vdev->dev, "%s failure: config access disabled\n",
 			__func__);
@@ -1762,12 +1944,23 @@ static int virtnet_probe(struct virtio_device *vdev)
 				   struct virtio_net_config,
 				   max_virtqueue_pairs, &max_queue_pairs);
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("err %d || max_queue_pairs %d < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN %d || "
+				"> VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX %d || "
+				"!virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ) %d (debug)\n",
+					err, max_queue_pairs, VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN,
+					VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX,
+					!virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ));
+#endif
 	/* We need at least 2 queue's */
 	if (err || max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN ||
 	    max_queue_pairs > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX ||
 	    !virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))
 		max_queue_pairs = 1;
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* Allocate multiqueue for the net dev */
+#endif
 	/* Allocate ourselves a network device with room for our info */
 	dev = alloc_etherdev_mq(sizeof(struct virtnet_info), max_queue_pairs);
 	if (!dev)
@@ -1866,8 +2059,12 @@ static int virtnet_probe(struct virtio_device *vdev)
 	if (vi->any_header_sg)
 		dev->needed_headroom = vi->hdr_len;
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	vi->curr_queue_pairs = 1; // pophype TODO
+#else
 	/* Use single tx/rx queue pair as default */
 	vi->curr_queue_pairs = 1;
+#endif
 	vi->max_queue_pairs = max_queue_pairs;
 
 	/* Allocate/initialize the rx/tx queues, and invoke find_vqs */
diff --git a/drivers/pci/msi.c b/drivers/pci/msi.c
index 10a6a8e5db88..590a49f9d340 100644
--- a/drivers/pci/msi.c
+++ b/drivers/pci/msi.c
@@ -22,6 +22,10 @@
 #include <linux/irqdomain.h>
 #include <linux/of_irq.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#endif
+
 #include "pci.h"
 
 static int pci_msi_enable = 1;
@@ -952,6 +956,13 @@ int pci_enable_msix(struct pci_dev *dev, struct msix_entry *entries, int nvec)
 	if (!entries)
 		return -EINVAL;
 
+//#if !POPHYPE_HOST_KERNEL
+#ifdef CONFIG_POPCORN_HYPE
+    POP_PK("%s(): pci_dev %p ->irq %d ->driver %p\n",
+				__func__, dev, dev->irq, dev->driver);
+#endif
+//#endif
+
 	nr_entries = pci_msix_vec_count(dev);
 	if (nr_entries < 0)
 		return nr_entries;
@@ -1145,6 +1156,38 @@ void pci_msi_domain_write_msg(struct irq_data *irq_data, struct msi_msg *msg)
 {
 	struct msi_desc *desc = irq_data_get_msi_desc(irq_data);
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+    VPCINETPRINTK("\tpophype: virtio: pci: net: <%d> %s():\n",
+									smp_processor_id(), __func__);
+	/*
+		msi_domain_activate
+		irq_domain_activate_irq
+		irq_startup
+		__setup_irq
+		request_threaded_irq
+		vp_try_to_find_vqs
+		vp_find_vqs
+		virtnet_find_vqs
+		init_vqs
+		virtnet_probe
+		virtio_dev_probe
+		driver_probe_device
+		__driver_attach
+		bus_for_each_dev
+		driver_attach
+		bus_add_driver
+		driver_register
+		register_virtio_driver
+		virtio_net_driver_init
+		do_one_initcall
+		kernel_init_freeable
+		kernel_init
+	*/
+#if !PERF_EXP
+	dump_stack();
+#endif
+#endif
+
 	/*
 	 * For MSI-X desc->irq is always equal to irq_data->irq. For
 	 * MSI only the first interrupt of MULTI MSI passes the test.
diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index 9113876487ed..82be2a1155ae 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -28,6 +28,11 @@
 #include "../base.h"
 #include "pnpacpi.h"
 
+#ifdef CONFIG_POPCORN_HYPE
+//#include <popcorn/bundle.h>
+#include <popcorn/debug.h>
+#endif
+
 static int num;
 
 /*
@@ -312,6 +317,14 @@ static acpi_status __init pnpacpi_add_device_handler(acpi_handle handle,
 int pnpacpi_disabled __initdata;
 static int __init pnpacpi_init(void)
 {
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+    GSMPBSPPRINTK("<%d> %s():\n", smp_processor_id(), __func__);
+    //GSMPBSPPRINTK("\t\t\t===============\n");
+    //dump_stack();
+    //GSMPBSPPRINTK("\t\t\t===============\n\n");
+#endif
+#endif
 	if (acpi_disabled || pnpacpi_disabled) {
 		printk(KERN_INFO "pnp: PnP ACPI: disabled\n");
 		return 0;
diff --git a/drivers/rtc/class.c b/drivers/rtc/class.c
index de86578bcd6d..80a57a8b4c2c 100644
--- a/drivers/rtc/class.c
+++ b/drivers/rtc/class.c
@@ -23,6 +23,10 @@
 
 #include "rtc-core.h"
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/bundle.h>
+#include <popcorn/debug.h>
+#endif
 
 static DEFINE_IDA(rtc_ida);
 struct class *rtc_class;
@@ -168,11 +172,19 @@ struct rtc_device *rtc_device_register(const char *name, struct device *dev,
 	struct rtc_wkalrm alrm;
 	int of_id = -1, id = -1, err;
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	HYPECKPTPRINTK("<%d> %s(): pophype start\n", smp_processor_id(), __func__);
+#endif
+
 	if (dev->of_node)
 		of_id = of_alias_get_id(dev->of_node, "rtc");
 	else if (dev->parent && dev->parent->of_node)
 		of_id = of_alias_get_id(dev->parent->of_node, "rtc");
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	HYPECKPTPRINTK("<%d> %s(): pophype ckpt 1\n", smp_processor_id(), __func__);
+#endif
+
 	if (of_id >= 0) {
 		id = ida_simple_get(&rtc_ida, of_id, of_id + 1,
 				    GFP_KERNEL);
@@ -181,6 +193,10 @@ struct rtc_device *rtc_device_register(const char *name, struct device *dev,
 				    of_id);
 	}
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	HYPECKPTPRINTK("<%d> %s(): pophype ckpt 2\n", smp_processor_id(), __func__);
+#endif
+
 	if (id < 0) {
 		id = ida_simple_get(&rtc_ida, 0, 0, GFP_KERNEL);
 		if (id < 0) {
@@ -189,6 +205,10 @@ struct rtc_device *rtc_device_register(const char *name, struct device *dev,
 		}
 	}
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	HYPECKPTPRINTK("<%d> %s(): pophype ckpt 3\n", smp_processor_id(), __func__);
+#endif
+
 	rtc = kzalloc(sizeof(struct rtc_device), GFP_KERNEL);
 	if (rtc == NULL) {
 		err = -ENOMEM;
@@ -210,6 +230,10 @@ struct rtc_device *rtc_device_register(const char *name, struct device *dev,
 	spin_lock_init(&rtc->irq_task_lock);
 	init_waitqueue_head(&rtc->irq_queue);
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	HYPECKPTPRINTK("<%d> %s(): pophype ckpt 4\n", smp_processor_id(), __func__);
+#endif
+
 	/* Init timerqueue */
 	timerqueue_init_head(&rtc->timerqueue);
 	INIT_WORK(&rtc->irqwork, rtc_timer_do_work);
@@ -225,14 +249,26 @@ struct rtc_device *rtc_device_register(const char *name, struct device *dev,
 	strlcpy(rtc->name, name, RTC_DEVICE_NAME_SIZE);
 	dev_set_name(&rtc->dev, "rtc%d", id);
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	HYPECKPTPRINTK("<%d> %s(): pophype ckpt 5\n", smp_processor_id(), __func__);
+#endif
+
 	/* Check to see if there is an ALARM already set in hw */
 	err = __rtc_read_alarm(rtc, &alrm);
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	HYPECKPTPRINTK("<%d> %s(): pophype ckpt 6\n", smp_processor_id(), __func__);
+#endif
+
 	if (!err && !rtc_valid_tm(&alrm.time))
 		rtc_initialize_alarm(rtc, &alrm);
 
 	rtc_dev_prepare(rtc);
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	HYPECKPTPRINTK("<%d> %s(): pophype ckpt 7\n", smp_processor_id(), __func__);
+#endif
+
 	err = device_register(&rtc->dev);
 	if (err) {
 		/* This will free both memory and the ID */
@@ -240,12 +276,23 @@ struct rtc_device *rtc_device_register(const char *name, struct device *dev,
 		goto exit;
 	}
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	HYPECKPTPRINTK("<%d> %s(): pophype ckpt 8\n", smp_processor_id(), __func__);
+#endif
+
 	rtc_dev_add_device(rtc);
 	rtc_proc_add_device(rtc);
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	HYPECKPTPRINTK("<%d> %s(): pophype ckpt 9\n", smp_processor_id(), __func__);
+#endif
+
 	dev_info(dev, "rtc core: registered %s as %s\n",
 			rtc->name, dev_name(&rtc->dev));
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	HYPECKPTPRINTK("<%d> %s(): pophype done\n", smp_processor_id(), __func__);
+#endif
 	return rtc;
 
 exit_ida:
@@ -352,6 +399,9 @@ EXPORT_SYMBOL_GPL(devm_rtc_device_unregister);
 
 static int __init rtc_init(void)
 {
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	HYPECKPTPRINTK("%s(): pophype\n", __func__);
+#endif
 	rtc_class = class_create(THIS_MODULE, "rtc");
 	if (IS_ERR(rtc_class)) {
 		pr_err("couldn't create class\n");
diff --git a/drivers/rtc/interface.c b/drivers/rtc/interface.c
index c2cf9485fe32..8e886395e8d6 100644
--- a/drivers/rtc/interface.c
+++ b/drivers/rtc/interface.c
@@ -17,6 +17,10 @@
 #include <linux/log2.h>
 #include <linux/workqueue.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#endif
+
 static int rtc_timer_enqueue(struct rtc_device *rtc, struct rtc_timer *timer);
 static void rtc_timer_remove(struct rtc_device *rtc, struct rtc_timer *timer);
 
@@ -597,6 +601,10 @@ struct rtc_device *rtc_class_open(const char *name)
 	if (dev)
 		rtc = to_rtc_device(dev);
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	HYPECKPTPRINTK("%s(): pophype\n", __func__);
+#endif
+
 	if (rtc) {
 		if (!try_module_get(rtc->owner)) {
 			put_device(dev);
diff --git a/drivers/staging/fwserial/fwserial.c b/drivers/staging/fwserial/fwserial.c
index b3ea4bb54e2c..03ed3a397795 100644
--- a/drivers/staging/fwserial/fwserial.c
+++ b/drivers/staging/fwserial/fwserial.c
@@ -2707,6 +2707,10 @@ static int fwserial_parse_mgmt_write(struct fwtty_peer *peer,
 		} else {
 			peer->work_params.plug_req = pkt->plug_req;
 			peer->workfn = fwserial_handle_plug_req;
+#ifdef CONFIG_POPCORN_HYPE
+			WARN_ON_ONCE(-1);
+			printk(KERN_ERR "Not expecting to see unbound_wq in pophype!!\n");
+#endif
 			queue_work(system_unbound_wq, &peer->work);
 		}
 		break;
@@ -2736,6 +2740,10 @@ static int fwserial_parse_mgmt_write(struct fwtty_peer *peer,
 			rcode = RCODE_CONFLICT_ERROR;
 		} else {
 			peer->workfn = fwserial_handle_unplug_req;
+#ifdef CONFIG_POPCORN_HYPE
+			WARN_ON_ONCE(-1);
+			printk(KERN_ERR "Not expecting to see unbound_wq in pophype!!\n");
+#endif
 			queue_work(system_unbound_wq, &peer->work);
 		}
 		break;
diff --git a/drivers/tty/serial/8250/8250_core.c b/drivers/tty/serial/8250/8250_core.c
index 39126460c1f5..47b6f492d570 100644
--- a/drivers/tty/serial/8250/8250_core.c
+++ b/drivers/tty/serial/8250/8250_core.c
@@ -43,6 +43,9 @@
 
 #include <asm/irq.h>
 
+#include <popcorn/bundle.h>
+#include <popcorn/debug.h>
+
 #include "8250.h"
 
 /*
@@ -114,6 +117,30 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 	struct list_head *l, *end = NULL;
 	int pass_counter = 0, handled = 0;
 
+#ifdef CONFIG_POPCORN_HYPE
+#if 0
+	//up->port->irq %u
+	static unsigned int cnt = 0;
+	cnt++;
+#endif
+#if !POPHYPE_HOST_KERNEL
+#if 0
+	printk("%s(): <%d> irq %d h %lu s %lu #%u\n",
+			__func__, smp_processor_id(), irq, in_irq(), in_softirq(), cnt);
+#endif
+//#ifdef CONFIG_POPCORN_CHECK_SANITY
+#if !POPHYPE_HOST_KERNEL
+	BUG_ON(smp_processor_id());
+#endif
+#else
+#if 0
+	if (cnt < 100)
+		printk("%s(): <%d> irq %d h %lu s %lu #%u\n",
+				__func__, smp_processor_id(), irq, in_irq(), in_softirq(), cnt);
+#endif
+#endif
+#endif
+
 	DEBUG_INTR("serial8250_interrupt(%d)...", irq);
 
 	spin_lock(&i->lock);
diff --git a/drivers/tty/serial/pch_uart.c b/drivers/tty/serial/pch_uart.c
index ea4ffc2ebb2f..797133fa3a02 100644
--- a/drivers/tty/serial/pch_uart.c
+++ b/drivers/tty/serial/pch_uart.c
@@ -36,6 +36,9 @@
 #include <linux/dmaengine.h>
 #include <linux/pch_dma.h>
 
+#include <popcorn/bundle.h>
+#include <popcorn/debug.h>
+
 enum {
 	PCH_UART_HANDLED_RX_INT_SHIFT,
 	PCH_UART_HANDLED_TX_INT_SHIFT,
@@ -1136,6 +1139,9 @@ static irqreturn_t pch_uart_interrupt(int irq, void *dev_id)
 						PCH_UART_HAL_RX_INT |
 						PCH_UART_HAL_RX_ERR_INT);
 			} else {
+#ifdef CONFIG_POPCORN_HYPE
+				/* Be careful */
+#endif
 				ret = handle_rx(priv);
 			}
 			break;
@@ -1358,6 +1364,9 @@ static int pch_uart_startup(struct uart_port *port)
 					    PCH_UART_HAL_RX_ERR_INT);
 	uart_update_timeout(port, CS8, default_baud);
 
+#ifdef CONFIG_POPCORN_HYPE
+	printk("%s(): pop_hype\n", __func__);
+#endif
 	return 0;
 }
 
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index def5199ca004..9aacc574e057 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -38,6 +38,8 @@
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 
+#include <popcorn/bundle.h>
+#include <popcorn/debug.h>
 /*
  * This is used to lock changes in serial line configuration.
  */
@@ -2204,6 +2206,27 @@ uart_report_port(struct uart_driver *drv, struct uart_port *port)
 	       drv->dev_name,
 	       drv->tty_driver->name_base + port->line,
 	       address, port->irq, port->uartclk / 16, uart_type(port));
+#if !POPHYPE_HOST_KERNEL
+#if 0 /* Doesn't work */
+//#define POPCORN_TTYS0_IRQ 4 /* port->irq */
+	{
+		cpumask_var_t new_value;
+		int ret;
+		BUG_ON(!alloc_cpumask_var(&new_value, GFP_KERNEL));
+		//BUG_ON(cpumask_parse_user("1", 2, new_value));
+		cpumask_clear(new_value);
+		cpumask_set_cpu(0, new_value);
+		ret = irq_set_affinity(port->irq, new_value);
+		printk("\t\t[%d] %s(): Pophype sets console/serial irq %d "
+						"as 0x01 (cpu0) ret %d(It may fail and idk)\n",
+								current->pid, __func__, port->irq, ret);
+		if (ret < 0)
+			printk(KERN_ERR "\n\n\t\t\tERROR: [%d] %s(): cannot set irq\n\n\n",
+														current->pid, __func__);
+		//show_irq_affinity
+	}
+#endif
+#endif
 }
 
 static void
@@ -2923,6 +2946,12 @@ void uart_insert_char(struct uart_port *port, unsigned int status,
 		 unsigned int overrun, unsigned int ch, unsigned int flag)
 {
 	struct tty_port *tport = &port->state->port;
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	/* watchout in irq_context & port_lock(uart_lock) */
+#else
+#endif
+#endif
 
 	if ((status & port->ignore_status_mask & ~overrun) == 0)
 		if (tty_insert_flip_char(tport, ch, flag) == 0)
diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c
index 8f3566cde3eb..a0871829d17b 100644
--- a/drivers/tty/tty_buffer.c
+++ b/drivers/tty/tty_buffer.c
@@ -17,6 +17,8 @@
 #include <linux/module.h>
 #include <linux/ratelimit.h>
 
+#include <popcorn/bundle.h>
+#include <popcorn/debug.h>
 
 #define MIN_TTYB_SIZE	256
 #define TTYB_ALIGN_MASK	255
@@ -71,7 +73,12 @@ void tty_buffer_unlock_exclusive(struct tty_port *port)
 	atomic_dec(&buf->priority);
 	mutex_unlock(&buf->lock);
 	if (restart)
+#if !POPHYPE_HOST_KERNEL
+		queue_work_on(0, system_wq, &buf->work);
+		//queue_work(system_wq, &buf->work);
+#else
 		queue_work(system_unbound_wq, &buf->work);
+#endif
 }
 EXPORT_SYMBOL_GPL(tty_buffer_unlock_exclusive);
 
@@ -404,7 +411,12 @@ void tty_schedule_flip(struct tty_port *port)
 	 * flush_to_ldisc() sees buffer data.
 	 */
 	smp_store_release(&buf->tail->commit, buf->tail->used);
+#if !POPHYPE_HOST_KERNEL
+	queue_work_on(0, system_wq, &buf->work);
+	//queue_work(system_wq, &buf->work);
+#else
 	queue_work(system_unbound_wq, &buf->work);
+#endif
 }
 EXPORT_SYMBOL(tty_schedule_flip);
 
@@ -589,7 +601,12 @@ void tty_buffer_set_lock_subclass(struct tty_port *port)
 
 bool tty_buffer_restart_work(struct tty_port *port)
 {
+#if !POPHYPE_HOST_KERNEL
+	return queue_work_on(0, system_wq, &port->buf.work);
+	//return queue_work(system_wq, &port->buf.work);
+#else
 	return queue_work(system_unbound_wq, &port->buf.work);
+#endif
 }
 
 bool tty_buffer_cancel_work(struct tty_port *port)
diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index 44a5a8777053..fea33ca90c5b 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -5,7 +5,6 @@
  *
  * virtio-net server in host kernel.
  */
-
 #include <linux/compat.h>
 #include <linux/eventfd.h>
 #include <linux/vhost.h>
@@ -30,6 +29,12 @@
 
 #include "vhost.h"
 
+#ifdef CONFIG_POPCORN_HYPE
+#define DEBUG
+#include <popcorn/debug.h>
+#include <popcorn/hype_kvm.h>
+#endif
+
 static int experimental_zcopytx = 1;
 module_param(experimental_zcopytx, int, 0444);
 MODULE_PARM_DESC(experimental_zcopytx, "Enable Zero Copy TX;"
@@ -309,6 +314,24 @@ static void handle_tx(struct vhost_net *net)
 	struct vhost_net_ubuf_ref *uninitialized_var(ubufs);
 	bool zcopy, zcopy_used;
 
+#ifdef CONFIG_POPCORN_HYPE
+	CRITICALNETPK("\tpophype: vhost-net: %s: %s():\n", __FILE__, __func__);
+#endif
+#if POPHYPE_NET_OPTIMIZE
+    {
+        static u64 cnt = 0;
+        cnt++;
+        if ((cnt > 70 && cnt < 100) || !(cnt % 1000)) {
+            POP_PK("\tpophype: vhost-net: opti: vanilla: <%d> %s: %s(): "
+				"(vhost_net)net %p (vhost_dev)&net->dev %p "
+				"(vhost_virtqueue)(&nvq(&net->vqs[VHOST_NET_VQ_TX])->vq)vq %p "
+				"#%llu\n",
+				smp_processor_id(), __FILE__, __func__,
+				net, &net->dev, vq, cnt);
+        }
+    }
+#endif
+
 	mutex_lock(&vq->mutex);
 	sock = vq->private_data;
 	if (!sock)
@@ -331,6 +354,9 @@ static void handle_tx(struct vhost_net *net)
 			      % UIO_MAXIOV == nvq->done_idx))
 			break;
 
+#if POPHYPE_NET_OPTIMIZE
+		/* Our delegation optmization doesn't need to do this, going through vq */
+#endif
 		head = vhost_get_vq_desc(vq, vq->iov,
 					 ARRAY_SIZE(vq->iov),
 					 &out, &in,
@@ -368,6 +394,25 @@ static void handle_tx(struct vhost_net *net)
 				   && (nvq->upend_idx + 1) % UIO_MAXIOV !=
 				      nvq->done_idx
 				   && vhost_net_tx_select_zcopy(net);
+#if POPHYPE_NET_OPTIMIZE
+		{
+			// TODO !len is worng I think
+			static u64 cnt = 0;
+			cnt++;
+			if ((cnt > 70 && cnt < 100) || !(cnt % 1000)) {
+				POP_PK("\t(kernel) pophype: vhost-net: opti: vanilla: <%d> %s: %s(): "
+					 "zcopy_used %d (0) vq->iov %p len %lu (nr_segs) out %d in %d "
+					"[sock %p] hdr_size(nvq->vhost_hlen) %d #%llu\n",
+					smp_processor_id(), __FILE__, __func__,
+					zcopy_used, vq->iov, len, out, in, sock, hdr_size, cnt);
+				/* zcopy_used 1 when len is large like XXX to xxxx */
+			}
+			// 09/25 debug
+			if (len == 233) {
+				POP_PK("\n\n\n\t\t%s(): === THERE IS STILL A HOPE ===\n\n\n\n", __func__);
+			}
+		}
+#endif
 
 		/* use msg_control to pass vhost zerocopy ubuf info to skb */
 		if (zcopy_used) {
@@ -402,9 +447,12 @@ static void handle_tx(struct vhost_net *net)
 		if (err != len)
 			pr_debug("Truncated TX packet: "
 				 " len %d != %zd\n", err, len);
-		if (!zcopy_used)
+		if (!zcopy_used) {
+#if POPHYPE_NET_OPTIMIZE
+			/* update virtqueue used ring (e.g. used_elem, last_used_idx) */
+#endif
 			vhost_add_used_and_signal(&net->dev, vq, head, 0);
-		else
+		} else
 			vhost_zerocopy_signal_used(net, vq);
 		total_len += len;
 		vhost_net_tx_packet(net);
@@ -540,6 +588,11 @@ static void handle_rx(struct vhost_net *net)
 	struct iov_iter fixup;
 	__virtio16 num_buffers;
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* kernel host */
+	CRITICALNETPK("\tpophype: vhost-net: %s: %s():\n", __FILE__, __func__);
+#endif
+
 	mutex_lock(&vq->mutex);
 	sock = vq->private_data;
 	if (!sock)
@@ -626,6 +679,22 @@ static void handle_rx(struct vhost_net *net)
 			vhost_discard_vq_desc(vq, headcount);
 			break;
 		}
+#ifdef CONFIG_POPCORN_HYPE
+		/* kernel host */
+		CRITICALNETPK("%s %s(): vhost_signal -> eventfd_signal\n",
+										__FILE__, __func__);
+		{
+			static u64 cnt = 0;
+			cnt++;
+			if ((cnt > 70 && cnt < 100) || !(cnt % 1000)) {
+				VHOSTNET_OPTIMIZE_PK("\tpophype: vhost-net: <%d> %s: %s(): "
+						"(vhost_dev)(&net->dev)dev %p (vhost_virtqueue)vq %p "
+						"vq->heads %p #%llu\n",
+						smp_processor_id(), __FILE__, __func__,
+						&net->dev, vq, vq->heads, cnt);
+			}
+		}
+#endif
 		vhost_add_used_and_signal_n(&net->dev, vq, vq->heads,
 					    headcount);
 		if (unlikely(vq_log))
@@ -669,6 +738,11 @@ static void handle_rx_net(struct vhost_work *work)
 {
 	struct vhost_net *net = container_of(work, struct vhost_net,
 					     poll[VHOST_NET_VQ_RX].work);
+#ifdef CONFIG_POPCORN_HYPE
+	/* host kernel */
+	CRITICALNETPK("%s %s(): vhost_signal -> eventfd_signal net->dev.**vqs %p\n",
+										__FILE__, __func__, net->dev.vqs);
+#endif
 	handle_rx(net);
 }
 
@@ -679,6 +753,16 @@ static int vhost_net_open(struct inode *inode, struct file *f)
 	struct vhost_virtqueue **vqs;
 	int i;
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("===================== (guest) start %s(): ====================\n"
+			"\tpophype: vhost-net: vhost_net_init -> vhost_net.open "
+			"\"devname:vhost-net\" ->vhost_dev_init() "
+			"and ->vhost_poll_init() * 2 (handle_tx_net & handle_rx_net). "
+			"vhost_net (1 per qp) = "
+			"ONE vhost_dev + TWO vhost_virtqueue vqs (tx&rx)"
+													"\n\n", __func__);
+#endif
+
 	n = kmalloc(sizeof *n, GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);
 	if (!n) {
 		n = vmalloc(sizeof *n);
@@ -710,7 +794,31 @@ static int vhost_net_open(struct inode *inode, struct file *f)
 	vhost_poll_init(n->poll + VHOST_NET_VQ_RX, handle_rx_net, POLLIN, dev);
 
 	f->private_data = n;
+#ifdef CONFIG_POPCORN_HYPE // #if POPHYPE_GUEST_NET_OPTIMIZE
+	POP_PK("\t(guest) pophype: vhost-net: opti: <%d> %s: %s(): "
+			"(struct vhost_virtqueue) vqs %p "
+			"[[[[[ Jack vqs[VHOST_NET_VQ_TX] [[[%p]]] (shared) "
+					"vqs[VHOST_NET_VQ_RX] [[[%p]]] (shared) ]]]]]"
+			"(This also explain why there is no MQ in vhost)\n",
+			smp_processor_id(), __FILE__, __func__,
+			vqs, vqs[VHOST_NET_VQ_TX], vqs[VHOST_NET_VQ_RX]);
+	POP_PK("\t(guest) pophype: vhost-net: opti: <%d> %s: %s(): "
+			"((vhost_dev)dev)->memory %p "
+			"((1 per qp) vhost_net %p -> vhost_dev %p -> "
+			"(vqs %p)vhost_virtqueue[TX/RX])\n",
+			smp_processor_id(), __FILE__, __func__,
+			dev->memory,
+			n, dev, vqs);
+	//POP_PK("\tpophype: vhost-net: opti: <%d> %s: %s(): "
+	//		"n->poll %p + (VHOST_NET_VQ_TX 0) / (VHOST_NET_VQ_TX 1)\n",
+	//		smp_processor_id(), __FILE__, __func__,
+	//		n->poll);
+#endif
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t(guest) pophype: vhost-net: vhost_net_init -> vhost_net.open dev %p created DONE\n"
+			"==================== %s() end ======================\n\n\n", dev, __func__);
+#endif
 	return 0;
 }
 
@@ -725,6 +833,10 @@ static void vhost_net_disable_vq(struct vhost_net *n,
 	vhost_poll_stop(poll);
 }
 
+#if POPHYPE_NET_OPTIMIZE
+//struct socket *pophype_origin_host_tun_sock;
+extern struct socket *pophype_origin_host_tun_sock;
+#endif
 static int vhost_net_enable_vq(struct vhost_net *n,
 				struct vhost_virtqueue *vq)
 {
@@ -733,6 +845,13 @@ static int vhost_net_enable_vq(struct vhost_net *n,
 	struct vhost_poll *poll = n->poll + (nvq - n->vqs);
 	struct socket *sock;
 
+#if POPHYPE_NET_OPTIMIZE
+	POP_PK("%s: %s(): Jack vq->private_data = (struct socket) *sock = %p\n",
+										__FILE__, __func__, vq->private_data);
+	WARN_ON("NEVER");
+	pophype_origin_host_tun_sock = vq->private_data;
+#endif
+
 	sock = vq->private_data;
 	if (!sock)
 		return 0;
@@ -892,6 +1011,11 @@ static long vhost_net_set_backend(struct vhost_net *n, unsigned index, int fd)
 	}
 	vq = &n->vqs[index].vq;
 	nvq = &n->vqs[index];
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("(host) %s(): init: fd %d queue index %d (0rx/1tx) "
+			"vq %p = nvq %p (%s)\n",
+			__func__, fd, index, vq, nvq, __FILE__);
+#endif
 	mutex_lock(&vq->mutex);
 
 	/* Verify that ring has been setup correctly. */
@@ -1032,6 +1156,11 @@ static long vhost_net_set_owner(struct vhost_net *n)
 {
 	int r;
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t\t%s: %s(): start ->kthread_create(vhost_worker)\n",
+											__FILE__, __func__);
+#endif
+
 	mutex_lock(&n->dev.mutex);
 	if (vhost_dev_has_owner(&n->dev)) {
 		r = -EBUSY;
@@ -1046,6 +1175,10 @@ static long vhost_net_set_owner(struct vhost_net *n)
 	vhost_net_flush(n);
 out:
 	mutex_unlock(&n->dev.mutex);
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t\t%s: %s(): done ->kthread_create(vhost_worker)\n",
+											__FILE__, __func__);
+#endif
 	return r;
 }
 
@@ -1059,8 +1192,20 @@ static long vhost_net_ioctl(struct file *f, unsigned int ioctl,
 	u64 features;
 	int r;
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t%s %s(): fd %d ioctl 0x%x\n",
+			//"host_usr rip 0x%lx guest_kern rip 0x%lx\n",
+			__FILE__, __func__,
+			popcorn_file_to_fd(current, f, false), ioctl);
+			//instruction_pointer(current_pt_regs()),
+			//((dsm_traffic_t)(pophype_show_guest_rip_rsp(0x0), false)).rip); /* just wanna show rip */
+#endif
 	switch (ioctl) {
 	case VHOST_NET_SET_BACKEND:
+#ifdef CONFIG_POPCORN_HYPE
+        POP_PK("\t\tpophype: vhost-net: %s: %s(): VHOST_NET_SET_BACKEND\n",
+                                                        __FILE__, __func__);
+#endif
 		if (copy_from_user(&backend, argp, sizeof backend))
 			return -EFAULT;
 		return vhost_net_set_backend(n, backend.index, backend.fd);
@@ -1078,6 +1223,11 @@ static long vhost_net_ioctl(struct file *f, unsigned int ioctl,
 	case VHOST_RESET_OWNER:
 		return vhost_net_reset_owner(n);
 	case VHOST_SET_OWNER:
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("\t\tpophype: vhost-net: %s: %s(): "
+				"ioctl 0x%x = 0x%x (VHOST_SET_OWNER)\n",
+				__FILE__, __func__, ioctl, VHOST_SET_OWNER);
+#endif
 		return vhost_net_set_owner(n);
 	default:
 		mutex_lock(&n->dev.mutex);
diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c
index 675819a1af37..2c33fde7fe84 100644
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -28,6 +28,10 @@
 #include <linux/module.h>
 #include <linux/sort.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/hype_kvm.h>
+#endif
+
 #include "vhost.h"
 
 static ushort max_mem_regions = 64;
@@ -155,6 +159,11 @@ void vhost_poll_init(struct vhost_poll *poll, vhost_work_fn_t fn,
 	poll->dev = dev;
 	poll->wqh = NULL;
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t\t(kernel) pophype: vhost-net: %s(): create a Q mask 0x%lx "
+							"rx: 0x1, tx: 0x4\n", __func__, mask);
+#endif
+
 	vhost_work_init(&poll->work, fn);
 }
 EXPORT_SYMBOL_GPL(vhost_poll_init);
@@ -166,6 +175,11 @@ int vhost_poll_start(struct vhost_poll *poll, struct file *file)
 	unsigned long mask;
 	int ret = 0;
 
+#ifdef CONFIG_POPCORN_HYPE
+    POP_PK("\t%s %s(): fd %d\n",
+		__FILE__, __func__, popcorn_file_to_fd(current, file, false));
+#endif
+
 	if (poll->wqh)
 		return 0;
 
@@ -286,6 +300,12 @@ static int vhost_worker(void *data)
 	unsigned uninitialized_var(seq);
 	mm_segment_t oldfs = get_fs();
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t[%d] pophype: vhost-net: %s(): I'm \"vhost-XXX\"\n",
+											current->pid, __func__);
+	//pophype_set_cpu0(); // kill me. This doesn't help
+#endif
+
 	set_fs(USER_DS);
 	use_mm(dev->mm);
 
@@ -386,6 +406,12 @@ void vhost_dev_init(struct vhost_dev *dev,
 	INIT_LIST_HEAD(&dev->work_list);
 	dev->worker = NULL;
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t(kernel) pophype: vhost-net: %s: %s(): "
+			"vhost_dev %p (1 per qp) dev->nvqs %d vhost_net_open()->\n",
+			__FILE__, __func__, dev, dev->nvqs);
+#endif
+
 	for (i = 0; i < dev->nvqs; ++i) {
 		vq = dev->vqs[i];
 		vq->log = NULL;
@@ -394,9 +420,20 @@ void vhost_dev_init(struct vhost_dev *dev,
 		vq->dev = dev;
 		mutex_init(&vq->mutex);
 		vhost_vq_reset(dev, vq);
-		if (vq->handle_kick)
+		if (vq->handle_kick) {
+#ifdef CONFIG_POPCORN_HYPE
+			POP_PK("\t(kernel) pophype: vhost-net: %s: %s(): "
+					"->vhost_poll_init(vq->handle_kick %p, rx) #%d/%d\n",
+					__FILE__, __func__, vq->handle_kick, i, dev->nvqs);
+#endif
+#if POPHYPE_NET_OPTIMIZE
+			POP_PK("\t(kernel) pophype: vhost-net: %s: %s(): "
+					"Jack (shared)vq va %p pa 0x%llx #%d/%d\n",
+					__FILE__, __func__, vq, virt_to_phys(vq), i, dev->nvqs);
+#endif
 			vhost_poll_init(&vq->poll, vq->handle_kick,
 					POLLIN, dev);
+		}
 	}
 }
 EXPORT_SYMBOL_GPL(vhost_dev_init);
@@ -453,6 +490,35 @@ long vhost_dev_set_owner(struct vhost_dev *dev)
 		goto err_mm;
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t\tpophype: vhost-net: %s(): %s(): "
+			"create vhost_worker \"vhost-%d\"\n",
+			__FILE__, __func__, current->pid);
+	if (distributed_process(current)) {
+		/* reinstall a proper tsk (this happens after kvm_vcpu_mmap) */
+		/* BUT ps aux at remote. Remote still use kernel thread to replay it =>
+			Cannot get the right usr's address space */
+		int i, found = 0;
+		for (i = 0; i < MAX_POPCORN_VCPU; i++) {
+			if (my_nid == popcorn_vcpuid_to_nid(i)) {
+				int fd = i + VCPU_FD_BASE;
+				POP_PK("\t\tpophype: vhost-net: vcpu_id %d is on my node\n", i);
+				if (hype_node_info[my_nid][fd]->vcpu) {
+					found = 1;
+					hype_node_info[my_nid][fd]->tsk = current;
+					POP_PK("[%d/%d] (INSTALL VCPU - TSK) fd %d current %p - "
+						"I'm a %s thread at %s\n",
+						my_nid, current->pid, fd,
+						current, current->mm ? "KERN" : "USER",
+						distributed_remote_process(current) ? "REMOTE" : "ORIGIN");
+					break;
+				}
+			}
+		}
+		BUG_ON(!found);
+	}
+#endif
+
 	/* No owner, become one */
 	dev->mm = get_task_mm(current);
 	worker = kthread_create(vhost_worker, dev, "vhost-%d", current->pid);
@@ -726,6 +792,15 @@ static long vhost_set_memory(struct vhost_dev *d, struct vhost_memory __user *m)
 		mutex_unlock(&d->vqs[i]->mutex);
 	}
 	kvfree(oldmem);
+#if POPHYPE_NET_OPTIMIZE
+	POP_PK("pophype: %s %s(): [[[vhost]]] Jack "
+			"newmem->regions[0] .guest_phys_addr 0x%llx .memory_size 0x%llx "
+			".userspace_addr 0x%llx .flags_padding 0x%llx\n",
+			__FILE__, __func__, newmem->regions[0].guest_phys_addr,
+			newmem->regions[0].memory_size,
+			newmem->regions[0].userspace_addr,
+			newmem->regions[0].flags_padding);
+#endif
 	return 0;
 }
 
@@ -742,9 +817,25 @@ long vhost_vring_ioctl(struct vhost_dev *d, int ioctl, void __user *argp)
 	u32 idx;
 	long r;
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t\tpophype: vhost-net: %s: %s(): "
+			"1 - ioctl 0x%x (default && -ENOIOCTLCMD)\n",
+							__FILE__, __func__, ioctl);
+#endif
+
 	r = get_user(idx, idxp);
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t\tpophype: vhost-net: %s: %s(): "
+			"2 - r %ld\n",
+			__FILE__, __func__, r);
+#endif
 	if (r < 0)
 		return r;
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t\tpophype: vhost-net: %s: %s(): "
+			"3 - idx %d >= d->nvqs %d d %p\n",
+			__FILE__, __func__, idx, d->nvqs, d);
+#endif
 	if (idx >= d->nvqs)
 		return -ENOBUFS;
 
@@ -813,6 +904,20 @@ long vhost_vring_ioctl(struct vhost_dev *d, int ioctl, void __user *argp)
 			break;
 		}
 
+#if POPHYPE_NET_OPTIMIZE
+		{
+			static u64 cnt = 0;
+			cnt++;
+			POP_PK("\t(kernel) pophype: vhost-net: %s: %s(): "
+					"VHOST_SET_VRING_ADDR Jack "
+					"a.desc_user_addr 0x%llx "
+					"a.used_user_addr 0x%llx "
+					"a.avail_user_addr 0x%llx "
+					"#%llu\n",
+					__FILE__, __func__,
+					a.desc_user_addr, a.used_user_addr, a.avail_user_addr, cnt);
+		}
+#endif
 		/* Make sure it's safe to cast pointers to vring types. */
 		BUILD_BUG_ON(__alignof__ *vq->avail > VRING_AVAIL_ALIGN_SIZE);
 		BUILD_BUG_ON(__alignof__ *vq->used > VRING_USED_ALIGN_SIZE);
@@ -852,7 +957,15 @@ long vhost_vring_ioctl(struct vhost_dev *d, int ioctl, void __user *argp)
 		vq->used = (void __user *)(unsigned long)a.used_user_addr;
 		break;
 	case VHOST_SET_VRING_KICK:
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("\t\tpophype: vhost-net: %s: %s(): VHOST_SET_VRING_KICK\n",
+														__FILE__, __func__);
+#endif
 		if (copy_from_user(&f, argp, sizeof f)) {
+#ifdef CONFIG_POPCORN_HYPE
+			POP_PK("\t\tpophype: vhost-net: %s: %s():\n",
+										__FILE__, __func__);
+#endif
 			r = -EFAULT;
 			break;
 		}
@@ -872,6 +985,11 @@ long vhost_vring_ioctl(struct vhost_dev *d, int ioctl, void __user *argp)
 			r = -EFAULT;
 			break;
 		}
+#ifdef CONFIG_POPCORN_HYPE
+		/* Set eventfd to signal when buffers have beed used */
+		POP_PK("\t\tpophype: vhost-net: %s: %s(): VHOST_SET_VRING_CALL "
+					"fd %d index %u\n", __FILE__, __func__, f.fd, f.index);
+#endif
 		eventfp = f.fd == -1 ? NULL : eventfd_fget(f.fd);
 		if (IS_ERR(eventfp)) {
 			r = PTR_ERR(eventfp);
@@ -943,6 +1061,11 @@ long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)
 	long r;
 	int i, fd;
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t\tpophype: vhost-net: %s: %s(): ioctl 0x%x (default)\n",
+												__FILE__, __func__, ioctl);
+#endif
+
 	/* If you are not the owner, you can become one */
 	if (ioctl == VHOST_SET_OWNER) {
 		r = vhost_dev_set_owner(d);
@@ -956,6 +1079,11 @@ long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)
 
 	switch (ioctl) {
 	case VHOST_SET_MEM_TABLE:
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("\t\t\tpophype: vhost-net: %s: %s(): "
+				"VHOST_SET_MEM_TABLE 0x%lx\n",
+				__FILE__, __func__, VHOST_SET_MEM_TABLE);
+#endif
 		r = vhost_set_memory(d, argp);
 		break;
 	case VHOST_SET_LOG_BASE:
@@ -1403,12 +1531,32 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 			       i, vq->num, head);
 			return -EINVAL;
 		}
+#if POPHYPE_NET_OPTIMIZE
+		/* Take data from desc from user */
+#endif
 		ret = __copy_from_user(&desc, vq->desc + i, sizeof desc);
 		if (unlikely(ret)) {
 			vq_err(vq, "Failed to get descriptor: idx %d addr %p\n",
 			       i, vq->desc + i);
 			return -EFAULT;
 		}
+#if POPHYPE_NET_OPTIMIZE
+		{
+			static u64 cnt = 0;
+			cnt++;
+			if ((cnt > 70 && cnt < 100) || !(cnt % 1000)) {
+				POP_PK("\t(kernel) pophype: vhost-net: vanilla: (\"%s\"->): "
+						"<%d> %s: %s(): "
+						"if(desc.flags & cpu_to_vhost16(vq, "
+						"VRING_DESC_F_INDIRECT)) (%d)(either one) "
+						"desc.addr 0x%llx #%llu\n",
+						log || log_num ? "handle_rx->get_rx_bufs": "handle_tx",
+						smp_processor_id(), __FILE__, __func__,
+						desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_INDIRECT),
+						desc.addr, cnt);
+			}
+		}
+#endif
 		if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_INDIRECT)) {
 			ret = get_indirect(vq, iov, iov_size,
 					   out_num, in_num,
@@ -1421,6 +1569,9 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 			continue;
 		}
 
+#if POPHYPE_NET_OPTIMIZE
+		/* Real ptr to the data (desc.addr) */
+#endif
 		ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
 				     vhost32_to_cpu(vq, desc.len), iov + iov_count,
 				     iov_size - iov_count);
diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c
index 462e183609b6..0c643931bdee 100644
--- a/drivers/virtio/virtio.c
+++ b/drivers/virtio/virtio.c
@@ -5,6 +5,11 @@
 #include <linux/idr.h>
 #include <uapi/linux/virtio_ids.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#include <popcorn/hype_kvm.h>
+#endif
+
 /* Unique numbering for virtio devices. */
 static DEFINE_IDA(virtio_index_ida);
 
@@ -192,6 +197,13 @@ static int virtio_dev_probe(struct device *_d)
 	u64 driver_features;
 	u64 driver_features_legacy;
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+    POP_PK("\t\tpophype: net: <%d> %s(): net prob - pin on cpu0\n",
+							smp_processor_id(), __func__);
+	pophype_set_cpu0();
+	VPCINETPRINTK("\tpophype: virtio: pci: net: %s():\n", __func__);
+#endif
+
 	/* We have a driver! */
 	add_status(dev, VIRTIO_CONFIG_S_DRIVER);
 
diff --git a/drivers/virtio/virtio_pci_common.c b/drivers/virtio/virtio_pci_common.c
index 2046a68ad0ba..a2233e9215ab 100644
--- a/drivers/virtio/virtio_pci_common.c
+++ b/drivers/virtio/virtio_pci_common.c
@@ -16,9 +16,14 @@
  * See the COPYING file in the top-level directory.
  *
  */
-
+#define DEBUG
 #include "virtio_pci_common.h"
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/hype_kvm.h>
+#include <popcorn/debug.h>
+#endif
+
 static bool force_legacy = false;
 
 #if IS_ENABLED(CONFIG_VIRTIO_PCI_LEGACY)
@@ -45,6 +50,20 @@ bool vp_notify(struct virtqueue *vq)
 {
 	/* we write the queue's selector into the notification register to
 	 * signal the other end */
+#ifdef CONFIG_POPCORN_HYPE
+	static u64 cnt = 0;
+	cnt++;
+	/* guest vm */
+	CRITICALNETPK("pophype: net: <%d> %s: %s(): [[[triger vhost im guest]]] "
+				"vq %p in_atomic %d #%llu\n",
+				smp_processor_id(), __FILE__, __func__, vq, in_atomic(), cnt);
+	if (my_nid > 0 || cnt < 20) {
+		//POP_PK("pophype: net: #%llu\n", cnt);
+		//dump_stack();
+	}
+	//pophype_set_cpu0();
+	/* vq->priv is set as VIRTIO_PCI_QUEUE_NOTIFY when init */
+#endif
 	iowrite16(vq->index, (void __iomem *)vq->priv);
 	return true;
 }
@@ -54,6 +73,9 @@ static irqreturn_t vp_config_changed(int irq, void *opaque)
 {
 	struct virtio_pci_device *vp_dev = opaque;
 
+#ifdef CONFIG_POPCORN_HYPE
+    VPCINETPRINTK("\tpophype: virtio: pci: net: %s():\n", __func__);
+#endif
 	virtio_config_changed(&vp_dev->vdev);
 	return IRQ_HANDLED;
 }
@@ -66,6 +88,9 @@ static irqreturn_t vp_vring_interrupt(int irq, void *opaque)
 	irqreturn_t ret = IRQ_NONE;
 	unsigned long flags;
 
+#ifdef CONFIG_POPCORN_HYPE
+    VPCINETPRINTK("\tpophype: virtio: pci: net: %s():\n", __func__);
+#endif
 	spin_lock_irqsave(&vp_dev->lock, flags);
 	list_for_each_entry(info, &vp_dev->virtqueues, node) {
 		if (vring_interrupt(irq, info->vq) == IRQ_HANDLED)
@@ -87,6 +112,9 @@ static irqreturn_t vp_interrupt(int irq, void *opaque)
 	struct virtio_pci_device *vp_dev = opaque;
 	u8 isr;
 
+#ifdef CONFIG_POPCORN_HYPE
+    VPCINETPRINTK("\tpophype: virtio: pci: net: %s():\n", __func__);
+#endif
 	/* reading the ISR has the effect of also clearing it so it's very
 	 * important to save off the value. */
 	isr = ioread8(vp_dev->isr);
@@ -145,6 +173,10 @@ static int vp_request_msix_vectors(struct virtio_device *vdev, int nvectors,
 	unsigned i, v;
 	int err = -ENOMEM;
 
+#ifdef CONFIG_POPCORN_HYPE
+    VPCINETPRINTK("\tpophype: virtio: pci: net: %s():\n", __func__);
+#endif
+
 	vp_dev->msix_vectors = nvectors;
 
 	vp_dev->msix_entries = kmalloc(nvectors * sizeof *vp_dev->msix_entries,
@@ -178,6 +210,11 @@ static int vp_request_msix_vectors(struct virtio_device *vdev, int nvectors,
 	v = vp_dev->msix_used_vectors;
 	snprintf(vp_dev->msix_names[v], sizeof *vp_dev->msix_names,
 		 "%s-config", name);
+#ifdef CONFIG_POPCORN_HYPE
+    VPCINETPRINTK("\tpophype: virtio: pci: net: irq: %s(): irq %d "
+			"(24:virtio0-config 25:virtio0-input.0 26:virtio0-output.0)\n",
+			__func__, vp_dev->msix_entries[v].vector);
+#endif
 	err = request_irq(vp_dev->msix_entries[v].vector,
 			  vp_config_changed, 0, vp_dev->msix_names[v],
 			  vp_dev);
@@ -197,6 +234,11 @@ static int vp_request_msix_vectors(struct virtio_device *vdev, int nvectors,
 		v = vp_dev->msix_used_vectors;
 		snprintf(vp_dev->msix_names[v], sizeof *vp_dev->msix_names,
 			 "%s-virtqueues", name);
+#ifdef CONFIG_POPCORN_HYPE
+    VPCINETPRINTK("\tpophype: virtio: pci: net: irq: %s(): irq %d "
+			"(24:virtio0-config 25:virtio0-input.0 26:virtio0-output.0)\n",
+			__func__, vp_dev->msix_entries[v].vector);
+#endif
 		err = request_irq(vp_dev->msix_entries[v].vector,
 				  vp_vring_interrupt, 0, vp_dev->msix_names[v],
 				  vp_dev);
@@ -215,6 +257,11 @@ static int vp_request_intx(struct virtio_device *vdev)
 	int err;
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 
+#ifdef CONFIG_POPCORN_HYPE
+    VPCINETPRINTK("\tpophype: virtio: pci: net: irq: %s(): irq %d"
+			"(24:virtio0-config 25:virtio0-input.0 26:virtio0-output.0)\n",
+			__func__, vp_dev->pci_dev->irq);
+#endif
 	err = request_irq(vp_dev->pci_dev->irq, vp_interrupt,
 			  IRQF_SHARED, dev_name(&vdev->dev), vp_dev);
 	if (!err)
@@ -236,10 +283,26 @@ static struct virtqueue *vp_setup_vq(struct virtio_device *vdev, unsigned index,
 	if (!info)
 		return ERR_PTR(-ENOMEM);
 
+#ifdef CONFIG_POPCORN_HYPE
+    POP_PK("pophype: %s %s(): [[[vhost]]] vdev %p vp_dev %p "
+			"callback %p name \"%s\" -> vp_dev->setup_vq "
+			"(./drivers/virtio/virtio_pci_legacy.c) "
+			"[register address to back end, vhost/lkvm] "
+			"msix_vec 0x%x vp_dev->pci_dev->irq %d\n",
+			__FILE__, __func__, vdev, vp_dev,
+			callback, name, msix_vec, vp_dev->pci_dev->irq);
+#endif
+
 	vq = vp_dev->setup_vq(vp_dev, info, index, callback, name, msix_vec);
 	if (IS_ERR(vq))
 		goto out_info;
 
+#ifdef CONFIG_POPCORN_HYPE
+    POP_PK("pophype: %s %s(): [[[vhost]]] Jack "
+			"vq(callback %p) %p pa 0x%llx name \"%s\"\n",
+			__FILE__, __func__, callback, vq, virt_to_phys(vq), name);
+#endif
+
 	info->vq = vq;
 	if (callback) {
 		spin_lock_irqsave(&vp_dev->lock, flags);
@@ -304,17 +367,40 @@ static int vp_try_to_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 	u16 msix_vec;
 	int i, err, nvectors, allocated_vectors;
 
+#ifdef CONFIG_POPCORN_HYPE
+    POP_PK("(guest) pophype: virtio-net-driver: net: pci: "
+			"%s %s(): vdev %p vp_dev %p "
+			"vp_dev->pci_dev->irq %u\n",
+			__FILE__, __func__, vdev, vp_dev, vp_dev->pci_dev->irq);
+    if (vp_dev) {
+		if (vp_dev->pci_dev) {
+			POP_PK("pophype: %s %s(): vp_dev->pci_dev->irq %u\n",
+					__FILE__, __func__, vp_dev->pci_dev->irq);
+		}
+	}
+#endif
 	vp_dev->vqs = kmalloc(nvqs * sizeof *vp_dev->vqs, GFP_KERNEL);
 	if (!vp_dev->vqs)
 		return -ENOMEM;
 
 	if (!use_msix) {
 		/* Old style: one normal interrupt for change and all vqs. */
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("\t\t(guest) pophype: virtio-net-driver: net: pci: "
+			"%s %s(): irq %u 1 irq for all vqs and change int\n",
+					__FILE__, __func__, vp_dev->pci_dev->irq);
+#endif
 		err = vp_request_intx(vdev);
 		if (err)
 			goto error_find;
 	} else {
 		if (per_vq_vectors) {
+#ifdef CONFIG_POPCORN_HYPE
+			POP_PK("\t\t(guest) pophype: virtio-net-driver: net: pci: "
+					"%s %s(): irq %u 1 irq for each vqs, "
+					"1 for change int\n",
+					__FILE__, __func__, vp_dev->pci_dev->irq);
+#endif
 			/* Best option: one for change interrupt, one per vq. */
 			nvectors = 1;
 			for (i = 0; i < nvqs; ++i)
@@ -322,6 +408,12 @@ static int vp_try_to_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 					++nvectors;
 		} else {
 			/* Second best: one for change, shared for all vqs. */
+#ifdef CONFIG_POPCORN_HYPE
+			POP_PK("\t\t(guest) pophype: virtio-net-driver: net: pci: "
+					"%s %s(): irq %u 1 irq for all vqs, "
+					"1 for change int\n",
+					__FILE__, __func__, vp_dev->pci_dev->irq);
+#endif
 			nvectors = 2;
 		}
 
@@ -333,6 +425,9 @@ static int vp_try_to_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 	vp_dev->per_vq_vectors = per_vq_vectors;
 	allocated_vectors = vp_dev->msix_used_vectors;
 	for (i = 0; i < nvqs; ++i) {
+#ifdef CONFIG_POPCORN_HYPE
+		int irq;
+#endif
 		if (!names[i]) {
 			vqs[i] = NULL;
 			continue;
@@ -342,6 +437,11 @@ static int vp_try_to_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 			msix_vec = allocated_vectors++;
 		else
 			msix_vec = VP_MSIX_VQ_VECTOR;
+
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("\t\t(guest) pophype: virtio-net-driver: net: pci: "
+				"%s %s(): vp_setup_vq()\n", __FILE__, __func__);
+#endif
 		vqs[i] = vp_setup_vq(vdev, i, callbacks[i], names[i], msix_vec);
 		if (IS_ERR(vqs[i])) {
 			err = PTR_ERR(vqs[i]);
@@ -356,6 +456,68 @@ static int vp_try_to_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 			 sizeof *vp_dev->msix_names,
 			 "%s-%s",
 			 dev_name(&vp_dev->vdev.dev), names[i]);
+#ifdef CONFIG_POPCORN_HYPE
+		irq = vp_dev->msix_entries[msix_vec].vector;
+		/* pophype: TODO if name matches */
+		VPCINETPRINTK("\tpophype: virtio: pci: net: irq: %s(): irq %d "
+				"name \"%s-%s\" #%d/%d\n",
+				__func__, vp_dev->msix_entries[msix_vec].vector,
+				dev_name(&vp_dev->vdev.dev), names[i], i, nvqs);
+
+		if (irq_can_set_affinity(irq)) {
+			VPCINETPRINTK("\t\tpophype: virtio: pci: net: irq: %s(): "
+					"irq %d CAN set irq\n",
+					__func__, vp_dev->msix_entries[msix_vec].vector);
+		} else {
+			VPCINETPRINTK("\t\tpophype: virtio: pci: net: irq: %s(): "
+					"irq %d CANNOT set irq\n",
+					__func__, vp_dev->msix_entries[msix_vec].vector);
+		}
+
+		/* pophype - hack 25 26 pci in and out for NIC */
+		if (irq == GUEST_X86_NET) { /* 26 pci-in, 26 pci-out: cannot */
+			struct irq_desc *desc = irq_to_desc(irq);
+			if (desc) {
+				if (desc->irq_data.chip) {
+					if (desc->irq_data.chip->irq_set_affinity) {
+						AFFPRINTK("%s(): over writing affinity\n", __func__);
+						AFFPRINTK("%s() check: bf "
+							"smp_irq_set_affinity_callback() %p "
+							"name \"%s\" cpu %*pbl %*pb\n", __func__,
+							desc->irq_data.chip->irq_set_affinity,
+							desc->irq_data.chip->name,
+							cpumask_pr_args(desc->irq_common_data.affinity),
+							cpumask_pr_args(desc->irq_common_data.affinity));
+
+						/* hardcoded */
+						//cpumask_var_t tmpmask;
+						//cpumask_set_cpu(0, tmpmask); // pin the irq on cpu0. cpumask =
+						//int ret = ;
+						//irq_set_affinity(irq, cpumask_of(0));
+						irq_set_affinity(irq, cpumask_of(1));
+						irq_set_affinity(irq, cpumask_of(1));
+						/* request_irq will over write it */
+
+						AFFPRINTK("%s() check: af "
+							"smp_irq_set_affinity_callback() %p "
+							"name \"%s\" cpu %*pbl %*pb\n", __func__,
+							desc->irq_data.chip->irq_set_affinity,
+							desc->irq_data.chip->name,
+							cpumask_pr_args(desc->irq_common_data.affinity),
+							cpumask_pr_args(desc->irq_common_data.affinity));
+					} else {
+						AFFPRINTK("%s() check: "
+							"!smp_irq_set_affinity_callback()\n", __func__);
+					}
+				} else {
+					  AFFPRINTK("%s() check: !desc->irq_data.chip case\n",
+																	__func__);
+				}
+			} else {
+			  AFFPRINTK("%s() check: !desc case\n", __func__);
+			}
+		}
+#endif
 		err = request_irq(vp_dev->msix_entries[msix_vec].vector,
 				  vring_interrupt, 0,
 				  vp_dev->msix_names[msix_vec],
@@ -380,6 +542,11 @@ int vp_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 {
 	int err;
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t (guest) pophype: virtio-net-driver: net: pci: %s():\n",
+															__func__);
+#endif
+
 	/* Try MSI-X with one vector per queue. */
 	err = vp_try_to_find_vqs(vdev, nvqs, vqs, callbacks, names, true, true);
 	if (!err)
@@ -490,6 +657,14 @@ static int virtio_pci_probe(struct pci_dev *pci_dev,
 	struct virtio_pci_device *vp_dev;
 	int rc;
 
+#ifdef CONFIG_POPCORN_HYPE
+    POP_PK("%s(): [[[vhost]]] pci_dev %p "
+			"pci_device_id vendor %u device %u"
+			"subvendor %u subdevice %u (1:net 3:console)\n",
+					__func__, pci_dev, id->vendor, id->device,
+								id->subvendor, id->subdevice);
+#endif
+
 	/* allocate our structure and fill it out */
 	vp_dev = kzalloc(sizeof(struct virtio_pci_device), GFP_KERNEL);
 	if (!vp_dev)
diff --git a/drivers/virtio/virtio_pci_legacy.c b/drivers/virtio/virtio_pci_legacy.c
index 48bc9797e530..9dbc57a771e4 100644
--- a/drivers/virtio/virtio_pci_legacy.c
+++ b/drivers/virtio/virtio_pci_legacy.c
@@ -19,6 +19,9 @@
 
 #include "virtio_pci_common.h"
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#endif
 /* virtio config->get_features() implementation */
 static u64 vp_get_features(struct virtio_device *vdev)
 {
@@ -122,6 +125,11 @@ static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 	unsigned long size;
 	u16 num;
 	int err;
+#if !POPHYPE_HOST_KERNEL && defined(CONFIG_POPCORN_HYPE)
+	POP_PK("\n\n\t============== "
+			"(guest)pophype: net: %s %s(): create ONE vq START ============\n",
+													__FILE__, __func__);
+#endif
 
 	/* Select the queue we're interested in */
 	iowrite16(index, vp_dev->ioaddr + VIRTIO_PCI_QUEUE_SEL);
@@ -130,12 +138,21 @@ static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 	num = ioread16(vp_dev->ioaddr + VIRTIO_PCI_QUEUE_NUM);
 	if (!num || ioread32(vp_dev->ioaddr + VIRTIO_PCI_QUEUE_PFN))
 		return ERR_PTR(-ENOENT);
+#if !POPHYPE_HOST_KERNEL && defined(CONFIG_POPCORN_HYPE)
+	POP_PK("(guest)pophype: net: %s(): num %d read here from ioread16\n",
+													__func__, num);
+#endif
 
 	info->num = num;
 	info->msix_vector = msix_vec;
 
 	size = PAGE_ALIGN(vring_size(num, VIRTIO_PCI_VRING_ALIGN));
 	info->queue = alloc_pages_exact(size, GFP_KERNEL|__GFP_ZERO);
+#if !POPHYPE_HOST_KERNEL && defined(CONFIG_POPCORN_HYPE)
+    POP_PK("(guest)pophype: net: %s(): [Jack] info->queue(pci) %p "
+			"vring_size %lu (This is pointed by vring->desc/avail/used)\n",
+			__func__, info->queue, size);
+#endif
 	if (info->queue == NULL)
 		return ERR_PTR(-ENOMEM);
 
@@ -143,6 +160,18 @@ static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 	iowrite32(virt_to_phys(info->queue) >> VIRTIO_PCI_QUEUE_ADDR_SHIFT,
 		  vp_dev->ioaddr + VIRTIO_PCI_QUEUE_PFN);
 
+#if !POPHYPE_HOST_KERNEL && defined(CONFIG_POPCORN_HYPE)
+    POP_PK("(guest)pophype: net: %s %s(): create a vq (vp_notify) for \"%s\" "
+			"(registered the address to the back end)"
+			"(virtio_pci_device)vp_dev->ioaddr (%p) + VIRTIO_PCI_QUEUE_PFN (%d) = "
+			"%p. info->queue va %p pa 0x%llx >> VIRTIO_PCI_QUEUE_ADDR_SHIFT(%d)."
+			" vring size %lu\n",
+			__FILE__, __func__, name,
+			vp_dev->ioaddr, VIRTIO_PCI_QUEUE_PFN,
+			vp_dev->ioaddr + VIRTIO_PCI_QUEUE_PFN,
+			info->queue, virt_to_phys(info->queue),
+			VIRTIO_PCI_QUEUE_ADDR_SHIFT, size);
+#endif
 	/* create the vring */
 	vq = vring_new_virtqueue(index, info->num,
 				 VIRTIO_PCI_VRING_ALIGN, &vp_dev->vdev,
@@ -163,6 +192,21 @@ static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 		}
 	}
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+    POP_PK("(guest)pophype: net: %s %s(): created vring_new_virtqueue() "
+			"vp_dev->pci_dev %p "
+			"vq info->num %u idx %u [Jack] name \"%s\" "
+			"kvaddr info->queue %p phy 0x%llx "
+			"written to VIRTIO_PCI_QUEUE_PFN 8\n",
+			__FILE__, __func__, vp_dev->pci_dev, info->num,
+			index, name, info->queue, virt_to_phys(info->queue));
+#endif
+#if !POPHYPE_HOST_KERNEL && defined(CONFIG_POPCORN_HYPE)
+	POP_PK("(guest)pophype: net: %s(): create a vq END\n"
+			"\t\t============================== END "
+			"==============================\n\n", __func__);
+#endif
+
 	return vq;
 
 out_assign:
@@ -217,6 +261,12 @@ int virtio_pci_legacy_probe(struct virtio_pci_device *vp_dev)
 	struct pci_dev *pci_dev = vp_dev->pci_dev;
 	int rc;
 
+#if !POPHYPE_HOST_KERNEL
+#ifdef CONFIG_POPCORN_HYPE
+    POP_PK("%s(): pci_dev %p\n", __func__, pci_dev);
+#endif
+#endif
+
 	/* We only own devices >= 0x1000 and <= 0x103f: leave the rest. */
 	if (pci_dev->device < 0x1000 || pci_dev->device > 0x103f)
 		return -ENODEV;
diff --git a/drivers/virtio/virtio_pci_modern.c b/drivers/virtio/virtio_pci_modern.c
index 4469202eaa8e..707073c38464 100644
--- a/drivers/virtio/virtio_pci_modern.c
+++ b/drivers/virtio/virtio_pci_modern.c
@@ -21,6 +21,9 @@
 #define VIRTIO_PCI_NO_LEGACY
 #include "virtio_pci_common.h"
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#endif
 /*
  * Type-safe wrappers for io accesses.
  * Use these to enforce at compile time the following spec requirement:
@@ -355,6 +358,12 @@ static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 	if (info->queue == NULL)
 		return ERR_PTR(-ENOMEM);
 
+#if !POPHYPE_HOST_KERNEL
+#ifdef CONFIG_POPCORN_HYPE
+    printk("%s %s(): create a vq (vp_notify) for \"%s\"\n",
+                                    __FILE__, __func__, name);
+#endif
+#endif
 	/* create the vring */
 	vq = vring_new_virtqueue(index, info->num,
 				 SMP_CACHE_BYTES, &vp_dev->vdev,
diff --git a/drivers/virtio/virtio_ring.c b/drivers/virtio/virtio_ring.c
index a01a41a41269..47a669e833fd 100644
--- a/drivers/virtio/virtio_ring.c
+++ b/drivers/virtio/virtio_ring.c
@@ -744,10 +744,16 @@ struct virtqueue *vring_new_virtqueue(unsigned int index,
 		return NULL;
 	}
 
+#if !POPHYPE_HOST_KERNEL && defined(CONFIG_POPCORN_HYPE)
+	/* struct + last *data[num] */
+#endif
 	vq = kmalloc(sizeof(*vq) + sizeof(void *)*num, GFP_KERNEL);
 	if (!vq)
 		return NULL;
 
+#if !POPHYPE_HOST_KERNEL && defined(CONFIG_POPCORN_HYPE)
+	//vring_align = 2 * PAGE_SIZE; // this odesn't help
+#endif
 	vring_init(&vq->vring, num, pages, vring_align);
 	vq->vq.callback = callback;
 	vq->vq.vdev = vdev;
@@ -785,6 +791,24 @@ struct virtqueue *vring_new_virtqueue(unsigned int index,
 	}
 	vq->data[i] = NULL;
 
+#if !POPHYPE_HOST_KERNEL && defined(CONFIG_POPCORN_HYPE)
+	POP_PK("pophype: net: %s %s(): "
+			"RECV path checks new package - "
+			"Jack [[&vq->last_used_idx %p (guest)]], "
+			"[[&vq->vring.used->idx %p (host) num for desc[] and ring[] %d "
+			"pages %p vring_align 0x%x\n",
+			__FILE__, __func__,
+			&vq->last_used_idx, &vq->vring.used->idx, num, pages, vring_align);
+	// align = VIRTIO_PCI_VRING_ALIGN
+	// pages = info->queue
+	POP_PK("pophype: net: %s %s(): "
+			"RECV path checks new package - "
+			"Jack [[&vq->vring.avail->idx %p]], "
+			"&vq->free_head %p\n",
+			__FILE__, __func__,
+			&vq->vring.avail->idx,
+			&vq->free_head);
+#endif
 	return &vq->vq;
 }
 EXPORT_SYMBOL_GPL(vring_new_virtqueue);
diff --git a/fs/anon_inodes.c b/fs/anon_inodes.c
index 80ef38c73e5a..b443a0b94381 100644
--- a/fs/anon_inodes.c
+++ b/fs/anon_inodes.c
@@ -22,6 +22,11 @@
 
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#include <popcorn/types.h>
+#endif
+
 static struct vfsmount *anon_inode_mnt __read_mostly;
 static struct inode *anon_inode_inode;
 
@@ -110,6 +115,15 @@ struct file *anon_inode_getfile(const char *name,
 	file->f_flags = flags & (O_ACCMODE | O_NONBLOCK);
 	file->private_data = priv;
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* More details outside. vpcu and vhost-net eventfd both use this!! */
+	HPPRINTK("%s(): \"%s\"\n", __func__, this.name);
+	/* event_signal for vhost for delegation */
+	if (distributed_process(current)) {
+		POP_PK("%s(): \"%s\"\n", __func__, this.name);
+	}
+#endif
+
 	return file;
 
 err_dput:
@@ -136,6 +150,10 @@ EXPORT_SYMBOL_GPL(anon_inode_getfile);
  * hence saving memory and avoiding code duplication for the file/inode/dentry
  * setup.  Returns new descriptor or an error code.
  */
+#ifdef CONFIG_POPCORN_HYPE
+#include <linux/kvm_host.h>
+#endif
+extern int get_file_path(struct file *file, char *sz, size_t size); /////////////
 int anon_inode_getfd(const char *name, const struct file_operations *fops,
 		     void *priv, int flags)
 {
@@ -154,6 +172,48 @@ int anon_inode_getfd(const char *name, const struct file_operations *fops,
 	}
 	fd_install(fd, file);
 
+#ifdef CONFIG_POPCORN_HYPE
+    if (file) {
+        char path[512];
+		HPPRINTK("%s(): \"%s\"\n", __func__, name);
+        get_file_path(file, path, sizeof(path));
+        if (!strncmp("anon_inode:kvm-vcpu:", path,
+                sizeof("anon_inode:kvm-vcpu:") - 1 ))
+		{
+			struct kvm_vcpu *vcpu = file->private_data;
+			POP_PK("   ================\n");
+			POP_PK("%s(): GT. fd %d <-> *file %p vcpu %p run %p TODO construct table here\n",
+														__func__, fd, file, vcpu, vcpu->run);
+			POP_PK("   ================\n\n");
+			/* MAKE VCPU FILE FD table here */
+#if 0
+			struct file *f = NULL;
+			f = filp_open(path, O_RDONLY | O_LARGEFILE | O_TMPFILE, 0);
+			if (IS_ERR(f)) {
+				printk("%s(): (try) filp open diectly (((FAIL)))\n", __func__);
+			} else {
+				printk("%s(): (test) filp open \"%s\" f %p O_TMPFILE (((O)))\n", __func__, path, f);
+				filp_close(f, NULL);
+			}
+#endif
+
+#if 0
+			{
+				struct fd __fd = fdget(fd);
+				printk("%s(): (try) use fd to get struct __fd.file %p "
+									"(matched???)\n", __func__, __fd.file);
+				if(__fd.file)
+					fdput(__fd);
+			}
+#endif
+        } else {
+            //printk("%s(): This is not our target. May try if no idea\n", __func__);
+		}
+    }
+#endif
+////////////////
+
+
 	return fd;
 
 err_put_unused_fd:
@@ -162,6 +222,34 @@ err_put_unused_fd:
 }
 EXPORT_SYMBOL_GPL(anon_inode_getfd);
 
+#ifdef CONFIG_POPCORN_HYPE
+int anon_inode_getfd_tsk(struct task_struct *tsk, const char *name, const struct file_operations *fops, void *priv, int flags)
+{
+	int error, fd;
+	struct file *file;
+
+	error = get_unused_fd_flags_tsk(tsk, flags);
+	if (error < 0)
+		return error;
+	fd = error;
+
+	HPPRINTK("%s(): Jack - TODO check moredetails\n", __func__);
+	file = anon_inode_getfile(name, fops, priv, flags);
+	if (IS_ERR(file)) {
+		error = PTR_ERR(file);
+		goto err_put_unused_fd;
+	}
+	fd_install_tsk(tsk, fd, file);
+
+	return fd;
+
+err_put_unused_fd:
+	put_unused_fd_tsk(tsk, fd);
+	return error;
+}
+EXPORT_SYMBOL_GPL(anon_inode_getfd_tsk);
+#endif
+
 static int __init anon_inode_init(void)
 {
 	anon_inode_mnt = kern_mount(&anon_inode_fs_type);
diff --git a/fs/buffer.c b/fs/buffer.c
index 6f7d519a093b..5db06638c52b 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -44,6 +44,11 @@
 #include <linux/bit_spinlock.h>
 #include <trace/events/block.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+//#include <popcorn/bundle.h>
+#include <popcorn/debug.h>
+#endif
+
 static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);
 static int submit_bh_wbc(int rw, struct buffer_head *bh,
 			 unsigned long bio_flags,
@@ -1236,8 +1241,23 @@ static struct buffer_head *__bread_slow(struct buffer_head *bh)
 	} else {
 		get_bh(bh);
 		bh->b_end_io = end_buffer_read_sync;
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+		GSMPBSPPRINTK("<%d> %s(): 1 submit_bh\n", smp_processor_id(), __func__);
+#endif
+#endif
 		submit_bh(READ, bh);
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+		GSMPBSPPRINTK("<%d> %s(): 2 wait_on_buffer\n", smp_processor_id(), __func__);
+#endif
+#endif
 		wait_on_buffer(bh);
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+		GSMPBSPPRINTK("<%d> %s(): 3 GO HOME\n", smp_processor_id(), __func__);
+#endif
+#endif
 		if (buffer_uptodate(bh))
 			return bh;
 	}
@@ -3054,6 +3074,11 @@ EXPORT_SYMBOL_GPL(_submit_bh);
 
 int submit_bh(int rw, struct buffer_head *bh)
 {
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+    GSMPBSPPRINTK("\t<%d> %s():\n", smp_processor_id(), __func__);
+#endif
+#endif
 	return submit_bh_wbc(rw, bh, 0, NULL);
 }
 EXPORT_SYMBOL(submit_bh);
diff --git a/fs/direct-io.c b/fs/direct-io.c
index 44f49d86d714..ecedeeab0fd1 100644
--- a/fs/direct-io.c
+++ b/fs/direct-io.c
@@ -38,6 +38,10 @@
 #include <linux/atomic.h>
 #include <linux/prefetch.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/hype_kvm.h>
+#endif
+
 /*
  * How many user pages to map in one call to get_user_pages().  This determines
  * the size of a structure in the slab cache
@@ -1347,6 +1351,10 @@ EXPORT_SYMBOL(__blockdev_direct_IO);
 
 static __init int dio_init(void)
 {
+#if !POPHYPE_HOST_KERNEL
+    POP_PK("%s %s(): pophype: set cpu0, (potential problematic point)\n", __FILE__, __func__);
+	pophype_set_cpu0();
+#endif
 	dio_cache = KMEM_CACHE(dio, SLAB_PANIC);
 	return 0;
 }
diff --git a/fs/eventfd.c b/fs/eventfd.c
index 8d0c0df01854..3ca747e637a6 100644
--- a/fs/eventfd.c
+++ b/fs/eventfd.c
@@ -22,6 +22,11 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/types.h>
+#include <popcorn/hype_kvm.h>
+#endif
+
 struct eventfd_ctx {
 	struct kref kref;
 	wait_queue_head_t wqh;
@@ -55,6 +60,53 @@ __u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n)
 {
 	unsigned long flags;
 
+#ifdef CONFIG_POPCORN_HYPE
+    static u64 cnt = 0;
+    cnt++;
+	//if (cnt < 10000) {
+	CRITICALNETPK("\tpophype: vhost-net: <%d> %s: %s(): -> #%llu\n",
+						smp_processor_id(), __FILE__, __func__, cnt);
+	//}
+
+	/* pophype prepares to delegate */
+	CRITICALNETPK("\tpophype: vhost-net: <%d> %s: %s(): "
+			"delegate event ctx %p ->count %llu ->flags %u "
+			"&ctx->kref.refcount %d => #%llu\n",
+			smp_processor_id(), __FILE__, __func__, ctx, ctx->count,
+			ctx->flags, atomic_read(&ctx->kref.refcount), cnt);
+	/* how can I get the wqh at remote (I need to record) */
+	/* What I'm doing now is to just wake up
+		the corresponding vhost_wq (I assume there is only one Q) */
+
+	/* pophype - ioeventfd delegation */
+	/* ctx to fd or file */
+	if (distributed_remote_process(current)) {
+		int fd = eventfd_ctx_to_fd(ctx);
+		__u64 res_n = pophype_eventfd_delegate(fd, n);
+		CRITICALNETPK("%s(): [DELEGATED] SKIP LOCAL\n", __func__);
+		//
+		//msg->fd = fd;
+		//pcnkmsg_send(msg);
+
+		/* Don't update local ctx->count at remote */
+		/* and return directly */
+		return res_n;
+/*
+		if (res_n == n)
+			fine
+		else
+			printk("ctx wqh ";);
+		spin_lock_irqsave(&ctx->wqh.lock, flags);
+		ctx->count += n;
+		spin_unlock_irqrestore(&ctx->wqh.lock, flags);
+*/
+	}
+	/* 2019/11/05 (remove above) change to nonblocking */
+
+	/* delegate */
+	/* ctx to fd or file */
+#endif
+
 	spin_lock_irqsave(&ctx->wqh.lock, flags);
 	if (ULLONG_MAX - ctx->count < n)
 		n = ULLONG_MAX - ctx->count;
@@ -67,6 +119,25 @@ __u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n)
 }
 EXPORT_SYMBOL_GPL(eventfd_signal);
 
+/* Delegation work */
+__u64 pophype_eventfd_signal(struct eventfd_ctx *ctx, __u64 n)
+{
+	unsigned long flags;
+
+	BUG_ON(current->at_remote);
+
+	spin_lock_irqsave(&ctx->wqh.lock, flags);
+	if (ULLONG_MAX - ctx->count < n)
+		n = ULLONG_MAX - ctx->count;
+	ctx->count += n;
+	if (waitqueue_active(&ctx->wqh))
+		wake_up_locked_poll(&ctx->wqh, POLLIN);
+	spin_unlock_irqrestore(&ctx->wqh.lock, flags);
+
+	return n;
+}
+//EXPORT_SYMBOL_GPL(pophype_eventfd_signal);
+
 static void eventfd_free_ctx(struct eventfd_ctx *ctx)
 {
 	kfree(ctx);
@@ -120,6 +191,14 @@ static unsigned int eventfd_poll(struct file *file, poll_table *wait)
 	unsigned int events = 0;
 	u64 count;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		POP_PK("%s(): file %p *eventfd_ctx = file->private_data fd %d\n",
+				__func__, file, popcorn_file_to_fd(current, file, false));
+		//dump_stack();
+	}
+#endif
+
 	poll_wait(file, &ctx->wqh, wait);
 	smp_rmb();
 	count = ctx->count;
@@ -230,6 +309,16 @@ static ssize_t eventfd_read(struct file *file, char __user *buf, size_t count,
 	ssize_t res;
 	__u64 cnt;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		int fd = popcorn_file_to_fd(current, file, false);
+		POP_PK("\t\t[%d] %s: [R] fd %d file %p count %lu ppos %lld\n\n",
+							current->pid, __func__, fd, file, count, *ppos);
+		//dump_stack();
+		/* Happens when using net-mq (fd 28) */
+	}
+#endif
+
 	if (count < sizeof(cnt))
 		return -EINVAL;
 	res = eventfd_ctx_read(ctx, file->f_flags & O_NONBLOCK, &cnt);
@@ -247,6 +336,14 @@ static ssize_t eventfd_write(struct file *file, const char __user *buf, size_t c
 	__u64 ucnt;
 	DECLARE_WAITQUEUE(wait, current);
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		int fd = popcorn_file_to_fd(current, file, false);
+		POP_PK("\t\t[%d] %s: [W] fd %d file %p count %lu ppos %lld\n\n",
+							current->pid, __func__, fd, file, count, *ppos);
+	}
+#endif
+
 	if (count < sizeof(ucnt))
 		return -EINVAL;
 	if (copy_from_user(&ucnt, buf, sizeof(ucnt)))
@@ -370,6 +467,11 @@ struct eventfd_ctx *eventfd_ctx_fileget(struct file *file)
 	if (file->f_op != &eventfd_fops)
 		return ERR_PTR(-EINVAL);
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t\tpophype: vhost-net: <%d> %s(): use file to get ctx\n",
+										smp_processor_id(), __func__);
+#endif
+
 	return eventfd_ctx_get(file->private_data);
 }
 EXPORT_SYMBOL_GPL(eventfd_ctx_fileget);
@@ -392,7 +494,9 @@ struct file *eventfd_file_create(unsigned int count, int flags)
 {
 	struct file *file;
 	struct eventfd_ctx *ctx;
-
+#ifdef CONFIG_POPCORN_HYPE
+	static int cnt = 0;
+#endif
 	/* Check the EFD_* constants for consistency.  */
 	BUILD_BUG_ON(EFD_CLOEXEC != O_CLOEXEC);
 	BUILD_BUG_ON(EFD_NONBLOCK != O_NONBLOCK);
@@ -414,6 +518,18 @@ struct file *eventfd_file_create(unsigned int count, int flags)
 	if (IS_ERR(file))
 		eventfd_free_ctx(ctx);
 
+#ifdef CONFIG_POPCORN_HYPE
+	cnt++;
+	/* pophype: memcached requires libevent and uses ebentfd a lot!!! */
+	CRITICALNETPK("\n\tpophype: vhost-net: <%d> %s(): [eventfd] ctx %p "
+			"I need this info to delegaten. "
+			"TODO RECORD mapping with "
+			"struct file %p <-priv data-> ctx %p #%d\n",
+			smp_processor_id(), __func__, ctx, file, ctx, cnt);
+	/* record it inside anon_inode_getfile() */
+	// event_ctx is from here............. not from 22
+#endif
+
 	return file;
 }
 
@@ -434,6 +550,56 @@ SYSCALL_DEFINE2(eventfd2, unsigned int, count, int, flags)
 	}
 	fd_install(fd, file);
 
+#ifdef CONFIG_POPCORN_HYPE
+    if (distributed_process(current)) {
+        POP_PK("\t[%d] %s() %s: *** eventfd fd %d *** <-> file %p "
+				"count %d flags %x rip 0x%lx\n",
+				current->pid, __func__, __FILE__,
+				fd, file, count, flags,
+				instruction_pointer(current_pt_regs()));
+
+		/* only here I can get fd!!!
+			This is the right place for vhost-net eventfd not from 22 */
+		if (!hype_eventfd_info[fd]) { /* new - install ctx */
+//			struct fd f = fdget(fd);
+//			struct file *file;
+//			struct eventfd_ctx *eventfd_ctx;
+			/* Attension eventfd_ctx != file->private_data but containerof() */
+
+			struct eventfd_ctx *eventfd_ctx = eventfd_ctx_fdget(fd);
+//			eventfd_ctx = eventfd_ctx_fileget(file);
+//			if (file)
+//				eventfd_ctx = eventfd_ctx_get(file->private_data);
+
+			hype_eventfd_info[fd] =
+				kmalloc(sizeof(**hype_eventfd_info), GFP_ATOMIC);
+			BUG_ON(!hype_eventfd_info[fd]);
+			if (eventfd_ctx < 0) {
+				POP_PK("\n\t\t%s: %s(): hype_eventfd_info[%d] BAD "
+						"don't install eventfd_ctx %p %d\n\n",
+						__FILE__, __func__, fd, eventfd_ctx, (int)eventfd_ctx);
+			} else if (eventfd_ctx) {
+				hype_eventfd_info[fd]->eventfd_ctx = eventfd_ctx;
+				//hype_eventfd_info[fd]->irqfd = irqfd;
+				POP_PK("\n\t\t%s %s(): [ADD] hype_eventfd_info[%d] "
+						"eventfd_ctx %p\n\n",
+						__FILE__, __func__, fd, eventfd_ctx);
+				/* optimize - record the smallest fd for faster lookup */
+			} else { // happens
+				POP_PK("\n\t\t%s %s(): [ADD] hype_eventfd_info[%d] BUT "
+					"this fd doesn't have a private_data (not eventfd_ctx) - "
+					"debug file %p file->private_data %p eventfd_ctx %p %d\n\n",
+					__FILE__, __func__,
+					fd, file, file->private_data, eventfd_ctx, (int)eventfd_ctx);
+			}
+		} else {
+			POP_PK("\n\t\t%s %s(): [ADD] hype_eventfd_info[%d] "
+					"eventfd_ctx %p already exitst\n\n",
+					__FILE__, __func__, fd, hype_eventfd_info[fd]->eventfd_ctx);
+		}
+    }
+#endif
+
 	return fd;
 
 err_put_unused_fd:
diff --git a/fs/eventpoll.c b/fs/eventpoll.c
index 1b08556776ce..9c527900c712 100644
--- a/fs/eventpoll.c
+++ b/fs/eventpoll.c
@@ -43,6 +43,10 @@
 #include <linux/compat.h>
 #include <linux/rculist.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/types.h>
+#include <popcorn/hype_kvm.h>
+#endif
 /*
  * LOCKING:
  * There are three level of locking required by epoll :
@@ -604,6 +608,14 @@ static int ep_scan_ready_list(struct eventpoll *ep,
 	struct epitem *epi, *nepi;
 	LIST_HEAD(txlist);
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		//dump_stack();
+		POP_PK("\t\t[%d] %s: scan callback ep %p\n",
+							current->pid, __func__, ep);
+	}
+#endif
+
 	/*
 	 * We need to lock this because we could be hit by
 	 * eventpoll_release_file() and epoll_ctl().
@@ -1008,6 +1020,16 @@ static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *k
 	struct epitem *epi = ep_item_from_wait(wait);
 	struct eventpoll *ep = epi->ep;
 
+#ifdef CONFIG_POPCORN_HYPE
+	// This wakeups epoll wait
+	if (distributed_process(current)) {
+		// too many and happend everywhere. the ep-file I saw, I even didn't track...
+		//printk("\t\t[%d] %s: got msg ep %p ep-file %p "
+		//				"wait %p mode %u sync %d key %p\n",
+		//	current->pid, __func__, ep, ep->file, wait, mode, sync, key);
+	}
+#endif
+
 	spin_lock_irqsave(&ep->lock, flags);
 
 	/*
@@ -1474,6 +1496,16 @@ static int ep_modify(struct eventpoll *ep, struct epitem *epi, struct epoll_even
 	return 0;
 }
 
+#ifdef CONFIG_POPCORN_HYPE
+typedef union epoll_data {
+     void *ptr; /* Pointer to user-defined data */
+     int fd; /* File descriptor */
+     uint32_t u32; /* 32-bit integer */
+     uint64_t u64; /* 64-bit integer */
+} epoll_data_t;
+
+#endif
+
 static int ep_send_events_proc(struct eventpoll *ep, struct list_head *head,
 			       void *priv)
 {
@@ -1485,6 +1517,19 @@ static int ep_send_events_proc(struct eventpoll *ep, struct list_head *head,
 	struct wakeup_source *ws;
 	poll_table pt;
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* Copy events to userspace */
+	if (distributed_process(current)) {
+		POP_PK("\t\t\t[%d] %s: epoll-> scan callback ep %p\n",
+									current->pid, __func__, ep);
+		//if (current->at_remote) {
+		//	POP_PK("\t\t\t[%d] %s: scan callback ep %p (hack skip)\n",
+		//									current->pid, __func__, ep);
+		//	return 0; // eventcnt
+		//}
+	}
+#endif
+
 	init_poll_funcptr(&pt, NULL);
 
 	/*
@@ -1496,6 +1541,14 @@ static int ep_send_events_proc(struct eventpoll *ep, struct list_head *head,
 	     !list_empty(head) && eventcnt < esed->maxevents;) {
 		epi = list_first_entry(head, struct epitem, rdllink);
 
+#ifdef CONFIG_POPCORN_HYPE
+		if (distributed_process(current)) {
+			/* fd 28 for net-mq on fd 8 epollfd */
+			POP_PK("\t\t\t\t[%d] %s: check one callback ep %p "
+					"epi %p epi->ep %p ->ffd.fd %d ([[[uevent %p]]] = events in ioeventfd.c)\n",
+					current->pid, __func__, ep, epi, epi->ep, epi->ffd.fd, uevent);
+		}
+#endif
 		/*
 		 * Activate ep->ws before deactivating epi->ws to prevent
 		 * triggering auto-suspend here (in case we reactive epi->ws
@@ -1523,10 +1576,38 @@ static int ep_send_events_proc(struct eventpoll *ep, struct list_head *head,
 		 * can change the item.
 		 */
 		if (revents) {
+#ifdef CONFIG_POPCORN_HYPE
+			int64_t kevent = epi->event.data;
+			if (distributed_process(current)) {
+				POP_PK("\t\t\t[%d] %s: check one callback ep %p "
+						"epi %p epi->ep %p ->ffd.fd %d [fd] "
+						//"([uevent] %p = events in ioeventfd.c) "
+						"[kevent (copied to uevent %p)] %d(int32) %lld(int64) %llx(u64) [%p(ptr)] eventcnt %d\n",
+						//"got uevent->data %p\n",
+						//*%lx data->fd %d data->ptr 0x%lx\n",
+						current->pid, __func__, ep, epi, epi->ep, epi->ffd.fd, uevent,
+						(int32_t)kevent, (int64_t)kevent, (u64)kevent, (void*)kevent, eventcnt);
+						//uevent->data);
+						// don't touch user space data
+						//, *(u64*)(uevent->data));
+						//((epoll_data_t*)(uevent->data))->fd,
+						//((epoll_data_t*)(uevent->data))->ptr);
+			}
+#endif
 			if (__put_user(revents, &uevent->events) ||
 			    __put_user(epi->event.data, &uevent->data)) {
 				list_add(&epi->rdllink, head);
 				ep_pm_stay_awake(epi);
+#ifdef CONFIG_POPCORN_HYPE
+				if (distributed_process(current)) {
+					POP_PK("\t\t\t\t(NET multiqueue fd 28 NEVER REACHED) "
+							"[%d] %s: pophype: ck ep %p epi %p "
+							"[kevent (copied to uevent)] %d %lld %llx "
+							"eventcnt %d\n",
+							current->pid, __func__, ep, epi,
+							(int32_t)kevent, (int64_t)kevent, (u64)kevent, eventcnt);
+				}
+#endif
 				return eventcnt ? eventcnt : -EFAULT;
 			}
 			eventcnt++;
@@ -1534,6 +1615,9 @@ static int ep_send_events_proc(struct eventpoll *ep, struct list_head *head,
 			if (epi->event.events & EPOLLONESHOT)
 				epi->event.events &= EP_PRIVATE_BITS;
 			else if (!(epi->event.events & EPOLLET)) {
+#ifdef CONFIG_POPCORN_HYPE
+				/* if not ET mode, add fd back to the list */
+#endif
 				/*
 				 * If this file has been added with Level
 				 * Trigger mode, we need to insert back inside
@@ -1562,6 +1646,8 @@ static int ep_send_events(struct eventpoll *ep,
 	esed.maxevents = maxevents;
 	esed.events = events;
 
+#ifdef CONFIG_POPCORN_HYPE
+#endif
 	return ep_scan_ready_list(ep, ep_send_events_proc, &esed, 0, false);
 }
 
@@ -1602,6 +1688,12 @@ static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,
 	wait_queue_t wait;
 	ktime_t expires, *to = NULL;
 
+#ifdef CONFIG_POPCORN_HYPE
+//	if (distributed_process(current)) {
+//		printk("\t\t\t\t[%d] %s: ep %p\n", current->pid, __func__, ep); // kill me redundant
+//	}
+#endif
+
 	if (timeout > 0) {
 		struct timespec end_time = ep_set_mstimeout(timeout);
 
@@ -1630,6 +1722,9 @@ fetch_events:
 		init_waitqueue_entry(&wait, current);
 		__add_wait_queue_exclusive(&ep->wq, &wait);
 
+#ifdef CONFIG_POPCORN_HYPE
+		/* Main waiting loop */
+#endif
 		for (;;) {
 			/*
 			 * We don't want to sleep if the ep_poll_callback() sends us
@@ -1665,6 +1760,14 @@ check_events:
 	 * there's still timeout left over, we go trying again in search of
 	 * more luck.
 	 */
+#ifdef CONFIG_POPCORN_HYPE
+//	if (distributed_remote_process(current)) {
+//		printk("\t\t\t\t[%d] %s: ep %p (hack) enforce to be timout (try only once)\n",
+//									current->pid, __func__, ep);
+//		timeout = 1;
+//	}
+	/* Got something, load & pass to userspace */
+#endif
 	if (!res && eavail &&
 	    !(res = ep_send_events(ep, events, maxevents)) && !timed_out)
 		goto fetch_events;
@@ -1804,6 +1907,19 @@ SYSCALL_DEFINE1(epoll_create1, int, flags)
 		error = PTR_ERR(file);
 		goto out_free_fd;
 	}
+#ifdef CONFIG_POPCORN_HYPE
+#if POPHYPE_HOST_KERNEL
+	if (distributed_process(current)) {
+		POP_PK("\n************************************\n"
+				"\t\t[%d] %s: fd %d ep %p file %p\n"
+				"************************************\n\n",
+					current->pid, __func__, fd, ep, file);
+	}
+#else
+	IRQINITPK("\n\n\t\t[%d] %s: fd %d ep %p file %p\n\n",
+				current->pid, __func__, fd, ep, file);
+#endif
+#endif
 	ep->file = file;
 	fd_install(fd, file);
 	return fd;
@@ -1839,6 +1955,27 @@ SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,
 	struct epoll_event epds;
 	struct eventpoll *tep = NULL;
 
+#ifdef CONFIG_POPCORN_HYPE
+//	if (distributed_process(current)) {
+//		printk("\n\t\t\t\t[%d] %s: epfd %d [%s] fd %d\n\n",
+//			current->pid, __func__, epfd,
+//			op == EPOLL_CTL_ADD ? "ADD" : op == EPOLL_CTL_DEL ? "DEL": "MOD",
+//			fd);
+//	}
+#if POPHYPE_HOST_KERNEL
+	/* nginx guest vm */
+	/* pophype: net debug -c 3 case net epfd=8 */
+	if (distributed_process(current)) {
+		if (epfd == 8) { /* pophype hardcode */
+			POP_PK("\n\t\t\t[net %d] %s: epfd %d [%s] fd %d\n\n",
+				current->pid, __func__, epfd,
+				op == EPOLL_CTL_ADD ? "ADD" :
+						op == EPOLL_CTL_DEL ? "DEL": "MOD", fd);
+		}
+	}
+#endif
+#endif
+
 	error = -EFAULT;
 	if (ep_op_has_event(op) &&
 	    copy_from_user(&epds, event, sizeof(struct epoll_event)))
@@ -2003,9 +2140,43 @@ SYSCALL_DEFINE4(epoll_wait, int, epfd, struct epoll_event __user *, events,
 	 */
 	ep = f.file->private_data;
 
+#ifdef CONFIG_POPCORN_HYPE
+#if POPHYPE_NET_OPTIMIZE_TMP_DEBUG
+	//if (distributed_process(current)) {
+	if ((epfd >= 28 || epfd == 8) && current->pid > 3000) { // dbg net-mq
+		POP_PK("\n\t\t\t[%d] %s %s: epfd %d ep %p [WAIT] in kern [test uevent %p]\n\n",
+					current->pid, __FILE__, __func__, epfd, ep, events);
+	}
+	//}
+#endif
+#endif
+
 	/* Time to fish for events ... */
 	error = ep_poll(ep, events, maxevents, timeout);
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* ep_poll() will scan ep list and find the task */
+//	if (distributed_process(current)) {
+//		printk("\n\t\t\t[%d] %s: epfd %d ep %p [WAKEUP]\n\n",
+//							current->pid, __func__, epfd, ep);
+//	}
+#if POPHYPE_HOST_KERNEL
+#if POPHYPE_NET_OPTIMIZE_TMP_DEBUG
+	/* nginx/memcached guest vm */
+	/* pophype: net debug -c 3 case net epfd=8 */
+	//if (distributed_process(current)) {
+		if ((epfd >= 28 || epfd == 8) && current->pid > 3000) { // dbg net-mq
+		//if (epfd == 8) { /* pophype ioepoll hardcode */
+			POP_PK("\t\t\t[net %d] %s %s: "
+					"epfd %d ep %p ->file %p [WAKEUP] to usr [test uevent %p]\n",
+					current->pid, __FILE__, __func__, epfd, ep, ep->file, events);
+
+		}
+	//}
+#endif
+#endif
+#endif
+
 error_fput:
 	fdput(f);
 	return error;
@@ -2105,6 +2276,11 @@ static int __init eventpoll_init(void)
 {
 	struct sysinfo si;
 
+#if !POPHYPE_HOST_KERNEL
+	POP_PK("pophype: %s %s(): set cpu0, (problematic point)\n", __FILE__, __func__);
+	pophype_set_cpu0();
+#endif
+
 	si_meminfo(&si);
 	/*
 	 * Allows top 4% of lomem to be allocated for epoll watches (per user).
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 0e0438b5ddbe..5b615f1f3551 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -50,6 +50,11 @@
 #include "acl.h"
 #include "mballoc.h"
 
+#ifdef CONFIG_POPCORN_HYPE
+//#include <popcorn/bundle.h>
+#include <popcorn/debug.h>
+#endif
+
 #define CREATE_TRACE_POINTS
 #include <trace/events/ext4.h>
 
@@ -3222,10 +3227,20 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 		logical_sb_block = sb_block;
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	GSMPBSPPRINTK("<%d> %s(): 1\n", smp_processor_id(), __func__);
+#endif
+#endif
 	if (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {
 		ext4_msg(sb, KERN_ERR, "unable to read superblock");
 		goto out_fail;
 	}
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	GSMPBSPPRINTK("<%d> %s(): 2\n", smp_processor_id(), __func__);
+#endif
+#endif
 	/*
 	 * Note: s_es must be initialized as soon as possible because
 	 *       some ext4 macro-instructions depend on its value
diff --git a/fs/file.c b/fs/file.c
index 39f8f15921da..c24e7cb48f50 100644
--- a/fs/file.c
+++ b/fs/file.c
@@ -23,6 +23,10 @@
 #include <linux/rcupdate.h>
 #include <linux/workqueue.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/types.h>
+#include <popcorn/hype_kvm.h>
+#endif
 int sysctl_nr_open __read_mostly = 1024*1024;
 int sysctl_nr_open_min = BITS_PER_LONG;
 /* our max() is unusable in constant expressions ;-/ */
@@ -558,10 +562,36 @@ static int alloc_fd(unsigned start, unsigned flags)
 
 int get_unused_fd_flags(unsigned flags)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	int fd = __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);
+	if (distributed_process(current) ||
+		(fd > FD_DEBUG_THREDSHOLD_LOW && fd < FD_DEBUG_THREDSHOLD_HIGH)) {
+		//printk("%s(): *** fd %d allocated*** \n", __func__, fd);
+	}
+	return fd;
+#else
 	return __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);
+#endif
 }
 EXPORT_SYMBOL(get_unused_fd_flags);
 
+//#ifdef CONFIG_POPCORN_HYPE /* Commented for supporting Vanilla */
+int get_unused_fd_flags_tsk(struct task_struct *tsk, unsigned flags)
+{
+#ifdef CONFIG_POPCORN_HYPE
+	int fd = __alloc_fd(tsk->files, 0, rlimit(RLIMIT_NOFILE), flags);
+	if (distributed_process(tsk) ||
+		(fd > FD_DEBUG_THREDSHOLD_LOW && fd < FD_DEBUG_THREDSHOLD_HIGH)) {
+		//printk("%s(): *** fd %d allocated*** \n", __func__, fd);
+	}
+	return fd;
+#else
+	return __alloc_fd(tsk->files, 0, rlimit(RLIMIT_NOFILE), flags);
+#endif
+}
+EXPORT_SYMBOL(get_unused_fd_flags_tsk);
+//#endif
+
 static void __put_unused_fd(struct files_struct *files, unsigned int fd)
 {
 	struct fdtable *fdt = files_fdtable(files);
@@ -577,9 +607,19 @@ void put_unused_fd(unsigned int fd)
 	__put_unused_fd(files, fd);
 	spin_unlock(&files->file_lock);
 }
-
 EXPORT_SYMBOL(put_unused_fd);
 
+#ifdef CONFIG_POPCORN_HYPE
+void put_unused_fd_tsk(struct task_struct *tsk, unsigned int fd)
+{
+	struct files_struct *files = tsk->files;
+	spin_lock(&files->file_lock);
+	__put_unused_fd(files, fd);
+	spin_unlock(&files->file_lock);
+}
+EXPORT_SYMBOL(put_unused_fd_tsk);
+#endif
+
 /*
  * Install a file pointer in the fd array.
  *
@@ -623,11 +663,44 @@ void __fd_install(struct files_struct *files, unsigned int fd,
 
 void fd_install(unsigned int fd, struct file *file)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	//if (cnt > 20000 && !(cnt % 1000) &&
+	if (distributed_process(current))
+		// cnt > 51421)
+		// && (distributed_process(current) ||
+		// (fd > FD_DEBUG_THREDSHOLD_LOW && fd < FD_DEBUG_THREDSHOLD_HIGH)))
+	{
+		static int cnt = 0;
+		cnt++;
+		POP_PK("[%d] %s(): *** fd %d used*** files %p file %p #%d\n",
+					current->pid, __func__, fd, current->files, file, cnt);
+		//if (fd == 17) { // TODO
+			//POP_PK("\n\n=================================================\n");
+			//dump_stack(); // from SyS_eventfd2()
+			//POP_PK("=================================================\n\n");
+		//}
+	}
+#endif
 	__fd_install(current->files, fd, file);
 }
-
 EXPORT_SYMBOL(fd_install);
 
+#ifdef CONFIG_POPCORN_HYPE
+void fd_install_tsk(struct task_struct *tsk, unsigned int fd, struct file *file)
+{
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(tsk))
+		//|| (fd > FD_DEBUG_THREDSHOLD_LOW && fd < FD_DEBUG_THREDSHOLD_HIGH))
+	{
+		POP_PK("[%d] %s(): *** fd %d used*** files %p file %p\n",
+					tsk->pid, __func__, fd, tsk->files, file);
+	}
+#endif
+	__fd_install(tsk->files, fd, file);
+}
+EXPORT_SYMBOL(fd_install_tsk);
+#endif
+
 /*
  * The same warnings as for __alloc_fd()/__fd_install() apply here...
  */
@@ -758,6 +831,48 @@ static unsigned long __fget_light(unsigned int fd, fmode_t mask)
 		return FDPUT_FPUT | (unsigned long)file;
 	}
 }
+#ifdef CONFIG_POPCORN_HYPE
+static struct file *__fget_tsk(struct task_struct *tsk, unsigned int fd, fmode_t mask)
+{
+	struct files_struct *files = tsk->files;
+	struct file *file;
+
+	rcu_read_lock();
+loop:
+	file = fcheck_files(files, fd);
+	if (file) {
+		/* File object ref couldn't be taken.
+		 * dup2() atomicity guarantee is the reason
+		 * we loop to catch the new file (or NULL pointer)
+		 */
+		if (file->f_mode & mask)
+			file = NULL;
+		else if (!get_file_rcu(file))
+			goto loop;
+	}
+	rcu_read_unlock();
+
+	return file;
+}
+unsigned long fget_light_tsk(struct task_struct *tsk, unsigned int fd, fmode_t mask)
+{
+	struct files_struct *files = tsk->files;
+	struct file *file;
+
+	if (atomic_read(&files->count) == 1) {
+		file = __fcheck_files(files, fd);
+		if (!file || unlikely(file->f_mode & mask))
+			return 0;
+		return (unsigned long)file;
+	} else {
+		file = __fget_tsk(tsk, fd, mask);
+		if (!file)
+			return 0;
+		return FDPUT_FPUT | (unsigned long)file;
+	}
+}
+EXPORT_SYMBOL(fget_light_tsk);
+#endif
 unsigned long __fdget(unsigned int fd)
 {
 	return __fget_light(fd, FMODE_PATH);
diff --git a/fs/file_table.c b/fs/file_table.c
index ad17e05ebf95..4cd816ed02fa 100644
--- a/fs/file_table.c
+++ b/fs/file_table.c
@@ -148,6 +148,54 @@ over:
 	return ERR_PTR(-ENFILE);
 }
 
+struct file *get_empty_filp_tsk(struct task_struct *tsk)
+{
+	const struct cred *cred = current_cred();
+	static long old_max;
+	struct file *f;
+	int error;
+
+	/*
+	 * Privileged users can go above max_files
+	 */
+	if (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {
+		/*
+		 * percpu_counters are inaccurate.  Do an expensive check before
+		 * we go and fail.
+		 */
+		if (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)
+			goto over;
+	}
+
+	f = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);
+	if (unlikely(!f))
+		return ERR_PTR(-ENOMEM);
+
+	percpu_counter_inc(&nr_files);
+	f->f_cred = get_cred(cred);
+	error = security_file_alloc(f);
+	if (unlikely(error)) {
+		file_free(f);
+		return ERR_PTR(error);
+	}
+
+	atomic_long_set(&f->f_count, 1);
+	rwlock_init(&f->f_owner.lock);
+	spin_lock_init(&f->f_lock);
+	mutex_init(&f->f_pos_lock);
+	eventpoll_init_file(f);
+	/* f->f_version: 0 */
+	return f;
+
+over:
+	/* Ran out of filps - report that */
+	if (get_nr_files() > old_max) {
+		pr_info("VFS: file-max limit %lu reached\n", get_max_files());
+		old_max = get_nr_files();
+	}
+	return ERR_PTR(-ENFILE);
+}
+
 /**
  * alloc_file - allocate and initialize a 'struct file'
  *
diff --git a/fs/internal.h b/fs/internal.h
index 71859c4d0b41..60fa61f7f439 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -79,6 +79,7 @@ extern void chroot_fs_refs(const struct path *, const struct path *);
  * file_table.c
  */
 extern struct file *get_empty_filp(void);
+extern struct file *get_empty_filp_tsk(struct task_struct *tsk);
 
 /*
  * super.c
@@ -101,6 +102,8 @@ struct open_flags {
 };
 extern struct file *do_filp_open(int dfd, struct filename *pathname,
 		const struct open_flags *op);
+extern struct file *do_filp_open_tsk(struct task_struct *tsk, int dfd, struct filename *pathname,
+		const struct open_flags *op);
 extern struct file *do_file_open_root(struct dentry *, struct vfsmount *,
 		const char *, const struct open_flags *);
 
diff --git a/fs/namei.c b/fs/namei.c
index de57dd59d95f..88ce5c8a7d81 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -528,6 +528,17 @@ static void set_nameidata(struct nameidata *p, int dfd, struct filename *name)
 	current->nameidata = p;
 }
 
+static void set_nameidata_tsk(struct task_struct *tsk, struct nameidata *p, int dfd, struct filename *name)
+{
+	struct nameidata *old = tsk->nameidata;
+	p->stack = p->internal;
+	p->dfd = dfd;
+	p->name = name;
+	p->total_link_count = old ? old->total_link_count : 0;
+	p->saved = old;
+	tsk->nameidata = p;
+}
+
 static void restore_nameidata(void)
 {
 	struct nameidata *now = current->nameidata, *old = now->saved;
@@ -541,6 +552,19 @@ static void restore_nameidata(void)
 	}
 }
 
+static void restore_nameidata_tsk(struct task_struct *tsk)
+{
+	struct nameidata *now = tsk->nameidata, *old = now->saved;
+
+	tsk->nameidata = old;
+	if (old)
+		old->total_link_count = now->total_link_count;
+	if (now->stack != now->internal) {
+		kfree(now->stack);
+		now->stack = now->internal;
+	}
+}
+
 static int __nd_alloc_stack(struct nameidata *nd)
 {
 	struct saved *p;
@@ -2100,6 +2124,109 @@ static const char *path_init(struct nameidata *nd, unsigned flags)
 	return ERR_PTR(-ECHILD);
 }
 
+static const char *path_init_tsk(struct task_struct *tsk, struct nameidata *nd, unsigned flags)
+{
+	int retval = 0;
+	const char *s = nd->name->name;
+
+	if (!*s)
+		flags &= ~LOOKUP_RCU;
+
+	nd->last_type = LAST_ROOT; /* if there are only slashes... */
+	nd->flags = flags | LOOKUP_JUMPED | LOOKUP_PARENT;
+	nd->depth = 0;
+	if (flags & LOOKUP_ROOT) {
+		struct dentry *root = nd->root.dentry;
+		struct inode *inode = root->d_inode;
+		if (*s) {
+			if (!d_can_lookup(root))
+				return ERR_PTR(-ENOTDIR);
+			retval = inode_permission(inode, MAY_EXEC);
+			if (retval)
+				return ERR_PTR(retval);
+		}
+		nd->path = nd->root;
+		nd->inode = inode;
+		if (flags & LOOKUP_RCU) {
+			rcu_read_lock();
+			nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
+			nd->root_seq = nd->seq;
+			nd->m_seq = read_seqbegin(&mount_lock);
+		} else {
+			path_get(&nd->path);
+		}
+		return s;
+	}
+
+	nd->root.mnt = NULL;
+
+	nd->m_seq = read_seqbegin(&mount_lock);
+	if (*s == '/') {
+		if (flags & LOOKUP_RCU) {
+			rcu_read_lock();
+			set_root_rcu(nd);
+			nd->seq = nd->root_seq;
+		} else {
+			set_root(nd);
+			path_get(&nd->root);
+		}
+		nd->path = nd->root;
+	} else if (nd->dfd == AT_FDCWD) {
+		if (flags & LOOKUP_RCU) {
+			struct fs_struct *fs = tsk->fs;
+			unsigned seq;
+
+			rcu_read_lock();
+
+			do {
+				seq = read_seqcount_begin(&fs->seq);
+				nd->path = fs->pwd;
+				nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
+			} while (read_seqcount_retry(&fs->seq, seq));
+		} else {
+			get_fs_pwd(tsk->fs, &nd->path);
+		}
+	} else {
+		/* Caller must check execute permissions on the starting path component */
+		struct fd f = fdget_raw(nd->dfd);
+		struct dentry *dentry;
+
+		if (!f.file)
+			return ERR_PTR(-EBADF);
+
+		dentry = f.file->f_path.dentry;
+
+		if (*s) {
+			if (!d_can_lookup(dentry)) {
+				fdput(f);
+				return ERR_PTR(-ENOTDIR);
+			}
+		}
+
+		nd->path = f.file->f_path;
+		if (flags & LOOKUP_RCU) {
+			rcu_read_lock();
+			nd->inode = nd->path.dentry->d_inode;
+			nd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);
+		} else {
+			path_get(&nd->path);
+			nd->inode = nd->path.dentry->d_inode;
+		}
+		fdput(f);
+		return s;
+	}
+
+	nd->inode = nd->path.dentry->d_inode;
+	if (!(flags & LOOKUP_RCU))
+		return s;
+	if (likely(!read_seqcount_retry(&nd->path.dentry->d_seq, nd->seq)))
+		return s;
+	if (!(nd->flags & LOOKUP_ROOT))
+		nd->root.mnt = NULL;
+	rcu_read_unlock();
+	return ERR_PTR(-ECHILD);
+}
+
 static const char *trailing_symlink(struct nameidata *nd)
 {
 	const char *s;
@@ -3350,6 +3477,56 @@ out2:
 	return file;
 }
 
+static struct file *path_openat_tsk(struct task_struct *tsk, struct nameidata *nd, const struct open_flags *op, unsigned flags)
+{
+	const char *s;
+	struct file *file;
+	int opened = 0;
+	int error;
+
+	file = get_empty_filp_tsk(tsk);
+	if (IS_ERR(file))
+		return file;
+
+	file->f_flags = op->open_flag;
+
+	if (unlikely(file->f_flags & __O_TMPFILE)) {
+		error = do_tmpfile(nd, flags, op, file, &opened); //TODO
+		goto out2;
+	}
+
+	s = path_init_tsk(tsk, nd, flags); // TODO inside
+	if (IS_ERR(s)) {
+		put_filp(file);
+		return ERR_CAST(s);
+	}
+	while (!(error = link_path_walk(s, nd)) && //TODO
+		(error = do_last(nd, file, op, &opened)) > 0) { //TODO it has
+		nd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);
+		s = trailing_symlink(nd); //TODO in may_follow_link
+		if (IS_ERR(s)) {
+			error = PTR_ERR(s);
+			break;
+		}
+	}
+	terminate_walk(nd); //TODO get_link->set_root_rcu
+out2:
+	if (!(opened & FILE_OPENED)) {
+		BUG_ON(!error);
+		put_filp(file);
+	}
+	if (unlikely(error)) {
+		if (error == -EOPENSTALE) {
+			if (flags & LOOKUP_RCU)
+				error = -ECHILD;
+			else
+				error = -ESTALE;
+		}
+		file = ERR_PTR(error);
+	}
+	return file;
+}
+
 struct file *do_filp_open(int dfd, struct filename *pathname,
 		const struct open_flags *op)
 {
@@ -3367,6 +3544,22 @@ struct file *do_filp_open(int dfd, struct filename *pathname,
 	return filp;
 }
 
+struct file *do_filp_open_tsk(struct task_struct *tsk, int dfd, struct filename *pathname, const struct open_flags *op)
+{
+	struct nameidata nd;
+	int flags = op->lookup_flags;
+	struct file *filp;
+
+	set_nameidata_tsk(tsk, &nd, dfd, pathname);
+	filp = path_openat_tsk(tsk, &nd, op, flags | LOOKUP_RCU); //doing
+	if (unlikely(filp == ERR_PTR(-ECHILD)))
+		filp = path_openat_tsk(tsk, &nd, op, flags);
+	if (unlikely(filp == ERR_PTR(-ESTALE)))
+		filp = path_openat_tsk(tsk, &nd, op, flags | LOOKUP_REVAL);
+	restore_nameidata_tsk(tsk);
+	return filp;
+}
+
 struct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt,
 		const char *name, const struct open_flags *op)
 {
diff --git a/fs/open.c b/fs/open.c
index fbc5c7b230b3..f561384b0fd7 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -32,6 +32,8 @@
 #include <linux/dnotify.h>
 #include <linux/compat.h>
 
+#include <popcorn/hype_file.h>
+
 #include "internal.h"
 
 int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,
@@ -871,7 +873,7 @@ struct file *dentry_open(const struct path *path, int flags,
 				fput(f);
 				f = ERR_PTR(error);
 			}
-		} else { 
+		} else {
 			put_filp(f);
 			f = ERR_PTR(error);
 		}
@@ -987,7 +989,7 @@ struct file *filp_open(const char *filename, int flags, umode_t mode)
 {
 	struct filename *name = getname_kernel(filename);
 	struct file *file = ERR_CAST(name);
-	
+
 	if (!IS_ERR(name)) {
 		file = file_open_name(name, flags, mode);
 		putname(name);
@@ -1007,15 +1009,233 @@ struct file *file_open_root(struct dentry *dentry, struct vfsmount *mnt,
 }
 EXPORT_SYMBOL(file_open_root);
 
+//#ifdef CONFIG_POPCORN_HYPE /* Commented for supporting Vanilla */ /* The real issue is syscall and pophype_stat related */
+/* origin recv a request */
+/* TODO: used by remote/origin nodes */
+/* TODO: used by remote/origin nodes */
+/* TODO: used by remote/origin nodes */
+long do_sys_open_tsk_req(struct task_struct *tsk, int dfd, char *filename, int flags, umode_t mode, int req_fd)
+{
+    struct open_flags op;
+    int fd = build_open_flags(flags, mode, &op);
+    struct filename *pathname;
+
+	pathname = getname_kernel(filename);
+    if (IS_ERR(pathname)) {
+		printk("ERR: req_fd %d vs got fd %d\n", req_fd, fd);
+		return PTR_ERR(pathname);
+	}
+
+	if (req_fd < 0) { /* origin */
+		//fd = __alloc_fd(tsk->files, 0, rlimit(RLIMIT_NOFILE), flags);
+		fd = get_unused_fd_flags_tsk(tsk, flags);
+	} else { /* remote */
+		fd = get_unused_fd_flags(flags);
+		POP_PK("[%d] req_fd %d vs got fd %d (testing - local open)\n",
+													tsk->pid, req_fd, fd);
+		fd = req_fd;
+		POP_PK("[%d] req_fd %d vs got fd %d (by delegation)\n",
+											tsk->pid, req_fd, fd);
+	}
+
+    if (fd >= 0) {
+        struct file *f = do_filp_open_tsk(tsk, dfd, pathname, &op); /* TODO: fix current */
+		if (f) {
+			POP_PK("[[OPEN]] fd %d \"%s\" f %p ->f_inode %p ->f_op %p\n",
+									fd, filename, f, f->f_inode, f->f_op);
+		} else {
+			POP_PK("[[OPEN]] fd %d \"%s\" f %p\n", fd, filename, f);
+		}
+        if (IS_ERR(f)) {
+            put_unused_fd(fd);
+            fd = PTR_ERR(f);
+			BUG();
+        } else {
+            fsnotify_open(f);
+			__fd_install(tsk->files, fd, f);
+			POP_PK("%s: popcorn open fd %d file %p\n", __func__, fd, f);
+        }
+    }
+    putname(pathname);
+	return fd;
+}
+
+/* Copy from old code: refactory required!! TODO */
+/*
+ *
+ * Due to files->count doesn't work, this is mainly built for geting correct number of opened files
+ * and debugging.
+// load=1: update fake_file_table[] (jack_open() doesn't mantian fake_file_table[])
+ */
+int jack_traverse_thread_files(struct task_struct* task, int debug, int load) {
+    struct fdtable *fdt_tmp;
+    int cnt = 0;
+    int i = 0;
+
+    if(debug) {
+		POP_PK("Jack: OOOOOOOOOOOOOOOO jack_traverse OOOOOOOOOOOOOOOO\n");
+	}
+
+	spin_lock(&task->files->file_lock);
+	fdt_tmp = files_fdtable(task->files);
+	spin_unlock(&task->files->file_lock);
+    while(1) {
+        if (fdt_tmp->fd[i] != NULL) {
+            char path[255] = {'\0'};
+            char *ppath = path;
+            ppath = d_path(&(fdt_tmp->fd[i]->f_path), ppath, 255);
+            if(debug != 0) {
+                FDPRINTK("fm: \ttfd[%d](fd)  d_path() = %s\n", i, ppath);
+            }
+            if(load) {  /* only before migration and closing files,
+							it needs to update current->fake_file_table[]
+							for recording existing (old) closed files */
+                if (task->fake_file_table[i] == NULL)
+                    task->fake_file_table[i] =
+						kmalloc(sizeof(remote_file_info_t), GFP_KERNEL);
+										// NOTE: only supporting 16 files
+
+                task->fake_file_table[i]->f_flags = fdt_tmp->fd[i]->f_flags;
+                task->fake_file_table[i]->f_mode = fdt_tmp->fd[i]->f_mode;
+                //task->fake_file_table[i]->f_owner_pid =
+				//							fdt_tmp->fd[i]->f_owner.pid;
+				memcpy(&task->fake_file_table[i]->f_owner_pid,
+						&fdt_tmp->fd[i]->f_owner, sizeof(struct fown_struct));
+                task->fake_file_table[i]->f_pos = fdt_tmp->fd[i]->f_pos;
+                strcpy(task->fake_file_table[i]->file_name, ppath);
+            }
+            cnt++;
+        }
+        else {
+            if(debug != 0) {
+                POP_PK("fm: \ttfd[%d](fd)  d_path() = %s\n", i, "NULL");
+            }
+            break;
+        }
+        i++;
+    }
+    return cnt;
+}
+
+void jack_do_file_migration(struct task_struct* task) {
+    int loop;
+	char label[]="fm";
+    struct fdtable *fdt_tmp;
+
+    // TODO: add t_FileOpenedCnt=0 to struct thread
+    int cur_total_files_cnt = jack_traverse_thread_files(task, 1, 1); // befor closing, recording all existing (old) files for future reopening
+	int delta_file_cnt = cur_total_files_cnt;
+    //int delta_file_cnt =  cur_total_files_cnt - current->t_FileOpenedCnt ; // Cnt in the end of this migration
+
+	spin_lock(&task->files->file_lock);
+    fdt_tmp = files_fdtable(task->files); // open file table
+	spin_unlock(&task->files->file_lock);
+    if (delta_file_cnt > 0 ) { // has file added // 0 =no file added
+        //current->t_FileOpenedCnt = cur_total_files_cnt;  // TODO: check current->files->count got migrated all the time? write a program - open migra open migra open migra open migra. If current->files->count works, use that  a opimiztion so late I dont
+        POP_PK("%s: [%d/%d] ------- found new files, loading to msg -------- \n", label, my_nid, task->pid);
+        for (loop = 0 ;loop < fdt_tmp->max_fds ;loop++) {
+            if (fdt_tmp->fd[loop]!=NULL) {
+                char path[255] = {'\0'};
+                char *ppath = path;
+                //debuging
+                FDPRINTK("%s: fdt_tmp->fd[%d] = *****yes***** \n", label, loop);
+                FDPRINTK("%s: fdt_tmp->fd[%d]->f_pos = %d \n",
+							label, loop, (int)fdt_tmp->fd[loop]->f_pos);
+                FDPRINTK("%s: fdt_tmp->fd[%d]->f_mode = %d \n",
+							label, loop, fdt_tmp->fd[loop]->f_mode);
+                FDPRINTK("%s: fdt_tmp->fd[%d]->f_flags = %d \n",
+						label, loop, fdt_tmp->fd[loop]->f_flags);
+				/* above msg below FYI */
+                //printk("%s: fdt_tmp->fd[%d]->f_owner = %d \n",
+				//		label, loop, fdt_tmp->fd[loop]->f_owner);
+				//							// compile warning // Not in ms
+				if (fdt_tmp->fd[loop]->f_owner.pid) {
+					FDPRINTK("%s: fdt_tmp->fd[%d]->f_owner.pid = %d \n", label,
+							loop, fdt_tmp->fd[loop]->f_owner.pid->numbers[0].nr);
+												// compile warning // Not in msg
+				}
+                FDPRINTK("%s: fdt_tmp->fd[%d]->f_owner.uid.val = %d \n",
+					label, loop, (int)fdt_tmp->fd[loop]->f_owner.uid.val);
+																	// Not in msg
+                POP_PK("%s: fdt_tmp->fd[%d]->f_owner.euid.val = %d \n",
+						label, loop, (int)fdt_tmp->fd[loop]->f_owner.euid.val);
+																	// Not in msg
+                FDPRINTK("%s: fdt_tmp->fd[%d]->f_inode->i_uid.val = %d \n",
+						label, loop, (int)fdt_tmp->fd[loop]->f_inode->i_uid.val);
+																	// Not in msg
+
+                //loading
+                // way 1 for getting a file path
+                ppath = d_path(&(fdt_tmp->fd[loop]->f_path), ppath, 255); // f_path -> name
+                POP_PK("%s: fdt_tmp->fd[%d] d_path() = %s \n",
+											label, loop, ppath);
+                FDPRINTK("%s: ppath = %s \n", label, ppath);
+                //strcpy(request->file_name[loop], ppath);
+                //printk("%s: request->file_name[%d] = %s \n",
+				//			label, loop, request->file_name[loop]);
+                // way 2 for getting a file path - requires to maintain faketable every open()
+                //strcpy( request->file_name, current->fake_file_table[loop]->filename);
+
+                //request->f_pos[loop] = fdt_tmp->fd[loop]->f_pos;
+                //request->f_flags[loop] = fdt_tmp->fd[loop]->f_flags;
+                //request->f_mode[loop] = fdt_tmp->fd[loop]->f_mode;
+                FDPRINTK("Jack: fd[%d] meta loaded in msg\n", loop);
+            }
+            else {
+                POP_PK("%s: cur->files->fd[%d] = *****null***** \n", label, loop);
+                break;  // uncomment if don't iter all nodes.
+            }
+        } // file[fd] iteration
+        POP_PK("%s: ------ loading to msg end -------- \n", label);
+
+        // make sure all files are closed
+        if (jack_traverse_thread_files(task, 1, 0) == 0) { // debug1, update0
+            POP_PK("%s: all files closed\n", label);
+        } else {
+            POP_PK("%s: WARNNING: not closed files correctly !!! %d left!!!\n",
+							label, jack_traverse_thread_files(task, 0, 0));
+        }
+        // --- merge to golbal file mapping table --- //
+        POP_PK("Jack: --- all files meta data loaded ---\n");
+    } // has file added end
+    else if (delta_file_cnt == 0) { // important, remote needs these info
+        POP_PK("%s: ------------ not open any new file. delta=%d -------- \n",
+						label, delta_file_cnt);
+    }
+    else if (delta_file_cnt < 0) {
+        POP_PK("%s: ERROR: delta_file_cnt<0 !!!delta_file_cnt=%d!!!!!\n",
+						label, delta_file_cnt);
+    }
+}
+//#endif
+
+/* POPCORN_HYPE
+ * /dev/kvm
+ * bzImage
+ * file img
+ *
+ *
+ * req: input
+ * res: struct file f and fd
+ *	fd_install()/__fd_install()
+ */
 long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
 {
 	struct open_flags op;
 	int fd = build_open_flags(flags, mode, &op);
 	struct filename *tmp;
 
+	/* Recycle fd for flag checking */
 	if (fd)
 		return fd;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		//HPPRINTK("%s: skip supporting open\n", __func__);
+	}
+//	if (!distributed_remote_process(current)) { /* origin */
+#endif
+
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1030,8 +1250,44 @@ long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
 			fsnotify_open(f);
 			fd_install(fd, f);
 		}
+#ifdef CONFIG_POPCORN_HYPE
+		if (distributed_process(current)) {
+			if (fd == -EEXIST)
+				printk(KERN_ERR "file exist -17\n"); // -17 !exist
+
+			if (fd < 0) {
+				printk(KERN_ERR "[%d] exit: fd %d \"%s\" not exist "
+								"(-13 EACCES) (-6 ENXIO)\n",
+								current->pid, fd, tmp->name);
+				BUG();
+			}
+			POP_PK("\n[%d] %s: popcorn [OPEN] fd %d file %p inst %lx sp %lx\n\n",
+					current->pid, __func__, fd, f,
+					instruction_pointer(current_pt_regs()),
+					user_stack_pointer(current_pt_regs()));
+		}
+		/**** HACK for debuging network device fd 15 - 17(?) when -c 3 ***/
+//		if (fd >= 15 && fd <= 20 && current->pid > 2000) {
+//			POP_PK("\tpophype: net: [%d] %s(): "
+//					"fd %d file %p inst %lx sp %lx\n",
+//					current->pid, __func__, fd, f,
+//					instruction_pointer(current_pt_regs()),
+//					user_stack_pointer(current_pt_regs()));
+//		}
+#endif
 	}
 	putname(tmp);
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		//HPPRINTK("%s: skip supporting open\n", __func__);
+	}
+//	} else {
+//		printk("remote open - skipped\n");
+//	}
+//
+//	if (distributed_process(current)) /* remote: delegate origin: brodcast */
+//		fd = popcorn_open(filename, flags, mode, fd);
+#endif
 	return fd;
 }
 
@@ -1099,6 +1355,12 @@ EXPORT_SYMBOL(filp_close);
 SYSCALL_DEFINE1(close, unsigned int, fd)
 {
 	int retval = __close_fd(current->files, fd);
+#ifdef CONFIG_POPCORN_HYPE
+		if (distributed_process(current)) {
+			POP_PK("\n[%d] %s: popcorn [CLOSE] fd %d\n\n",
+								current->pid, __func__, fd);
+		}
+#endif
 
 	/* can't restart close syscall because file table entry was cleared */
 	if (unlikely(retval == -ERESTARTSYS ||
diff --git a/fs/read_write.c b/fs/read_write.c
index 3f9c8a038138..d8e01f1c7d2e 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -4,7 +4,7 @@
  *  Copyright (C) 1991, 1992  Linus Torvalds
  */
 
-#include <linux/slab.h> 
+#include <linux/slab.h>
 #include <linux/stat.h>
 #include <linux/fcntl.h>
 #include <linux/file.h>
@@ -21,6 +21,14 @@
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
+#include <popcorn/hype_file.h>
+#define STDIN_FILENO 0
+#define STDOUT_FILENO 1
+#define STDERR_FILENO 2
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+#include <popcorn/types.h>
+#endif
+
 typedef ssize_t (*io_fn_t)(struct file *, char __user *, size_t, loff_t *);
 typedef ssize_t (*iter_fn_t)(struct kiocb *, struct iov_iter *);
 
@@ -559,18 +567,53 @@ static inline void file_pos_write(struct file *file, loff_t pos)
 	file->f_pos = pos;
 }
 
-#ifdef CONFIG_POPCORN_CHECK_SANITY
-#include <popcorn/types.h>
-#endif
-
 SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)
 {
 	struct fd f = fdget_pos(fd);
 	ssize_t ret = -EBADF;
 
-#ifdef CONFIG_POPCORN_CHECK_SANITY
-	if (WARN_ON(distributed_remote_process(current))) {
-		printk("  file read at remote thread is not supported yet\n");
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_CHECK_SANITY) && HYPEBOOTDEBUG
+	/*** TODO: generalize ***/
+	/*** TODO: generalize ***/
+	/*** TODO: generalize ***/
+	// TODO skip if first_fd_after_vcpufd == 0
+
+	// 2 cpu case: fd 11 12
+	// 13 = first_fd_after_vcpufd + 0
+	// 14 = first_fd_after_vcpufd + 1
+	// 15 = first_fd_after_vcpufd + 2
+	// 16 = first_fd_after_vcpufd + 3
+	if (distributed_process(current)) {
+		if (fd == 9 || fd == 7 || fd == 10 ||
+			fd == (first_fd_after_vcpufd + 1) || fd == (first_fd_after_vcpufd + 2) ||
+			fd == (first_fd_after_vcpufd + 3) || fd == (first_fd_after_vcpufd + 4)) {
+			printk("\t(hardcode) evenfd [R] fd %d\n", fd); // captureed by event_write
+		}
+		if (fd == 5 || fd == 7) {
+			printk("\n\t(hardcode) epfd 6 [R] fd %d\n", fd);
+		}
+		// 15 = first_fd_after_vcpufd +3
+		if (fd == 9 || fd == (first_fd_after_vcpufd + 2) || fd == (first_fd_after_vcpufd + 3)) {
+			printk("\n\t(harcode) epfd 8 [R] fd %d\n", fd);
+		}
+	}
+	if (fd != STDIN_FILENO) {
+		if (WARN_ON(distributed_remote_process(current))) {
+		//if (distributed_remote_process(current)) {
+			if (fd == (first_fd_after_vcpufd + 2) || fd == (first_fd_after_vcpufd + 4)) { // TODO: generalize
+				printk("\n\n\tTODO delegate [R] fd %d\n\n", fd); // delegate
+				//dump_stack();
+				ret = popcorn_delegate_rw(fd, buf, count, true);
+				printk("\n\n\tTODO delegate [R] fd %d ret %ld\n\n", fd, ret); // delegate
+			} else { // e.g. ft
+				printk(KERN_ERR "\n\n\t\t%s: file *READ* at remote thread "
+					"is not supported yet fd %d file %p inst %lx sp %lx\n\n",
+						__FILE__, fd, f.file,
+						instruction_pointer(current_pt_regs()),
+						user_stack_pointer(current_pt_regs()));
+			}
+			//return ret; // only warn since ft leverages it
+		}
 	}
 #endif
 
@@ -584,15 +627,65 @@ SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)
 	return ret;
 }
 
+
 SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf,
 		size_t, count)
 {
 	struct fd f = fdget_pos(fd);
 	ssize_t ret = -EBADF;
 
-#ifdef CONFIG_POPCORN_CHECK_SANITY
-	if (WARN_ON(distributed_remote_process(current))) {
-		printk("  file write at remote thread is not supported yet\n");
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_CHECK_SANITY) && HYPEBOOTDEBUG
+	/*** TODO: generalize ***/
+	/*** TODO: generalize ***/
+	/*** TODO: generalize ***/
+
+	// TODO skip if first_fd_after_vcpufd == 0
+
+	// 2 cpu case: fd 11 12
+	// 13 = first_fd_after_vcpufd + 0
+	// 14 = first_fd_after_vcpufd + 1
+	// 15 = first_fd_after_vcpufd + 2
+	// 16 = first_fd_after_vcpufd + 3
+	if (distributed_process(current)) {
+		/* eventfd 7 9 10   14 15 16 17
+		 * epfd
+		 * 6: 5 7
+		 * 8: 9 15 16
+		 *
+		 * [8791] SYSC_epoll_create1: fd 6 ep ffff88084c958280 file ffff88084426ab00
+		 * [8791] SYSC_epoll_create1: fd 8 ep ffff88084c958340 file ffff8807fbb3f700
+		 */
+		if (fd == 7 || fd == 9 || fd == 10 ||
+			fd == (first_fd_after_vcpufd + 1) || fd == (first_fd_after_vcpufd + 2) ||
+			fd == (first_fd_after_vcpufd + 3) || fd == (first_fd_after_vcpufd + 4)) {
+			printk("\t(hardcode) evenfd [W] fd %d\n", fd); // captureed by event_write
+		}
+		if (fd == 5 || fd == 7) {
+			printk("\n\t(hardcode) epfd 6 [W] fd %d\n", fd);
+		}
+		if (fd == 9 || fd == (first_fd_after_vcpufd + 2) || fd == (first_fd_after_vcpufd + 3)) {
+			printk("\n\t(harcode) epfd 8 [W] fd %d\n", fd);
+		}
+	}
+	if (fd != STDOUT_FILENO && fd != STDERR_FILENO) {
+		if (WARN_ON(distributed_remote_process(current))) {
+		//if (distributed_remote_process(current)) {
+			if (fd == (first_fd_after_vcpufd + 2) || fd == (first_fd_after_vcpufd + 4)) { // TODO: generalize
+				printk("\n\n\tTODO delegate [W] fd %d\n\n", fd); // delegate
+				//dump_stack();
+				ret = popcorn_delegate_rw(fd, (char *)buf, count, false);
+				printk("\n\n\tTODO delegate [W] fd %d ret %ld\n\n", fd, ret); // delegate
+			} else { // not handled
+				printk(KERN_ERR "\n\n\t\t%s: file *WRITE* at remote thread is "
+						"not supported yet fd %d file %p inst %lx sp %lx\n\n",
+						__FILE__, fd, f.file,
+						instruction_pointer(current_pt_regs()),
+						user_stack_pointer(current_pt_regs()));
+			}
+			//return ret; // only warn since ft leverages it
+		} else {
+			// origin debug?
+		}
 	}
 #endif
 
@@ -607,6 +700,46 @@ SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf,
 	return ret;
 }
 
+#ifdef CONFIG_POPCORN_HYPE
+// fdget_pos() -> __fget_light() uses current
+// SyS_read()
+ssize_t do_tsk_delegate_rw(struct task_struct *tsk, unsigned int fd, char *buf, size_t count, bool is_read)
+{
+	ssize_t ret = -EBADF;
+	unsigned long v;
+    struct fd f;
+
+retry:
+	v = fget_light_tsk(tsk, fd, FMODE_PATH);
+    f = (struct fd){(struct file *)(v & ~3),v & 3};
+	//struct fd f = fdget_pos(fd);
+
+	printk("\t#working# <*> performing [%c] on struct fd f %p\n",
+										is_read ? 'R' : 'W', &f);
+
+	if (f.file) {
+		loff_t pos = file_pos_read(f.file);
+		printk("\t\t#working# <*> performing [%c] on file %p (GOOD)\n",
+											is_read ? 'R' : 'W', f.file);
+		if (is_read)
+			ret = vfs_read(f.file, buf, count, &pos);
+		else
+			ret = vfs_write(f.file, buf, count, &pos);
+		if (ret >= 0)
+			file_pos_write(f.file, pos);
+		fdput_pos(f);
+	} else {
+		//BUG_ON("CHECK");
+		msleep(5000);
+		printk(KERN_ERR "\t\tRETRY FD->FILE\n");
+		goto retry;
+	}
+
+	return ret;
+}
+#endif
+
+
 SYSCALL_DEFINE4(pread64, unsigned int, fd, char __user *, buf,
 			size_t, count, loff_t, pos)
 {
@@ -639,7 +772,7 @@ SYSCALL_DEFINE4(pwrite64, unsigned int, fd, const char __user *, buf,
 	f = fdget(fd);
 	if (f.file) {
 		ret = -ESPIPE;
-		if (f.file->f_mode & FMODE_PWRITE)  
+		if (f.file->f_mode & FMODE_PWRITE)
 			ret = vfs_write(f.file, buf, count, &pos);
 		fdput(f);
 	}
diff --git a/include/asm-generic/bitops/non-atomic.h b/include/asm-generic/bitops/non-atomic.h
index 697cc2b7e0f0..a16b4c09b726 100644
--- a/include/asm-generic/bitops/non-atomic.h
+++ b/include/asm-generic/bitops/non-atomic.h
@@ -3,6 +3,10 @@
 
 #include <asm/types.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#endif
+
 /**
  * __set_bit - Set a bit in memory
  * @nr: the bit to set
@@ -102,6 +106,11 @@ static inline int __test_and_change_bit(int nr,
  */
 static inline int test_bit(int nr, const volatile unsigned long *addr)
 {
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	GSMPBSPPRINTK("\t<%d> %s():\n", smp_processor_id(), __func__);
+#endif
+#endif
 	return 1UL & (addr[BIT_WORD(nr)] >> (nr & (BITS_PER_LONG-1)));
 }
 
diff --git a/include/asm-generic/page.h b/include/asm-generic/page.h
index 37d1fe28960a..0f6199ba5a7c 100644
--- a/include/asm-generic/page.h
+++ b/include/asm-generic/page.h
@@ -44,7 +44,9 @@ typedef struct {
 } pmd_t;
 typedef struct {
 	unsigned long pgd;
-} pgd_t;
+} pgd_t; 123456789 /* NOT USED */
+//} __attribute__((__aligned__(16))) pgd_t;
+
 typedef struct {
 	unsigned long pgprot;
 } pgprot_t;
diff --git a/include/asm-generic/pgtable-nopud.h b/include/asm-generic/pgtable-nopud.h
index 810431d8351b..afe451328ed8 100644
--- a/include/asm-generic/pgtable-nopud.h
+++ b/include/asm-generic/pgtable-nopud.h
@@ -11,6 +11,8 @@
  * without casting.
  */
 typedef struct { pgd_t pgd; } pud_t;
+//typedef struct { pgd_t pgd; } __attribute__((__aligned__(16))) pud_t;
+//typedef struct { pgd_t __attribute__((__aligned__(4096))) pgd; } pud_t;
 
 #define PUD_SHIFT	PGDIR_SHIFT
 #define PTRS_PER_PUD	1
diff --git a/include/linux/anon_inodes.h b/include/linux/anon_inodes.h
index 8013a45242fe..f9c56db6e9a9 100644
--- a/include/linux/anon_inodes.h
+++ b/include/linux/anon_inodes.h
@@ -15,6 +15,9 @@ struct file *anon_inode_getfile(const char *name,
 				void *priv, int flags);
 int anon_inode_getfd(const char *name, const struct file_operations *fops,
 		     void *priv, int flags);
-
+#ifdef CONFIG_POPCORN_HYPE
+int anon_inode_getfd_tsk(struct task_struct *tsk, const char *name,
+				const struct file_operations *fops, void *priv, int flags);
+#endif
 #endif /* _LINUX_ANON_INODES_H */
 
diff --git a/include/linux/file.h b/include/linux/file.h
index f87d30882a24..9857a2fa092e 100644
--- a/include/linux/file.h
+++ b/include/linux/file.h
@@ -9,6 +9,10 @@
 #include <linux/types.h>
 #include <linux/posix_types.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <linux/sched.h>
+#endif
+
 struct file;
 
 extern void fput(struct file *);
@@ -67,8 +71,17 @@ extern bool get_close_on_exec(unsigned int fd);
 extern void put_filp(struct file *);
 extern int get_unused_fd_flags(unsigned flags);
 extern void put_unused_fd(unsigned int fd);
+//#ifdef CONFIG_POPCORN_HYPE /* Commented for supporting Vanilla */
+extern int get_unused_fd_flags_tsk(struct task_struct *tsk, unsigned flags);
+extern void put_unused_fd_tsk(struct task_struct *tsk, unsigned int fd);
+//#endif
 
 extern void fd_install(unsigned int fd, struct file *file);
+#ifdef CONFIG_POPCORN_HYPE
+extern void fd_install_tsk(struct task_struct *tsk, unsigned int fd, struct file *file);
+//extern unsigned long fget_light_tsk(struct task_struct *tsk, unsigned int fd, fmode_t mask);
+unsigned long fget_light_tsk(struct task_struct *tsk, unsigned int fd, fmode_t mask);
+#endif
 
 extern void flush_delayed_fput(void);
 extern void __fput_sync(struct file *);
diff --git a/include/linux/fs.h b/include/linux/fs.h
index da79e9d66e5b..4457bb19ca99 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2268,6 +2268,10 @@ extern struct filename *getname(const char __user *);
 extern struct filename *getname_kernel(const char *);
 extern void putname(struct filename *name);
 
+#ifdef CONFIG_POPCORN_HYPE
+extern long do_sys_open_tsk_req(struct task_struct *, int, char *, int, umode_t, int);
+#endif
+
 enum {
 	FILE_CREATED = 1,
 	FILE_OPENED = 2
@@ -3069,4 +3073,14 @@ static inline bool dir_relax(struct inode *inode)
 extern bool path_noexec(const struct path *path);
 extern void inode_nohighmem(struct inode *inode);
 
+/* FD migration is not considered in Pophype but it's needed in Pophype */
+//#ifdef CONFIG_POPCORN_HYPE
+//extern long jack_open(int dfd, const char *filename, int flags, umode_t mode, loff_t pos, struct task_struct* task);
+extern int jack_traverse_thread_files(struct task_struct* task, int debug, int load);
+extern void jack_do_file_migration(struct task_struct* task);
+
+/* delegate rw */
+ssize_t do_tsk_delegate_rw(struct task_struct *tsk, unsigned int fd, char *buf, size_t count, bool is_read);
+//#endif
+
 #endif /* _LINUX_FS_H */
diff --git a/include/linux/hrtimer.h b/include/linux/hrtimer.h
index 2ead22dd74a0..b1f3c58972f9 100644
--- a/include/linux/hrtimer.h
+++ b/include/linux/hrtimer.h
@@ -24,6 +24,8 @@
 #include <linux/timer.h>
 #include <linux/timerqueue.h>
 
+//#include <popcorn/debug.h> /* pophype - cannot compile */
+
 struct hrtimer_clock_base;
 struct hrtimer_cpu_base;
 
@@ -204,7 +206,13 @@ struct hrtimer_cpu_base {
 	unsigned int			max_hang_time;
 #endif
 	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];
-} ____cacheline_aligned;
+//} ____cacheline_aligned;
+} __attribute__((aligned(PAGE_SIZE))); /* pophype - dsm traffic */
+//#if !GUEST_KERNEL_OPTIMIZE
+//} ____cacheline_aligned;
+//#else
+//} __attribute__((aligned(PAGE_SIZE))); /* pophype - dsm traffic */
+//#endif
 
 static inline void hrtimer_set_expires(struct hrtimer *timer, ktime_t time)
 {
diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index ad16809c8596..cb514fad80ae 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -19,6 +19,8 @@
 #include <asm/ptrace.h>
 #include <asm/irq.h>
 
+//#include <popcorn/debug.h>
+
 /*
  * These correspond to the IORESOURCE_IRQ_* defines in
  * linux/ioport.h to select the interrupt line behaviour.  When
@@ -134,6 +136,11 @@ static inline int __must_check
 request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
 	    const char *name, void *dev)
 {
+#ifdef CONFIG_POPCORN_HYPE
+//    IRQINITPK("[pophype irq] %s(): cpu<-gic<-[2nd level] "
+//			"irq %u name \"%s\" handler %p flags 0x%lu\n",
+//						__func__, irq, name, handler, flags);
+#endif
 	return request_threaded_irq(irq, handler, NULL, flags, name, dev);
 }
 
diff --git a/include/linux/jiffies.h b/include/linux/jiffies.h
index 2fb10601febe..f88b996ec665 100644
--- a/include/linux/jiffies.h
+++ b/include/linux/jiffies.h
@@ -75,6 +75,8 @@ extern int register_refined_jiffies(long clock_tick_rate);
  */
 extern u64 __cacheline_aligned_in_smp jiffies_64;
 extern unsigned long volatile __cacheline_aligned_in_smp __jiffy_arch_data jiffies;
+//extern u64 __attribute__((__aligned__(PAGE_SIZE))) __jiffy_arch_data jiffies_64; /* pophype */
+//extern unsigned long volatile __attribute__((__aligned__(PAGE_SIZE))) __jiffy_arch_data jiffies; /* pophype */
 
 #if (BITS_PER_LONG < 64)
 u64 get_jiffies_64(void);
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index d7ce4e3280db..3ebd781cebb4 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -34,6 +34,8 @@
 
 #include <asm/kvm_host.h>
 
+#include <popcorn/debug.h>
+
 /*
  * The bit 16 ~ bit 31 of kvm_memory_region::flags are internally used
  * in kvm, other bits are visible for userspace which are defined in
@@ -143,6 +145,9 @@ static inline bool is_error_page(struct page *page)
 #define KVM_REQ_HV_CRASH          27
 #define KVM_REQ_IOAPIC_EOI_EXIT   28
 #define KVM_REQ_HV_RESET          29
+#ifdef CONFIG_POPCORN_HYPE
+#define KVM_REQ_VCPU_MIGRATION    30
+#endif
 
 #define KVM_USERSPACE_IRQ_SOURCE_ID		0
 #define KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID	1
@@ -229,6 +234,10 @@ struct kvm_vcpu {
 #endif
 	int cpu;
 	int vcpu_id;
+#ifdef CONFIG_POPCORN_HYPE
+	int nid;
+	unsigned long vaddr;
+#endif
 	int srcu_idx;
 	int mode;
 	unsigned long requests;
@@ -282,7 +291,13 @@ struct kvm_vcpu {
 #endif
 	bool preempted;
 	struct kvm_vcpu_arch arch;
+////};
+//} __attribute__((aligned(PAGE_SIZE))); /* pophype - dsm traffic */
+#if !GUEST_KERNEL_OPTIMIZE
 };
+#else
+} __attribute__((aligned(PAGE_SIZE))); /* pophype - dsm traffic */
+#endif
 
 static inline int kvm_vcpu_exiting_guest_mode(struct kvm_vcpu *vcpu)
 {
@@ -465,6 +480,10 @@ static inline struct kvm_vcpu *kvm_get_vcpu_by_id(struct kvm *kvm, int id)
 	struct kvm_vcpu *vcpu;
 	int i;
 
+#ifdef CONFIG_POPCORN_HYPE
+	printk("\t\tkvm %p %d", kvm, id);
+#endif
+
 	kvm_for_each_vcpu(i, vcpu, kvm)
 		if (vcpu->vcpu_id == id)
 			return vcpu;
@@ -482,6 +501,10 @@ void kvm_vcpu_uninit(struct kvm_vcpu *vcpu);
 int __must_check vcpu_load(struct kvm_vcpu *vcpu);
 void vcpu_put(struct kvm_vcpu *vcpu);
 
+#ifdef CONFIG_POPCORN_HYPE
+int replay_kvm_dev_ioctl_create_vm_tsk(struct task_struct *tsk, unsigned long type);
+#endif
+
 #ifdef __KVM_HAVE_IOAPIC
 void kvm_vcpu_request_scan_ioapic(struct kvm *kvm);
 void kvm_arch_irq_routing_update(struct kvm *kvm);
@@ -529,6 +552,22 @@ static inline struct kvm_memslots *kvm_memslots(struct kvm *kvm)
 static inline struct kvm_memslots *kvm_vcpu_memslots(struct kvm_vcpu *vcpu)
 {
 	int as_id = kvm_arch_vcpu_memslots_id(vcpu);
+#ifdef CONFIG_POPCORN_HYPE
+	if (current->at_remote || vcpu->vcpu_id) {
+//		EPTVPRINTK("%s(): <%d> as_id %d cpus %d flags %x [0] %p %d [1] %p %d\n",
+//							__func__, vcpu->vcpu_id, as_id,
+//							atomic_read(&vcpu->kvm->online_vcpus),
+//							vcpu->arch.hflags,
+//									vcpu->kvm->memslots[0],
+//										vcpu->kvm->memslots[0]->used_slots,
+//									vcpu->kvm->memslots[1],
+//										vcpu->kvm->memslots[1]->used_slots);
+
+//		printk("%s(): <%d> HACKING!!!!\n",
+//						__func__, vcpu->vcpu_id);
+//		return vcpu->kvm->memslots[as_id];
+	}
+#endif
 
 	return __kvm_memslots(vcpu->kvm, as_id);
 }
@@ -598,6 +637,10 @@ unsigned long gfn_to_hva_prot(struct kvm *kvm, gfn_t gfn, bool *writable);
 unsigned long gfn_to_hva_memslot(struct kvm_memory_slot *slot, gfn_t gfn);
 unsigned long gfn_to_hva_memslot_prot(struct kvm_memory_slot *slot, gfn_t gfn,
 				      bool *writable);
+#ifdef CONFIG_POPCORN_HYPE
+unsigned long gfn_to_hva_many_pub(struct kvm_memory_slot *slot, gfn_t gfn,
+									gfn_t *nr_pages, bool write);
+#endif
 void kvm_release_page_clean(struct page *page);
 void kvm_release_page_dirty(struct page *page);
 void kvm_set_page_accessed(struct page *page);
@@ -921,6 +964,27 @@ search_memslots(struct kvm_memslots *slots, gfn_t gfn)
 	int slot = atomic_read(&slots->lru_slot);
 	struct kvm_memory_slot *memslots = slots->memslots;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (gfn == 0x99) {
+		EPTVPRINTK("%s(): slots %p used_slots(end) %d "
+				"memslots %p base_gfn[%d] %llx %lx\n",
+				__func__, slots, slots->used_slots, memslots, slot,
+								memslots?memslots[slot].base_gfn:0,
+								memslots?memslots[slot].npages:0);
+
+		/* dbg info */
+		{	int i;
+			for (i = 0; i < slots->used_slots; i++) {
+				DDPRINTK("%s(): base_gfn[%d/%d] base %llx pgs %lx uaddr %lx\n",
+									__func__, i, slots->used_slots - 1,
+													memslots[i].base_gfn,
+													memslots[i].npages,
+													memslots[i].userspace_addr);
+			}
+		}
+	}
+#endif
+
 	if (gfn >= memslots[slot].base_gfn &&
 	    gfn < memslots[slot].base_gfn + memslots[slot].npages)
 		return &memslots[slot];
@@ -939,6 +1003,13 @@ search_memslots(struct kvm_memslots *slots, gfn_t gfn)
 		atomic_set(&slots->lru_slot, start);
 		return &memslots[start];
 	}
+#ifdef CONFIG_POPCORN_HYPE
+	if (gfn == 0x99) {
+		EPTVPRINTK("%s(): slots %p memslots %p base_gfn %llx [[[[[[FAIL]]]]]]\n",
+								__func__, slots, memslots,
+						 memslots?memslots[slot].base_gfn:0);
+	}
+#endif
 
 	return NULL;
 }
@@ -1013,7 +1084,7 @@ extern struct dentry *kvm_debugfs_dir;
 static inline int mmu_notifier_retry(struct kvm *kvm, unsigned long mmu_seq)
 {
 	if (unlikely(kvm->mmu_notifier_count))
-		return 1;
+		return 1; /* RETRY */
 	/*
 	 * Ensure the read of mmu_notifier_count happens before the read
 	 * of mmu_notifier_seq.  This interacts with the smp_wmb() in
@@ -1026,8 +1097,8 @@ static inline int mmu_notifier_retry(struct kvm *kvm, unsigned long mmu_seq)
 	 */
 	smp_rmb();
 	if (kvm->mmu_notifier_seq != mmu_seq)
-		return 1;
-	return 0;
+		return 1; /* RETRY */
+	return 0; /* GOOD */
 }
 #endif
 
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 82bc061460fc..e69b24fa0342 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1046,6 +1046,9 @@ static inline void clear_page_pfmemalloc(struct page *page)
 #ifdef CONFIG_POPCORN
 #define VM_FAULT_CONTINUE	0x1000
 #define VM_FAULT_KILLED		0x2000
+#ifdef CONFIG_POPCORN_HYPE
+#define VM_FAULT_HYPE_RETRY	0x4000	/* hype retry - one level above other faulting reasons */
+#endif
 #endif
 
 #define VM_FAULT_ERROR	(VM_FAULT_OOM | VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV | \
diff --git a/include/linux/mmu_notifier.h b/include/linux/mmu_notifier.h
index 38c5eb21883e..116c553eb5d1 100644
--- a/include/linux/mmu_notifier.h
+++ b/include/linux/mmu_notifier.h
@@ -6,6 +6,11 @@
 #include <linux/mm_types.h>
 #include <linux/srcu.h>
 
+
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/types.h>
+#endif
+
 struct mmu_notifier;
 struct mmu_notifier_ops;
 
@@ -271,8 +276,15 @@ static inline void mmu_notifier_change_pte(struct mm_struct *mm,
 static inline void mmu_notifier_invalidate_page(struct mm_struct *mm,
 					  unsigned long address)
 {
-	if (mm_has_notifiers(mm))
+	if (mm_has_notifiers(mm)) {
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+		//if (distributed_process(current)) { /* BUG current is msg_handler !!!! */
+		//	//trace_kvm_ept_retry(0, address);
+		//}
+		/* (USED) */
+#endif
 		__mmu_notifier_invalidate_page(mm, address);
+	}
 }
 
 static inline void mmu_notifier_invalidate_range_start(struct mm_struct *mm,
@@ -432,6 +444,18 @@ static inline void mmu_notifier_change_pte(struct mm_struct *mm,
 static inline void mmu_notifier_invalidate_page(struct mm_struct *mm,
 					  unsigned long address)
 {
+#if defined(CONFIG_POPCORN_HYPE)
+	// BUG_ON("we are not");
+#endif
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+//	if (distributed_process(current)) {
+		static int cnt_all = 0;
+		cnt_all++;
+		//if (cnt_all < 100)
+			printk("%s(): OMG bad place. checking how to explain cnt_all#%d\n",
+													__func__, cnt_all);
+//	}
+#endif
 }
 
 static inline void mmu_notifier_invalidate_range_start(struct mm_struct *mm,
diff --git a/include/linux/percpu-defs.h b/include/linux/percpu-defs.h
index 8902f23bb770..ff778c7b7332 100644
--- a/include/linux/percpu-defs.h
+++ b/include/linux/percpu-defs.h
@@ -117,15 +117,23 @@
  */
 #define DECLARE_PER_CPU(type, name)					\
 	DECLARE_PER_CPU_SECTION(type, name, "")
+/*	DECLARE_PER_CPU_SECTION(type, name, "..page_aligned")		\
+	__aligned(PAGE_SIZE) // pophype */
 
 #define DEFINE_PER_CPU(type, name)					\
 	DEFINE_PER_CPU_SECTION(type, name, "")
+/*	DEFINE_PER_CPU_SECTION(type, name, "..page_aligned")		\
+	__aligned(PAGE_SIZE) // pophype */
 
 #define DECLARE_PER_CPU_USER_MAPPED(type, name)				\
 	DECLARE_PER_CPU_SECTION(type, name, USER_MAPPED_SECTION)
+/*	DECLARE_PER_CPU_SECTION(type, name, USER_MAPPED_SECTION"..page_aligned") \
+	__aligned(PAGE_SIZE) // pophype */
 
 #define DEFINE_PER_CPU_USER_MAPPED(type, name)				\
 	DEFINE_PER_CPU_SECTION(type, name, USER_MAPPED_SECTION)
+/*	DEFINE_PER_CPU_SECTION(type, name, USER_MAPPED_SECTION"..page_aligned") \
+	__aligned(PAGE_SIZE) // pophype */
 
 /*
  * Declaration/definition used for per-CPU variables that must come first in
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 5fb63fabc903..c9e16e081e04 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -64,6 +64,9 @@ struct sched_param {
 
 #define SCHED_ATTR_SIZE_VER0	48	/* sizeof first published struct */
 
+#ifdef CONFIG_POPCORN_HYPE
+//#include <popcorn/hype_kvm.h>
+#endif
 /*
  * Extended scheduling parameters data structure.
  *
@@ -1388,6 +1391,19 @@ struct tlbflush_unmap_batch {
 	bool writable;
 };
 
+//#ifdef CONFIG_POPCORN_HYPE /* Commented for supporting Vanilla - fs/open.c */
+//#include <popcorn/hype_kvm.h>
+#define _MAX_POPCORN_FD 50
+/* saif added to hold info about the remote threads */
+typedef struct task_file_data {
+    char file_name[256];
+    unsigned int f_flags;
+    fmode_t f_mode;
+    off_t f_pos;
+    pid_t f_owner_pid;
+} remote_file_info_t;
+//#endif
+
 struct task_struct {
 	volatile long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
 	void *stack;
@@ -1853,6 +1869,7 @@ struct task_struct {
 
 	int migration_target_nid;
 	int backoff_weight;
+	int is_backoff;
 
 #ifdef CONFIG_POPCORN_STAT_PGFAULTS
 	unsigned long fault_address;
@@ -1860,6 +1877,10 @@ struct task_struct {
 	ktime_t fault_start;
 #endif
 
+//#ifdef CONFIG_POPCORN_HYPE /* Commented for supporting Vanilla - fs/open.c */
+    remote_file_info_t *fake_file_table[_MAX_POPCORN_FD]; // # of opened files for a process supported
+//#endif
+
 	/*
 	 * scheduling -- antoniob
 	 * in jiffies for load accounting
diff --git a/include/linux/slab.h b/include/linux/slab.h
index 8a2a9ffaf5de..c5c69dd9908b 100644
--- a/include/linux/slab.h
+++ b/include/linux/slab.h
@@ -15,6 +15,7 @@
 #include <linux/types.h>
 #include <linux/workqueue.h>
 
+#include <popcorn/debug.h>
 
 /*
  * Flags to pass to kmem_cache_create().
@@ -460,7 +461,39 @@ static __always_inline void *kmalloc(size_t size, gfp_t flags)
 		}
 #endif
 	}
+#ifdef CONFIG_POPCORN_HYPE
+	{
+		void *tmp = __kmalloc(size, flags);
+#if HYPE_PERF_CRITICAL_DEBUG //&& defined(CONFIG_POPCORN_STAT)
+		int i;
+		unsigned long target_addr[] = { 0xffff88012b105000,
+										0xffff88012b106000,
+										0xffff88012b10c000,
+										0xffff88012a413000,
+										0xffff88012b016000,
+										0xffff88012ffff000,
+										0xffff88012fc14000 }; /* kvaadr */
+		for (i = 0; i < ARRAY_SIZE(target_addr); i++) {
+			if (target_addr[i] >= (unsigned long)tmp &&
+				target_addr[i] < (unsigned long)tmp + size) {
+				static unsigned int cnt = 0;
+				cnt++;
+				POP_PK("\n\npophype: got you #%u: "
+						"target_addr[] = 0x%lx %p ~ 0x%lx\n\n",
+						cnt, target_addr[i], tmp, (unsigned long)tmp + size);
+				dump_stack();
+				printk("\n\n\n");
+			}
+		}
+#endif
+		return tmp;
+	}
+//#else
+//	return __kmalloc(size, flags);
+//#endif
+#else
 	return __kmalloc(size, flags);
+#endif
 }
 
 /*
diff --git a/include/linux/smp.h b/include/linux/smp.h
index c4414074bd88..f0d64b196fc5 100644
--- a/include/linux/smp.h
+++ b/include/linux/smp.h
@@ -196,4 +196,9 @@ extern void arch_enable_nonboot_cpus_end(void);
 
 void smp_setup_processor_id(void);
 
+#ifdef CONFIG_POPCORN_HYPE
+void popcorn_hype_faultaddr_test(bool is_bsp);
+void ssleep_at_ap(int seconds);
+void cpu_sleep_almost_forever(int cpu);
+#endif
 #endif /* __LINUX_SMP_H */
diff --git a/include/linux/smpboot.h b/include/linux/smpboot.h
index 12910cf19869..9b302f414200 100644
--- a/include/linux/smpboot.h
+++ b/include/linux/smpboot.h
@@ -57,5 +57,7 @@ smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)
 void smpboot_unregister_percpu_thread(struct smp_hotplug_thread *plug_thread);
 int smpboot_update_cpumask_percpu_thread(struct smp_hotplug_thread *plug_thread,
 					 const struct cpumask *);
-
+#ifdef CONFIG_POPCORN_HYPE
+void popcorn_hype_check_remote_cpus(void);
+#endif
 #endif
diff --git a/include/linux/socket.h b/include/linux/socket.h
index 5bf59c8493b7..b1452ff4fec3 100644
--- a/include/linux/socket.h
+++ b/include/linux/socket.h
@@ -25,7 +25,7 @@ typedef __kernel_sa_family_t	sa_family_t;
 /*
  *	1003.1g requires sa_family_t and that sa_data is char.
  */
- 
+
 struct sockaddr {
 	sa_family_t	sa_family;	/* address family, AF_xxx	*/
 	char		sa_data[14];	/* 14 bytes of protocol address	*/
@@ -43,7 +43,7 @@ struct linger {
  *	system, not 4.3. Thus msg_accrights(len) are now missing. They
  *	belong in an obscure libc emulation or the bin.
  */
- 
+
 struct msghdr {
 	void		*msg_name;	/* ptr to socket address structure */
 	int		msg_namelen;	/* size of socket address structure */
@@ -53,7 +53,76 @@ struct msghdr {
 	unsigned int	msg_flags;	/* flags on received message */
 	struct kiocb	*msg_iocb;	/* ptr to iocb for async requests */
 };
- 
+
+/* Pophype - in order to write to const on the target node (origin) */
+//struct kernel_iovec
+//{
+//    void *iov_base;  /* BSD uses caddr_t (1003.1g requires void *) */
+//    __kernel_size_t iov_len; /* Must be size_t (1003.1g) */
+//};
+struct kernel_iov_iter {
+    int type;
+    size_t iov_offset;
+    size_t count;
+	//struct kernel_iovec *iov;
+	struct kvec *iov;
+    unsigned long nr_segs;
+};
+
+struct kernel_msghdr {
+	void		*msg_name;	/* ptr to socket address structure */
+	int		msg_namelen;	/* size of socket address structure */
+	struct kernel_iov_iter	msg_iter;	/* data */
+	void		*msg_control;	/* ancillary data */
+	__kernel_size_t	msg_controllen;	/* ancillary data buffer length */
+	unsigned int	msg_flags;	/* flags on received message */
+	struct kiocb	*msg_iocb;	/* ptr to iocb for async requests */
+};
+//struct iov_iter {
+//    int type;
+//    size_t iov_offset;
+//    size_t count;
+//    union {
+//        const struct iovec *iov;
+//        const struct kvec *kvec;
+//        const struct bio_vec *bvec;
+//    };
+//    unsigned long nr_segs;
+//};
+//
+//struct iovec
+//{
+//    void __user *iov_base;  /* BSD uses caddr_t (1003.1g requires void *) */
+//    __kernel_size_t iov_len; /* Must be size_t (1003.1g) */
+//};
+//struct kvec {
+//	void *iov_base; /* and that should *never* hold a userland pointer */
+//	size_t iov_len;
+//};
+
+//#define POPHYPE_MSGHDR_BUF_SIZE PAGE_SIZE
+//#define POPHYPE_MSGHDR_BUF_SIZE 2048
+#define POPHYPE_MSGHDR_BUF_SIZE 1024
+struct pophype_msghdr {
+	char msg_name[128];
+	int msg_namelen; //128
+	int msg_flags;
+
+	/* struct iov_iter msg_iter;   // data */
+    int type;
+    size_t iov_offset;
+    size_t count;
+	unsigned long nr_segs;
+
+	/* iovec */
+	__kernel_size_t iov_len;
+	char iov_base[POPHYPE_MSGHDR_BUF_SIZE];
+
+	//void        *msg_control;   /* ancillary data */
+	//__kernel_size_t msg_controllen; /* ancillary data buffer length */
+	//struct kiocb    *msg_iocb;
+};
+
 struct user_msghdr {
 	void		__user *msg_name;	/* ptr to socket address structure */
 	int		msg_namelen;		/* size of socket address structure */
@@ -121,7 +190,7 @@ struct cmsghdr {
  *	inside range, given by msg->msg_controllen before using
  *	ancillary object DATA.				--ANK (980731)
  */
- 
+
 static inline struct cmsghdr * __cmsg_nxthdr(void *__ctl, __kernel_size_t __size,
 					       struct cmsghdr *__cmsg)
 {
@@ -251,10 +320,10 @@ struct ucred {
 /* Maximum queue length specifiable by listen.  */
 #define SOMAXCONN	128
 
-/* Flags we can use with send/ and recv. 
+/* Flags we can use with send/ and recv.
    Added those for 1003.1g not all are supported yet
  */
- 
+
 #define MSG_OOB		1
 #define MSG_PEEK	2
 #define MSG_DONTROUTE	4
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index 163ced4dc0f1..67b82892ea15 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -895,5 +895,14 @@ asmlinkage long sys_popcorn_migrate(int nid, void __user *uregs);
 asmlinkage long sys_popcorn_propose_migration(pid_t pid, int nid);
 asmlinkage long sys_popcorn_get_thread_status(struct popcorn_thread_status __user *status);
 asmlinkage long sys_popcorn_get_node_info(int * __user _my_nid, struct popcorn_node_info __user *info);
+asmlinkage long sys_popcorn_broadcast_cpu_table(int *nid);
+asmlinkage long sys_popcorn_false_share(int notused);
+asmlinkage long sys_popcorn_true_share(int *notused);
+asmlinkage long sys_popcorn_no_share(int notused);
+asmlinkage long sys_pophype_migrate(int a0, int a1); // vm
+asmlinkage long sys_pophype_migrate_on_hostusr(int vcpu_id);
+asmlinkage long sys_pophype_remote_checkin_vcpu_pid(int pid);
+asmlinkage long sys_pophype_vcpu_migrate_trigger(int vcpu_id);
+asmlinkage long sys_pophype_origin_checkin_vcpu_pid(int from_nid);
 
 #endif
diff --git a/include/popcorn/bundle.h b/include/popcorn/bundle.h
index 515b07a4faef..b8a4c65c8039 100644
--- a/include/popcorn/bundle.h
+++ b/include/popcorn/bundle.h
@@ -6,6 +6,10 @@
 #error Currently support up to 62 nodes
 #endif
 
+#if defined(CONFIG_POPCORN_HYPE)
+#define POPHYPE_MIGRATE_BACK -78
+#endif
+
 enum popcorn_arch {
 	POPCORN_ARCH_UNKNOWN = -1,
 	POPCORN_ARCH_ARM = 0,
@@ -24,6 +28,8 @@ int get_popcorn_node_arch(int nid);
 
 void broadcast_my_node_info(int nr_nodes);
 
+int get_popcorn_nodes(void);
+
 int popcorn_nodes_init(void);
 
 struct popcorn_thread_status {
diff --git a/include/popcorn/debug.h b/include/popcorn/debug.h
index 857b9bf13b5f..b86d5b644140 100644
--- a/include/popcorn/debug.h
+++ b/include/popcorn/debug.h
@@ -1,6 +1,16 @@
 #ifndef __INCLUDE_POPCORN_DEBUG_H__
 #define __INCLUDE_POPCORN_DEBUG_H__
 
+#include <linux/kernel.h>
+#include <linux/module.h>
+//#include <linux/delay.h>
+#include <linux/init.h>
+//#include <linux/dmi.h>
+#include <linux/io.h>
+
+#define MICROSECOND 1000000
+
+
 #define PCNPRINTK(...) printk(KERN_INFO "popcorn: " __VA_ARGS__)
 #define PCNPRINTK_ERR(...) printk(KERN_ERR "popcorn: " __VA_ARGS__)
 
@@ -41,4 +51,718 @@
 #define MSGPRINTK(...)
 #endif
 
+
+#ifdef CONFIG_POPCORN_DEBUG_HYPE
+#define HPPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#else
+#define HPPRINTK(...) ;
+#endif
+
+
+#ifdef CONFIG_POPCORN_DEBUG_HYPE_EPT
+#define EPTPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#else
+#define EPTPRINTK(...) ;
+#endif
+
+#ifdef CONFIG_POPCORN_DEBUG_HYPE_EPT_MORE
+#define EPTMPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#else
+#define EPTMPRINTK(...) ;
+#endif
+
+/* usable */
+#ifdef CONFIG_POPCORN_DEBUG_HYPE_EPT_VERBOSE
+#define EPTVPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#else
+#define EPTVPRINTK(...) ;
+#endif
+
+/* TODO */
+#define EPTVVPRINTK(...) ;
+
+#ifdef CONFIG_POPCORN_DEBUG_DEBUG
+#define DDPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#else
+#define DDPRINTK(...) ;
+#endif
+
+/*************** THE ONLY IMPORTANT TUNNING KNOBS IN THIS FILE **************/
+/* CHECK make menuconfig for other printks */
+#define PERF_EXP 1 /* 0: development 1: get # */
+/* pophype DSM debug - check bool pophype_debug in page_server.c */
+
+#define GUEST_KERNEL_OPTIMIZE 1 /* search "pophype - dsm traffic" to find them */
+/* ATTENTION: manually check these files since it cannot include <popcorn/debug.h>
+ * ./arch/x86/include/asm/pvclock-abi.h - sturct pvclock_vcpu_time_info {} // AB suggests to only change this
+ * ./include/linux/hrtimer.h - struct hrtimer_cpu_base {}
+ *
+ * For our convinice to test them one by one
+ * ./arch/x86/kvm/vmx.c - EPT_AD
+ * ./arch/x86/kernel/pvclock.c - last_value alignment
+ */
+
+#define GUEST_KERNEL_OPTIMIZE_EPT_AD 1
+
+//#define EPT_RETRY_VM_OPTIMIZE 0 /* under developemnt - make sure this is 0 when collecting #s */
+#define EPT_RETRY_VM_OPTIMIZE 1 /* under developemnt - make sure this is 0 when collecting #s - retry in tdp_page_fault() */ // dbg
+
+/* Other important tunable parameters
+ *	- HANDLE_NET_MSI at ./arch/x86/kvm/lapic.c
+ */
+
+
+
+
+
+/* TODO: remove msleep() in int __init shmem_init(void) and more...
+ * 	_cpu_up();
+ */
+
+/* TODO clean run/fast boot (no printk) */
+
+/* Give me a clean pophype (0 printk) -
+	used only when getting init time */
+#define POP_CLEAN 1 /* Make sure CONFIG_POPCORN_STAT off */
+#if POP_CLEAN
+/* essential debug messages -
+	turn off only if measuring init time */
+#define KVMCLOCKPK(...) ;
+//#define KVMCLOCKPK(...) printk(KERN_INFO __VA_ARGS__); // debug kvm-clock
+#define POP_PK(...) ;
+//#define POP_PK(...) printk(KERN_INFO __VA_ARGS__); // watchout: may not boot
+#else
+#define KVMCLOCKPK(...) printk(KERN_INFO __VA_ARGS__);
+#define POP_PK(...) printk(KERN_INFO __VA_ARGS__);
+#endif
+
+/* init time - always on */
+#define POP_INIT_TIME 1
+#define POP_INIT_TIME_PK(...) printk(KERN_INFO __VA_ARGS__);
+
+/* 1st version network optimization (not working) */
+#define POPHYPE_NET_OPTIMIZE 0 //rely on POPHYPE_HOST_KERNEL
+#define POPHYPE_NET_OPTIMIZE_TMP_DEBUG 0 // temporary debugging info for optimizing network
+#define POP_NET_PK_TMP(...) ; // printk(KERN_INFO __VA_ARGS__)
+
+/* mq debug */
+#define POPCORN_STAT_MQ_INFO 0
+
+/* ft debug */
+#define POPCORN_DEBUG_FT 0
+
+
+/****
+ * Exceptions need your attention
+ */
+/* Happens when ramdisk is to large and relocated to a new region -
+ * this printk will print forever */
+#define MMIOPK(...) printk(KERN_INFO __VA_ARGS__);
+
+/* Performace critial
+	- DSMPATCHPK - compromise with dsm shortage (can only support 1 pg at a time)
+ */
+#if PERF_EXP
+#define CRITICALNETPK(...) ;
+#define CRITICALIOPK(...) ;
+#define CRITICALALLPK(...) ;
+#define DSMPATCHPK(...) ;
+#define POPHYPE_DEBUG_ADDR 0
+#else
+#define POPHYPE_DEBUG_ADDR 1
+#define CRITICALNETPK(...) printk(KERN_INFO __VA_ARGS__) /* guest has (not debugging now) */
+//#define CRITICALNETPK(...) ;
+#define CRITICALIOPK(...) printk(KERN_INFO __VA_ARGS__)
+#define CRITICALALLPK(...) printk(KERN_INFO __VA_ARGS__)
+//#define DSMPATCHPK(...) printk(KERN_INFO __VA_ARGS__) /* DSM NET PATCH (!handle < 1 pg) */
+#define DSMPATCHPK(...) ;
+#endif
+
+
+#if PERF_EXP
+#define HYPE_PERF_CRITICAL_DEBUG 0 /* This will turn on debug msg and harm the performance */
+#define HYPE_PERF_CRITICAL_IPI_DEBUG 0
+#define HYPE_PERF_CRITICAL_DSM_TRAFFIC_DEBUG 0
+#define HYPE_PERF_CRITICAL_DSM_TRAFFIC_PRINTK 0
+#define HYPE_PERF_DSM_TRAFFIC_PK 0
+#define DSM_COLLECT_PK(...) ;
+//#define VHOSTNET_OPTIMIZE_PK(...) printk(KERN_INFO __VA_ARGS__)
+#define VHOSTNET_OPTIMIZE_PK(...) ;
+#define HYPE_PERF_CRITICAL_MSG_DEBUG 0 /* msg rb util */
+#define HYPE_PERF_CRITICAL_NET_DEBUG 0 /* net related not used */
+//#define HYPE_KVM_CLOCK_DEBUG 0
+#define HYPE_PERF_NET_DEBUG 0
+#else
+#define HYPE_PERF_CRITICAL_DEBUG 0 /* This will turn on debug msg and harm the performance */
+#define HYPE_PERF_CRITICAL_IPI_DEBUG 0
+#define HYPE_PERF_CRITICAL_DSM_TRAFFIC_DEBUG 1 /* use /proc/popcorn_debug */
+#define HYPE_PERF_CRITICAL_DSM_TRAFFIC_PRINTK 0 /* traslation host addr to guest rip */
+#define HYPE_PERF_DSM_TRAFFIC_PK 1
+#define DSM_COLLECT_PK(...) printk(KERN_INFO __VA_ARGS__)
+#define VHOSTNET_OPTIMIZE_PK(...) printk(KERN_INFO __VA_ARGS__)
+//#define VHOSTNET_OPTIMIZE_PK(...) ;
+//#define DSM_COLLECT_PK(...) ; /* show [new] when collecting or not */
+#define HYPE_PERF_CRITICAL_MSG_DEBUG 0 /* msg rb util */
+#define HYPE_PERF_CRITICAL_NET_DEBUG 0 /* net related not used */
+//#define HYPE_KVM_CLOCK_DEBUG 1
+#define HYPE_PERF_NET_DEBUG 1
+#endif
+
+#if PERF_EXP
+#define VM_DSM_COLLECT_PK(...)
+#else
+#define VM_DSM_COLLECT_PK(...) printk(KERN_INFO __VA_ARGS__) /* vm dsm stack walk*/
+#endif
+
+#define OPENLAMBDA_EXP 1
+/* Not perf critical but system-crash critical -
+	turn off for long runtime init process e.g. openlambda's systemd.
+	If not openlambda/systemd, turn it on since it's not perf critical */
+#if OPENLAMBDA_EXP
+#define IRQINITPK(...) ;
+#else
+#define IRQINITPK(...) printk(KERN_INFO __VA_ARGS__)
+#endif
+
+
+/* Popcorn-hype 1: host 0: guest */
+#define POPHYPE_HOST_KERNEL 1
+#define POPHYPE_GUEST_DEBUG_CPU 1 // going to use
+#define POPHYPE_GUEST_DEBUG_NODE 1 // going to use
+
+/* Pophype + guest + net optimize */
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL && POPHYPE_NET_OPTIMIZE
+#define POPHYPE_GUEST_NET_OPTIMIZE 1
+#else
+#define POPHYPE_GUEST_NET_OPTIMIZE 0
+#endif
+
+
+/* 1: yes 0: not interested in any address */
+#define INTERESTED_ADDRS 1
+
+/* Pophype migration */
+#if PERF_EXP
+#define HPMIGRATION_DEBUG 0
+//#define HPMIGRATION_DEBUG 1 //debug: ft
+#define POPHYPE_MIGRATE_DEBUG 0
+//#define POPHYPE_MIGRATE_DEBUG 1
+#define PHGMIGRATEPRINTK(...)
+//#define PHGMIGRATEPRINTK(...) printk(KERN_INFO __VA_ARGS__) // debug: ft
+#define PHMIGRATEPRINTK(...)
+//#define PHMIGRATEPRINTK(...) printk(KERN_INFO __VA_ARGS__) // debug: ft
+#define FTPRINTK(...)
+#define POPHYPE_MIGRATE_VERBOSE_DEBUG 0
+//#define POPHYPE_MIGRATE_VERBOSE_DEBUG 1 // debug: ft
+#define PHMIGRATEVPRINTK(...)
+
+#define VPCINETPRINTK(...) ;
+#define POPHYPE_APIC_DEBUG 0
+#define PHAPICPRINTK(...)
+#define VCPUPRINTK(...)
+#define PHMSRPRINTK(...)
+#else
+#define HPMIGRATION_DEBUG 1
+#define POPHYPE_MIGRATE_DEBUG 1
+#define PHMIGRATEPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#define PHGMIGRATEPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#define POPHYPE_MIGRATE_VERBOSE_DEBUG 0
+#define PHMIGRATEVPRINTK(...) /* sub pophype migration */
+#define FTPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+
+#define VPCINETPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#define PHAPICPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#define VCPUPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#define POPHYPE_APIC_DEBUG 1
+#define PHMSRPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#endif
+/* PHMIGRATEPRINTK and POPHYPE_MIGRATE_DEBUG include lots vCPU related essential states */
+//TODO: #if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+// 				=> #if defined(CONFIG_POPCORN_HYPE) && POPHYPE_MIGRATE_DEBUG
+
+/* TODO: move PHAPICPRINTK outside to here */
+/* MAKE SURE boot_cmd has no apic_debug */
+
+/* overwrite it for debugging */
+
+/* Pophype migration end */
+
+
+/* Hype-popcorn fine grained debug log (perf-related) too verbose */
+#if PERF_EXP
+#define IPIPRINTK(...) ; /* you usually want this on except doing exp */
+#define IPIVPRINTK(...) ;
+#define SIGVPRINTK(...) ;
+//#define SIGVPRINTK(...) printk(KERN_INFO __VA_ARGS__)  // debug: ft
+#else
+#define IPIPRINTK(...) ; /* periodically */
+#define IPIVPRINTK(...) ;
+//#define IPIPRINTK(...) printk(KERN_INFO __VA_ARGS__) /* you usually want this on except doing exp */
+//#define IPIVPRINTK(...) printk(KERN_INFO __VA_ARGS__) /* cannot boot */
+#define SIGVPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#endif
+
+
+/* Boot time pophype debug msg */
+#if PERF_EXP
+#define HYPEBOOTDBGPRINTK(...) ;
+#define HYPECKPTPRINTK(...) ;
+#define HYPEBOOTDEBUG 1 // debugging
+//#define HYPEBOOTDEBUG 0 /* Speed up boot time */
+#define WRMSRPRINTK(...)
+#else
+#define HYPEBOOTDBGPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#define HYPECKPTPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#define HYPEBOOTDEBUG 1 /* Speed up boot time */
+#define WRMSRPRINTK(...)
+#endif
+
+
+#if POP_CLEAN
+#define IPIINITPRINTK(...) ;
+#define SIPIPRINTK(...) ;
+#define SMPPRINTK(...) ;
+#define SMPBSPPRINTK(...) ;
+#define SMPAPPRINTK(...) ;
+#define APICIRQPRINTK(...) ;
+#define FUTEXPRINTK(...) ;
+#define FDPRINTK(...) ;
+#define VMPRINTK(...) ;
+#define DBGPRINTK(...) ;
+#define UARTPRINTK(...) ;
+#define IRQCHIPPRINTK(...) ;
+#define AFFPRINTK(...) ;
+#define IRQPROCPRINTK(...) ;
+#define LKPRINTK(...) ;
+#define GUPFASTPRINTK(...) ;
+#define DSMRETRYPRINTK(...) ;
+#define NOTIFYCHAINPRINTK(...) ;
+#define VCPUTONIDPRINTK(...) ;
+#define KVMINITRINTK(...) ;
+#define GSMPBSPPRINTK(...) ;
+#define GSMPPRINTK(...) ;
+#define GBSPIPIPRINTK(...) ;
+#define GSMPIPIRESCHEDPRINTK(...) ;
+#else /* else POP_CLEAN*/
+#define IPIINITPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#define SIPIPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#define SMPPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#define SMPBSPPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#define SMPAPPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#define APICIRQPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#define FUTEXPRINTK(...) ;
+#define FDPRINTK(...) ;
+#define VMPRINTK(...) ;
+#define DBGPRINTK(...) ;
+#define UARTPRINTK(...) ;
+#define IRQCHIPPRINTK(...) ;
+#define AFFPRINTK(...) ; // irq affinity for PCI-MSI //not verbose
+//#define AFFPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#define IRQPROCPRINTK(...) ;
+//#define IRQPROCPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+
+/* Lock */
+//#define LKPRINTK(...) printk(KERN_INFO __VA_ARGS__) /* up_read() debug */
+#define LKPRINTK(...) ;
+
+#define GUPFASTPRINTK(...) ;
+#define DSMRETRYPRINTK(...) ;
+//#define NOTIFYCHAINPRINTK(...) printk(KERN_INFO __VA_ARGS__) // for register_cpu_notifier()
+#define NOTIFYCHAINPRINTK(...) ;
+
+/* Super specific debugging */
+#define VCPUTONIDPRINTK(...) ;
+//#define VCPUTONIDPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+
+/* Not perf critical */
+#define KVMINITRINTK(...) printk(KERN_INFO __VA_ARGS__)
+
+/* GEST OS printks */
+//#define GSMPBSPPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#define GSMPBSPPRINTK(...) ; // for gust smp bp //many
+//#define GSMPPRINTK(...) printk(KERN_INFO __VA_ARGS__) // for guest smp
+#define GSMPPRINTK(...) ; // for guest smp
+//#define GBSPIPIPRINTK(...) printk(KERN_INFO __VA_ARGS__) // for ipi in guest e.g. do_nothing(), kick_all_cpus_sync(), smp_call_function_single(), smp_call_function_many()
+#define GBSPIPIPRINTK(...) ;
+#define GSMPIPIRESCHEDPRINTK(...) printk(KERN_INFO __VA_ARGS__) // for ipi-resched in guest
+//#define GSMPIPIRESCHEDPRINTK(...) ; // for ipi-resched in guest
+#endif /*else POP_CLEAN*/
+
+#define DEBUG_VMDSM_TRACE_SKIP_STACK 1
+#define HYPE_VMCALL_DEBUG 0
+#define ENFORCE_TOUCH_USR 0
+#define ENFORCE_TOUCH_KERN 0
+#define ENFORCE_TOUCH_BYTES 10
+
+#define RETRY_FIRST_EPT 1 /* don't go to 2nd __gfn_to_pfn_memslot() / hva_to_pfn() */
+#define DISABLE_WRITABLE_EPT 1 /* in hva_to_pfn_slow() virt/kvm/kvm_main.c */
+#define DISABLE_VANILLA_DIRECT_PTE_PREFETCH 1 /* disable vanilla's direct_ept_prefetch in __direct_map() arch/x86/kvm/mmu.c */
+/* Also check page_server.c HYPE_RETRY */
+
+#define CONFIG_POPCORN_TERMINAL_MIGRATION 1
+
+
+/* Debug */
+#define DEBUG_PREFETCH_EPT 0
+
+/* Hack */
+#define HACK_GUEST_DS_ES_GS_AT_ORIGIN 0 /* doesn't affect*/
+#define HACK_GUEST_EFER 0 /* affected but not helpful */
+
+
+/* Parameters */
+#define HOST_X86_UART 3
+#define GUEST_X86_UART 4
+#define GUEST_X86_NET 25 /* aka PCN-IN */
+#define VM_SINGLE_HANDLE_DISPLAY_CNT 100 /* large = slow */
+
+/*************************************************************************/
+
+/* guesos debugging points */
+//typedef
+enum {
+	HYPE_DEBUG_POINT0,
+	HYPE_DEBUG_POINT1,
+	HYPE_DEBUG_POINT2,
+	HYPE_DEBUG_POINT3,
+	HYPE_DEBUG_POINT4,
+	HYPE_DEBUG_POINT5,
+	HYPE_DEBUG_POINT6,
+	HYPE_DEBUG_POINT7,
+	HYPE_DEBUG_POINT8,
+	HYPE_DEBUG_POINT9,
+	HYPE_DEBUG_POINT10,
+	HYPE_DEBUG_POINT_MAX,
+};
+//hype_callin_enum;
+//extern hype_callin_enum hype_cin_enum;
+
+//0x1a00
+//0x1aff
+// fault addr: 0x3055 0x1c0c 0x1c12
+// serious debugging (more log but long)
+//#define INTERESTED_GVA_LOW  0x1900
+//#define INTERESTED_GVA_HIGH 0x1fff
+// fast debugging (less logfast)
+#define INTERESTED_GVA_LOW  0x1a00
+#define INTERESTED_GVA_HIGH 0x1d00
+
+//#define INTERESTED_GVA_6LOW  0xec1900
+#define INTERESTED_GVA_6LOW  0xec1a00
+#define INTERESTED_GVA_6HIGH 0xec1d00
+//#define (((gva) >> PAGE_SHIFT) & PAGE_MASK0x)
+//#define INTERESTED_BITS PAGE_MASK
+#define INTERESTED_4_BITS 0xffff
+#define INTERESTED_6_BITS 0xffffff
+#define INTERESTED_GVA_MASK(gva) (((gva) >> PAGE_SHIFT) & INTERESTED_4_BITS)
+#define INTERESTED_GFN_MASK(gfn) (((gfn) >> 0) & INTERESTED_4_BITS)
+#define INTERESTED_GVA_6MASK(gva) (((gva) >> PAGE_SHIFT) & INTERESTED_6_BITS)
+#define INTERESTED_GFN_6MASK(gfn) (((gfn) >> 0) & INTERESTED_6_BITS)
+
+#define INTERESTED_2AFTER4_BITS 0xffff00
+#define INTERESTED_GVA_2AFTER4MASK(gva) (((gva) >> PAGE_SHIFT) & INTERESTED_2AFTER4_BITS)
+#define INTERESTED_GFN_2AFTER4MASK(gfn) (((gfn) >> 0) & INTERESTED_2AFTER4_BITS)
+//gva / hva
+/*
+				((INTERESTED_GVA_MASK(gva) > INTERESTED_GVA_LOW) \
+				&& (INTERESTED_GVA_MASK(gva) < INTERESTED_GVA_HIGH)) || \
+*/
+
+#if INTERESTED_ADDRS
+
+/* For mount_root() */
+#define INTERESTED_GVA(gva) ( 0 )
+
+/* For SMP */
+/*
+#define INTERESTED_GVA(gva) (INTERESTED_GVA_MASK(gva) == 0x1c75 || \
+								INTERESTED_GVA_MASK(gva) == 0x1f1b \
+							)
+*/
+
+/*
+#define INTERESTED_GVA(gva) (\
+						( \
+						((INTERESTED_GVA_6MASK(gva) >= INTERESTED_GVA_6LOW) \
+						&& (INTERESTED_GVA_6MASK(gva) <= INTERESTED_GVA_6HIGH)) || \
+						(INTERESTED_GVA_MASK(gva) == 0x99) || \
+						(INTERESTED_GVA_MASK(gva) == 0x4fdd) || \
+						(INTERESTED_GVA_MASK(gva) == 0x77f5) || \
+						(INTERESTED_GVA_MASK(gva) == 0x6ff) || \
+						(INTERESTED_GVA_MASK(gva) == 0x70f) || \
+						(INTERESTED_GVA_MASK(gva) == 0x70d) || \
+						(INTERESTED_GVA_MASK(gva) == 0x1c75) || \
+							((INTERESTED_GVA_MASK(gva) >= 0x1a0c) && \
+							(INTERESTED_GVA_MASK(gva) <= 0x1c20)) \
+								|| \
+							((INTERESTED_GVA_MASK(gva) >= 0x3054) && \
+							(INTERESTED_GVA_MASK(gva) <= 0x3060)) \
+						) \
+						)
+						// 0x1a11 0x1a12 0x1a13
+						// 0x3054 0x3055 0x3056 0x3057 0x3058 0x3059
+//						(INTERESTED_GVA_MASK(gva) == 0x1a0c) ||
+//						(INTERESTED_GVA_MASK(gva) == 0x1c0c) ||
+//						(INTERESTED_GVA_MASK(gva) == 0x1c11) ||
+//						(INTERESTED_GVA_MASK(gva) == 0x1c12) ||
+//						(INTERESTED_GVA_MASK(gva) == 0x1a14) ||
+//						(INTERESTED_GVA_MASK(gva) == 0x1a15) ||
+*/
+
+/*
+#define NOTINTERESTED_GVA(gva) (\
+						!(INTERESTED_GVA_MASK(gva) == 0x1a0c) && \
+						!(INTERESTED_GVA_MASK(gva) == 0x1c0c) && \
+						!(INTERESTED_GVA_MASK(gva) == 0x1c11) && \
+						!(INTERESTED_GVA_MASK(gva) == 0x1c12) \
+						)
+*/
+/*
+#define NOTINTERESTED_GVA(gva) (\
+						!(INTERESTED_GVA_MASK(gva) == 0x1a0c) && \
+						!(INTERESTED_GVA_MASK(gva) == 0x1c12) \
+						)
+*/
+/*
+#define NOTINTERESTED_GVA(gva) (\
+						!(INTERESTED_GVA_MASK(gva) == 0x1a0c) && \
+						!(INTERESTED_GVA_MASK(gva) == 0x1c11) && \
+						!(INTERESTED_GVA_MASK(gva) == 0x1c12) \
+						)
+*/
+/*
+#define NOTINTERESTED_GVA(gva) (\
+						!(INTERESTED_GVA_MASK(gva) == 0x1c0c) && \
+						!(INTERESTED_GVA_MASK(gva) == 0x1c11) \
+						)
+*/
+///*
+//#define NOTINTERESTED_GVA(gva) ( 1 ) // afftected btw cnt
+#define NOTINTERESTED_GVA(gva) ( 0 ) // not affected btw cnt
+/* last used
+#define NOTINTERESTED_GVA(gva) (\
+						( \
+							!((INTERESTED_GVA_MASK(gva) >= 0x1a0c) && \
+								(INTERESTED_GVA_MASK(gva) <= 0x1c20)) \
+							&& \
+							!((INTERESTED_GVA_MASK(gva) >= 0x3054) && \
+								(INTERESTED_GVA_MASK(gva) <= 0x3060)) \
+							&& \
+							!((INTERESTED_GVA_MASK(gva) >= 0x1f1b) && \
+								(INTERESTED_GVA_MASK(gva) <= 0x1f1e)) \
+							&& \
+							!((INTERESTED_GVA_MASK(gva) >= 0xfd10) && \
+								(INTERESTED_GVA_MASK(gva) <= 0xfd16)) \
+							&& \
+							!((INTERESTED_GVA_MASK(gva) >= 0xa487) && \
+								(INTERESTED_GVA_MASK(gva) <= 0xabe5)) \
+							&& \
+							!((INTERESTED_GVA_MASK(gva) >= 0x1ca8) && \
+								(INTERESTED_GVA_MASK(gva) <= 0x1caf)) \
+							&& \
+							!((INTERESTED_GVA_MASK(gva) >= 0xfc11) && \
+								(INTERESTED_GVA_MASK(gva) <= 0xfc16)) \
+							&& \
+							!(INTERESTED_GVA_MASK(gva) == 0xfff3) \
+							&& \
+							!(INTERESTED_GVA_MASK(gva) == 0x1eb6) \
+							&& \
+							!(INTERESTED_GVA_MASK(gva) == 0x1a0a) \
+							&& \
+							!(INTERESTED_GVA_MASK(gva) == 0x1eb7) \
+							&& \
+							!(INTERESTED_GVA_MASK(gva) == 0xb885) \
+						) \
+						)
+*/
+//*/
+
+
+/* For mount_root() */
+#define INTERESTED_GFN(gfn) ( 0 )
+
+
+/* For SMP */
+/*
+#define INTERESTED_GFN(gfn) (INTERESTED_GFN_MASK(gfn) == 0x1c75 || \
+								INTERESTED_GFN_MASK(gfn) == 0x1f1b \
+							)
+*/
+
+/*
+#define INTERESTED_GFN(gfn) ( \
+						( \
+						((INTERESTED_GFN_MASK(gfn) >= INTERESTED_GVA_LOW) \
+						&& (INTERESTED_GFN_MASK(gfn) <= INTERESTED_GVA_HIGH)) || \
+						(INTERESTED_GFN_MASK(gfn) == 0x99) || \
+						(INTERESTED_GFN_MASK(gfn) == 0x4fdd) || \
+						(INTERESTED_GFN_MASK(gfn) == 0x77f5) || \
+						(INTERESTED_GFN_MASK(gfn) == 0x6ff) || \
+						(INTERESTED_GFN_MASK(gfn) == 0x70f) || \
+						(INTERESTED_GFN_MASK(gfn) == 0x70d) || \
+						(INTERESTED_GFN_MASK(gfn) == 0x1c75) || \
+							((INTERESTED_GFN_MASK(gfn) >= 0x1a0c) && \
+							(INTERESTED_GFN_MASK(gfn) <= 0x1c20)) \
+								|| \
+							((INTERESTED_GFN_MASK(gfn) >= 0x3054) && \
+							(INTERESTED_GFN_MASK(gfn) <= 0x3060)) \
+						) \
+						)
+						// 0x1a11 0x1a12 0x1a13
+						// 0x3054 0x3055 0x3056 0x3057 0x3058 0x3059
+//						(INTERESTED_GFN_MASK(gfn) == 0x1a0c) ||
+//						(INTERESTED_GFN_MASK(gfn) == 0x1c0c) ||
+//						(INTERESTED_GFN_MASK(gfn) == 0x1c11) ||
+//						(INTERESTED_GFN_MASK(gfn) == 0x1c12) ||
+//						(INTERESTED_GFN_MASK(gfn) == 0x1a11) ||
+//						(INTERESTED_GFN_MASK(gfn) == 0x1a14) ||
+//						(INTERESTED_GFN_MASK(gfn) == 0x1a15) ||
+*/
+
+/*
+#define NOTINTERESTED_GFN(gfn) ( \
+						!(INTERESTED_GFN_MASK(gfn) == 0x1a0c) && \
+						!(INTERESTED_GFN_MASK(gfn) == 0x1c0c) && \
+						!(INTERESTED_GFN_MASK(gfn) == 0x1c11) && \
+						!(INTERESTED_GFN_MASK(gfn) == 0x1c12) \
+						)
+*/
+/*
+#define NOTINTERESTED_GFN(gfn) ( \
+						!(INTERESTED_GFN_MASK(gfn) == 0x1a0c) && \
+						!(INTERESTED_GFN_MASK(gfn) == 0x1c12) \
+						)
+*/
+/*
+#define NOTINTERESTED_GFN(gfn) ( \
+						!(INTERESTED_GFN_MASK(gfn) == 0x1a0c) && \
+						!(INTERESTED_GFN_MASK(gfn) == 0x1c11) && \
+						!(INTERESTED_GFN_MASK(gfn) == 0x1c12) \
+						)
+*/
+/*
+#define NOTINTERESTED_GFN(gfn) ( \
+						!(INTERESTED_GFN_MASK(gfn) == 0x1c0c) && \
+						!(INTERESTED_GFN_MASK(gfn) == 0x1c11) \
+						)
+*/
+///*
+#define NOTINTERESTED_GFN(gfn) ( 1 )
+/* last used
+#define NOTINTERESTED_GFN(gfn) ( \
+						( \
+							!((INTERESTED_GFN_MASK(gfn) >= 0x1a0c) && \
+								(INTERESTED_GFN_MASK(gfn) <= 0x1c20)) \
+							&& \
+							!((INTERESTED_GFN_MASK(gfn) >= 0x3054) && \
+								(INTERESTED_GFN_MASK(gfn) <= 0x3060)) \
+							&& \
+							!((INTERESTED_GFN_MASK(gfn) >= 0x1f1b) && \
+								(INTERESTED_GFN_MASK(gfn) <= 0x1f1e)) \
+							&& \
+							!((INTERESTED_GFN_MASK(gfn) >= 0xfd10) && \
+								(INTERESTED_GFN_MASK(gfn) <= 0xfd16)) \
+							&& \
+							!((INTERESTED_GFN_MASK(gfn) >= 0xa487) && \
+								(INTERESTED_GFN_MASK(gfn) <= 0xabe5)) \
+							&& \
+							!((INTERESTED_GFN_MASK(gfn) >= 0x1ca8) && \
+								(INTERESTED_GFN_MASK(gfn) <= 0x1caf)) \
+							&& \
+							!((INTERESTED_GFN_MASK(gfn) >= 0xfc11) && \
+								(INTERESTED_GFN_MASK(gfn) <= 0xfc16)) \
+							&& \
+							!(INTERESTED_GFN_MASK(gfn) == 0xfff3) \
+							&& \
+							!(INTERESTED_GFN_MASK(gfn) == 0x1eb6) \
+							&& \
+							!(INTERESTED_GFN_MASK(gfn) == 0x1a0a) \
+							&& \
+							!(INTERESTED_GFN_MASK(gfn) == 0x1eb7) \
+							&& \
+							!(INTERESTED_GFN_MASK(gfn) == 0xb885) \
+						) \
+						)
+*/
+//*/
+// 0xf8a700 many
+/*
+#define INTERESTED_GVA_2AFTER4(gva) ( INTERESTED_GVA_2AFTER4MASK(gva) == 0xf8a700 || \
+										INTERESTED_GVA_2AFTER4MASK(gva) == 0xf8bc00 || \
+										INTERESTED_GVA_2AFTER4MASK(gva) == 0xf8b800)
+#define INTERESTED_GFN_2AFTER4(gfn) ( INTERESTED_GFN_2AFTER4MASK(gfn) == 0xf8a700 \\
+										INTERESTED_GFN_2AFTER4MASK(gfn) == 0xf8bc00 \\
+										INTERESTED_GFN_2AFTER4MASK(gfn) == 0xf8b800)
+*/
+#define INTERESTED_GFN_2AFTER4(gfn) ( 0 )
+#define INTERESTED_GVA_2AFTER4(gva) ( 0 )
+
+//*/
+#else // !INTERESTED_ADDRS
+#define INTERESTED_GVA(gva) 0
+#define INTERESTED_GFN(gfn) 0
+#define NOTINTERESTED_GVA(gva) 0
+#endif
+
+// vcpu mmap
+// 7ffff47xx000
+
+//// 1f1b
+//// fd16
+
+// a487
+// a499
+//  ~
+// a53c
+// a53d
+//  ~
+// abe5
+
+// 1eb6
+// 1ca8
+// 1caf
+
+// fc11
+// fc16
+// 1a0a
+
+// b885 no
+
+// root_mount() 00cb062
+
+/*
+cpu_initialized_mask passed ffffffff81c75c80 0x1c75c80
+***cpu_callout_mask*** ffffffff81c75c40 0x1c75c40
+cpu_online_mask kva ffffffff81b0bf00 kpa 0x1b0bf00
+__bss_stop ffffffff81f1b000 0x1f1b000
+__bss_start ffffffff81c66000 0x1c66000
+
+// # ffffffff81a0a000 <jiffies>
+// 1eb7 <watchdog> <curr_clocksource> <finished_booting>
+*/
+
+// 7ffff4fdd
+// 7ffff77f5000 before kernel.....origin keep !mine and retry.... THIS IS ONE PROBLEM  WITHOUT ENTERING EPT AT ALL.....remote at RETRY_REMOTEFAULT_GIVEUP O
+// 70d000 before
+// 70f000  before kernel // happens when remote_bsp not properly commendeud out // may happen right after lkvm:parse_options_end()
+// 6ff000 after 2nd is up  // this is comfirmed as futex
+/*
+#ifdef CONFIG_POPCORN_HYPE
+//	if (
+//		(gpa > 0x190c000 && gpa < 0x1ffe000) || // bug addr
+//		(gpa > 0xa1000 && gpa <= 0x1fff000)) {
+//		if (!(gpa > 0x12a490040 && gpa < 0x12fbf3000) &&
+//				!(gpa > 0xcb9f6000 && gpa < 0xcffea000) &&//) {
+//				!( gpa > 0x12a800 && gpa < 0x12ff21) &&
+//				!( gpa > 0xcc013 && gpa < 0xcffeb) &&
+//				!( gpa > 0x12fcf1 && gpa < 0x12f5e4)) {
+	}
+#endif
+*/
+
+// TODO efff3
+// [   37.868000] kvm-stealtime: cpu 1, msr 12fd10300
+
+// (perf) When remote 4 threads idle in bash, there are many 0x7ffec1a0c000, 0x7ffec1a11000, 0x7fffefff3000
+
 #endif /*  __INCLUDE_POPCORN_DEBUG_H__ */
diff --git a/include/popcorn/hype.h b/include/popcorn/hype.h
new file mode 100644
index 000000000000..9a62e270ad8d
--- /dev/null
+++ b/include/popcorn/hype.h
@@ -0,0 +1,24 @@
+/*
+ * hype.h
+ * Copyright (C) 2019 jackchuang <jackchuang@mir7>
+ *
+ * Distributed under terms of the MIT license.
+ */
+
+#ifndef HYPE_H
+#define HYPE_H
+#include <../kernel/popcorn/types.h>
+#include <../kernel/popcorn/wait_station.h>
+
+#include <popcorn/debug.h>
+//#include <popcorn/hype_file.h>
+
+#define POPHYPE_PRIVATE_TSS 1 /* anon pg's pgoff = 0 */
+
+
+/* VM_EXIT negative to return to userspace */
+#define KVM_RET_POPHYPE_MIGRATE -78
+
+
+
+#endif /* !HYPE_H */
diff --git a/include/popcorn/hype_file.h b/include/popcorn/hype_file.h
new file mode 100644
index 000000000000..0372f1754251
--- /dev/null
+++ b/include/popcorn/hype_file.h
@@ -0,0 +1,29 @@
+/*
+ * hype_file.h
+ * Copyright (C) 2019 jackchuang <jackchuang@mir7>
+ *
+ * Distributed under terms of the MIT license.
+ */
+
+#ifndef HYPE_FILES_H
+#define HYPE_FILES_H
+#include <linux/types.h>
+#include <linux/compiler.h>
+
+#include <popcorn/hype.h>
+
+//#include <linux/file.h>
+//#include <linux/fsnotify.h>
+//#include <linux/fdtable.h>
+#include <linux/fs.h>
+//#include <../fs/internal.h>
+
+#include <linux/uaccess.h> // copy_from_user
+
+#include <popcorn/types.h>
+#include <popcorn/pcn_kmsg.h>
+
+
+int popcorn_open(const char __user *filename, int flags, umode_t mode, int fd);
+ssize_t popcorn_delegate_rw(unsigned int fd, char *buf, size_t count, bool is_read);
+#endif /* !HYPE_FILES_H */
diff --git a/include/popcorn/hype_kvm.h b/include/popcorn/hype_kvm.h
new file mode 100644
index 000000000000..0bf99b97f6a1
--- /dev/null
+++ b/include/popcorn/hype_kvm.h
@@ -0,0 +1,145 @@
+/*
+ * hype_kvm.h
+ * Copyright (C) 2019 jackchuang <jackchuang@mir7>
+ *
+ * Distributed under terms of the MIT license.
+ */
+
+#ifndef HYPE_KVM_H
+#define HYPE_KVM_H
+
+#include <popcorn/hype.h>
+
+#include <linux/types.h>
+#include <linux/compiler.h>
+
+#include <linux/kvm_host.h>
+
+#include <linux/delay.h>
+
+
+/* vhost-net: eventfd */
+#include <linux/kvm_irqfd.h>
+#include <linux/eventfd.h>
+
+#include <linux/skbuff.h> // vhost-net optimication
+
+/* Debug */
+#define FD_DEBUG_THREDSHOLD_LOW 10
+#define FD_DEBUG_THREDSHOLD_HIGH 20
+
+#define MAX_POPCORN_VCPU 32 /* Since current pophype migration assumption (including lkvm implementation, 1vcpu on 1 node), This value should not be less than MAX_POPCORN_NODES(32). */
+
+#define POPCORN_HOST_NID 0
+#define FD_START 3 /* look up fd from this f. io and other files */ // wrong since kvm start 4 or 5
+#define MAX_POPCORN_FD (MAX_POPCORN_VCPU + 30)
+//MAX_POPCORN_FD 30
+
+#define POPHYPE_ORIGIN_TAP_NAME "tap0"
+
+/*
+ * Which cpu on which node and info
+ */
+struct hype_node_info_t {
+    struct kvm_vcpu *vcpu;
+    struct kvm_run *run;
+    int vcpu_id;
+	int fd;
+    unsigned long uaddr;
+	bool on_mynid; /* TODO - so that show_guest_rip can do fastpath*/
+	struct task_struct *tsk; /* buffer this for debugging */
+	int remote_pid; /* Remote vCPU thread pid at origin */
+	int origin_pid; /* Original pid at origin for remote vCPU thread for lookup */
+};
+extern struct hype_node_info_t *hype_node_info[MAX_POPCORN_NODES][MAX_POPCORN_VCPU]; /* Attention: [MY_NID][FD] set by ./kernel/popcorn/vma_server.c pophype mmap() feature */
+
+extern void *popcorn_vcpu_op;
+
+#define VCPU_FD_BASE 11 /* TODO BAD hardcode */
+extern int popcorn_vcpu_cnt;
+extern int first_fd_after_vcpufd;
+
+//struct popcorn_vcpu_info popcorn_vcpu_infos[MAX_POPCORN_VCPU];
+
+
+/*
+ * vhost-net: eventfd ctx for delegation
+ */
+struct hype_eventfd_info_t {
+	// int fd; // already in idx
+	// fd f = fdget(fd);
+	// struct file *file = &f.file
+	struct eventfd_ctx *eventfd_ctx;
+	struct kvm_kernel_irqfd *irqfd; /* Not sure if needed. Just in case */
+};
+extern struct hype_eventfd_info_t *hype_eventfd_info[MAX_POPCORN_FD]; /* [fd_idx] */
+int eventfd_ctx_to_fd(struct eventfd_ctx *eventfd_ctx); /* generate at remote */
+__u64 pophype_eventfd_delegate(int eventfd_fd, __u64 n); /* retrive at origin */
+
+/*
+ * DSM VM info
+ */
+#define MAX_VM_STACK_DEBUG 5
+//struct _dsm_traffic
+typedef struct {
+    unsigned long addr; /* faulting addr */
+    unsigned long rip;
+    unsigned long rbp;
+    unsigned long rsp;
+    unsigned long stack[MAX_VM_STACK_DEBUG];
+    unsigned long cnt; /* freq */
+//    unsigned long long time; /* total */
+} dsm_traffic_t;
+
+
+/* others */
+#define REMOTE_CANNOT_DOWN_MMAP_SEM (-78)
+
+int popcorn_kvm_dev_ioctl_create_vm_tsk(unsigned long type);
+void popcorn_broadcast_apic_reg_write(int vcpu_id, u32 reg, u32 val);
+void popcorn_broadcast_accept_irq(int vcpu_id, int delivery_mode, int vector, int level, int trig_mode, int dest_map);
+int popcorn_send_ipi(struct kvm_vcpu *dst_vcpu, struct kvm_lapic_irq *irq, unsigned long *dest_map);
+void popcorn_send_sipi(int vcpu_id, int vector);
+
+int popcorn_broadcast_sig(int usr_sig);
+int pophype_do_send_specific_at_remote(pid_t tgid, pid_t pid, int sig, struct siginfo *info); /* kernel/signal.c */
+
+int pophype_available_vcpu(void);
+void pophype_set_cpu0(void);
+
+int popcorn_get_hnid(void);
+int popcorn_vcpuid_to_nid(int vcpu_id);
+int vcpuid_to_fd(int vcpu_id);
+bool popcorn_on_right_nid(int vcpu_id);
+int vcpuid_to_nid(int vcpu_id);
+void popcorn_show_gcpu_table(void);
+
+/* debug - reg dump */
+dsm_traffic_t pophype_show_guest_rip_rsp(unsigned long host_addr, bool show, struct kvm_vcpu *vcpu);
+
+/* arch/x86/kvm/lapic.c */
+int popcorn_kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq, unsigned long *dest_map); // used for SIPI special cases
+int popcorn_apic_inject_ipi(struct kvm_lapic *apic, struct kvm_lapic_irq *irq, int dst_vcpu_id);
+int popcorn_apic_accept_irq(struct kvm_lapic *apic, int delivery_mode, int vector, int level, int trig_mode, unsigned long *dest_map);
+
+int popcorn_file_to_fd(struct task_struct *tsk, struct file *file, bool is_vcpu);
+
+/* Pophype migration */
+int popcorn_update_remote_vcpu(int dst_nid, int dst_vcpu);
+
+/* vhost-net optimization - at remote */
+struct pophype_skb *guest_skb_to_pophype_skb(struct sk_buff *skb); // guest - create
+void delegate_skb_tx_hypercall(struct pophype_skb *skb, int pskb_size); // guest - estory
+int delegate_skb_tx(struct pophype_skb *pskb_gva, int pskb_size); // host
+
+void guest_delegate_net_msg_tx_hypercall(struct sock *sk, struct msghdr *msg, size_t size);
+void delegate_net_msg_tx(struct pophype_msghdr __user *pmsg, int pmsghdr_size);
+
+
+
+/* To identify this apic irq insertion is from remote */
+/* We found dest_map is always NULL in our use cases */
+/* If dest_map is not always NULL, everything related to REMOTE_APIC is a HACK !!! */
+/* Can we capture !!dest_map case? yes, TODO */
+#define REMOTE_APIC ((void*)0x1000) /* FROM REMOTE */
+#endif /* !HYPE_KVM_H */
diff --git a/include/popcorn/hype_migrate.h b/include/popcorn/hype_migrate.h
new file mode 100644
index 000000000000..22b5cd139840
--- /dev/null
+++ b/include/popcorn/hype_migrate.h
@@ -0,0 +1,14 @@
+/*
+ * hype_migrate.h
+ * Copyright (C) 2020 jackchuang <jackchuang@mir>
+ *
+ * Distributed under terms of the MIT license.
+ */
+
+#ifndef HYPE_MIGRATE_H
+#define HYPE_MIGRATE_H
+
+#include <popcorn/hype.h>
+
+
+#endif /* !HYPE_MIGRATE_H */
diff --git a/include/popcorn/page_server.h b/include/popcorn/page_server.h
index fb7d086e04d2..23b524d2a55e 100644
--- a/include/popcorn/page_server.h
+++ b/include/popcorn/page_server.h
@@ -23,6 +23,10 @@ int page_server_handle_pte_fault(
 		unsigned long address, pmd_t *pmd, pte_t *pte, pte_t entry,
 		unsigned int flags);
 
+#ifdef CONFIG_POPCORN_HYPE
+bool page_is_mine_pub(struct mm_struct *mm, unsigned long addr);
+#endif
+
 /*
  * Flush pages in remote to the origin
  */
diff --git a/include/popcorn/pcn_kmsg.h b/include/popcorn/pcn_kmsg.h
index a00cd2f9a1bd..582b1628f25d 100644
--- a/include/popcorn/pcn_kmsg.h
+++ b/include/popcorn/pcn_kmsg.h
@@ -10,6 +10,11 @@
 
 #include <linux/types.h>
 
+#define MULTI_CONN_PER_NODE 0
+
+//#define MAX_POPCORN_THREADS ARM_THREADS
+#define MAX_POPCORN_THREADS 96
+
 /* Enumerate message types */
 enum pcn_kmsg_type {
 	/* Thread migration */
@@ -47,6 +52,8 @@ enum pcn_kmsg_type {
 	PCN_KMSG_TYPE_TEST_RESPONSE,
 	PCN_KMSG_TYPE_TEST_RDMA_REQUEST,
 	PCN_KMSG_TYPE_TEST_RDMA_RESPONSE,
+	PCN_KMSG_TYPE_TEST_RDMA_DSMRR_REQUEST,
+	PCN_KMSG_TYPE_TEST_RDMA_DSMRR_RESPONSE,
 
 	/* Provide the single system image */
 	PCN_KMSG_TYPE_REMOTE_PROC_CPUINFO_REQUEST,
@@ -56,6 +63,60 @@ enum pcn_kmsg_type {
 	PCN_KMSG_TYPE_REMOTE_PROC_PS_REQUEST,
 	PCN_KMSG_TYPE_REMOTE_PROC_PS_RESPONSE,
 
+	/* Hype */
+	PCN_KMSG_TYPE_REMOTE_KVM_CREATE_REQUEST, /* !used */
+	PCN_KMSG_TYPE_REMOTE_KVM_CREATE_RESPONSE, /* !used */
+
+	PCN_KMSG_TYPE_ORIGIN_SIPI_REQUEST, /* !used */
+	PCN_KMSG_TYPE_ORIGIN_SIPI_RESPONSE, /* !used */
+	PCN_KMSG_TYPE_ORIGIN_BROADCAST_ACCEPT_IRQ_REQUEST, /* !used */
+	PCN_KMSG_TYPE_ORIGIN_BROADCAST_ACCEPT_IRQ_RESPONSE, /* !used */
+	PCN_KMSG_TYPE_ORIGIN_BROADCAST_APIC_REG_WRITE_REQUEST,
+	PCN_KMSG_TYPE_ORIGIN_BROADCAST_APIC_REG_WRITE_RESPONSE,
+
+	PCN_KMSG_TYPE_IPI_REQUEST,
+	PCN_KMSG_TYPE_IPI_RESPONSE,
+
+	PCN_KMSG_TYPE_SIG_REQUEST,
+	PCN_KMSG_TYPE_SIG_RESPONSE,
+
+	PCN_KMSG_TYPE_REMOTE_CHECKIN_VCPU_PID_REQUEST,
+	PCN_KMSG_TYPE_REMOTE_CHECKIN_VCPU_PID_RESPONSE,
+	PCN_KMSG_TYPE_ORIGIN_CHECKIN_VCPU_PID_REQUEST,
+	PCN_KMSG_TYPE_ORIGIN_CHECKIN_VCPU_PID_RESPONSE,
+
+	/* Pophype migration - sync up vcpu info */
+	PCN_KMSG_TYPE_UPDATE_VCPU_REQUEST,
+	PCN_KMSG_TYPE_UPDATE_VCPU_RESPONSE,
+
+	/* File op */
+	PCN_KMSG_TYPE_REMOTE_OPEN_REQUEST,
+	PCN_KMSG_TYPE_REMOTE_OPEN_RESPONSE,
+
+	PCN_KMSG_TYPE_DELEGATE_RW_REQUEST,
+	PCN_KMSG_TYPE_DELEGATE_RW_RESPONSE,
+//	PCN_KMSG_TYPE_ORIGIN_OPEN_REQUEST,
+
+	/* remote asks other remote tgids */
+	PCN_KMSG_TYPE_REMOTE_ASK_ORIGIN_TGID_REQUEST,
+	PCN_KMSG_TYPE_ORIGIN_ASK_REMOTE_TGID_REQUEST,
+	PCN_KMSG_TYPE_ORIGIN_ASK_REMOTE_TGID_RESPONSE,
+	PCN_KMSG_TYPE_REMOTE_ASK_ORIGIN_TGID_RESPONSE,
+
+	PCN_KMSG_TYPE_ORIGIN_BROADCAST_CPU_TABLE_REQUEST,
+	PCN_KMSG_TYPE_ORIGIN_BROADCAST_CPU_TABLE_RESPONSE,
+	PCN_KMSG_TYPE_UPDATE_CPU_TABLE_REQUEST_FIELDS,
+
+	/* vhost-net: eventfd delegation */
+	PCN_KMSG_TYPE_DELEGATE_EVENTFD_REQUEST,
+	PCN_KMSG_TYPE_DELEGATE_EVENTFD_RESPONSE,
+
+	/* vhost-net: optimization */
+	PCN_KMSG_TYPE_DELEGATE_SKB_TX_REQUEST,
+	PCN_KMSG_TYPE_DELEGATE_SKB_TX_RESPONSE,
+	PCN_KMSG_TYPE_DELEGATE_NET_MSG_TX_REQUEST,
+	PCN_KMSG_TYPE_DELEGATE_NET_MSG_TX_RESPONSE,
+
 	/* Schedule server */
 	PCN_KMSG_TYPE_SCHED_PERIODIC,		/* XXX sched requires help!! */
 
@@ -71,9 +132,12 @@ enum pcn_kmsg_prio {
 
 /* Message header */
 struct pcn_kmsg_hdr {
-	int from_nid			:6;
+	int from_nid			:6;	///* max node = 15 */
 	enum pcn_kmsg_prio prio	:2;
-	enum pcn_kmsg_type type	:8;
+	enum pcn_kmsg_type type	:8; ///* max type = 127 */
+#if MULTI_CONN_PER_NODE
+	unsigned int channel;		///* max node = */
+#endif
 	size_t size;
 } __attribute__((packed));
 
@@ -81,7 +145,7 @@ struct pcn_kmsg_hdr {
 	(((struct pcn_kmsg_message *)x)->header.from_nid)
 #define PCN_KMSG_SIZE(x) (sizeof(struct pcn_kmsg_hdr) + x)
 
-#define PCN_KMSG_MAX_SIZE (64UL << 10)
+#define PCN_KMSG_MAX_SIZE (32UL << 10)
 #define PCN_KMSG_MAX_PAYLOAD_SIZE \
 	(PCN_KMSG_MAX_SIZE - sizeof(struct pcn_kmsg_hdr))
 
diff --git a/include/popcorn/process_server.h b/include/popcorn/process_server.h
index 2f2d3ca46993..11da0551c9a2 100644
--- a/include/popcorn/process_server.h
+++ b/include/popcorn/process_server.h
@@ -3,6 +3,7 @@
 
 struct task_struct;
 
+int pophype_do_migrate(void);
 int process_server_do_migration(struct task_struct* tsk, unsigned int dst_nid, void __user *uregs);
 int process_server_task_exit(struct task_struct *tsk);
 int update_frame_pointer(void);
diff --git a/include/popcorn/regset.h b/include/popcorn/regset.h
index fd4042962db5..a209c7e78fb1 100644
--- a/include/popcorn/regset.h
+++ b/include/popcorn/regset.h
@@ -91,6 +91,12 @@ static inline size_t regset_size(int arch) {
 		sizeof(struct regset_x86_64),
 		sizeof(struct regset_powerpc),
 	};
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_CHECK_SANITY)
+	if (arch <= POPCORN_ARCH_UNKNOWN || arch >= POPCORN_ARCH_MAX) {
+		printk("%s(): arch %d\n", __func__, arch);
+		dump_stack();
+	}
+#endif
 	BUG_ON(arch <= POPCORN_ARCH_UNKNOWN || arch >= POPCORN_ARCH_MAX);
 	return sizes[arch];
 }
diff --git a/include/popcorn/sync.h b/include/popcorn/sync.h
new file mode 100644
index 000000000000..4ef148a6c7b4
--- /dev/null
+++ b/include/popcorn/sync.h
@@ -0,0 +1,32 @@
+/*
+ * sync.h
+ * Copyright (C) 2018 Ho-Ren(Jack) Chuang <horenc@vt.edu>
+ *
+ * Distributed under terms of the MIT license.
+ */
+
+#ifndef SYNC_H
+#define SYNC_H
+#include <popcorn/pcn_kmsg.h>
+
+#define MAX_OMP_REGIONS 100
+
+/* Depends on (PCN_KMSG_MAX_SIZE - 1) pages for msg head + metadata */
+#define LIMIT_PER_INV_ADDR_SIZE_FACTOR (PCN_KMSG_MAX_SIZE / (32UL << 10)) // for seting inv cnt as the same as when size = 32k
+#define MAX_WRITE_INV_BUFFERS ((long unsigned int)((PCN_KMSG_MAX_PAYLOAD_SIZE / LIMIT_PER_INV_ADDR_SIZE_FACTOR) / sizeof(unsigned long)) - 8) // (-8) since page_merge_request_t has 8 element each has 8 bytes (worst case)
+
+/* IS-D, BT-D use more: 2000 => 2000 * 96(max threads)
+ * For not IS-D: 1500
+ * 2500 will crash since cannot allocate sys_region
+ */
+#define MAX_READ_BUFFERS 2000
+#define MAX_WRITE_NOPAGE_BUFFERS 2000
+
+#define MAX_PF_MSG (ARM_THREADS * 10 * 2) // = (1000msg * 31pg per msg) pages is enough except sp (2000)
+
+/* 1 end spot for sorting */
+#define MAX_ALIVE_THREADS (X86_THREADS + ARM_THREADS + 1)
+
+
+
+#endif /* !SYNC_H */
diff --git a/include/popcorn/types.h b/include/popcorn/types.h
index 48ccb12578da..65b635fe1610 100644
--- a/include/popcorn/types.h
+++ b/include/popcorn/types.h
@@ -14,12 +14,18 @@
 
 static inline bool distributed_process(struct task_struct *tsk)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	if (unlikely(!tsk)) return false;
+#endif
 	if (!tsk->mm) return false;
 	return !!tsk->mm->remote;
 }
 
 static inline bool distributed_remote_process(struct task_struct *tsk)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	if (unlikely(!tsk)) return false;
+#endif
 	return distributed_process(tsk) && tsk->at_remote;
 }
 
diff --git a/include/popcorn/vma_server.h b/include/popcorn/vma_server.h
index dbc261d4b24e..8f5e90e2d3bd 100644
--- a/include/popcorn/vma_server.h
+++ b/include/popcorn/vma_server.h
@@ -38,4 +38,7 @@ int vma_server_mprotect_remote(unsigned long start, size_t len, unsigned long pr
 int vma_server_mremap_remote(unsigned long addr, unsigned long old_len,
 		unsigned long new_len, unsigned long flags, unsigned long new_addr);
 
+/* hype */
+unsigned long pophype_vm_mmap_anon(unsigned long size, unsigned long prot, unsigned long flags);
+
 #endif /* INCLUDE_POPCORN_VMA_SERVER_H_ */
diff --git a/include/trace/events/kvm.h b/include/trace/events/kvm.h
index 67ff6555967f..82a86015134c 100644
--- a/include/trace/events/kvm.h
+++ b/include/trace/events/kvm.h
@@ -16,6 +16,23 @@
 	ERSN(NMI), ERSN(INTERNAL_ERROR), ERSN(OSI), ERSN(PAPR_HCALL),	\
 	ERSN(S390_UCONTROL), ERSN(WATCHDOG), ERSN(S390_TSCH)
 
+TRACE_EVENT(kvm_ept_inv,
+    TP_PROTO(unsigned long inv_addr),
+    TP_ARGS(inv_addr),
+
+    TP_STRUCT__entry(
+        __field(    unsigned long,  inv_addr )
+    ),
+
+    TP_fast_assign(
+        __entry->inv_addr    = inv_addr;
+    ),
+
+    TP_printk("retry_inv %lx",
+          __entry->inv_addr)
+);
+
+
 TRACE_EVENT(kvm_userspace_exit,
 	    TP_PROTO(__u32 reason, int errno),
 	    TP_ARGS(reason, errno),
diff --git a/include/uapi/asm-generic/unistd.h b/include/uapi/asm-generic/unistd.h
index 921efb9419c4..a38ee5dd45bf 100644
--- a/include/uapi/asm-generic/unistd.h
+++ b/include/uapi/asm-generic/unistd.h
@@ -723,9 +723,28 @@ __SYSCALL(__NR_popcorn_propose_migration, sys_popcorn_propose_migration)
 __SYSCALL(__NR_popcorn_get_thread_status, sys_popcorn_get_thread_status)
 #define __NR_popcorn_get_node_info 288
 __SYSCALL(__NR_popcorn_get_node_info, sys_popcorn_get_node_info)
+#define __NR_popcorn_broadcast_cpu_table 370
+__SYSCALL(__NR_popcorn_broadcast_cpu_table, sys_popcorn_broadcast_cpu_table)
+#define __NR_popcorn_false_share 375
+__SYSCALL(__NR_popcorn_false_share, sys_popcorn_false_share)
+#define __NR_popcorn_true_share 376
+__SYSCALL(__NR_popcorn_true_share, sys_popcorn_true_share)
+#define __NR_popcorn_no_share 377
+__SYSCALL(__NR_popcorn_no_share, sys_popcorn_no_share)
+#define __NR_pophype_migrate 380
+__SYSCALL(__NR_pophype_migrate, sys_pophype_migrate)
+#define __NR_pophype_migrate_on_hostusr 381
+__SYSCALL(__NR_pophype_migrate_on_hostusr, sys_pophype_migrate_on_hostusr)
+#define __NR_pophype_remote_checkin_vcpu_pid 382
+__SYSCALL(__NR_pophype_remote_checkin_vcpu_pid, sys_pophype_remote_checkin_vcpu_pid)
+#define __NR_pophype_origin_checkin_vcpu_pid 383
+__SYSCALL(__NR_pophype_origin_checkin_vcpu_pid, sys_pophype_origin_checkin_vcpu_pid)
+#define __NR_pophype_vcpu_migrate_trigger 384
+__SYSCALL(__NR_pophype_vcpu_migrate_trigger, sys_pophype_vcpu_migrate_trigger)
 
 #undef __NR_syscalls
-#define __NR_syscalls 289
+//#define __NR_syscalls 289
+#define __NR_syscalls 400
 
 /*
  * All syscalls below here should go away really,
diff --git a/include/uapi/linux/kvm.h b/include/uapi/linux/kvm.h
index 376d0ab5b9f2..95413a0f52aa 100644
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@ -14,6 +14,10 @@
 
 #define KVM_API_VERSION 12
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#endif
+
 /* *** Deprecated interfaces *** */
 
 #define KVM_TRC_SHIFT           16
@@ -184,6 +188,10 @@ struct kvm_s390_skeys {
 #define KVM_EXIT_SYSTEM_EVENT     24
 #define KVM_EXIT_S390_STSI        25
 #define KVM_EXIT_IOAPIC_EOI       26
+#ifdef CONFIG_POPCORN_HYPE
+#define KVM_EXIT_POPHYPE_MIGRATE  78
+#define KVM_EXIT_REQ_POPHYPE_MIGRATE  79
+#endif
 
 /* For KVM_EXIT_INTERNAL_ERROR */
 /* Emulate instruction failed. */
@@ -351,11 +359,20 @@ struct kvm_run {
 	 */
 	__u64 kvm_valid_regs;
 	__u64 kvm_dirty_regs;
+#ifdef CONFIG_POPCORN_HYPE
+	/* pophype migration arg */
+	unsigned long a0;
+	unsigned long a1;
+#endif
 	union {
 		struct kvm_sync_regs regs;
 		char padding[2048];
 	} s;
+#if !GUEST_KERNEL_OPTIMIZE
 };
+#else
+}__attribute__((__aligned__(PAGE_SIZE))); /* TODO check this struct size */
+#endif
 
 /* for KVM_REGISTER_COALESCED_MMIO / KVM_UNREGISTER_COALESCED_MMIO */
 
@@ -458,6 +475,7 @@ struct kvm_vapic_addr {
 #define KVM_MP_STATE_CHECK_STOP        6
 #define KVM_MP_STATE_OPERATING         7
 #define KVM_MP_STATE_LOAD              8
+#define KVM_MP_STATE_UNKNOW            9 /* pophype unknow for debugging */
 
 struct kvm_mp_state {
 	__u32 mp_state;
diff --git a/include/uapi/linux/kvm_para.h b/include/uapi/linux/kvm_para.h
index bf6cd7d5cac2..2a9eaacd5f63 100644
--- a/include/uapi/linux/kvm_para.h
+++ b/include/uapi/linux/kvm_para.h
@@ -23,6 +23,9 @@
 #define KVM_HC_MIPS_GET_CLOCK_FREQ	6
 #define KVM_HC_MIPS_EXIT_VM		7
 #define KVM_HC_MIPS_CONSOLE_OUTPUT	8
+#define KVM_HC_POPHYPE_MIGRATE		10
+#define KVM_HC_POPHYPE_NET_DELEGATE	11
+#define KVM_HC_POPHYPE_NET_MSG_DELEGATE	12
 
 /*
  * hypercalls use architecture specific
diff --git a/include/uapi/linux/virtio_ring.h b/include/uapi/linux/virtio_ring.h
index c07295969b7e..47fcbbf0d0cb 100644
--- a/include/uapi/linux/virtio_ring.h
+++ b/include/uapi/linux/virtio_ring.h
@@ -37,6 +37,8 @@
 #include <linux/types.h>
 #include <linux/virtio_types.h>
 
+#include <popcorn/debug.h>
+
 /* This marks a buffer as continuing via the next field. */
 #define VRING_DESC_F_NEXT	1
 /* This marks a buffer as write-only (otherwise read-only). */
@@ -77,6 +79,12 @@ struct vring_desc {
 struct vring_avail {
 	__virtio16 flags;
 	__virtio16 idx;
+//#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL && POPHYPE_NET_OPTIMIZE
+#if POPHYPE_GUEST_NET_OPTIMIZE
+	/* TODO; also change vring_init() */
+//	char pad[4092]; // 4kB - 32b (4B) = 4092B
+#else
+#endif
 	__virtio16 ring[];
 };
 
@@ -91,8 +99,20 @@ struct vring_used_elem {
 struct vring_used {
 	__virtio16 flags;
 	__virtio16 idx;
+//#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL && POPHYPE_NET_OPTIMIZE
+#if POPHYPE_GUEST_NET_OPTIMIZE
+//	char pad[4092]; // 4kB - 32b (4B) = 4092B
+	//char pad[2046]; // 4kB - 32b (4B) = 4092B
+#endif
 	struct vring_used_elem ring[];
+//#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL && POPHYPE_NET_OPTIMIZE
+#if POPHYPE_GUEST_NET_OPTIMIZE
+//} __attribute__((packed, aligned(PAGE_SIZE))); /* aligned(PAGE_SIZE) will cause compiler error */
+} __attribute__((packed)); /* guest kernel unable to handle kernel paging reques (2 times) # looks ping working */
+//};
+#else
 };
+#endif
 
 struct vring {
 	unsigned int num;
@@ -146,17 +166,50 @@ static inline void vring_init(struct vring *vr, unsigned int num, void *p,
 	vr->num = num;
 	vr->desc = p;
 	vr->avail = p + num*sizeof(struct vring_desc);
+//#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL && POPHYPE_NET_OPTIMIZE
+#if POPHYPE_GUEST_NET_OPTIMIZE
+	/* Also check vring_size */
+	//vr->used = (void *)(((uintptr_t)&vr->avail->ring[num] + sizeof(__virtio16) + (sizeof(char) * 4092) // when avail padding ON
+	vr->used = (void *)(((uintptr_t)&vr->avail->ring[num] + sizeof(__virtio16)
+		+ align-1) & ~(align - 1));
+
+	POP_PK("pophype: net: %s %s(): [Jack] vr->used %p vr->avail %p "
+			"vring %p num %u *p %p align 0x%lx\n", // looks like cannot printk here?
+			__FILE__, __func__, vr->used, vr->avail, vr, num, p, align);
+    // align = VIRTIO_PCI_VRING_ALIGN
+	// pages = info->queue (info=virtio_pci_vq_info)
+#else
 	vr->used = (void *)(((uintptr_t)&vr->avail->ring[num] + sizeof(__virtio16)
 		+ align-1) & ~(align - 1));
+#endif
 }
 
 static inline unsigned vring_size(unsigned int num, unsigned long align)
 {
+//#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL && POPHYPE_NET_OPTIMIZE
+#if POPHYPE_GUEST_NET_OPTIMIZE
+	printk("%s(): [Jack] original %lu pophype %lu\n",
+			__func__,
+			((sizeof(struct vring_desc) * num + sizeof(__virtio16) * (3 + num)
+			 + align - 1) & ~(align - 1))
+			+ sizeof(__virtio16) * 3 + sizeof(struct vring_used_elem) * num
+			,
+			((sizeof(struct vring_desc) * num + sizeof(__virtio16) * (3 + num)
+			 + align - 1) & ~(align - 1))
+				+ sizeof(__virtio16) * 3 + sizeof(char) * 4092 + sizeof(struct vring_used_elem) * num
+			);
+	return ((sizeof(struct vring_desc) * num + sizeof(__virtio16) * (3 + num)
+		 + align - 1) & ~(align - 1))
+//			+ sizeof(__virtio16) * 3 + sizeof(char) * 4092 + sizeof(struct vring_used_elem) * num;
+			+ sizeof(__virtio16) * 3 + sizeof(struct vring_used_elem) * num;
+#else
 	return ((sizeof(struct vring_desc) * num + sizeof(__virtio16) * (3 + num)
 		 + align - 1) & ~(align - 1))
 		+ sizeof(__virtio16) * 3 + sizeof(struct vring_used_elem) * num;
+#endif
 }
 
+
 /* The following is used with USED_EVENT_IDX and AVAIL_EVENT_IDX */
 /* Assuming a given event_idx value from the other side, if
  * we have just incremented index from old to new_idx,
diff --git a/init/do_mounts.c b/init/do_mounts.c
index dea5de95c2dd..543072fffd8e 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -33,6 +33,11 @@
 #include <linux/nfs_fs_sb.h>
 #include <linux/nfs_mount.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+//#include <popcorn/bundle.h>
+#include <popcorn/debug.h>
+#endif
+
 #include "do_mounts.h"
 
 int __initdata rd_doload;	/* 1 = load RAM disk, 0 = don't load */
@@ -550,6 +555,12 @@ void __init prepare_namespace(void)
 {
 	int is_floppy;
 
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	GSMPBSPPRINTK("<%d> %s():\n", smp_processor_id(), __func__);
+#endif
+#endif
+
 	if (root_delay) {
 		printk(KERN_INFO "Waiting %d sec before mounting root device...\n",
 		       root_delay);
@@ -598,6 +609,14 @@ void __init prepare_namespace(void)
 		ROOT_DEV = Root_RAM0;
 
 	mount_root();
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	POP_PK("<%d> %s(): [mount disk time] after mount_root()\n",
+									smp_processor_id(), __func__);
+	//POP_PK("<%d> %s(): after mount_root()\n", smp_processor_id(), __func__);
+	//SMPPRINTK("<%d> %s(): after mount_root()\n", smp_processor_id(), __func__);
+#endif
+#endif
 out:
 	devtmpfs_mount("dev");
 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
diff --git a/init/do_mounts_rd.c b/init/do_mounts_rd.c
index e5d059e8aa11..44330f94143b 100644
--- a/init/do_mounts_rd.c
+++ b/init/do_mounts_rd.c
@@ -23,6 +23,9 @@
 
 #include <linux/decompress/generic.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/hype_kvm.h>
+#endif
 
 int __initdata rd_prompt = 1;/* 1 = prompt for RAM disk, 0 = don't prompt */
 
@@ -94,8 +97,18 @@ identify_ramdisk_image(int fd, int start_block, decompress_fn *decompressor)
 
 	*decompressor = decompress_method(buf, size, &compress_name);
 	if (compress_name) {
-		printk(KERN_NOTICE "RAMDISK: %s image found at block %d\n",
-		       compress_name, start_block);
+#if !POPHYPE_HOST_KERNEL
+		if (smp_processor_id()) {
+			printk("Force to set this process at cpu 0 on host."
+					"Otherwise, you will lose terminal control.\n");
+			pophype_set_cpu0();
+		}
+#endif
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK(KERN_NOTICE "<%d> [mount disk time] RAMDISK: "
+								"%s image found at block %d\n",
+		       smp_processor_id(), compress_name, start_block);
+#endif
 		if (!*decompressor)
 			printk(KERN_EMERG
 			       "RAMDISK: %s decompressor not configured!\n",
diff --git a/init/main.c b/init/main.c
index 49926d95442f..32fe2cb1c155 100644
--- a/init/main.c
+++ b/init/main.c
@@ -89,6 +89,14 @@
 #include <asm/sections.h>
 #include <asm/cacheflush.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+//#include <popcorn/bundle.h>
+#include <popcorn/types.h>
+#include <popcorn/debug.h>
+#include <popcorn/bundle.h>
+#include <popcorn/hype_kvm.h>
+#endif
+
 static int kernel_init(void *);
 
 extern void init_IRQ(void);
@@ -387,15 +395,34 @@ static __initdata DECLARE_COMPLETION(kthreadd_done);
 static noinline void __init_refok rest_init(void)
 {
 	int pid;
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	long int rc;
+#endif
+#endif
 
 	rcu_scheduler_starting();
 	smpboot_thread_init();
+#ifndef CONFIG_POPCORN_HYPE
 	/*
 	 * We need to spawn init first so that it obtains pid 1, however
 	 * the init task will end up wanting to create kthreads, which, if
 	 * we schedule it before we create kthreadd, will OOPS.
 	 */
 	kernel_thread(kernel_init, NULL, CLONE_FS);
+#else
+#if POPHYPE_HOST_KERNEL
+	kernel_thread(kernel_init, NULL, CLONE_FS);
+#else
+	POP_PK("\t<%d> pophype: %s(): pin \"kernel_init\" on bootcpu\n",
+								smp_processor_id(), __func__);
+	pid = kernel_thread(kernel_init, NULL, CLONE_FS);
+    rc = sched_setaffinity(pid, cpumask_of(0));
+	if (rc != 0)
+		pr_err("pophype: cannot set init affinity to boot cpu (%ld)\n", rc);
+#endif
+#endif
+
 	numa_default_policy();
 	pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);
 	rcu_read_lock();
@@ -409,6 +436,13 @@ static noinline void __init_refok rest_init(void)
 	 */
 	init_idle_bootup_task(current);
 	schedule_preempt_disabled();
+
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+    POP_PK("\t\t<%d> pophype: %s(): (BSP initing)\n",
+			smp_processor_id(), __func__);
+#endif
+#endif
 	/* Call into cpu_idle with preempt disabled */
 	cpu_startup_entry(CPUHP_ONLINE);
 }
@@ -496,11 +530,37 @@ static void __init mm_init(void)
 	kaiser_init();
 }
 
+#ifdef CONFIG_POPCORN_HYPE
+//extern bool **hype_callin;
+#endif
 asmlinkage __visible void __init start_kernel(void)
 {
 	char *command_line;
 	char *after_dashes;
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("%s(): LINUX KERNEL ENTRY at_remote %d <%d>\n",
+			__func__, current->at_remote, smp_processor_id());
+
+	POP_PK("%s(): HYPE_DEBUG_POINT_MAX %d\n", __func__, HYPE_DEBUG_POINT_MAX);
+	POP_PK("%s(): MAX_POPCORN_NODES %d\n", __func__, MAX_POPCORN_NODES);
+#if !POPHYPE_HOST_KERNEL
+//	{
+//	int i, j;
+//	POP_PK("%s(): guest init hype_callin[i][j]\n", __func__);
+//	for (i = 0; i < HYPE_DEBUG_POINT_MAX; i++)
+//		for (j = 0; j < MAX_POPCORN_NODES; j++)
+//			hype_callin[i][j] = false;
+//	}
+#endif
+
+	/* No BSP at remote */
+	if (distributed_remote_process(current)) {
+		printk(KERN_ERR "%s(): DIE DIE DIE\n", __func__);
+		BUG();
+	}
+#endif
+
 	/*
 	 * Need to run as early as possible, to initialize the
 	 * lockdep hash:
@@ -909,6 +969,28 @@ void __init load_default_modules(void)
 
 static int run_init_process(const char *init_filename)
 {
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	POP_PK("\t<%d> pophype: %s(): %s trying to save the world!! "
+			"(pophype setaffinity cpu 0)\n",
+			smp_processor_id(), __func__, init_filename);
+
+	pophype_set_cpu0();
+
+    //cpumask_var_t new_mask;
+	//BUG_ON(!alloc_cpumask_var(&new_mask, GFP_KERNEL)); /* return -ENOMEM; */
+	//cpumask_clear(new_mask);
+    //cpumask_set_cpu(0, new_mask);
+	//sched_setaffinity(current->pid, new_mask);
+	// BUG - no free
+
+	POP_PK("\t<%d> pophype: %s(): %s\n",
+			smp_processor_id(), __func__, init_filename);
+	/* before going to run first bash */
+	POP_INIT_TIME_PK("pophype: guest: [LAST] "
+					"This is guest kernel init time\n\n\n");
+#endif
+#endif
 	argv_init[0] = init_filename;
 	return do_execve(getname_kernel(init_filename),
 		(const char __user *const __user *)argv_init,
@@ -919,6 +1001,13 @@ static int try_to_run_init_process(const char *init_filename)
 {
 	int ret;
 
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	POP_PK("\t<%d> pophype: %s(): %s\n",
+			smp_processor_id(), __func__, init_filename);
+#endif
+#endif
+
 	ret = run_init_process(init_filename);
 
 	if (ret && ret != -ENOENT) {
@@ -944,6 +1033,11 @@ static int __ref kernel_init(void *unused)
 	numa_default_policy();
 
 	flush_delayed_fput();
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	POP_PK("\t<%d> pophype: %s(): t: - 1 try ramdisk first\n", smp_processor_id(), __func__);
+#endif
+#endif
 
 	if (ramdisk_execute_command) {
 		ret = run_init_process(ramdisk_execute_command);
@@ -953,6 +1047,13 @@ static int __ref kernel_init(void *unused)
 		       ramdisk_execute_command, ret);
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	POP_PK("\t<%d> pophype: %s(): t: - 2 good sign (2 free kmem done. "
+							"going to launch init process)\n",
+								smp_processor_id(), __func__);
+#endif
+#endif
 	/*
 	 * We try each of these until one succeeds.
 	 *
@@ -966,11 +1067,28 @@ static int __ref kernel_init(void *unused)
 		panic("Requested init %s failed (error %d).",
 		      execute_command, ret);
 	}
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	POP_PK("\t<%d> pophype: %s(): t: - 3\n", smp_processor_id(), __func__);
+#endif
+#endif
 	if (!try_to_run_init_process("/sbin/init") ||
 	    !try_to_run_init_process("/etc/init") ||
 	    !try_to_run_init_process("/bin/init") ||
-	    !try_to_run_init_process("/bin/sh"))
+	    !try_to_run_init_process("/bin/sh")) {
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+		POP_PK("\t<%d> pophype: %s(): t: cannot run_init_process\n",
+								smp_processor_id(), __func__);
+#endif
+#endif
 		return 0;
+	}
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	POP_PK("\t<%d> %s(): - 4\n", smp_processor_id(), __func__);
+#endif
+#endif
 
 	panic("No working init found.  Try passing init= option to kernel. "
 	      "See Linux Documentation/init.txt for guidance.");
@@ -978,6 +1096,14 @@ static int __ref kernel_init(void *unused)
 
 static noinline void __init kernel_init_freeable(void)
 {
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	POP_PK("\tpophype: <%d> %s(): I think this is the first smp work\n",
+			smp_processor_id(), __func__);
+	POP_PK("\tpophype: <%d> %s(): here is a open(/dev/console) "
+			"in guest kernel\n", smp_processor_id(), __func__);
+#endif
+#endif
 	/*
 	 * Wait until kthreadd is all set-up.
 	 */
@@ -1013,6 +1139,13 @@ static noinline void __init kernel_init_freeable(void)
 	if (sys_open((const char __user *) "/dev/console", O_RDWR, 0) < 0)
 		pr_err("Warning: unable to open an initial console.\n");
 
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	POP_PK("\t<%d> pophype: %s(): after open(/dev/console) "
+			"in guest kernel\n", smp_processor_id(), __func__);
+#endif
+#endif
+
 	(void) sys_dup(0);
 	(void) sys_dup(0);
 	/*
diff --git a/jack_frequent b/jack_frequent
new file mode 100644
index 000000000000..e834a82b54c5
--- /dev/null
+++ b/jack_frequent
@@ -0,0 +1,76 @@
+Notes:
+1. for easier vanilla code procedure debugging, don't put process_()
+
+boot:
+bsp ap arch/x86/kernel/smpboot.c
+ap arch/x86/kernel/cpu/common.c
+kernel/smp.c
+init/main.c
+
+cpu_callout_mask 1c75 ffffffff81c75c40 0x1c75c40
+bss_stop 1f1b
+
+smp:
+ap last call ./kernel/sched/idle.c
+
+sipi/ipi(icr):
+arch/x86/kvm/lapic.c
+
+
+
+mm:
+virt/kvm/kvm_main.c
+mm/gup.c
+
+arch/x86/kvm/mmu.c
+
+
+
+flush_tlb_mm->flush_tlb_mm_range->flush_tlb_others->native_flush_tlb_others->smp_call_function_many->flush_tlb_func->leave_mm():
+
+SMP doing TLB flush by communicating via IPI. Its relavant code and procedures:
+flush_tlb_mm->
+    flush_tlb_mm_range->
+        flush_tlb_others->
+            native_flush_tlb_others->
+                smp_call_function_many->
+                    smp_call_function_single->
+                        generic_exec_single->
+                            arch_send_call_function_single_ipi->
+                                send_call_func_single_ipi->
+                                    native_send_call_func_single_ipi->
+Final IPI sending via apic's send_IPI_mask interface
+
+
+more:
+lock
+Name:		kvm->srcu
+Type:		srcu lock
+Arch:		any
+Protects:	- kvm->memslots
+		- kvm->buses
+Comment:	The srcu read lock must be held while accessing memslots (e.g.
+		when using gfn_to_* functions) and while accessing in-kernel
+		MMIO/PIO address->device structure mapping (kvm->buses).
+		The srcu index can be stored in kvm_vcpu->srcu_idx per vcpu
+		if it is needed by multiple functions.`
+
+
+
+
+///////////////////// user space lkvm
+if include <popcorn/utils.h> in ./include/kvm/kvm-config.h
+vfio/core.c macro is not on
+
+[fd] - kvm 4 vcpu12
+
+// kernel
+// nr_cpu_ids is from bios/lkvm argv
+
+First (dummy) function an AP does - do_nothing();
+
+
+
+////////// others: arm64 aarch64 kernel
+./arch/arm64/include/asm/pgtable.h
+./arch/arm64/include/asm/pgtable-types.h
diff --git a/kernel/Kconfig.popcorn b/kernel/Kconfig.popcorn
index c6f67896cc30..b4d28213ee6f 100644
--- a/kernel/Kconfig.popcorn
+++ b/kernel/Kconfig.popcorn
@@ -13,6 +13,12 @@ config POPCORN
 
 if POPCORN
 
+config POPCORN_HYPE
+	bool "Popcorn hype features"
+	default y
+	help
+		Enable VM migration
+
 config POPCORN_DEBUG
 	bool "Log debug messages for Popcorn"
 	default n
@@ -39,6 +45,30 @@ config POPCORN_DEBUG_VERBOSE
 	depends on POPCORN_DEBUG
 	default n
 
+config POPCORN_DEBUG_HYPE
+	bool "Hype log (verbose)"
+	depends on POPCORN_DEBUG
+	default y
+
+config POPCORN_DEBUG_HYPE_EPT
+	bool "Hype EPT log (precise)"
+	depends on POPCORN_DEBUG
+	default n
+
+config POPCORN_DEBUG_HYPE_EPT_MORE
+	bool "Hype EPT log (more)"
+	depends on POPCORN_DEBUG_HYPE_EPT
+	default n
+
+config POPCORN_DEBUG_HYPE_EPT_VERBOSE
+	bool "Hype EPT log (verbose)"
+	depends on POPCORN_DEBUG_HYPE_EPT
+	default n
+
+config POPCORN_DEBUG_DEBUG
+	bool "Debug log (verbose)"
+	depends on POPCORN_DEBUG
+	default n
 
 config POPCORN_CHECK_SANITY
 	bool "Perform extra-sanity checks"
@@ -66,6 +96,10 @@ config POPCORN_STAT_PGFAULTS
 	depends on POPCORN_STAT
 	default n
 
+config POPCORN_STAT_MSG
+	bool "MSG handling"
+	depends on POPCORN_STAT
+	default n
 
 comment "Popcorn is not currently supported on this architecture"
 	depends on !ARCH_SUPPORTS_POPCORN
diff --git a/kernel/async.c b/kernel/async.c
index f1fd155abff6..8e0519595171 100644
--- a/kernel/async.c
+++ b/kernel/async.c
@@ -195,6 +195,11 @@ static async_cookie_t __async_schedule(async_func_t func, void *data, struct asy
 	current->flags |= PF_USED_ASYNC;
 
 	/* schedule for execution */
+#ifdef CONFIG_POPCORN_HYPE
+	WARN_ON_ONCE(-1);
+	printk(KERN_ERR
+		"Not expecting to see unbound_wq in pophype!! func %p\n", func);
+#endif
 	queue_work(system_unbound_wq, &entry->work);
 
 	return newcookie;
diff --git a/kernel/cpu.c b/kernel/cpu.c
index 40d20bf5de28..31f3b22aaff3 100644
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@ -26,6 +26,11 @@
 
 #include "smpboot.h"
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#include <linux/delay.h>
+#endif
+
 #ifdef CONFIG_SMP
 /* Serializes the updates to cpu_online_mask, cpu_present_mask */
 static DEFINE_MUTEX(cpu_add_remove_lock);
@@ -196,6 +201,9 @@ EXPORT_SYMBOL_GPL(cpu_hotplug_enable);
 int register_cpu_notifier(struct notifier_block *nb)
 {
 	int ret;
+#ifdef CONFIG_POPCORN_HYPE
+    NOTIFYCHAINPRINTK("%s(): <%d?> nb %p\n", __func__, smp_processor_id(), nb);
+#endif
 	cpu_maps_update_begin();
 	ret = raw_notifier_chain_register(&cpu_chain, nb);
 	cpu_maps_update_done();
@@ -204,6 +212,9 @@ int register_cpu_notifier(struct notifier_block *nb)
 
 int __register_cpu_notifier(struct notifier_block *nb)
 {
+#ifdef CONFIG_POPCORN_HYPE
+    NOTIFYCHAINPRINTK("%s(): <%d?> nb %p\n", __func__, smp_processor_id(), nb);
+#endif
 	return raw_notifier_chain_register(&cpu_chain, nb);
 }
 
@@ -458,6 +469,11 @@ static int smpboot_thread_call(struct notifier_block *nfb,
 {
 	int cpu = (long)hcpu;
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* See codes here include/linux/cpu.h */
+    POP_PK("\t\t%s(): <%d> 0x%lx (by .notifier_call)\n",
+			__func__, cpu, action & ~CPU_TASKS_FROZEN);
+#endif
 	switch (action & ~CPU_TASKS_FROZEN) {
 
 	case CPU_DOWN_FAILED:
@@ -507,6 +523,9 @@ static int _cpu_up(unsigned int cpu, int tasks_frozen)
 	if (ret)
 		goto out;
 
+#ifdef CONFIG_POPCORN_HYPE
+    POP_PK("<*> pophype: %s(): 0x03 > <%d>, enter native_cpu_up()\n", __func__, cpu);
+#endif
 	ret = __cpu_notify(CPU_UP_PREPARE | mod, hcpu, -1, &nr_calls);
 	if (ret) {
 		nr_calls--;
@@ -520,11 +539,45 @@ static int _cpu_up(unsigned int cpu, int tasks_frozen)
 
 	if (ret != 0)
 		goto out_notify;
+
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+    POP_PK("<*> cpu_online(cpu) 2nd last check - 16 <%d>\n", cpu);
+//    if (cpu != 1) {
+        POP_PK("%s(): <*> check cpu_online 2nd for <%d>\n", __func__, cpu);
+		BUG_ON(!cpu_online(cpu));
+//    } else {
+//        POP_PK("%s(): <*> skip check cpu_online 2nd for <%d>\n", __func__, cpu);
+//	}
+#else
+	BUG_ON(!cpu_online(cpu));
+#endif
+#else
 	BUG_ON(!cpu_online(cpu));
+#endif
 
+#ifdef CONFIG_POPCORN_HYPE
+    POP_PK("<*> %s(): 0x02 CPU_ONLINE > <%d> (this cause ICR)\n",
+														__func__, cpu);
+#if !POPHYPE_HOST_KERNEL
+    POP_PK("<*> %s(): > <%d> (this cause ICR) - 1 START\n",
+														__func__, cpu);
+    //POP_PK("<*> %s(): > <%d> sleep 2s - 1 START\n", __func__, cpu);
+	//msleep(2 * 1000);
+#endif
+#endif
 	/* Now call notifier in preparation. */
 	cpu_notify(CPU_ONLINE | mod, hcpu);
 
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+    POP_PK("<*> %s(): > <%d> (this cause ICR) - 2 END\n",
+														__func__, cpu);
+    //POP_PK("<*> %s(): > <%d> sleep 2s - 2 END\n", __func__, cpu);
+	//msleep(2 * 1000);
+#endif
+#endif
+
 out_notify:
 	if (ret != 0)
 		__cpu_notify(CPU_UP_CANCELED | mod, hcpu, nr_calls, NULL);
@@ -720,12 +773,21 @@ core_initcall(cpu_hotplug_pm_sync_init);
 void notify_cpu_starting(unsigned int cpu)
 {
 	unsigned long val = CPU_STARTING;
+#ifdef CONFIG_POPCORN_HYPE
+	int ret;
+#endif
 
 #ifdef CONFIG_PM_SLEEP_SMP
 	if (frozen_cpus != NULL && cpumask_test_cpu(cpu, frozen_cpus))
 		val = CPU_STARTING_FROZEN;
 #endif /* CONFIG_PM_SLEEP_SMP */
+#ifdef CONFIG_POPCORN_HYPE
+	ret = cpu_notify(val, (void *)(long)cpu);
+	POP_PK("%s(): AP <%d> did cpu_call_chain %s ret %d\n",
+			__func__, cpu, ret ? "bad" : "good(only locally TODO all)", ret);
+#else
 	cpu_notify(val, (void *)(long)cpu);
+#endif
 }
 
 #endif /* CONFIG_SMP */
diff --git a/kernel/fork.c b/kernel/fork.c
index 5b4a83a1b71d..14688e9e09f4 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -454,6 +454,9 @@ static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)
 	int retval;
 	unsigned long charge;
 
+#ifdef CONFIG_POPCORN_HYPE
+    if (distributed_process(current)) { BUG(); } // $$$
+#endif
 	uprobe_start_dup_mmap();
 	down_write(&oldmm->mmap_sem);
 	flush_cache_dup_mm(oldmm);
@@ -595,6 +598,9 @@ static inline void mm_free_pgd(struct mm_struct *mm)
 #else
 static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)
 {
+#ifdef CONFIG_POPCORN_HYPE
+    if (distributed_process(current)) { BUG(); } // $$$
+#endif
 	down_write(&oldmm->mmap_sem);
 	RCU_INIT_POINTER(mm->exe_file, get_mm_exe_file(oldmm));
 	up_write(&oldmm->mmap_sem);
diff --git a/kernel/futex.c b/kernel/futex.c
index 407aab2792dc..5220679f122b 100644
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@ -3238,11 +3238,20 @@ long do_futex(u32 __user *uaddr, int op, u32 val, ktime_t *timeout,
 
 #ifdef CONFIG_POPCORN
 	if (distributed_process(current)) {
-		// printk("  [%d] F %x %x %x %p\n", current->pid, op, flags, val, uaddr);
-		WARN_ON(cmd != FUTEX_WAIT &&
-				cmd != FUTEX_WAIT_BITSET &&
-				cmd != FUTEX_WAKE &&
-				cmd != FUTEX_WAKE_BITSET);
+        // printk("  [%d] F %x %x %x %p\n", current->pid, op, flags, val, uaddr);
+//      WARN_ON(cmd != FUTEX_WAIT &&
+//              cmd != FUTEX_WAIT_BITSET &&
+//              cmd != FUTEX_WAKE &&
+//              cmd != FUTEX_WAKE_BITSET);
+        if (cmd != FUTEX_WAIT &&
+                cmd != FUTEX_WAIT_BITSET &&
+                cmd != FUTEX_WAKE &&
+                cmd != FUTEX_WAKE_BITSET) {
+            printk("  [%d] FUTEX %x %x %x %p cmd %d\n",
+                    current->pid, op, flags, val, uaddr, cmd);
+            //printk("FUXTEX cmd %d \n", cmd);
+            __WARN(); /* Pophype - net-mq touches FUTEX_WAKE_OP cmd 5 */
+        }
 	}
 #endif
 
diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index 74d90a754268..a0c753d9e11b 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -3,6 +3,8 @@
 #include <linux/device.h>
 #include <linux/gfp.h>
 
+#include <popcorn/debug.h>
+
 /*
  * Device resource management aware IRQ request/free implementation.
  */
@@ -57,6 +59,19 @@ int devm_request_threaded_irq(struct device *dev, unsigned int irq,
 	if (!dr)
 		return -ENOMEM;
 
+#ifdef CONFIG_POPCORN_HYPE
+#if 0
+	static int cnt = 0;
+	if (irq == HOST_X86_UART || irq == GUEST_X86_UART || cnt < 1000) {
+		cnt++;
+		if (cnt < 10000) {
+			UARTPRINTK("%s(): pop_uart dev irq %d name %s thread %p #%d\n",
+									__func__, irq, "TODO", thread_fn, cnt);
+		}
+	}
+#endif
+#endif
+
 	rc = request_threaded_irq(irq, handler, thread_fn, irqflags, devname,
 				  dev_id);
 	if (rc) {
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 5f55a8bf5264..8ac1c23c1659 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -21,6 +21,9 @@
 
 #include "internals.h"
 
+#include <popcorn/bundle.h>
+#include <popcorn/debug.h>
+
 #ifdef CONFIG_IRQ_FORCED_THREADING
 __read_mostly bool force_irqthreads;
 
@@ -189,6 +192,18 @@ int irq_do_set_affinity(struct irq_data *data, const struct cpumask *mask,
 	int ret;
 
 	ret = chip->irq_set_affinity(data, mask, force);
+#ifdef CONFIG_POPCORN_HYPE
+	/* many */
+	if (desc && chip) {
+		VPCINETPRINTK("\tpophype: virtio: pci: net: [%d] <%d> %s(): "
+				"irq %u chip->irq_set_affinity %p ret %d mask %*pb "
+				"(24:virtio0-config 25:virtio0-input.0 26:virtio0-output.0)\n",
+				current->pid, smp_processor_id(), __func__,
+				desc->irq_data.irq, chip->irq_set_affinity,
+				ret, cpumask_pr_args(mask));
+	}
+	/* the next line */
+#endif
 	switch (ret) {
 	case IRQ_SET_MASK_OK:
 	case IRQ_SET_MASK_OK_DONE:
@@ -335,6 +350,14 @@ static int setup_affinity(struct irq_desc *desc, struct cpumask *mask)
 	struct cpumask *set = irq_default_affinity;
 	int node = irq_desc_get_node(desc);
 
+#ifdef CONFIG_POPCORN_HYPE
+	unsigned int irq = desc->irq_data.irq;
+	if (irq == HOST_X86_UART || irq == GUEST_X86_UART || irq == GUEST_X86_NET) {
+		UARTPRINTK("\t[%d] %s(): pop_uart irq %u looks like "
+					"a default smp affinity\n",
+					current->pid, __func__, irq);
+	}
+#endif
 	/* Excludes PER_CPU and NO_BALANCE interrupts */
 	if (!__irq_can_set_affinity(desc))
 		return 0;
@@ -1062,6 +1085,10 @@ setup_irq_thread(struct irqaction *new, unsigned int irq, bool secondary)
 		.sched_priority = MAX_USER_RT_PRIO/2,
 	};
 
+#ifdef CONFIG_POPCORN_HYPE
+	printk("[pophype irq][%d] %s(): create thread for irq %u\n",
+										current->pid, __func__, irq);
+#endif
 	if (!secondary) {
 		t = kthread_create(irq_thread, new, "irq/%d-%s", irq,
 				   new->name);
@@ -1317,6 +1344,14 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 			irqd_set(&desc->irq_data, IRQD_NO_BALANCING);
 		}
 
+#ifdef CONFIG_POPCORN_HYPE
+		/* mask not yet installed */
+		IRQINITPK("[pophype irq][%d] %s(): "
+				//"first action does init irq %u - setup affinity mask %pbc\n",
+				//						current->pid, __func__, irq, mask);
+				"first action does init irq %u - setup affinity\n",
+						current->pid, __func__, irq);
+#endif
 		/* Set default affinity mask once everything is setup */
 		setup_affinity(desc, mask);
 
@@ -1330,6 +1365,9 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 				   irq, nmsk, omsk);
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* in stall new action in to desc */
+#endif
 	*old_ptr = new;
 
 	irq_pm_install_action(desc, new);
@@ -1358,6 +1396,12 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 	if (new->secondary)
 		wake_up_process(new->secondary->thread);
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (irq == HOST_X86_UART || irq == GUEST_X86_UART || irq == GUEST_X86_NET) {
+		UARTPRINTK("\t%s(): pop_uart irq %u (many src)\n", __func__, irq);
+	}
+#endif
+
 	register_irq_proc(irq, desc);
 	new->dir = NULL;
 	register_handler_proc(irq, new);
diff --git a/kernel/irq/migration.c b/kernel/irq/migration.c
index 37ddb7bda651..4226acbf3fe8 100644
--- a/kernel/irq/migration.c
+++ b/kernel/irq/migration.c
@@ -4,6 +4,8 @@
 
 #include "internals.h"
 
+#include <popcorn/debug.h>
+
 void irq_move_masked_irq(struct irq_data *idata)
 {
 	struct irq_desc *desc = irq_data_to_desc(idata);
@@ -30,6 +32,10 @@ void irq_move_masked_irq(struct irq_data *idata)
 
 	assert_raw_spin_locked(&desc->lock);
 
+#ifdef CONFIG_POPCORN_HYPE
+    VPCINETPRINTK("\tpophype: virtio: pci: net: <%d> %s(): real culprit irq %u\n",
+							smp_processor_id(), __func__, desc->irq_data.irq);
+#endif
 	/*
 	 * If there was a valid mask to work with, please
 	 * do the disable, re-program, enable sequence.
diff --git a/kernel/irq/msi.c b/kernel/irq/msi.c
index cd6009006510..6cf06ef25c2f 100644
--- a/kernel/irq/msi.c
+++ b/kernel/irq/msi.c
@@ -18,6 +18,8 @@
 /* Temparory solution for building, will be removed later */
 #include <linux/pci.h>
 
+#include <popcorn/debug.h>
+
 struct msi_desc *alloc_msi_entry(struct device *dev)
 {
 	struct msi_desc *desc = kzalloc(sizeof(*desc), GFP_KERNEL);
@@ -77,6 +79,14 @@ int msi_domain_set_affinity(struct irq_data *irq_data,
 		irq_chip_write_msi_msg(irq_data, &msg);
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (irq_data->irq == HOST_X86_UART || irq_data->irq == GUEST_X86_UART ||
+		irq_data->irq == GUEST_X86_NET)
+		AFFPRINTK("%s(): pop_aff irq %u hwirq %lu "
+			"(24:virtio0-config 25:virtio0-input.0 26:virtio0-output.0)\n",
+			__func__, irq_data->irq, irq_data->hwirq);
+#endif
+
 	return ret;
 }
 
diff --git a/kernel/irq/proc.c b/kernel/irq/proc.c
index a2c02fd5d6d0..ef022e73c6a7 100644
--- a/kernel/irq/proc.c
+++ b/kernel/irq/proc.c
@@ -14,8 +14,14 @@
 #include <linux/kernel_stat.h>
 #include <linux/mutex.h>
 
-#include "internals.h"
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/bundle.h>
+#include <popcorn/debug.h>
+#else /* Support for vanilla*/
+#include <popcorn/debug.h>
+#endif
 
+#include "internals.h"
 /*
  * Access rules:
  *
@@ -42,14 +48,25 @@ static int show_irq_affinity(int type, struct seq_file *m, void *v)
 	struct irq_desc *desc = irq_to_desc((long)m->private);
 	const struct cpumask *mask = desc->irq_common_data.affinity;
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	//unsigned int irq = desc->irq_data.irq;
+	IRQPROCPRINTK("\t\t[%d] %s(): read/show/open type %d "
+			"(irq_desc is the meta data for irq in kernel)\n",
+								current->pid, __func__, type);
+#endif
 #ifdef CONFIG_GENERIC_PENDING_IRQ
-	if (irqd_is_setaffinity_pending(&desc->irq_data))
+	if (irqd_is_setaffinity_pending(&desc->irq_data)) {
 		mask = desc->pending_mask;
+#if !POPHYPE_HOST_KERNEL
+		IRQPROCPRINTK("irq affinity overwritten by desc->pending_mask %*pb\n",
+										cpumask_pr_args(desc->pending_mask));
+#endif
+	}
 #endif
 	if (type)
-		seq_printf(m, "%*pbl\n", cpumask_pr_args(mask));
+		seq_printf(m, "%*pbl\n", cpumask_pr_args(mask)); /* irq/<>/smp_affinity_list */
 	else
-		seq_printf(m, "%*pb\n", cpumask_pr_args(mask));
+		seq_printf(m, "%*pb\n", cpumask_pr_args(mask)); /* irq/<>/smp_affinity */
 	return 0;
 }
 
@@ -58,15 +75,70 @@ static int irq_affinity_hint_proc_show(struct seq_file *m, void *v)
 	struct irq_desc *desc = irq_to_desc((long)m->private);
 	unsigned long flags;
 	cpumask_var_t mask;
+#if !POPHYPE_HOST_KERNEL
+	unsigned int irq = desc->irq_data.irq;
+	if (irq == HOST_X86_UART || irq == GUEST_X86_UART || irq == GUEST_X86_NET)
+		IRQPROCPRINTK("%s(): pop_irqproc irq %u (no hope)\n",
+										__func__, irq);
+#endif
 
 	if (!zalloc_cpumask_var(&mask, GFP_KERNEL))
 		return -ENOMEM;
 
 	raw_spin_lock_irqsave(&desc->lock, flags);
-	if (desc->affinity_hint)
+	if (desc->affinity_hint) {
+#if !POPHYPE_HOST_KERNEL
+		if (irq == HOST_X86_UART || irq == GUEST_X86_UART ||
+			irq == GUEST_X86_NET) { /* not used */
+			IRQPROCPRINTK("%s(): pop_irqproc irq %u "
+						"uses affinity_hint (no hope)\n", __func__, irq);
+		}
+#endif
 		cpumask_copy(mask, desc->affinity_hint);
+	}
 	raw_spin_unlock_irqrestore(&desc->lock, flags);
 
+#if !POPHYPE_HOST_KERNEL
+	IRQPROCPRINTK("%s(): preparing to overwrit irq %u\n", __func__, irq);
+	if (irq == GUEST_X86_NET) {
+		if (irq_can_set_affinity(irq)) {
+			//desc->irq_common_data.affinity
+			//(irq_common_data.affinity, );
+			//IRQPROCPRINTK("%s(): don't care hint, overwriting irq %u to 1\n",
+			//													__func__, irq);
+			IRQPROCPRINTK("%s(): overwriting irq %u "
+						"hint & affinity to 1 (hardcoded)\n", __func__, irq);
+
+			IRQPROCPRINTK("%s(): check: bf: affinity cpu %*pbl %*pb\n",
+					__func__, cpumask_pr_args(desc->irq_common_data.affinity),
+					cpumask_pr_args(desc->irq_common_data.affinity));
+			irq_set_affinity(irq, cpumask_of(1));
+			IRQPROCPRINTK("%s(): check: af1: affinity cpu %*pbl %*pb\n",
+					__func__, cpumask_pr_args(desc->irq_common_data.affinity),
+					cpumask_pr_args(desc->irq_common_data.affinity));
+
+			cpumask_copy(desc->irq_common_data.affinity, cpumask_of(1));
+			IRQPROCPRINTK("%s(): check: af2: affinity cpu %*pbl %*pb\n",
+					__func__, cpumask_pr_args(desc->irq_common_data.affinity),
+					cpumask_pr_args(desc->irq_common_data.affinity));
+
+			//cpumask_copy(desc->affinity_hint, cpumask_of(1));
+			//IRQPROCPRINTK("%s(): do this at least 2 times "
+			//			"BUT hint is const........\n", __func__);
+			if (desc->affinity_notify) {
+				IRQPROCPRINTK("%s(): check desc->affinity_notify->notify %p\n",
+									__func__, desc->affinity_notify->notify);
+			} else {
+				IRQPROCPRINTK("%s(): check "
+					"!desc->affinity_notify(->notify) %p\n", __func__, NULL);
+			}
+			IRQPROCPRINTK("%s(): try irq balance disable but how?\n", __func__);
+		} else {
+			IRQPROCPRINTK("%s(): CANNOT set irq affinity\n", __func__);
+		}
+	}
+#endif
+
 	seq_printf(m, "%*pb\n", cpumask_pr_args(mask));
 	free_cpumask_var(mask);
 
@@ -96,11 +168,108 @@ static ssize_t write_irq_affinity(int type, struct file *file,
 	cpumask_var_t new_value;
 	int err;
 
-	if (!irq_can_set_affinity(irq) || no_irq_affinity)
+#if !POPHYPE_HOST_KERNEL
+	IRQPROCPRINTK("\t\t[%d] %s(): set irq %u as ??? type %d\n",
+							current->pid, __func__, irq, type);
+#endif
+	if (!irq_can_set_affinity(irq) || no_irq_affinity) {
+//#if !POPHYPE_HOST_KERNEL
+#ifdef CONFIG_POPCORN_HYPE
+#if 0
+		/* patch: echo "" > /proc/irq/ && no set_affinity callback func */
+		/* echo */
+		if (irq == HOST_X86_UART || irq == GUEST_X86_UART) {
+			int count = 1;
+			cpumask_var_t tmpmask;
+			struct irq_desc *desc = irq_to_desc(irq);
+			IRQPROCPRINTK("\t\t[%d] %s(): irq %d return 1 cannot set %d "
+					"no affi %d \n\t\t\t\t"
+					"irqd_can_balance() ret %d   "
+					"1 %d 2 %d 3 %d 4 %d (1problem)\n",
+					current->pid, __func__, irq,
+					!irq_can_set_affinity(irq), no_irq_affinity,
+						!desc || !irqd_can_balance(&desc->irq_data) ||
+							!desc->irq_data.chip ||
+								!desc->irq_data.chip->irq_set_affinity ? 0 : 1,
+					!desc, !irqd_can_balance(&desc->irq_data),
+					!desc->irq_data.chip,
+					!desc->irq_data.chip->irq_set_affinity);
+			// ...... no call back function...
+			IRQPROCPRINTK("\t\t[%d] %s(): irq %u no callback -> rollback\n",
+										current->pid, __func__, irq);
+
+			if (!alloc_cpumask_var(&tmpmask, GFP_KERNEL))
+				return -ENOMEM;
+			cpumask_clear(tmpmask);
+			if (cpumask_parse_user(buffer, count, tmpmask))
+			//err = cpumask_parse(buffer, tmpmask);
+				return -ENOMEM;
+
+			/* hardcoded */
+			//cpumask_set_cpu(0, tmpmask); // pin the irq on cpu0. cpumask = 1
+			//cpumask_set_cpu(1, tmpmask);
+
+			IRQPROCPRINTK("\tpop_irqproc get a irq affinity from usr: %*pb "
+							"test nr_cpumask_bits %d\n",
+							cpumask_pr_args(tmpmask), nr_cpumask_bits);
+
+			/* default*/
+			// mask = desc->irq_common_data.affinity
+			// cpumask_var_t irq_default_affinity; /* global in kernel/irq/manage.c and used for default_affinity_show */
+
+			/* now. write it */
+			if (desc->affinity_hint)
+				cpumask_copy(desc->affinity_hint,
+						(const struct cpumask *)tmpmask); // update aff_hint
+			else
+				IRQPROCPRINTK("\tpop_irqproc CANNOT SET desc-> "
+									"irq_common_data.affinity\n");
+
+			/* write/set desc->irq_common_data.affinity  */
+			//cpumask_copy(mask, tmpmask); // update mask // cannot write directly so write indrectly
+			cpumask_copy(desc->irq_common_data.affinity, tmpmask); // update mask // cannot write directly so write indrectly
+			IRQPROCPRINTK("\tpop_irqproc set irq affinity ->.aff: %*pb\n",
+								cpumask_pr_args(desc->irq_common_data.affinity));
+			//IRQPROCPRINTK("\tpop_irqproc set irq affinity mask: %*pb\n",
+			//										cpumask_pr_args(mask));
+			IRQPROCPRINTK("\n");
+
+			free_cpumask_var(tmpmask);
+		}
+#endif
+#endif
 		return -EIO;
+	}
 
-	if (!alloc_cpumask_var(&new_value, GFP_KERNEL))
+#ifdef CONFIG_POPCORN_HYPE
+	//debug
+	{
+		struct irq_desc *desc = irq_to_desc(irq);
+		if (desc) {
+			if (desc->irq_data.chip) {
+				if (desc->irq_data.chip->irq_set_affinity) {
+					AFFPRINTK("%s() check: smp_irq_set_affinity_callback() %p name %s\n",
+							__func__, desc->irq_data.chip->irq_set_affinity,
+										desc->irq_data.chip->name);
+				} else {
+					AFFPRINTK("%s() check: !smp_irq_set_affinity_callback() \n", __func__);
+				}
+			} else {
+				AFFPRINTK("%s() check: !desc->irq_data.chip case\n", __func__);
+			}
+		} else {
+			AFFPRINTK("%s() check: !desc case\n", __func__);
+		}
+	}
+#endif
+
+	if (!alloc_cpumask_var(&new_value, GFP_KERNEL)) {
+#if !POPHYPE_HOST_KERNEL
+		IRQPROCPRINTK("\t\t[%d] %s(): irq %d return 1\n",
+							current->pid, __func__, irq);
+#endif
 		return -ENOMEM;
+	}
 
 	if (type)
 		err = cpumask_parselist_user(buffer, count, new_value);
@@ -110,6 +279,10 @@ static ssize_t write_irq_affinity(int type, struct file *file,
 		goto free_cpumask;
 
 	if (!is_affinity_mask_valid(new_value)) {
+#if !POPHYPE_HOST_KERNEL
+		IRQPROCPRINTK("\t\t[%d] %s(): irq %d return 1\n",
+							current->pid, __func__, irq);
+#endif
 		err = -EINVAL;
 		goto free_cpumask;
 	}
@@ -124,7 +297,18 @@ static ssize_t write_irq_affinity(int type, struct file *file,
 		   code to set default SMP affinity. */
 		err = irq_select_affinity_usr(irq, new_value) ? -EINVAL : count;
 	} else {
+#if !POPHYPE_HOST_KERNEL
+#if 0
+		/* x86: ioapic_set_affinity */
+		int ret = irq_set_affinity(irq, new_value);
+		IRQPROCPRINTK("\t\t[%d] %s(): set irq %d as ??? ret %d\n",
+								current->pid, __func__, irq, ret);
+#else
 		irq_set_affinity(irq, new_value);
+#endif
+#else
+		irq_set_affinity(irq, new_value);
+#endif
 		err = count;
 	}
 
@@ -363,6 +547,10 @@ void register_irq_proc(unsigned int irq, struct irq_desc *desc)
 
 	proc_create_data("node", 0444, desc->dir,
 			 &irq_node_proc_fops, (void *)(long)irq);
+#ifdef CONFIG_POPCORN_HYPE
+	if (irq == HOST_X86_UART || irq == GUEST_X86_UART || irq == GUEST_X86_NET)
+		IRQPROCPRINTK("\t%s(): pop_irqproc irq %u create irq/affinity_hint!\n", __func__, irq);
+#endif
 #endif
 
 	proc_create_data("spurious", 0444, desc->dir,
diff --git a/kernel/locking/lockdep.c b/kernel/locking/lockdep.c
index 0e2c4911ba61..3c137250d39c 100644
--- a/kernel/locking/lockdep.c
+++ b/kernel/locking/lockdep.c
@@ -53,6 +53,11 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/lock.h>
 
+#ifdef CONFIG_POPCORN
+#include <popcorn/types.h>
+#include <popcorn/debug.h>
+#endif
+
 #ifdef CONFIG_PROVE_LOCKING
 int prove_locking = 1;
 module_param(prove_locking, int, 0644);
@@ -3386,8 +3391,15 @@ __lock_release(struct lockdep_map *lock, int nested, unsigned long ip)
 	 * So we're all set to release this lock.. wait what lock? We don't
 	 * own any locks, you've been drinking again?
 	 */
-	if (DEBUG_LOCKS_WARN_ON(depth <= 0))
+	if (DEBUG_LOCKS_WARN_ON(depth <= 0)) {
+#ifdef CONFIG_POPCORN_HYPE
+		if (distributed_process(current)) {
+			printk("lk: [%d] UNLOCK FAIL %p ip %lx\n",
+								current->pid, lock, ip);
+		}
+#endif
 		 return print_unlock_imbalance_bug(curr, lock, ip);
+	}
 
 	/*
 	 * Check whether the lock exists in the current stack
diff --git a/kernel/locking/rwsem.c b/kernel/locking/rwsem.c
index 205be0ce34de..e9a8e055484c 100644
--- a/kernel/locking/rwsem.c
+++ b/kernel/locking/rwsem.c
@@ -13,11 +13,43 @@
 
 #include "rwsem.h"
 
+#ifdef CONFIG_POPCORN
+#include <popcorn/types.h>
+#include <popcorn/debug.h>
+#endif
 /*
  * lock for reading
  */
 void __sched down_read(struct rw_semaphore *sem)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	static unsigned long down_read_cnt = 0;
+	unsigned long limit_down_read_cnt = 0;
+	if (distributed_process(current) &&
+		!(_RET_IP_ > 0xffffffff81450000) &&
+		_RET_IP_ != 0xffffffff81450a61 &&
+		_RET_IP_ != 0xffffffff81450b61 &&
+		_RET_IP_ != 0xffffffff81456dfa &&
+		_RET_IP_ != 0xffffffff81456f0a) {
+		down_read_cnt++;
+		if (current->at_remote) {
+			//limit_down_read_cnt = 1048500; /* trying to find a good value */
+			//limit_down_read_cnt = 948500;
+			limit_down_read_cnt = 0; // 1xxxxx
+		} else {
+			//limit_down_read_cnt = 1048655;
+			//limit_down_read_cnt = 40000; // 4xxxxx
+			limit_down_read_cnt = 47000; // 47491
+		}
+		if (down_read_cnt > limit_down_read_cnt ||
+			!(down_read_cnt % 10000) // testing
+			) {
+			LKPRINTK("lk: [%d] LOCK %p %lx #%lu\n",
+					current->pid, sem, //(void *)&sem->dep_map,
+					_RET_IP_, down_read_cnt);
+		}
+	}
+#endif
 	might_sleep();
 	rwsem_acquire_read(&sem->dep_map, 0, 0, _RET_IP_);
 
@@ -32,9 +64,37 @@ EXPORT_SYMBOL(down_read);
 int down_read_trylock(struct rw_semaphore *sem)
 {
 	int ret = __down_read_trylock(sem);
+#ifdef CONFIG_POPCORN_HYPE
+	static unsigned long try_down_read_cnt = 0;
+	unsigned long limit_try_down_read_cnt = 0;
+#endif
 
-	if (ret == 1)
+	if (ret == 1) {
+#ifdef CONFIG_POPCORN_HYPE
+		if (distributed_process(current) &&
+			!(_RET_IP_ > 0xffffffff81450000) &&
+			_RET_IP_ != 0xffffffff81450a61 && // 5tty
+			_RET_IP_ != 0xffffffff81450b61 && // 5tty
+			_RET_IP_ != 0xffffffff81456dfa && // 4tty
+			_RET_IP_ != 0xffffffff81456f0a) { // 4tty
+			try_down_read_cnt++;
+			if (current->at_remote) {
+				limit_try_down_read_cnt = 1048500;
+			} else {
+				//limit_try_down_read_cnt = 1048655;
+				//limit_try_down_read_cnt = 1053413;
+				//limit_try_down_read_cnt = 1093181;
+				limit_try_down_read_cnt = 1094616;
+			}
+			if (try_down_read_cnt > limit_try_down_read_cnt) {
+				LKPRINTK("lk: [%d] try succ LOCK %p %lx #%lu\n",
+						current->pid, sem, //(void *)&sem->dep_map,
+									_RET_IP_, try_down_read_cnt);
+			}
+		}
+#endif
 		rwsem_acquire_read(&sem->dep_map, 0, 1, _RET_IP_);
+	}
 	return ret;
 }
 
@@ -76,6 +136,41 @@ EXPORT_SYMBOL(down_write_trylock);
  */
 void up_read(struct rw_semaphore *sem)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	static unsigned long up_read_cnt = 0;
+	unsigned long limit_up_read_cnt = 0;
+	if (distributed_process(current) &&
+		!(_RET_IP_ > 0xffffffff81450000) &&
+		_RET_IP_ != 0xffffffff81450a61 &&
+		_RET_IP_ != 0xffffffff81450b61 &&
+		_RET_IP_ != 0xffffffff81456dfa &&
+		_RET_IP_ != 0xffffffff81456f0a) {
+		up_read_cnt++;
+		if (current->at_remote) {
+			limit_up_read_cnt = 1048646;
+		} else {
+			//limit_up_read_cnt = 1048747;
+			//limit_up_read_cnt = 1145400;
+			//limit_up_read_cnt = 1125666;
+			limit_up_read_cnt = 1140503; // good to see origin kernel log and other logs
+			//limit_up_read_cnt = 1142400; // good to see origin kernel log
+			//limit_up_read_cnt = 1151800; // start from sipi
+		}
+		if (up_read_cnt > limit_up_read_cnt) {
+			LKPRINTK("lk: [%d] UNLOCK %p %s%lx%s #%lu\n",
+				current->pid, sem, //(void *)&sem->dep_map,
+				/* 0xffffffff810ad239 try succ LOCK origin */
+				_RET_IP_ == 0xffffffff810ad239 || _RET_IP_ == 0xffffffff810ad2e3 ?
+					"$$[[[" : "",
+				_RET_IP_,
+				_RET_IP_ == 0xffffffff810ad239 || _RET_IP_ == 0xffffffff810ad2e3?
+					"]]]" : "",
+				up_read_cnt);
+		}
+		//if (up_read_cnt > 1153750 && up_read_cnt < 1153950)
+		//	dump_stack();
+	}
+#endif
 	rwsem_release(&sem->dep_map, 1, _RET_IP_);
 
 	__up_read(sem);
diff --git a/kernel/locking/rwsem.h b/kernel/locking/rwsem.h
index 870ed9a5b426..251e6eded13e 100644
--- a/kernel/locking/rwsem.h
+++ b/kernel/locking/rwsem.h
@@ -1,11 +1,30 @@
 #ifdef CONFIG_RWSEM_SPIN_ON_OWNER
+#include <popcorn/types.h>
 static inline void rwsem_set_owner(struct rw_semaphore *sem)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	static unsigned long cnt = 0;
+	//if (cnt > 100000)
+	if (distributed_remote_process(current)) {
+		if (cnt >= 0) {
+			LKPRINTK("[%d] (down_write->)rwsem_set_owner cnt %ld #%lu\n", current->pid, sem->count, ++cnt);
+		}
+	}
+#endif
 	sem->owner = current;
 }
 
 static inline void rwsem_clear_owner(struct rw_semaphore *sem)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	static unsigned long cnt = 0;
+	//if (cnt > 100000)
+	if (distributed_remote_process(current)) {
+		if (cnt >= 0) {
+			LKPRINTK("[%d] (up_write->)rwsem_clear_owner cnt %ld #%lu\n", current->pid, sem->count, ++cnt);
+		}
+	}
+#endif
 	sem->owner = NULL;
 }
 
diff --git a/kernel/notifier.c b/kernel/notifier.c
index fd2c9acbcc19..0ae2829af654 100644
--- a/kernel/notifier.c
+++ b/kernel/notifier.c
@@ -90,6 +90,11 @@ static int notifier_call_chain(struct notifier_block **nl,
 			continue;
 		}
 #endif
+
+#ifdef CONFIG_POPCORN_HYPE
+		// 0x02 CPUONLINE and nb->notifier_call -> kvm_cpu_notify()
+		//						-> smp_call_function_single()
+#endif
 		ret = nb->notifier_call(nb, val, v);
 
 		if (nr_calls)
diff --git a/kernel/popcorn/Makefile b/kernel/popcorn/Makefile
index 674c4c575f8b..413e73133bd1 100644
--- a/kernel/popcorn/Makefile
+++ b/kernel/popcorn/Makefile
@@ -1,4 +1,4 @@
-obj-$(CONFIG_POPCORN)	+= init.o util.o
+obj-$(CONFIG_POPCORN)	+= init.o util.o timer.o
 obj-$(CONFIG_POPCORN)	+= wait_station.o
 obj-$(CONFIG_POPCORN)	+= sched_server.o process_server.o vma_server.o
 obj-$(CONFIG_POPCORN)	+= page_server.o fh_action.o
@@ -6,6 +6,9 @@ obj-$(CONFIG_POPCORN)	+= bundle.o
 obj-$(CONFIG_POPCORN)	+= remote_info.o
 obj-$(CONFIG_POPCORN)	+= pcn_kmsg.o
 obj-$(CONFIG_POPCORN)	+= stat.o
+obj-$(CONFIG_POPCORN_HYPE)	+= hype_file.o
+obj-$(CONFIG_POPCORN_HYPE)	+= hype_kvm.o
+obj-$(CONFIG_POPCORN_HYPE)	+= hype_migrate.o
 
 obj-$(CONFIG_POPCORN_POWER_SENSOR_X86) += power_sensor_x86.o
 obj-$(CONFIG_POPCORN_POWER_SENSOR_ARM) += power_sensor_arm.o
diff --git a/kernel/popcorn/bundle.c b/kernel/popcorn/bundle.c
index 04eaf0a5eaf8..bee83615ad48 100644
--- a/kernel/popcorn/bundle.c
+++ b/kernel/popcorn/bundle.c
@@ -33,6 +33,18 @@ void set_popcorn_node_online(int nid, bool online)
 }
 EXPORT_SYMBOL(set_popcorn_node_online);
 
+int get_popcorn_nodes(void)
+{
+	int i, cnt = 0;
+	for (i = 0; i < MAX_POPCORN_NODES; i++) {
+		//if (i == my_nid) { cnt++; continue; }
+		if (popcorn_nodes[i].is_connected)
+			cnt++;
+	}
+	return cnt;
+}
+EXPORT_SYMBOL(get_popcorn_nodes);
+
 
 int my_nid __read_mostly = -1;
 EXPORT_SYMBOL(my_nid);
diff --git a/kernel/popcorn/configs/config_puzzlehype_echo_200512_prelim_systor20 b/kernel/popcorn/configs/config_puzzlehype_echo_200512_prelim_systor20
new file mode 100644
index 000000000000..b6e079752e9d
--- /dev/null
+++ b/kernel/popcorn/configs/config_puzzlehype_echo_200512_prelim_systor20
@@ -0,0 +1,3514 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/x86 4.4.137 Kernel Configuration
+#
+CONFIG_64BIT=y
+CONFIG_X86_64=y
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_PERF_EVENTS_INTEL_UNCORE=y
+CONFIG_OUTPUT_FORMAT="elf64-x86-64"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/x86_64_defconfig"
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+CONFIG_ZONE_DMA32=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_HAVE_INTEL_TXT=y
+CONFIG_X86_64_SMP=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PGTABLE_LEVELS=4
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION="-pop-hype"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KERNEL_XZ=y
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_FHANDLE=y
+CONFIG_USELIB=y
+CONFIG_AUDIT=y
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_VIRT_CPU_ACCOUNTING=y
+# CONFIG_TICK_CPU_ACCOUNTING is not set
+CONFIG_VIRT_CPU_ACCOUNTING_GEN=y
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_CONTEXT_TRACKING=y
+# CONFIG_CONTEXT_TRACKING_FORCE is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_EXPEDITE_BOOT is not set
+CONFIG_BUILD_BIN2C=y
+CONFIG_IKCONFIG=m
+# CONFIG_IKCONFIG_PROC is not set
+CONFIG_LOG_BUF_SHIFT=21
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
+CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH=y
+CONFIG_ARCH_SUPPORTS_INT128=y
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_PAGE_COUNTER=y
+CONFIG_MEMCG=y
+# CONFIG_MEMCG_KMEM is not set
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+CONFIG_CGROUP_WRITEBACK=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_RD_LZ4=y
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_HAVE_PCSPKR_PLATFORM=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+CONFIG_SGETMASK_SYSCALL=y
+CONFIG_SYSFS_SYSCALL=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_BPF_SYSCALL is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_USERFAULTFD is not set
+CONFIG_PCI_QUIRKS=y
+CONFIG_MEMBARRIER=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_KEXEC_CORE=y
+# CONFIG_OPROFILE is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_OPROFILE_NMI_TIMER=y
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+CONFIG_OPTPROBES=y
+CONFIG_KPROBES_ON_FTRACE=y
+CONFIG_UPROBES=y
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_KRETPROBES=y
+CONFIG_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_KPROBES_ON_FTRACE=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_ARCH_WANT_OLD_COMPAT_IPC=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR_NONE is not set
+CONFIG_CC_STACKPROTECTOR_REGULAR=y
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_HAVE_ARCH_HUGE_VMAP=y
+CONFIG_HAVE_ARCH_SOFT_DIRTY=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_COPY_THREAD_TLS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_BLK_DEV_THROTTLING=y
+# CONFIG_BLK_CMDLINE_PARSER is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+# CONFIG_CMDLINE_PARTITION is not set
+CONFIG_BLOCK_COMPAT=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_PREEMPT_NOTIFIERS=y
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_ARCH_USE_QUEUED_SPINLOCKS=y
+CONFIG_QUEUED_SPINLOCKS=y
+CONFIG_ARCH_USE_QUEUED_RWLOCKS=y
+CONFIG_QUEUED_RWLOCKS=y
+CONFIG_FREEZER=y
+
+#
+# Popcorn Distributed Execution Support
+#
+CONFIG_ARCH_SUPPORTS_POPCORN=y
+CONFIG_POPCORN=y
+CONFIG_POPCORN_HYPE=y
+# CONFIG_POPCORN_DEBUG is not set
+CONFIG_POPCORN_CHECK_SANITY=y
+# CONFIG_POPCORN_REMOTE_INFO is not set
+CONFIG_POPCORN_STAT=y
+CONFIG_POPCORN_STAT_PGFAULTS=y
+# CONFIG_POPCORN_STAT_MSG is not set
+CONFIG_POPCORN_KMSG=y
+CONFIG_POPCORN_KMSG_SOCKET=m
+CONFIG_POPCORN_KMSG_RDMA=m
+CONFIG_POPCORN_KMSG_TEST=m
+
+#
+# Processor type and features
+#
+CONFIG_ZONE_DMA=y
+CONFIG_SMP=y
+CONFIG_X86_FEATURE_NAMES=y
+CONFIG_X86_X2APIC=y
+CONFIG_X86_MPPARSE=y
+CONFIG_RETPOLINE=y
+# CONFIG_X86_EXTENDED_PLATFORM is not set
+CONFIG_X86_INTEL_LPSS=y
+# CONFIG_X86_AMD_PLATFORM_DEVICE is not set
+CONFIG_IOSF_MBI=m
+# CONFIG_IOSF_MBI_DEBUG is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+CONFIG_HYPERVISOR_GUEST=y
+CONFIG_PARAVIRT=y
+# CONFIG_PARAVIRT_DEBUG is not set
+# CONFIG_PARAVIRT_SPINLOCKS is not set
+CONFIG_XEN=y
+CONFIG_XEN_DOM0=y
+CONFIG_XEN_PVHVM=y
+CONFIG_XEN_512GB=y
+CONFIG_XEN_SAVE_RESTORE=y
+# CONFIG_XEN_DEBUG_FS is not set
+CONFIG_XEN_PVH=y
+CONFIG_KVM_GUEST=y
+# CONFIG_KVM_DEBUG_FS is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+CONFIG_PARAVIRT_CLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MK8 is not set
+# CONFIG_MPSC is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MATOM is not set
+CONFIG_GENERIC_CPU=y
+CONFIG_X86_INTERNODE_CACHE_SHIFT=6
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=64
+CONFIG_X86_DEBUGCTLMSR=y
+# CONFIG_PROCESSOR_SELECT is not set
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+CONFIG_GART_IOMMU=y
+CONFIG_CALGARY_IOMMU=y
+CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT=y
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_MAXSMP is not set
+CONFIG_NR_CPUS=64
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_X86_MCE_THRESHOLD=y
+# CONFIG_X86_MCE_INJECT is not set
+CONFIG_X86_THERMAL_VECTOR=y
+# CONFIG_VM86 is not set
+CONFIG_X86_16BIT=y
+CONFIG_X86_ESPFIX64=y
+CONFIG_X86_VSYSCALL_EMULATION=y
+# CONFIG_I8K is not set
+CONFIG_MICROCODE=y
+CONFIG_MICROCODE_INTEL=y
+CONFIG_MICROCODE_AMD=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+# CONFIG_X86_MSR is not set
+# CONFIG_X86_CPUID is not set
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_X86_DIRECT_GBPAGES=y
+CONFIG_NUMA=y
+CONFIG_AMD_NUMA=y
+CONFIG_X86_64_ACPI_NUMA=y
+CONFIG_NODES_SPAN_OTHER_NODES=y
+CONFIG_NUMA_EMU=y
+CONFIG_NODES_SHIFT=6
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_ARCH_DISCARD_MEMBLOCK=y
+CONFIG_MEMORY_ISOLATION=y
+# CONFIG_MOVABLE_NODE is not set
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+# CONFIG_MEMORY_HOTPLUG is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK=y
+CONFIG_MEMORY_BALLOON=y
+# CONFIG_COMPACTION is not set
+# CONFIG_MIGRATION is not set
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_MMU_NOTIFIER=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_MEMORY_FAILURE=y
+# CONFIG_HWPOISON_INJECT is not set
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CMA is not set
+CONFIG_MEM_SOFT_DIRTY=y
+# CONFIG_ZPOOL is not set
+CONFIG_ZBUD=y
+CONFIG_ZSMALLOC=y
+# CONFIG_PGTABLE_MAPPING is not set
+# CONFIG_ZSMALLOC_STAT is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+CONFIG_ARCH_SUPPORTS_DEFERRED_STRUCT_PAGE_INIT=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_X86_PMEM_LEGACY is not set
+# CONFIG_X86_CHECK_BIOS_CORRUPTION is not set
+CONFIG_X86_RESERVE_LOW=64
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_ARCH_RANDOM=y
+CONFIG_X86_SMAP=y
+# CONFIG_X86_INTEL_MPX is not set
+CONFIG_EFI=y
+CONFIG_EFI_STUB=y
+CONFIG_EFI_MIXED=y
+CONFIG_SECCOMP=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+# CONFIG_RANDOMIZE_BASE is not set
+CONFIG_PHYSICAL_ALIGN=0x200000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_BOOTPARAM_HOTPLUG_CPU0 is not set
+# CONFIG_DEBUG_HOTPLUG_CPU0 is not set
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_LEGACY_VSYSCALL_NATIVE is not set
+CONFIG_LEGACY_VSYSCALL_EMULATE=y
+# CONFIG_LEGACY_VSYSCALL_NONE is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MODIFY_LDT_SYSCALL=y
+CONFIG_HAVE_LIVEPATCH=y
+# CONFIG_LIVEPATCH is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_USE_PERCPU_NUMA_NODE_ID=y
+
+#
+# Power management and ACPI options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+CONFIG_HIBERNATE_CALLBACKS=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+# CONFIG_PM_TEST_SUSPEND is not set
+CONFIG_PM_SLEEP_DEBUG=y
+# CONFIG_DPM_WATCHDOG is not set
+# CONFIG_PM_TRACE_RTC is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_LEGACY_TABLES_LOOKUP=y
+CONFIG_ARCH_MIGHT_HAVE_ACPI_PDC=y
+CONFIG_ACPI_SYSTEM_POWER_STATES_SUPPORT=y
+# CONFIG_ACPI_DEBUGGER is not set
+CONFIG_ACPI_SLEEP=y
+# CONFIG_ACPI_PROCFS_POWER is not set
+CONFIG_ACPI_REV_OVERRIDE_POSSIBLE=y
+# CONFIG_ACPI_EC_DEBUGFS is not set
+# CONFIG_ACPI_AC is not set
+# CONFIG_ACPI_BATTERY is not set
+CONFIG_ACPI_BUTTON=m
+# CONFIG_ACPI_FAN is not set
+CONFIG_ACPI_DOCK=y
+CONFIG_ACPI_CPU_FREQ_PSS=y
+CONFIG_ACPI_PROCESSOR_IDLE=y
+CONFIG_ACPI_PROCESSOR=m
+# CONFIG_ACPI_IPMI is not set
+CONFIG_ACPI_HOTPLUG_CPU=y
+CONFIG_ACPI_PROCESSOR_AGGREGATOR=m
+# CONFIG_ACPI_THERMAL is not set
+CONFIG_ACPI_NUMA=y
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+CONFIG_ACPI_INITRD_TABLE_OVERRIDE=y
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_PCI_SLOT=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_ACPI_HOTPLUG_IOAPIC=y
+# CONFIG_ACPI_SBS is not set
+CONFIG_ACPI_HED=y
+# CONFIG_ACPI_CUSTOM_METHOD is not set
+CONFIG_ACPI_BGRT=y
+# CONFIG_ACPI_REDUCED_HARDWARE_ONLY is not set
+# CONFIG_ACPI_NFIT is not set
+CONFIG_HAVE_ACPI_APEI=y
+CONFIG_HAVE_ACPI_APEI_NMI=y
+CONFIG_ACPI_APEI=y
+CONFIG_ACPI_APEI_GHES=y
+CONFIG_ACPI_APEI_PCIEAER=y
+CONFIG_ACPI_APEI_MEMORY_FAILURE=y
+# CONFIG_ACPI_APEI_EINJ is not set
+# CONFIG_ACPI_APEI_ERST_DEBUG is not set
+CONFIG_ACPI_EXTLOG=y
+# CONFIG_PMIC_OPREGION is not set
+CONFIG_SFI=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+# CONFIG_CPU_FREQ_STAT is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# CPU frequency scaling drivers
+#
+CONFIG_X86_INTEL_PSTATE=y
+# CONFIG_X86_PCC_CPUFREQ is not set
+# CONFIG_X86_ACPI_CPUFREQ is not set
+# CONFIG_X86_SPEEDSTEP_CENTRINO is not set
+# CONFIG_X86_P4_CLOCKMOD is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+CONFIG_INTEL_IDLE=y
+
+#
+# Memory power savings
+#
+# CONFIG_I7300_IDLE is not set
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCI_XEN=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_HOTPLUG_PCI_PCIE=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIEAER_INJECT is not set
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PME=y
+CONFIG_PCI_BUS_ADDR_T_64BIT=y
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+# CONFIG_PCI_DEBUG is not set
+CONFIG_PCI_REALLOC_ENABLE_AUTO=y
+# CONFIG_PCI_STUB is not set
+# CONFIG_XEN_PCIDEV_FRONTEND is not set
+CONFIG_HT_IRQ=y
+CONFIG_PCI_ATS=y
+CONFIG_PCI_IOV=y
+CONFIG_PCI_PRI=y
+CONFIG_PCI_PASID=y
+CONFIG_PCI_LABEL=y
+
+#
+# PCI host controller drivers
+#
+CONFIG_ISA_DMA_API=y
+CONFIG_AMD_NB=y
+# CONFIG_PCCARD is not set
+CONFIG_HOTPLUG_PCI=y
+CONFIG_HOTPLUG_PCI_ACPI=y
+# CONFIG_HOTPLUG_PCI_ACPI_IBM is not set
+CONFIG_HOTPLUG_PCI_CPCI=y
+# CONFIG_HOTPLUG_PCI_CPCI_ZT5550 is not set
+# CONFIG_HOTPLUG_PCI_CPCI_GENERIC is not set
+CONFIG_HOTPLUG_PCI_SHPC=m
+# CONFIG_RAPIDIO is not set
+# CONFIG_X86_SYSFB is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=m
+CONFIG_COREDUMP=y
+CONFIG_IA32_EMULATION=y
+CONFIG_IA32_AOUT=y
+CONFIG_X86_X32=y
+CONFIG_COMPAT=y
+CONFIG_COMPAT_FOR_U64_ALIGNMENT=y
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_X86_DEV_DMA_OPS=y
+CONFIG_PMC_ATOM=y
+CONFIG_NET=y
+CONFIG_NET_INGRESS=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+CONFIG_XFRM_SUB_POLICY=y
+CONFIG_XFRM_MIGRATE=y
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_TRIE_STATS=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_NET_IP_TUNNEL is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_SYN_COOKIES=y
+# CONFIG_NET_UDP_TUNNEL is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_UDP_DIAG=y
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+# CONFIG_TCP_CONG_DCTCP is not set
+# CONFIG_TCP_CONG_CDG is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+CONFIG_IPV6_MIP6=y
+# CONFIG_IPV6_ILA is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_BEET is not set
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+# CONFIG_IPV6_SIT is not set
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_GRE is not set
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IPV6_PIMSM_V2=y
+# CONFIG_NETLABEL is not set
+CONFIG_NETWORK_SECMARK=y
+CONFIG_NET_PTP_CLASSIFY=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=m
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_INGRESS=y
+CONFIG_NETFILTER_NETLINK=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+# CONFIG_NF_CONNTRACK_MARK is not set
+# CONFIG_NF_CONNTRACK_SECMARK is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CT_NETLINK is not set
+# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+# CONFIG_NF_NAT_AMANDA is not set
+# CONFIG_NF_NAT_FTP is not set
+# CONFIG_NF_NAT_IRC is not set
+# CONFIG_NF_NAT_SIP is not set
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NF_NAT_REDIRECT is not set
+CONFIG_NF_TABLES=y
+CONFIG_NF_TABLES_INET=y
+CONFIG_NF_TABLES_NETDEV=y
+CONFIG_NFT_EXTHDR=y
+# CONFIG_NFT_META is not set
+# CONFIG_NFT_CT is not set
+# CONFIG_NFT_RBTREE is not set
+# CONFIG_NFT_HASH is not set
+# CONFIG_NFT_COUNTER is not set
+# CONFIG_NFT_LOG is not set
+# CONFIG_NFT_LIMIT is not set
+# CONFIG_NFT_MASQ is not set
+# CONFIG_NFT_REDIR is not set
+# CONFIG_NFT_NAT is not set
+# CONFIG_NFT_REJECT is not set
+# CONFIG_NFT_REJECT_INET is not set
+CONFIG_NFT_COMPAT=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+# CONFIG_NETFILTER_XT_CONNMARK is not set
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+# CONFIG_NETFILTER_XT_TARGET_LOG is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+CONFIG_NETFILTER_XT_NAT=y
+# CONFIG_NETFILTER_XT_TARGET_NETMAP is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_REDIRECT is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
+# CONFIG_NETFILTER_XT_TARGET_SECMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y
+# CONFIG_NETFILTER_XT_MATCH_BPF is not set
+# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ECN is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+CONFIG_NETFILTER_XT_MATCH_HL=y
+# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_IPVS=y
+# CONFIG_NETFILTER_XT_MATCH_L2TP is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+CONFIG_NETFILTER_XT_MATCH_RECENT=y
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+# CONFIG_NETFILTER_XT_MATCH_STATE is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_IP_SET is not set
+CONFIG_IP_VS=y
+# CONFIG_IP_VS_IPV6 is not set
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+# CONFIG_IP_VS_PROTO_TCP is not set
+# CONFIG_IP_VS_PROTO_UDP is not set
+# CONFIG_IP_VS_PROTO_AH_ESP is not set
+# CONFIG_IP_VS_PROTO_ESP is not set
+# CONFIG_IP_VS_PROTO_AH is not set
+# CONFIG_IP_VS_PROTO_SCTP is not set
+
+#
+# IPVS scheduler
+#
+# CONFIG_IP_VS_RR is not set
+# CONFIG_IP_VS_WRR is not set
+# CONFIG_IP_VS_LC is not set
+# CONFIG_IP_VS_WLC is not set
+# CONFIG_IP_VS_FO is not set
+# CONFIG_IP_VS_OVF is not set
+# CONFIG_IP_VS_LBLC is not set
+# CONFIG_IP_VS_LBLCR is not set
+# CONFIG_IP_VS_DH is not set
+# CONFIG_IP_VS_SH is not set
+# CONFIG_IP_VS_SED is not set
+# CONFIG_IP_VS_NQ is not set
+
+#
+# IPVS SH scheduler
+#
+CONFIG_IP_VS_SH_TAB_BITS=8
+
+#
+# IPVS application helper
+#
+# CONFIG_IP_VS_NFCT is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_NF_TABLES_IPV4=y
+CONFIG_NFT_CHAIN_ROUTE_IPV4=y
+# CONFIG_NFT_REJECT_IPV4 is not set
+# CONFIG_NFT_DUP_IPV4 is not set
+CONFIG_NF_TABLES_ARP=y
+# CONFIG_NF_DUP_IPV4 is not set
+# CONFIG_NF_LOG_ARP is not set
+# CONFIG_NF_LOG_IPV4 is not set
+# CONFIG_NF_REJECT_IPV4 is not set
+CONFIG_NF_NAT_IPV4=y
+CONFIG_NFT_CHAIN_NAT_IPV4=y
+CONFIG_NF_NAT_MASQUERADE_IPV4=y
+# CONFIG_NF_NAT_PPTP is not set
+# CONFIG_NF_NAT_H323 is not set
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+CONFIG_IP_NF_FILTER=y
+# CONFIG_IP_NF_TARGET_REJECT is not set
+# CONFIG_IP_NF_TARGET_SYNPROXY is not set
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+# CONFIG_IP_NF_TARGET_NETMAP is not set
+# CONFIG_IP_NF_TARGET_REDIRECT is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_SECURITY is not set
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+# CONFIG_IP_NF_ARP_MANGLE is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV6 is not set
+# CONFIG_NF_CONNTRACK_IPV6 is not set
+CONFIG_NF_TABLES_IPV6=y
+# CONFIG_NFT_CHAIN_ROUTE_IPV6 is not set
+# CONFIG_NFT_REJECT_IPV6 is not set
+# CONFIG_NFT_DUP_IPV6 is not set
+# CONFIG_NF_DUP_IPV6 is not set
+# CONFIG_NF_REJECT_IPV6 is not set
+# CONFIG_NF_LOG_IPV6 is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_NF_TABLES_BRIDGE is not set
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+CONFIG_STP=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+# CONFIG_NET_SCH_FQ is not set
+# CONFIG_NET_SCH_HHF is not set
+# CONFIG_NET_SCH_PIE is not set
+# CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_PLUG is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+# CONFIG_NET_CLS_BPF is not set
+# CONFIG_NET_CLS_FLOWER is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+# CONFIG_NET_EMATCH_U32 is not set
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_ACT_VLAN is not set
+# CONFIG_NET_ACT_BPF is not set
+CONFIG_NET_SCH_FIFO=y
+CONFIG_DCB=y
+CONFIG_DNS_RESOLVER=m
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+CONFIG_NETLINK_DIAG=y
+CONFIG_MPLS=y
+CONFIG_NET_MPLS_GSO=y
+# CONFIG_MPLS_ROUTING is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_CGROUP_NET_CLASSID=y
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+CONFIG_BPF_JIT=y
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+# CONFIG_NET_9P_RDMA is not set
+# CONFIG_NET_9P_DEBUG is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_LWTUNNEL is not set
+# CONFIG_DST_CACHE is not set
+CONFIG_HAVE_BPF_JIT=y
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_GENERIC_CPU_VULNERABILITIES=y
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_FENCE_TRACE is not set
+
+#
+# Bus devices
+#
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_OF is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG_MESSAGES is not set
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_ZRAM is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_SKD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=18874368
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_XEN_BLKDEV_FRONTEND is not set
+CONFIG_VIRTIO_BLK=y
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+# CONFIG_BLK_DEV_NVME is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_INTEL_MEI=m
+CONFIG_INTEL_MEI_ME=m
+# CONFIG_INTEL_MEI_TXE is not set
+# CONFIG_VMWARE_VMCI is not set
+
+#
+# Intel MIC Bus Driver
+#
+# CONFIG_INTEL_MIC_BUS is not set
+
+#
+# SCIF Bus Driver
+#
+# CONFIG_SCIF_BUS is not set
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+# CONFIG_GENWQE is not set
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_KERNEL_API is not set
+# CONFIG_CXL_EEH is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=m
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=m
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_MQ_DEFAULT is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_SCSI_ESAS2R is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT3SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_VMWARE_PVSCSI is not set
+# CONFIG_XEN_SCSI_FRONTEND is not set
+# CONFIG_SCSI_SNIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_ISCI is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_WD719X is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_VIRTIO is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=m
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_ZPODD=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI=m
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+# CONFIG_ATA_SFF is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_BCACHE is not set
+# CONFIG_BLK_DEV_DM is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+# CONFIG_IFB is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+CONFIG_TUN=y
+# CONFIG_TUN_VNET_CROSS_LE is not set
+CONFIG_VETH=y
+CONFIG_VIRTIO_NET=y
+# CONFIG_NLMON is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_VHOST_NET=y
+CONFIG_VHOST_RING=y
+CONFIG_VHOST=y
+# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+CONFIG_ETHERNET=y
+CONFIG_MDIO=m
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_CX_ECAT is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_HP is not set
+CONFIG_NET_VENDOR_INTEL=y
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IXGB is not set
+CONFIG_IXGBE=m
+CONFIG_IXGBE_HWMON=y
+CONFIG_IXGBE_DCA=y
+CONFIG_IXGBE_DCB=y
+# CONFIG_IXGBEVF is not set
+# CONFIG_I40E is not set
+# CONFIG_I40EVF is not set
+# CONFIG_FM10K is not set
+CONFIG_NET_VENDOR_I825XX=y
+# CONFIG_JME is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+CONFIG_MLX5_CORE=m
+CONFIG_MLX5_CORE_EN=y
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_SFC is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_NET_SB1000 is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Host-side USB support is needed for USB Network Adapter support
+#
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_XEN_NETDEV_FRONTEND is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_FUJITSU_ES is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
+CONFIG_SERIO_I8042=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVMEM is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DMA=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_RSA=y
+# CONFIG_SERIAL_8250_FSL is not set
+# CONFIG_SERIAL_8250_DW is not set
+# CONFIG_SERIAL_8250_RT288X is not set
+# CONFIG_SERIAL_8250_FINTEK is not set
+# CONFIG_SERIAL_8250_MID is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+CONFIG_TTY_PRINTK=y
+CONFIG_HVC_DRIVER=y
+# CONFIG_HVC_XEN is not set
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_IPMI_HANDLER=m
+# CONFIG_IPMI_PANIC_EVENT is not set
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+# CONFIG_IPMI_SI_PROBE_DEFAULTS is not set
+# CONFIG_IPMI_SSIF is not set
+CONFIG_IPMI_WATCHDOG=m
+CONFIG_IPMI_POWEROFF=m
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_VIA=y
+CONFIG_HW_RANDOM_VIRTIO=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_MWAVE is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_HPET=y
+CONFIG_HPET_MMAP=y
+CONFIG_HPET_MMAP_DEFAULT=y
+CONFIG_HANGCHECK_TIMER=y
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_MUX=m
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=m
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+CONFIG_I2C_I801=m
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_ISMT is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# ACPI drivers
+#
+# CONFIG_I2C_SCMI is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+# CONFIG_NTP_PPS is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=m
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_CHERRYVIEW is not set
+# CONFIG_PINCTRL_BROXTON is not set
+# CONFIG_PINCTRL_SUNRISEPOINT is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_APPLESMC is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_DELL_SMM is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_G762 is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_IBMAEM is not set
+# CONFIG_SENSORS_IBMPEX is not set
+# CONFIG_SENSORS_I5500 is not set
+CONFIG_SENSORS_CORETEMP=m
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_POWR1220 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LTC2945 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4222 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4260 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MAX31790 is not set
+# CONFIG_SENSORS_HTU21 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_NCT6683 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_NCT7802 is not set
+# CONFIG_SENSORS_NCT7904 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SHTC1 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_ADC128D818 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_TC74 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP103 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+
+#
+# ACPI drivers
+#
+CONFIG_SENSORS_ACPI_POWER=m
+# CONFIG_SENSORS_ATK0110 is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_THERMAL_GOV_BANG_BANG=y
+CONFIG_THERMAL_GOV_USER_SPACE=y
+# CONFIG_THERMAL_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_EMULATION is not set
+CONFIG_INTEL_POWERCLAMP=m
+CONFIG_X86_PKG_TEMP_THERMAL=m
+# CONFIG_INTEL_SOC_DTS_THERMAL is not set
+# CONFIG_INT340X_THERMAL is not set
+# CONFIG_INTEL_PCH_THERMAL is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_ACQUIRE_WDT is not set
+# CONFIG_ADVANTECH_WDT is not set
+# CONFIG_ALIM1535_WDT is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_F71808E_WDT is not set
+# CONFIG_SP5100_TCO is not set
+# CONFIG_SBC_FITPC2_WATCHDOG is not set
+# CONFIG_EUROTECH_WDT is not set
+# CONFIG_IB700_WDT is not set
+# CONFIG_IBMASR is not set
+# CONFIG_WAFER_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_IE6XX_WDT is not set
+CONFIG_ITCO_WDT=m
+CONFIG_ITCO_VENDOR_SUPPORT=y
+# CONFIG_IT8712F_WDT is not set
+# CONFIG_IT87_WDT is not set
+# CONFIG_HP_WATCHDOG is not set
+# CONFIG_SC1200_WDT is not set
+# CONFIG_PC87413_WDT is not set
+# CONFIG_NV_TCO is not set
+# CONFIG_60XX_WDT is not set
+# CONFIG_CPU5_WDT is not set
+# CONFIG_SMSC_SCH311X_WDT is not set
+# CONFIG_SMSC37B787_WDT is not set
+# CONFIG_VIA_WDT is not set
+# CONFIG_W83627HF_WDT is not set
+# CONFIG_W83877F_WDT is not set
+# CONFIG_W83977F_WDT is not set
+# CONFIG_MACHZ_WDT is not set
+# CONFIG_SBC_EPX_C3_WATCHDOG is not set
+# CONFIG_BCM7038_WDT is not set
+# CONFIG_XEN_WDT is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=m
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_INTEL_QUARK_I2C_GPIO is not set
+CONFIG_LPC_ICH=m
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_INTEL_LPSS_ACPI is not set
+# CONFIG_MFD_INTEL_LPSS_PCI is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RTSX_USB is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_AGP is not set
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_VGA_SWITCHEROO=y
+CONFIG_DRM=m
+CONFIG_DRM_KMS_HELPER=m
+CONFIG_DRM_KMS_FB_HELPER=y
+CONFIG_DRM_FBDEV_EMULATION=y
+CONFIG_DRM_LOAD_EDID_FIRMWARE=y
+
+#
+# I2C encoder or helper chips
+#
+# CONFIG_DRM_I2C_ADV7511 is not set
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I2C_NXP_TDA998X is not set
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_AMDGPU is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_I915 is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_DRM_VGEM is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_GMA500 is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_MGAG200 is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_QXL is not set
+# CONFIG_DRM_BOCHS is not set
+# CONFIG_DRM_VIRTIO_GPU is not set
+CONFIG_DRM_BRIDGE=y
+
+#
+# Display Interface Bridges
+#
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+CONFIG_FB_CMDLINE=y
+# CONFIG_FB_DDC is not set
+CONFIG_FB_BOOT_VESA_SUPPORT=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_VGA16 is not set
+CONFIG_FB_VESA=y
+CONFIG_FB_EFI=y
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_XEN_FBDEV_FRONTEND=y
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SM712 is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+CONFIG_HDMI=y
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=25
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=m
+# CONFIG_HID_BATTERY_STRENGTH is not set
+CONFIG_HIDRAW=y
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=m
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=m
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=m
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=m
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=m
+CONFIG_USB_XHCI_PCI=m
+# CONFIG_USB_XHCI_PLATFORM is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_PCI=m
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+# CONFIG_USB_STORAGE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+# CONFIG_USB_CHAOSKEY is not set
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_USB_PHY is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_INFINIBAND=m
+CONFIG_INFINIBAND_USER_MAD=m
+CONFIG_INFINIBAND_USER_ACCESS=m
+CONFIG_INFINIBAND_USER_MEM=y
+CONFIG_INFINIBAND_ON_DEMAND_PAGING=y
+CONFIG_INFINIBAND_ADDR_TRANS=y
+# CONFIG_INFINIBAND_MTHCA is not set
+# CONFIG_INFINIBAND_QIB is not set
+# CONFIG_MLX4_INFINIBAND is not set
+CONFIG_MLX5_INFINIBAND=m
+# CONFIG_INFINIBAND_NES is not set
+# CONFIG_INFINIBAND_OCRDMA is not set
+# CONFIG_INFINIBAND_USNIC is not set
+CONFIG_INFINIBAND_IPOIB=m
+CONFIG_INFINIBAND_IPOIB_CM=y
+# CONFIG_INFINIBAND_IPOIB_DEBUG is not set
+# CONFIG_INFINIBAND_SRP is not set
+# CONFIG_INFINIBAND_ISER is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_EDAC=y
+CONFIG_EDAC_LEGACY_SYSFS=y
+# CONFIG_EDAC_DEBUG is not set
+# CONFIG_EDAC_DECODE_MCE is not set
+CONFIG_EDAC_MM_EDAC=m
+# CONFIG_EDAC_E752X is not set
+# CONFIG_EDAC_I82975X is not set
+# CONFIG_EDAC_I3000 is not set
+# CONFIG_EDAC_I3200 is not set
+# CONFIG_EDAC_IE31200 is not set
+# CONFIG_EDAC_X38 is not set
+# CONFIG_EDAC_I5400 is not set
+# CONFIG_EDAC_I7CORE is not set
+# CONFIG_EDAC_I5000 is not set
+# CONFIG_EDAC_I5100 is not set
+# CONFIG_EDAC_I7300 is not set
+CONFIG_EDAC_SBRIDGE=m
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12057 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_ACPI=y
+# CONFIG_INTEL_IDMA64 is not set
+CONFIG_INTEL_IOATDMA=m
+# CONFIG_DW_DMAC is not set
+# CONFIG_DW_DMAC_PCI is not set
+
+#
+# DMA Clients
+#
+CONFIG_ASYNC_TX_DMA=y
+# CONFIG_DMATEST is not set
+CONFIG_DMA_ENGINE_RAID=y
+CONFIG_DCA=m
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VFIO is not set
+CONFIG_IRQ_BYPASS_MANAGER=y
+CONFIG_VIRT_DRIVERS=y
+CONFIG_VIRTIO=y
+
+#
+# Virtio drivers
+#
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO_PCI_LEGACY=y
+CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_INPUT=y
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_HYPERV is not set
+
+#
+# Xen driver support
+#
+# CONFIG_XEN_BALLOON is not set
+# CONFIG_XEN_DEV_EVTCHN is not set
+# CONFIG_XEN_BACKEND is not set
+# CONFIG_XENFS is not set
+# CONFIG_XEN_SYS_HYPERVISOR is not set
+CONFIG_XEN_XENBUS_FRONTEND=y
+# CONFIG_XEN_GNTDEV is not set
+# CONFIG_XEN_GRANT_DEV_ALLOC is not set
+CONFIG_SWIOTLB_XEN=y
+CONFIG_XEN_PRIVCMD=m
+# CONFIG_XEN_ACPI_PROCESSOR is not set
+# CONFIG_XEN_MCE_LOG is not set
+CONFIG_XEN_HAVE_PVMMU=y
+CONFIG_XEN_EFI=y
+CONFIG_XEN_AUTO_XLATE=y
+CONFIG_XEN_ACPI=y
+CONFIG_XEN_HAVE_VPMU=y
+# CONFIG_STAGING is not set
+CONFIG_X86_PLATFORM_DEVICES=y
+# CONFIG_ACERHDF is not set
+# CONFIG_DELL_WMI is not set
+# CONFIG_DELL_WMI_AIO is not set
+# CONFIG_DELL_SMO8800 is not set
+# CONFIG_FUJITSU_TABLET is not set
+# CONFIG_HP_ACCEL is not set
+# CONFIG_HP_WIRELESS is not set
+# CONFIG_HP_WMI is not set
+# CONFIG_SENSORS_HDAPS is not set
+CONFIG_ACPI_WMI=m
+# CONFIG_TOPSTAR_LAPTOP is not set
+# CONFIG_TOSHIBA_BT_RFKILL is not set
+# CONFIG_TOSHIBA_HAPS is not set
+# CONFIG_TOSHIBA_WMI is not set
+# CONFIG_ACPI_CMPC is not set
+# CONFIG_INTEL_IPS is not set
+# CONFIG_IBM_RTL is not set
+CONFIG_MXM_WMI=m
+# CONFIG_SAMSUNG_Q10 is not set
+# CONFIG_INTEL_RST is not set
+# CONFIG_INTEL_SMARTCONNECT is not set
+# CONFIG_PVPANIC is not set
+# CONFIG_INTEL_PMC_IPC is not set
+# CONFIG_SURFACE_PRO3_BUTTON is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_PXA is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKEVT_I8253=y
+CONFIG_I8253_LOCK=y
+CONFIG_CLKBLD_I8253=y
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_API=y
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Generic IOMMU Pagetable Support
+#
+CONFIG_IOMMU_IOVA=y
+CONFIG_AMD_IOMMU=y
+# CONFIG_AMD_IOMMU_STATS is not set
+CONFIG_AMD_IOMMU_V2=y
+CONFIG_DMAR_TABLE=y
+CONFIG_INTEL_IOMMU=y
+# CONFIG_INTEL_IOMMU_SVM is not set
+# CONFIG_INTEL_IOMMU_DEFAULT_ON is not set
+CONFIG_INTEL_IOMMU_FLOPPY_WA=y
+CONFIG_IRQ_REMAP=y
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+CONFIG_PM_DEVFREQ=y
+
+#
+# DEVFREQ Governors
+#
+# CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND is not set
+# CONFIG_DEVFREQ_GOV_PERFORMANCE is not set
+# CONFIG_DEVFREQ_GOV_POWERSAVE is not set
+# CONFIG_DEVFREQ_GOV_USERSPACE is not set
+
+#
+# DEVFREQ Drivers
+#
+# CONFIG_PM_DEVFREQ_EVENT is not set
+# CONFIG_EXTCON is not set
+CONFIG_MEMORY=y
+# CONFIG_IIO is not set
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_PWM is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+CONFIG_POWERCAP=y
+CONFIG_INTEL_RAPL=m
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_RAS=y
+# CONFIG_THUNDERBOLT is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_STM_DUMMY is not set
+# CONFIG_STM_SOURCE_CONSOLE is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+CONFIG_FIRMWARE_MEMMAP=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+CONFIG_DMI_SYSFS=y
+CONFIG_DMI_SCAN_MACHINE_NON_EFI_FALLBACK=y
+# CONFIG_ISCSI_IBFT_FIND is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# EFI (Extensible Firmware Interface) Support
+#
+# CONFIG_EFI_VARS is not set
+CONFIG_EFI_ESRT=y
+CONFIG_EFI_RUNTIME_MAP=y
+# CONFIG_EFI_FAKE_MEMMAP is not set
+CONFIG_EFI_RUNTIME_WRAPPERS=y
+CONFIG_UEFI_CPER=y
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_ENCRYPTION is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+CONFIG_BTRFS_FS=y
+# CONFIG_BTRFS_FS_POSIX_ACL is not set
+# CONFIG_BTRFS_FS_CHECK_INTEGRITY is not set
+# CONFIG_BTRFS_FS_RUN_SANITY_TESTS is not set
+# CONFIG_BTRFS_DEBUG is not set
+# CONFIG_BTRFS_ASSERT is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_FS_DAX is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+# CONFIG_FANOTIFY_ACCESS_PERMISSIONS is not set
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+CONFIG_PRINT_QUOTA_WARNING=y
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTACTL=y
+CONFIG_QUOTACTL_COMPAT=y
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+CONFIG_OVERLAY_FS=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_PROC_CHILDREN=y
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_EFIVAR_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_PSTORE=y
+# CONFIG_PSTORE_CONSOLE is not set
+# CONFIG_PSTORE_PMSG is not set
+# CONFIG_PSTORE_FTRACE is not set
+# CONFIG_PSTORE_RAM is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+# CONFIG_NFS_V2 is not set
+# CONFIG_NFS_V3 is not set
+CONFIG_NFS_V4=m
+CONFIG_NFS_SWAP=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_PNFS_FILE_LAYOUT=m
+CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN="kernel.org"
+# CONFIG_NFS_V4_1_MIGRATION is not set
+CONFIG_NFS_V4_SECURITY_LABEL=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_NFS_DEBUG=y
+# CONFIG_NFSD is not set
+CONFIG_GRACE_PERIOD=m
+CONFIG_LOCKD=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+CONFIG_SUNRPC_GSS=m
+CONFIG_SUNRPC_BACKCHANNEL=y
+CONFIG_SUNRPC_SWAP=y
+CONFIG_SUNRPC_DEBUG=y
+# CONFIG_SUNRPC_XPRT_RDMA is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_9P_FS=y
+# CONFIG_9P_FS_POSIX_ACL is not set
+# CONFIG_9P_FS_SECURITY is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_INFO_SPLIT is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+# CONFIG_GDB_SCRIPTS is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=8192
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_READABLE_ASM is not set
+CONFIG_UNUSED_SYMBOLS=y
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x01b6
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+CONFIG_HAVE_ARCH_KASAN=y
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_HARDLOCKUP_DETECTOR=y
+# CONFIG_BOOTPARAM_HARDLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE=0
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=60
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHED_INFO=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+CONFIG_TIMER_STATS=y
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS=y
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_FENTRY=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACER_MAX_TRACE=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_TRACER_SNAPSHOT=y
+# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+CONFIG_STACK_TRACER=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_KPROBE_EVENT=y
+CONFIG_UPROBE_EVENT=y
+CONFIG_PROBE_EVENTS=y
+CONFIG_DYNAMIC_FTRACE=y
+CONFIG_DYNAMIC_FTRACE_WITH_REGS=y
+# CONFIG_FUNCTION_PROFILER is not set
+CONFIG_FTRACE_MCOUNT_RECORD=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+# CONFIG_MMIOTRACE is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_TRACE_ENUM_MAP_FILE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_UDELAY is not set
+CONFIG_MEMTEST=y
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+CONFIG_EARLY_PRINTK_EFI=y
+# CONFIG_X86_PTDUMP_CORE is not set
+# CONFIG_X86_PTDUMP is not set
+# CONFIG_EFI_PGT_DUMP is not set
+CONFIG_DEBUG_RODATA=y
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_WX is not set
+CONFIG_DEBUG_SET_MODULE_RONX=y
+# CONFIG_DEBUG_NX_TEST is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_DEBUG_TLBFLUSH is not set
+# CONFIG_IOMMU_DEBUG is not set
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+# CONFIG_X86_DECODER_SELFTEST is not set
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_IO_DELAY_0X80=y
+# CONFIG_IO_DELAY_0XED is not set
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+# CONFIG_DEBUG_BOOT_PARAMS is not set
+# CONFIG_CPA_DEBUG is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_ENTRY is not set
+# CONFIG_DEBUG_NMI_SELFTEST is not set
+# CONFIG_X86_DEBUG_STATIC_CPU_HAS is not set
+CONFIG_X86_DEBUG_FPU=y
+# CONFIG_PUNIT_ATOM_DEBUG is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_COMPAT=y
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+# CONFIG_PAGE_TABLE_ISOLATION is not set
+CONFIG_SECURITYFS=y
+# CONFIG_SECURITY_NETWORK is not set
+# CONFIG_SECURITY_PATH is not set
+# CONFIG_INTEL_TXT is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_APPARMOR is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_INTEGRITY is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_XOR_BLOCKS=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+# CONFIG_CRYPTO_RSA is not set
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRC32_PCLMUL is not set
+CONFIG_CRYPTO_CRCT10DIF=y
+# CONFIG_CRYPTO_CRCT10DIF_PCLMUL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_POLY1305_X86_64 is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA1_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256_SSSE3 is not set
+# CONFIG_CRYPTO_SHA512_SSSE3 is not set
+# CONFIG_CRYPTO_SHA1_MB is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_X86_64 is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_BLOWFISH_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAMELLIA_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST5_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_CAST6_AVX_X86_64 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_DES3_EDE_X86_64 is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_X86_64 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_CHACHA20_X86_64 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SERPENT_SSE2_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64 is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64_3WAY is not set
+# CONFIG_CRYPTO_TWOFISH_AVX_X86_64 is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_DRBG_MENU is not set
+# CONFIG_CRYPTO_JITTERENTROPY is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
+CONFIG_HAVE_KVM=y
+CONFIG_HAVE_KVM_IRQCHIP=y
+CONFIG_HAVE_KVM_IRQFD=y
+CONFIG_HAVE_KVM_IRQ_ROUTING=y
+CONFIG_HAVE_KVM_EVENTFD=y
+CONFIG_KVM_APIC_ARCHITECTURE=y
+CONFIG_KVM_MMIO=y
+CONFIG_KVM_ASYNC_PF=y
+CONFIG_HAVE_KVM_MSI=y
+CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT=y
+CONFIG_KVM_VFIO=y
+CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT=y
+CONFIG_KVM_COMPAT=y
+CONFIG_HAVE_KVM_IRQ_BYPASS=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_KVM_INTEL=m
+# CONFIG_KVM_AMD is not set
+# CONFIG_KVM_MMU_AUDIT is not set
+# CONFIG_KVM_DEVICE_ASSIGNMENT is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_RAID6_PQ=y
+CONFIG_BITREVERSE=y
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_ARCH_HAS_FAST_MULTIPLIER=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_CHECK_SIGNATURE=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_OID_REGISTRY=m
+CONFIG_UCS2_STRING=y
+CONFIG_FONT_SUPPORT=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_SG_SPLIT is not set
+CONFIG_ARCH_HAS_SG_CHAIN=y
+CONFIG_ARCH_HAS_PMEM_API=y
+CONFIG_ARCH_HAS_MMIO_FLUSH=y
diff --git a/kernel/popcorn/configs/config_puzzlehype_echo_210407 b/kernel/popcorn/configs/config_puzzlehype_echo_210407
new file mode 100644
index 000000000000..8c203c46efe2
--- /dev/null
+++ b/kernel/popcorn/configs/config_puzzlehype_echo_210407
@@ -0,0 +1,3512 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/x86 4.4.137 Kernel Configuration
+#
+CONFIG_64BIT=y
+CONFIG_X86_64=y
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_PERF_EVENTS_INTEL_UNCORE=y
+CONFIG_OUTPUT_FORMAT="elf64-x86-64"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/x86_64_defconfig"
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+CONFIG_ZONE_DMA32=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_HAVE_INTEL_TXT=y
+CONFIG_X86_64_SMP=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PGTABLE_LEVELS=4
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION="-pop-hype-jack"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KERNEL_XZ=y
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_FHANDLE=y
+CONFIG_USELIB=y
+CONFIG_AUDIT=y
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_HZ_PERIODIC=y
+# CONFIG_NO_HZ_IDLE is not set
+# CONFIG_NO_HZ_FULL is not set
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_VIRT_CPU_ACCOUNTING=y
+# CONFIG_TICK_CPU_ACCOUNTING is not set
+CONFIG_VIRT_CPU_ACCOUNTING_GEN=y
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_CONTEXT_TRACKING=y
+# CONFIG_CONTEXT_TRACKING_FORCE is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_EXPEDITE_BOOT is not set
+CONFIG_BUILD_BIN2C=y
+CONFIG_IKCONFIG=m
+# CONFIG_IKCONFIG_PROC is not set
+CONFIG_LOG_BUF_SHIFT=21
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
+CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH=y
+CONFIG_ARCH_SUPPORTS_INT128=y
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_PAGE_COUNTER=y
+CONFIG_MEMCG=y
+# CONFIG_MEMCG_KMEM is not set
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+CONFIG_CGROUP_WRITEBACK=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_RD_LZ4=y
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_HAVE_PCSPKR_PLATFORM=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+CONFIG_SGETMASK_SYSCALL=y
+CONFIG_SYSFS_SYSCALL=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_BPF_SYSCALL is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_USERFAULTFD is not set
+CONFIG_PCI_QUIRKS=y
+CONFIG_MEMBARRIER=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_KEXEC_CORE=y
+# CONFIG_OPROFILE is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_OPROFILE_NMI_TIMER=y
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+CONFIG_OPTPROBES=y
+CONFIG_KPROBES_ON_FTRACE=y
+CONFIG_UPROBES=y
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_KRETPROBES=y
+CONFIG_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_KPROBES_ON_FTRACE=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_ARCH_WANT_OLD_COMPAT_IPC=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR_NONE is not set
+CONFIG_CC_STACKPROTECTOR_REGULAR=y
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_HAVE_ARCH_HUGE_VMAP=y
+CONFIG_HAVE_ARCH_SOFT_DIRTY=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_COPY_THREAD_TLS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_BLK_DEV_THROTTLING=y
+# CONFIG_BLK_CMDLINE_PARSER is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+# CONFIG_CMDLINE_PARTITION is not set
+CONFIG_BLOCK_COMPAT=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_PREEMPT_NOTIFIERS=y
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_ARCH_USE_QUEUED_SPINLOCKS=y
+CONFIG_QUEUED_SPINLOCKS=y
+CONFIG_ARCH_USE_QUEUED_RWLOCKS=y
+CONFIG_QUEUED_RWLOCKS=y
+CONFIG_FREEZER=y
+
+#
+# Popcorn Distributed Execution Support
+#
+CONFIG_ARCH_SUPPORTS_POPCORN=y
+CONFIG_POPCORN=y
+CONFIG_POPCORN_HYPE=y
+# CONFIG_POPCORN_DEBUG is not set
+# CONFIG_POPCORN_CHECK_SANITY is not set
+# CONFIG_POPCORN_REMOTE_INFO is not set
+CONFIG_POPCORN_STAT=y
+CONFIG_POPCORN_STAT_PGFAULTS=y
+CONFIG_POPCORN_STAT_MSG=y
+CONFIG_POPCORN_KMSG=y
+CONFIG_POPCORN_KMSG_SOCKET=m
+CONFIG_POPCORN_KMSG_RDMA=m
+CONFIG_POPCORN_KMSG_TEST=m
+
+#
+# Processor type and features
+#
+CONFIG_ZONE_DMA=y
+CONFIG_SMP=y
+CONFIG_X86_FEATURE_NAMES=y
+CONFIG_X86_X2APIC=y
+CONFIG_X86_MPPARSE=y
+CONFIG_RETPOLINE=y
+# CONFIG_X86_EXTENDED_PLATFORM is not set
+CONFIG_X86_INTEL_LPSS=y
+# CONFIG_X86_AMD_PLATFORM_DEVICE is not set
+CONFIG_IOSF_MBI=m
+# CONFIG_IOSF_MBI_DEBUG is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+CONFIG_HYPERVISOR_GUEST=y
+CONFIG_PARAVIRT=y
+# CONFIG_PARAVIRT_DEBUG is not set
+# CONFIG_PARAVIRT_SPINLOCKS is not set
+CONFIG_XEN=y
+CONFIG_XEN_DOM0=y
+CONFIG_XEN_PVHVM=y
+CONFIG_XEN_512GB=y
+CONFIG_XEN_SAVE_RESTORE=y
+# CONFIG_XEN_DEBUG_FS is not set
+CONFIG_XEN_PVH=y
+CONFIG_KVM_GUEST=y
+# CONFIG_KVM_DEBUG_FS is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+CONFIG_PARAVIRT_CLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MK8 is not set
+# CONFIG_MPSC is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MATOM is not set
+CONFIG_GENERIC_CPU=y
+CONFIG_X86_INTERNODE_CACHE_SHIFT=6
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=64
+CONFIG_X86_DEBUGCTLMSR=y
+# CONFIG_PROCESSOR_SELECT is not set
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+CONFIG_GART_IOMMU=y
+CONFIG_CALGARY_IOMMU=y
+CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT=y
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_MAXSMP is not set
+CONFIG_NR_CPUS=64
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_X86_MCE_THRESHOLD=y
+# CONFIG_X86_MCE_INJECT is not set
+CONFIG_X86_THERMAL_VECTOR=y
+# CONFIG_VM86 is not set
+CONFIG_X86_16BIT=y
+CONFIG_X86_ESPFIX64=y
+CONFIG_X86_VSYSCALL_EMULATION=y
+# CONFIG_I8K is not set
+CONFIG_MICROCODE=y
+CONFIG_MICROCODE_INTEL=y
+CONFIG_MICROCODE_AMD=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+# CONFIG_X86_MSR is not set
+# CONFIG_X86_CPUID is not set
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_X86_DIRECT_GBPAGES=y
+CONFIG_NUMA=y
+CONFIG_AMD_NUMA=y
+CONFIG_X86_64_ACPI_NUMA=y
+CONFIG_NODES_SPAN_OTHER_NODES=y
+CONFIG_NUMA_EMU=y
+CONFIG_NODES_SHIFT=6
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_ARCH_DISCARD_MEMBLOCK=y
+CONFIG_MEMORY_ISOLATION=y
+# CONFIG_MOVABLE_NODE is not set
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+# CONFIG_MEMORY_HOTPLUG is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK=y
+CONFIG_MEMORY_BALLOON=y
+# CONFIG_COMPACTION is not set
+# CONFIG_MIGRATION is not set
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_MMU_NOTIFIER=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_MEMORY_FAILURE=y
+# CONFIG_HWPOISON_INJECT is not set
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CMA is not set
+CONFIG_MEM_SOFT_DIRTY=y
+# CONFIG_ZPOOL is not set
+CONFIG_ZBUD=y
+CONFIG_ZSMALLOC=y
+# CONFIG_PGTABLE_MAPPING is not set
+# CONFIG_ZSMALLOC_STAT is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+CONFIG_ARCH_SUPPORTS_DEFERRED_STRUCT_PAGE_INIT=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_X86_PMEM_LEGACY is not set
+# CONFIG_X86_CHECK_BIOS_CORRUPTION is not set
+CONFIG_X86_RESERVE_LOW=64
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_ARCH_RANDOM=y
+CONFIG_X86_SMAP=y
+# CONFIG_X86_INTEL_MPX is not set
+CONFIG_EFI=y
+CONFIG_EFI_STUB=y
+CONFIG_EFI_MIXED=y
+CONFIG_SECCOMP=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+# CONFIG_RANDOMIZE_BASE is not set
+CONFIG_PHYSICAL_ALIGN=0x200000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_BOOTPARAM_HOTPLUG_CPU0 is not set
+# CONFIG_DEBUG_HOTPLUG_CPU0 is not set
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_LEGACY_VSYSCALL_NATIVE is not set
+CONFIG_LEGACY_VSYSCALL_EMULATE=y
+# CONFIG_LEGACY_VSYSCALL_NONE is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MODIFY_LDT_SYSCALL=y
+CONFIG_HAVE_LIVEPATCH=y
+# CONFIG_LIVEPATCH is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_USE_PERCPU_NUMA_NODE_ID=y
+
+#
+# Power management and ACPI options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+CONFIG_HIBERNATE_CALLBACKS=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+# CONFIG_PM_TEST_SUSPEND is not set
+CONFIG_PM_SLEEP_DEBUG=y
+# CONFIG_DPM_WATCHDOG is not set
+# CONFIG_PM_TRACE_RTC is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_LEGACY_TABLES_LOOKUP=y
+CONFIG_ARCH_MIGHT_HAVE_ACPI_PDC=y
+CONFIG_ACPI_SYSTEM_POWER_STATES_SUPPORT=y
+# CONFIG_ACPI_DEBUGGER is not set
+CONFIG_ACPI_SLEEP=y
+# CONFIG_ACPI_PROCFS_POWER is not set
+CONFIG_ACPI_REV_OVERRIDE_POSSIBLE=y
+# CONFIG_ACPI_EC_DEBUGFS is not set
+# CONFIG_ACPI_AC is not set
+# CONFIG_ACPI_BATTERY is not set
+CONFIG_ACPI_BUTTON=m
+# CONFIG_ACPI_FAN is not set
+CONFIG_ACPI_DOCK=y
+CONFIG_ACPI_CPU_FREQ_PSS=y
+CONFIG_ACPI_PROCESSOR_IDLE=y
+CONFIG_ACPI_PROCESSOR=m
+# CONFIG_ACPI_IPMI is not set
+CONFIG_ACPI_HOTPLUG_CPU=y
+CONFIG_ACPI_PROCESSOR_AGGREGATOR=m
+# CONFIG_ACPI_THERMAL is not set
+CONFIG_ACPI_NUMA=y
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+CONFIG_ACPI_INITRD_TABLE_OVERRIDE=y
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_PCI_SLOT=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_ACPI_HOTPLUG_IOAPIC=y
+# CONFIG_ACPI_SBS is not set
+CONFIG_ACPI_HED=y
+# CONFIG_ACPI_CUSTOM_METHOD is not set
+CONFIG_ACPI_BGRT=y
+# CONFIG_ACPI_REDUCED_HARDWARE_ONLY is not set
+# CONFIG_ACPI_NFIT is not set
+CONFIG_HAVE_ACPI_APEI=y
+CONFIG_HAVE_ACPI_APEI_NMI=y
+CONFIG_ACPI_APEI=y
+CONFIG_ACPI_APEI_GHES=y
+CONFIG_ACPI_APEI_PCIEAER=y
+CONFIG_ACPI_APEI_MEMORY_FAILURE=y
+# CONFIG_ACPI_APEI_EINJ is not set
+# CONFIG_ACPI_APEI_ERST_DEBUG is not set
+CONFIG_ACPI_EXTLOG=y
+# CONFIG_PMIC_OPREGION is not set
+CONFIG_SFI=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+# CONFIG_CPU_FREQ_STAT is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# CPU frequency scaling drivers
+#
+CONFIG_X86_INTEL_PSTATE=y
+# CONFIG_X86_PCC_CPUFREQ is not set
+# CONFIG_X86_ACPI_CPUFREQ is not set
+# CONFIG_X86_SPEEDSTEP_CENTRINO is not set
+# CONFIG_X86_P4_CLOCKMOD is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+CONFIG_INTEL_IDLE=y
+
+#
+# Memory power savings
+#
+# CONFIG_I7300_IDLE is not set
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCI_XEN=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_HOTPLUG_PCI_PCIE=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIEAER_INJECT is not set
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PME=y
+CONFIG_PCI_BUS_ADDR_T_64BIT=y
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+# CONFIG_PCI_DEBUG is not set
+CONFIG_PCI_REALLOC_ENABLE_AUTO=y
+# CONFIG_PCI_STUB is not set
+# CONFIG_XEN_PCIDEV_FRONTEND is not set
+CONFIG_HT_IRQ=y
+CONFIG_PCI_ATS=y
+CONFIG_PCI_IOV=y
+CONFIG_PCI_PRI=y
+CONFIG_PCI_PASID=y
+CONFIG_PCI_LABEL=y
+
+#
+# PCI host controller drivers
+#
+CONFIG_ISA_DMA_API=y
+CONFIG_AMD_NB=y
+# CONFIG_PCCARD is not set
+CONFIG_HOTPLUG_PCI=y
+CONFIG_HOTPLUG_PCI_ACPI=y
+# CONFIG_HOTPLUG_PCI_ACPI_IBM is not set
+CONFIG_HOTPLUG_PCI_CPCI=y
+# CONFIG_HOTPLUG_PCI_CPCI_ZT5550 is not set
+# CONFIG_HOTPLUG_PCI_CPCI_GENERIC is not set
+CONFIG_HOTPLUG_PCI_SHPC=m
+# CONFIG_RAPIDIO is not set
+# CONFIG_X86_SYSFB is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=m
+CONFIG_COREDUMP=y
+CONFIG_IA32_EMULATION=y
+CONFIG_IA32_AOUT=y
+CONFIG_X86_X32=y
+CONFIG_COMPAT=y
+CONFIG_COMPAT_FOR_U64_ALIGNMENT=y
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_X86_DEV_DMA_OPS=y
+CONFIG_PMC_ATOM=y
+CONFIG_NET=y
+CONFIG_NET_INGRESS=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+CONFIG_XFRM_SUB_POLICY=y
+CONFIG_XFRM_MIGRATE=y
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_TRIE_STATS=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_NET_IP_TUNNEL is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_SYN_COOKIES=y
+# CONFIG_NET_UDP_TUNNEL is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_UDP_DIAG=y
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+# CONFIG_TCP_CONG_DCTCP is not set
+# CONFIG_TCP_CONG_CDG is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+CONFIG_IPV6_MIP6=y
+# CONFIG_IPV6_ILA is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_BEET is not set
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+# CONFIG_IPV6_SIT is not set
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_GRE is not set
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IPV6_PIMSM_V2=y
+# CONFIG_NETLABEL is not set
+CONFIG_NETWORK_SECMARK=y
+CONFIG_NET_PTP_CLASSIFY=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=m
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_INGRESS=y
+CONFIG_NETFILTER_NETLINK=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+# CONFIG_NF_CONNTRACK_MARK is not set
+# CONFIG_NF_CONNTRACK_SECMARK is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CT_NETLINK is not set
+# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+# CONFIG_NF_NAT_AMANDA is not set
+# CONFIG_NF_NAT_FTP is not set
+# CONFIG_NF_NAT_IRC is not set
+# CONFIG_NF_NAT_SIP is not set
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NF_NAT_REDIRECT is not set
+CONFIG_NF_TABLES=y
+CONFIG_NF_TABLES_INET=y
+CONFIG_NF_TABLES_NETDEV=y
+CONFIG_NFT_EXTHDR=y
+# CONFIG_NFT_META is not set
+# CONFIG_NFT_CT is not set
+# CONFIG_NFT_RBTREE is not set
+# CONFIG_NFT_HASH is not set
+# CONFIG_NFT_COUNTER is not set
+# CONFIG_NFT_LOG is not set
+# CONFIG_NFT_LIMIT is not set
+# CONFIG_NFT_MASQ is not set
+# CONFIG_NFT_REDIR is not set
+# CONFIG_NFT_NAT is not set
+# CONFIG_NFT_REJECT is not set
+# CONFIG_NFT_REJECT_INET is not set
+CONFIG_NFT_COMPAT=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+# CONFIG_NETFILTER_XT_CONNMARK is not set
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+# CONFIG_NETFILTER_XT_TARGET_LOG is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+CONFIG_NETFILTER_XT_NAT=y
+# CONFIG_NETFILTER_XT_TARGET_NETMAP is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_REDIRECT is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
+# CONFIG_NETFILTER_XT_TARGET_SECMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y
+# CONFIG_NETFILTER_XT_MATCH_BPF is not set
+# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ECN is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+CONFIG_NETFILTER_XT_MATCH_HL=y
+# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_IPVS=y
+# CONFIG_NETFILTER_XT_MATCH_L2TP is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+CONFIG_NETFILTER_XT_MATCH_RECENT=y
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+# CONFIG_NETFILTER_XT_MATCH_STATE is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_IP_SET is not set
+CONFIG_IP_VS=y
+# CONFIG_IP_VS_IPV6 is not set
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+# CONFIG_IP_VS_PROTO_TCP is not set
+# CONFIG_IP_VS_PROTO_UDP is not set
+# CONFIG_IP_VS_PROTO_AH_ESP is not set
+# CONFIG_IP_VS_PROTO_ESP is not set
+# CONFIG_IP_VS_PROTO_AH is not set
+# CONFIG_IP_VS_PROTO_SCTP is not set
+
+#
+# IPVS scheduler
+#
+# CONFIG_IP_VS_RR is not set
+# CONFIG_IP_VS_WRR is not set
+# CONFIG_IP_VS_LC is not set
+# CONFIG_IP_VS_WLC is not set
+# CONFIG_IP_VS_FO is not set
+# CONFIG_IP_VS_OVF is not set
+# CONFIG_IP_VS_LBLC is not set
+# CONFIG_IP_VS_LBLCR is not set
+# CONFIG_IP_VS_DH is not set
+# CONFIG_IP_VS_SH is not set
+# CONFIG_IP_VS_SED is not set
+# CONFIG_IP_VS_NQ is not set
+
+#
+# IPVS SH scheduler
+#
+CONFIG_IP_VS_SH_TAB_BITS=8
+
+#
+# IPVS application helper
+#
+# CONFIG_IP_VS_NFCT is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_NF_TABLES_IPV4=y
+CONFIG_NFT_CHAIN_ROUTE_IPV4=y
+# CONFIG_NFT_REJECT_IPV4 is not set
+# CONFIG_NFT_DUP_IPV4 is not set
+CONFIG_NF_TABLES_ARP=y
+# CONFIG_NF_DUP_IPV4 is not set
+# CONFIG_NF_LOG_ARP is not set
+# CONFIG_NF_LOG_IPV4 is not set
+# CONFIG_NF_REJECT_IPV4 is not set
+CONFIG_NF_NAT_IPV4=y
+CONFIG_NFT_CHAIN_NAT_IPV4=y
+CONFIG_NF_NAT_MASQUERADE_IPV4=y
+# CONFIG_NF_NAT_PPTP is not set
+# CONFIG_NF_NAT_H323 is not set
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+CONFIG_IP_NF_FILTER=y
+# CONFIG_IP_NF_TARGET_REJECT is not set
+# CONFIG_IP_NF_TARGET_SYNPROXY is not set
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+# CONFIG_IP_NF_TARGET_NETMAP is not set
+# CONFIG_IP_NF_TARGET_REDIRECT is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_SECURITY is not set
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+# CONFIG_IP_NF_ARP_MANGLE is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV6 is not set
+# CONFIG_NF_CONNTRACK_IPV6 is not set
+CONFIG_NF_TABLES_IPV6=y
+# CONFIG_NFT_CHAIN_ROUTE_IPV6 is not set
+# CONFIG_NFT_REJECT_IPV6 is not set
+# CONFIG_NFT_DUP_IPV6 is not set
+# CONFIG_NF_DUP_IPV6 is not set
+# CONFIG_NF_REJECT_IPV6 is not set
+# CONFIG_NF_LOG_IPV6 is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_NF_TABLES_BRIDGE is not set
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+CONFIG_STP=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+# CONFIG_NET_SCH_FQ is not set
+# CONFIG_NET_SCH_HHF is not set
+# CONFIG_NET_SCH_PIE is not set
+# CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_PLUG is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+# CONFIG_NET_CLS_BPF is not set
+# CONFIG_NET_CLS_FLOWER is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+# CONFIG_NET_EMATCH_U32 is not set
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_ACT_VLAN is not set
+# CONFIG_NET_ACT_BPF is not set
+CONFIG_NET_SCH_FIFO=y
+CONFIG_DCB=y
+CONFIG_DNS_RESOLVER=m
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+CONFIG_NETLINK_DIAG=y
+CONFIG_MPLS=y
+CONFIG_NET_MPLS_GSO=y
+# CONFIG_MPLS_ROUTING is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_CGROUP_NET_CLASSID=y
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+CONFIG_BPF_JIT=y
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+# CONFIG_NET_9P_RDMA is not set
+# CONFIG_NET_9P_DEBUG is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_LWTUNNEL is not set
+# CONFIG_DST_CACHE is not set
+CONFIG_HAVE_BPF_JIT=y
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_GENERIC_CPU_VULNERABILITIES=y
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_FENCE_TRACE is not set
+
+#
+# Bus devices
+#
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_OF is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG_MESSAGES is not set
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_ZRAM is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_SKD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_BLK_DEV_RAM_SIZE=33554415
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_XEN_BLKDEV_FRONTEND is not set
+CONFIG_VIRTIO_BLK=y
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+# CONFIG_BLK_DEV_NVME is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_INTEL_MEI=m
+CONFIG_INTEL_MEI_ME=m
+# CONFIG_INTEL_MEI_TXE is not set
+# CONFIG_VMWARE_VMCI is not set
+
+#
+# Intel MIC Bus Driver
+#
+# CONFIG_INTEL_MIC_BUS is not set
+
+#
+# SCIF Bus Driver
+#
+# CONFIG_SCIF_BUS is not set
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+# CONFIG_GENWQE is not set
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_KERNEL_API is not set
+# CONFIG_CXL_EEH is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=m
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=m
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_MQ_DEFAULT is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_SCSI_ESAS2R is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT3SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_VMWARE_PVSCSI is not set
+# CONFIG_XEN_SCSI_FRONTEND is not set
+# CONFIG_SCSI_SNIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_ISCI is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_WD719X is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_VIRTIO is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=m
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_ZPODD=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI=m
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+# CONFIG_ATA_SFF is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_BCACHE is not set
+# CONFIG_BLK_DEV_DM is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+# CONFIG_IFB is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+CONFIG_TUN=y
+# CONFIG_TUN_VNET_CROSS_LE is not set
+CONFIG_VETH=y
+CONFIG_VIRTIO_NET=y
+# CONFIG_NLMON is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_VHOST_NET=y
+CONFIG_VHOST_RING=y
+CONFIG_VHOST=y
+# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+CONFIG_ETHERNET=y
+CONFIG_MDIO=m
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_CX_ECAT is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_HP is not set
+CONFIG_NET_VENDOR_INTEL=y
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IXGB is not set
+CONFIG_IXGBE=m
+CONFIG_IXGBE_HWMON=y
+CONFIG_IXGBE_DCA=y
+CONFIG_IXGBE_DCB=y
+# CONFIG_IXGBEVF is not set
+# CONFIG_I40E is not set
+# CONFIG_I40EVF is not set
+# CONFIG_FM10K is not set
+CONFIG_NET_VENDOR_I825XX=y
+# CONFIG_JME is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+CONFIG_MLX5_CORE=m
+CONFIG_MLX5_CORE_EN=y
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_SFC is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_NET_SB1000 is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Host-side USB support is needed for USB Network Adapter support
+#
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_XEN_NETDEV_FRONTEND is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_FUJITSU_ES is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
+CONFIG_SERIO_I8042=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVMEM is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DMA=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_RSA=y
+# CONFIG_SERIAL_8250_FSL is not set
+# CONFIG_SERIAL_8250_DW is not set
+# CONFIG_SERIAL_8250_RT288X is not set
+# CONFIG_SERIAL_8250_FINTEK is not set
+# CONFIG_SERIAL_8250_MID is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+CONFIG_TTY_PRINTK=y
+CONFIG_HVC_DRIVER=y
+# CONFIG_HVC_XEN is not set
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_IPMI_HANDLER=m
+# CONFIG_IPMI_PANIC_EVENT is not set
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+# CONFIG_IPMI_SI_PROBE_DEFAULTS is not set
+# CONFIG_IPMI_SSIF is not set
+CONFIG_IPMI_WATCHDOG=m
+CONFIG_IPMI_POWEROFF=m
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_VIA=y
+CONFIG_HW_RANDOM_VIRTIO=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_MWAVE is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_HPET=y
+CONFIG_HPET_MMAP=y
+CONFIG_HPET_MMAP_DEFAULT=y
+CONFIG_HANGCHECK_TIMER=y
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_MUX=m
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=m
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+CONFIG_I2C_I801=m
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_ISMT is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# ACPI drivers
+#
+# CONFIG_I2C_SCMI is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=m
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_CHERRYVIEW is not set
+# CONFIG_PINCTRL_BROXTON is not set
+# CONFIG_PINCTRL_SUNRISEPOINT is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_APPLESMC is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_DELL_SMM is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_G762 is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_IBMAEM is not set
+# CONFIG_SENSORS_IBMPEX is not set
+# CONFIG_SENSORS_I5500 is not set
+CONFIG_SENSORS_CORETEMP=m
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_POWR1220 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LTC2945 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4222 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4260 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MAX31790 is not set
+# CONFIG_SENSORS_HTU21 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_NCT6683 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_NCT7802 is not set
+# CONFIG_SENSORS_NCT7904 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SHTC1 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_ADC128D818 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_TC74 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP103 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+
+#
+# ACPI drivers
+#
+CONFIG_SENSORS_ACPI_POWER=m
+# CONFIG_SENSORS_ATK0110 is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_THERMAL_GOV_BANG_BANG=y
+CONFIG_THERMAL_GOV_USER_SPACE=y
+# CONFIG_THERMAL_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_EMULATION is not set
+CONFIG_INTEL_POWERCLAMP=m
+CONFIG_X86_PKG_TEMP_THERMAL=m
+# CONFIG_INTEL_SOC_DTS_THERMAL is not set
+# CONFIG_INT340X_THERMAL is not set
+# CONFIG_INTEL_PCH_THERMAL is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_ACQUIRE_WDT is not set
+# CONFIG_ADVANTECH_WDT is not set
+# CONFIG_ALIM1535_WDT is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_F71808E_WDT is not set
+# CONFIG_SP5100_TCO is not set
+# CONFIG_SBC_FITPC2_WATCHDOG is not set
+# CONFIG_EUROTECH_WDT is not set
+# CONFIG_IB700_WDT is not set
+# CONFIG_IBMASR is not set
+# CONFIG_WAFER_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_IE6XX_WDT is not set
+CONFIG_ITCO_WDT=m
+CONFIG_ITCO_VENDOR_SUPPORT=y
+# CONFIG_IT8712F_WDT is not set
+# CONFIG_IT87_WDT is not set
+# CONFIG_HP_WATCHDOG is not set
+# CONFIG_SC1200_WDT is not set
+# CONFIG_PC87413_WDT is not set
+# CONFIG_NV_TCO is not set
+# CONFIG_60XX_WDT is not set
+# CONFIG_CPU5_WDT is not set
+# CONFIG_SMSC_SCH311X_WDT is not set
+# CONFIG_SMSC37B787_WDT is not set
+# CONFIG_VIA_WDT is not set
+# CONFIG_W83627HF_WDT is not set
+# CONFIG_W83877F_WDT is not set
+# CONFIG_W83977F_WDT is not set
+# CONFIG_MACHZ_WDT is not set
+# CONFIG_SBC_EPX_C3_WATCHDOG is not set
+# CONFIG_BCM7038_WDT is not set
+# CONFIG_XEN_WDT is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=m
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_INTEL_QUARK_I2C_GPIO is not set
+CONFIG_LPC_ICH=m
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_INTEL_LPSS_ACPI is not set
+# CONFIG_MFD_INTEL_LPSS_PCI is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RTSX_USB is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_AGP is not set
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_VGA_SWITCHEROO=y
+CONFIG_DRM=m
+CONFIG_DRM_KMS_HELPER=m
+CONFIG_DRM_KMS_FB_HELPER=y
+CONFIG_DRM_FBDEV_EMULATION=y
+CONFIG_DRM_LOAD_EDID_FIRMWARE=y
+
+#
+# I2C encoder or helper chips
+#
+# CONFIG_DRM_I2C_ADV7511 is not set
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I2C_NXP_TDA998X is not set
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_AMDGPU is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_I915 is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_DRM_VGEM is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_GMA500 is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_MGAG200 is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_QXL is not set
+# CONFIG_DRM_BOCHS is not set
+# CONFIG_DRM_VIRTIO_GPU is not set
+CONFIG_DRM_BRIDGE=y
+
+#
+# Display Interface Bridges
+#
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+CONFIG_FB_CMDLINE=y
+# CONFIG_FB_DDC is not set
+CONFIG_FB_BOOT_VESA_SUPPORT=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_VGA16 is not set
+CONFIG_FB_VESA=y
+CONFIG_FB_EFI=y
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_XEN_FBDEV_FRONTEND=y
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SM712 is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+CONFIG_HDMI=y
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=25
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=m
+# CONFIG_HID_BATTERY_STRENGTH is not set
+CONFIG_HIDRAW=y
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=m
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=m
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=m
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=m
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=m
+CONFIG_USB_XHCI_PCI=m
+# CONFIG_USB_XHCI_PLATFORM is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_PCI=m
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+# CONFIG_USB_STORAGE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+# CONFIG_USB_CHAOSKEY is not set
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_USB_PHY is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_INFINIBAND=m
+CONFIG_INFINIBAND_USER_MAD=m
+CONFIG_INFINIBAND_USER_ACCESS=m
+CONFIG_INFINIBAND_USER_MEM=y
+CONFIG_INFINIBAND_ON_DEMAND_PAGING=y
+CONFIG_INFINIBAND_ADDR_TRANS=y
+# CONFIG_INFINIBAND_MTHCA is not set
+# CONFIG_INFINIBAND_QIB is not set
+# CONFIG_MLX4_INFINIBAND is not set
+CONFIG_MLX5_INFINIBAND=m
+# CONFIG_INFINIBAND_NES is not set
+# CONFIG_INFINIBAND_OCRDMA is not set
+# CONFIG_INFINIBAND_USNIC is not set
+CONFIG_INFINIBAND_IPOIB=m
+CONFIG_INFINIBAND_IPOIB_CM=y
+# CONFIG_INFINIBAND_IPOIB_DEBUG is not set
+# CONFIG_INFINIBAND_SRP is not set
+# CONFIG_INFINIBAND_ISER is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_EDAC=y
+CONFIG_EDAC_LEGACY_SYSFS=y
+# CONFIG_EDAC_DEBUG is not set
+# CONFIG_EDAC_DECODE_MCE is not set
+CONFIG_EDAC_MM_EDAC=m
+# CONFIG_EDAC_E752X is not set
+# CONFIG_EDAC_I82975X is not set
+# CONFIG_EDAC_I3000 is not set
+# CONFIG_EDAC_I3200 is not set
+# CONFIG_EDAC_IE31200 is not set
+# CONFIG_EDAC_X38 is not set
+# CONFIG_EDAC_I5400 is not set
+# CONFIG_EDAC_I7CORE is not set
+# CONFIG_EDAC_I5000 is not set
+# CONFIG_EDAC_I5100 is not set
+# CONFIG_EDAC_I7300 is not set
+CONFIG_EDAC_SBRIDGE=m
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12057 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_ACPI=y
+# CONFIG_INTEL_IDMA64 is not set
+CONFIG_INTEL_IOATDMA=m
+# CONFIG_DW_DMAC is not set
+# CONFIG_DW_DMAC_PCI is not set
+
+#
+# DMA Clients
+#
+CONFIG_ASYNC_TX_DMA=y
+# CONFIG_DMATEST is not set
+CONFIG_DMA_ENGINE_RAID=y
+CONFIG_DCA=m
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VFIO is not set
+CONFIG_IRQ_BYPASS_MANAGER=y
+CONFIG_VIRT_DRIVERS=y
+CONFIG_VIRTIO=y
+
+#
+# Virtio drivers
+#
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO_PCI_LEGACY=y
+CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_INPUT=y
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_HYPERV is not set
+
+#
+# Xen driver support
+#
+# CONFIG_XEN_BALLOON is not set
+# CONFIG_XEN_DEV_EVTCHN is not set
+# CONFIG_XEN_BACKEND is not set
+# CONFIG_XENFS is not set
+# CONFIG_XEN_SYS_HYPERVISOR is not set
+CONFIG_XEN_XENBUS_FRONTEND=y
+# CONFIG_XEN_GNTDEV is not set
+# CONFIG_XEN_GRANT_DEV_ALLOC is not set
+CONFIG_SWIOTLB_XEN=y
+CONFIG_XEN_PRIVCMD=m
+# CONFIG_XEN_ACPI_PROCESSOR is not set
+# CONFIG_XEN_MCE_LOG is not set
+CONFIG_XEN_HAVE_PVMMU=y
+CONFIG_XEN_EFI=y
+CONFIG_XEN_AUTO_XLATE=y
+CONFIG_XEN_ACPI=y
+CONFIG_XEN_HAVE_VPMU=y
+# CONFIG_STAGING is not set
+CONFIG_X86_PLATFORM_DEVICES=y
+# CONFIG_ACERHDF is not set
+# CONFIG_DELL_WMI is not set
+# CONFIG_DELL_WMI_AIO is not set
+# CONFIG_DELL_SMO8800 is not set
+# CONFIG_FUJITSU_TABLET is not set
+# CONFIG_HP_ACCEL is not set
+# CONFIG_HP_WIRELESS is not set
+# CONFIG_HP_WMI is not set
+# CONFIG_SENSORS_HDAPS is not set
+CONFIG_ACPI_WMI=m
+# CONFIG_TOPSTAR_LAPTOP is not set
+# CONFIG_TOSHIBA_BT_RFKILL is not set
+# CONFIG_TOSHIBA_HAPS is not set
+# CONFIG_TOSHIBA_WMI is not set
+# CONFIG_ACPI_CMPC is not set
+# CONFIG_INTEL_IPS is not set
+# CONFIG_IBM_RTL is not set
+CONFIG_MXM_WMI=m
+# CONFIG_SAMSUNG_Q10 is not set
+# CONFIG_INTEL_RST is not set
+# CONFIG_INTEL_SMARTCONNECT is not set
+# CONFIG_PVPANIC is not set
+# CONFIG_INTEL_PMC_IPC is not set
+# CONFIG_SURFACE_PRO3_BUTTON is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_PXA is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKEVT_I8253=y
+CONFIG_I8253_LOCK=y
+CONFIG_CLKBLD_I8253=y
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_API=y
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Generic IOMMU Pagetable Support
+#
+CONFIG_IOMMU_IOVA=y
+CONFIG_AMD_IOMMU=y
+# CONFIG_AMD_IOMMU_STATS is not set
+CONFIG_AMD_IOMMU_V2=y
+CONFIG_DMAR_TABLE=y
+CONFIG_INTEL_IOMMU=y
+# CONFIG_INTEL_IOMMU_SVM is not set
+# CONFIG_INTEL_IOMMU_DEFAULT_ON is not set
+CONFIG_INTEL_IOMMU_FLOPPY_WA=y
+CONFIG_IRQ_REMAP=y
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+CONFIG_PM_DEVFREQ=y
+
+#
+# DEVFREQ Governors
+#
+# CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND is not set
+# CONFIG_DEVFREQ_GOV_PERFORMANCE is not set
+# CONFIG_DEVFREQ_GOV_POWERSAVE is not set
+# CONFIG_DEVFREQ_GOV_USERSPACE is not set
+
+#
+# DEVFREQ Drivers
+#
+# CONFIG_PM_DEVFREQ_EVENT is not set
+# CONFIG_EXTCON is not set
+CONFIG_MEMORY=y
+# CONFIG_IIO is not set
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_PWM is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+CONFIG_POWERCAP=y
+CONFIG_INTEL_RAPL=m
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_RAS=y
+# CONFIG_THUNDERBOLT is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_STM_DUMMY is not set
+# CONFIG_STM_SOURCE_CONSOLE is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+CONFIG_FIRMWARE_MEMMAP=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+CONFIG_DMI_SYSFS=y
+CONFIG_DMI_SCAN_MACHINE_NON_EFI_FALLBACK=y
+# CONFIG_ISCSI_IBFT_FIND is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# EFI (Extensible Firmware Interface) Support
+#
+# CONFIG_EFI_VARS is not set
+CONFIG_EFI_ESRT=y
+CONFIG_EFI_RUNTIME_MAP=y
+# CONFIG_EFI_FAKE_MEMMAP is not set
+CONFIG_EFI_RUNTIME_WRAPPERS=y
+CONFIG_UEFI_CPER=y
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_ENCRYPTION is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+CONFIG_BTRFS_FS=y
+# CONFIG_BTRFS_FS_POSIX_ACL is not set
+# CONFIG_BTRFS_FS_CHECK_INTEGRITY is not set
+# CONFIG_BTRFS_FS_RUN_SANITY_TESTS is not set
+# CONFIG_BTRFS_DEBUG is not set
+# CONFIG_BTRFS_ASSERT is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_FS_DAX is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+# CONFIG_FANOTIFY_ACCESS_PERMISSIONS is not set
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+CONFIG_PRINT_QUOTA_WARNING=y
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTACTL=y
+CONFIG_QUOTACTL_COMPAT=y
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+CONFIG_OVERLAY_FS=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_PROC_CHILDREN=y
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_EFIVAR_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_PSTORE=y
+# CONFIG_PSTORE_CONSOLE is not set
+# CONFIG_PSTORE_PMSG is not set
+# CONFIG_PSTORE_FTRACE is not set
+# CONFIG_PSTORE_RAM is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+# CONFIG_NFS_V2 is not set
+# CONFIG_NFS_V3 is not set
+CONFIG_NFS_V4=m
+CONFIG_NFS_SWAP=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_PNFS_FILE_LAYOUT=m
+CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN="kernel.org"
+# CONFIG_NFS_V4_1_MIGRATION is not set
+CONFIG_NFS_V4_SECURITY_LABEL=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_NFS_DEBUG=y
+# CONFIG_NFSD is not set
+CONFIG_GRACE_PERIOD=m
+CONFIG_LOCKD=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+CONFIG_SUNRPC_GSS=m
+CONFIG_SUNRPC_BACKCHANNEL=y
+CONFIG_SUNRPC_SWAP=y
+CONFIG_SUNRPC_DEBUG=y
+# CONFIG_SUNRPC_XPRT_RDMA is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_9P_FS=y
+# CONFIG_9P_FS_POSIX_ACL is not set
+# CONFIG_9P_FS_SECURITY is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_INFO_SPLIT is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+# CONFIG_GDB_SCRIPTS is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=8192
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_READABLE_ASM is not set
+CONFIG_UNUSED_SYMBOLS=y
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x01b6
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+CONFIG_HAVE_ARCH_KASAN=y
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_HARDLOCKUP_DETECTOR=y
+# CONFIG_BOOTPARAM_HARDLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE=0
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=60
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHED_INFO=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+CONFIG_TIMER_STATS=y
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS=y
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_FENTRY=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACER_MAX_TRACE=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_TRACER_SNAPSHOT=y
+# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+CONFIG_STACK_TRACER=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_KPROBE_EVENT=y
+CONFIG_UPROBE_EVENT=y
+CONFIG_PROBE_EVENTS=y
+CONFIG_DYNAMIC_FTRACE=y
+CONFIG_DYNAMIC_FTRACE_WITH_REGS=y
+# CONFIG_FUNCTION_PROFILER is not set
+CONFIG_FTRACE_MCOUNT_RECORD=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+# CONFIG_MMIOTRACE is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_TRACE_ENUM_MAP_FILE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_UDELAY is not set
+CONFIG_MEMTEST=y
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+CONFIG_EARLY_PRINTK_EFI=y
+# CONFIG_X86_PTDUMP_CORE is not set
+# CONFIG_X86_PTDUMP is not set
+# CONFIG_EFI_PGT_DUMP is not set
+CONFIG_DEBUG_RODATA=y
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_WX is not set
+CONFIG_DEBUG_SET_MODULE_RONX=y
+# CONFIG_DEBUG_NX_TEST is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_DEBUG_TLBFLUSH is not set
+# CONFIG_IOMMU_DEBUG is not set
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+# CONFIG_X86_DECODER_SELFTEST is not set
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_IO_DELAY_0X80=y
+# CONFIG_IO_DELAY_0XED is not set
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+# CONFIG_DEBUG_BOOT_PARAMS is not set
+# CONFIG_CPA_DEBUG is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_ENTRY is not set
+# CONFIG_DEBUG_NMI_SELFTEST is not set
+# CONFIG_X86_DEBUG_STATIC_CPU_HAS is not set
+CONFIG_X86_DEBUG_FPU=y
+# CONFIG_PUNIT_ATOM_DEBUG is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_COMPAT=y
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+# CONFIG_PAGE_TABLE_ISOLATION is not set
+CONFIG_SECURITYFS=y
+# CONFIG_SECURITY_NETWORK is not set
+# CONFIG_SECURITY_PATH is not set
+# CONFIG_INTEL_TXT is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_APPARMOR is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_INTEGRITY is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_XOR_BLOCKS=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+# CONFIG_CRYPTO_RSA is not set
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRC32_PCLMUL is not set
+CONFIG_CRYPTO_CRCT10DIF=y
+# CONFIG_CRYPTO_CRCT10DIF_PCLMUL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_POLY1305_X86_64 is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA1_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256_SSSE3 is not set
+# CONFIG_CRYPTO_SHA512_SSSE3 is not set
+# CONFIG_CRYPTO_SHA1_MB is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_X86_64 is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_BLOWFISH_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAMELLIA_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST5_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_CAST6_AVX_X86_64 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_DES3_EDE_X86_64 is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_X86_64 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_CHACHA20_X86_64 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SERPENT_SSE2_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64 is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64_3WAY is not set
+# CONFIG_CRYPTO_TWOFISH_AVX_X86_64 is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_DRBG_MENU is not set
+# CONFIG_CRYPTO_JITTERENTROPY is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
+CONFIG_HAVE_KVM=y
+CONFIG_HAVE_KVM_IRQCHIP=y
+CONFIG_HAVE_KVM_IRQFD=y
+CONFIG_HAVE_KVM_IRQ_ROUTING=y
+CONFIG_HAVE_KVM_EVENTFD=y
+CONFIG_KVM_APIC_ARCHITECTURE=y
+CONFIG_KVM_MMIO=y
+CONFIG_KVM_ASYNC_PF=y
+CONFIG_HAVE_KVM_MSI=y
+CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT=y
+CONFIG_KVM_VFIO=y
+CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT=y
+CONFIG_KVM_COMPAT=y
+CONFIG_HAVE_KVM_IRQ_BYPASS=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_KVM_INTEL=m
+# CONFIG_KVM_AMD is not set
+# CONFIG_KVM_MMU_AUDIT is not set
+# CONFIG_KVM_DEVICE_ASSIGNMENT is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_RAID6_PQ=y
+CONFIG_BITREVERSE=y
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_ARCH_HAS_FAST_MULTIPLIER=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_CHECK_SIGNATURE=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_OID_REGISTRY=m
+CONFIG_UCS2_STRING=y
+CONFIG_FONT_SUPPORT=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_SG_SPLIT is not set
+CONFIG_ARCH_HAS_SG_CHAIN=y
+CONFIG_ARCH_HAS_PMEM_API=y
+CONFIG_ARCH_HAS_MMIO_FLUSH=y
diff --git a/kernel/popcorn/configs/config_puzzlehype_mir_200512_1st_working b/kernel/popcorn/configs/config_puzzlehype_mir_200512_1st_working
new file mode 100644
index 000000000000..4e880118d2cf
--- /dev/null
+++ b/kernel/popcorn/configs/config_puzzlehype_mir_200512_1st_working
@@ -0,0 +1,3042 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/x86 4.4.137 Kernel Configuration
+#
+CONFIG_64BIT=y
+CONFIG_X86_64=y
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_PERF_EVENTS_INTEL_UNCORE=y
+CONFIG_OUTPUT_FORMAT="elf64-x86-64"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/x86_64_defconfig"
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+CONFIG_ZONE_DMA32=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_HAVE_INTEL_TXT=y
+CONFIG_X86_64_SMP=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PGTABLE_LEVELS=4
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION="-pop-hype"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KERNEL_XZ=y
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_FHANDLE=y
+CONFIG_USELIB=y
+CONFIG_AUDIT=y
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_VIRT_CPU_ACCOUNTING=y
+# CONFIG_TICK_CPU_ACCOUNTING is not set
+CONFIG_VIRT_CPU_ACCOUNTING_GEN=y
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_CONTEXT_TRACKING=y
+# CONFIG_CONTEXT_TRACKING_FORCE is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_EXPEDITE_BOOT is not set
+# CONFIG_BUILD_BIN2C is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=21
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=13
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
+CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH=y
+CONFIG_ARCH_SUPPORTS_INT128=y
+# CONFIG_NUMA_BALANCING is not set
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_PAGE_COUNTER=y
+CONFIG_MEMCG=y
+# CONFIG_MEMCG_KMEM is not set
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+CONFIG_CGROUP_WRITEBACK=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_RD_LZ4=y
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_HAVE_PCSPKR_PLATFORM=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_MULTIUSER=y
+CONFIG_SGETMASK_SYSCALL=y
+CONFIG_SYSFS_SYSCALL=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_BPF_SYSCALL=y
+# CONFIG_BPF_JIT_ALWAYS_ON is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_USERFAULTFD=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_MEMBARRIER=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_KEXEC_CORE=y
+CONFIG_OPROFILE=m
+# CONFIG_OPROFILE_EVENT_MULTIPLEX is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_OPROFILE_NMI_TIMER=y
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+CONFIG_OPTPROBES=y
+CONFIG_KPROBES_ON_FTRACE=y
+CONFIG_UPROBES=y
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_KRETPROBES=y
+CONFIG_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_KPROBES_ON_FTRACE=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR_NONE is not set
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+CONFIG_CC_STACKPROTECTOR_STRONG=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_HAVE_ARCH_HUGE_VMAP=y
+CONFIG_HAVE_ARCH_SOFT_DIRTY=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_COPY_THREAD_TLS=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_BLK_DEV_THROTTLING=y
+# CONFIG_BLK_CMDLINE_PARSER is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+# CONFIG_CMDLINE_PARTITION is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_PREEMPT_NOTIFIERS=y
+CONFIG_ASN1=m
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_ARCH_USE_QUEUED_SPINLOCKS=y
+CONFIG_QUEUED_SPINLOCKS=y
+CONFIG_ARCH_USE_QUEUED_RWLOCKS=y
+CONFIG_QUEUED_RWLOCKS=y
+CONFIG_FREEZER=y
+
+#
+# Popcorn Distributed Execution Support
+#
+CONFIG_ARCH_SUPPORTS_POPCORN=y
+CONFIG_POPCORN=y
+CONFIG_POPCORN_HYPE=y
+# CONFIG_POPCORN_DEBUG is not set
+CONFIG_POPCORN_CHECK_SANITY=y
+# CONFIG_POPCORN_REMOTE_INFO is not set
+# CONFIG_POPCORN_STAT is not set
+CONFIG_POPCORN_KMSG=y
+CONFIG_POPCORN_KMSG_SOCKET=m
+CONFIG_POPCORN_KMSG_RDMA=m
+# CONFIG_POPCORN_KMSG_TEST is not set
+
+#
+# Processor type and features
+#
+CONFIG_ZONE_DMA=y
+CONFIG_SMP=y
+CONFIG_X86_FEATURE_NAMES=y
+# CONFIG_X86_X2APIC is not set
+CONFIG_X86_MPPARSE=y
+CONFIG_RETPOLINE=y
+# CONFIG_X86_EXTENDED_PLATFORM is not set
+CONFIG_X86_INTEL_LPSS=y
+CONFIG_X86_AMD_PLATFORM_DEVICE=y
+CONFIG_IOSF_MBI=y
+# CONFIG_IOSF_MBI_DEBUG is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+CONFIG_HYPERVISOR_GUEST=y
+CONFIG_PARAVIRT=y
+# CONFIG_PARAVIRT_DEBUG is not set
+CONFIG_PARAVIRT_SPINLOCKS=y
+# CONFIG_XEN is not set
+CONFIG_KVM_GUEST=y
+# CONFIG_KVM_DEBUG_FS is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+CONFIG_PARAVIRT_CLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MK8 is not set
+# CONFIG_MPSC is not set
+CONFIG_MCORE2=y
+# CONFIG_MATOM is not set
+# CONFIG_GENERIC_CPU is not set
+CONFIG_X86_INTERNODE_CACHE_SHIFT=6
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_INTEL_USERCOPY=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_X86_P6_NOP=y
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=64
+CONFIG_X86_DEBUGCTLMSR=y
+# CONFIG_PROCESSOR_SELECT is not set
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+# CONFIG_GART_IOMMU is not set
+# CONFIG_CALGARY_IOMMU is not set
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_MAXSMP is not set
+CONFIG_NR_CPUS=64
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_X86_MCE_THRESHOLD=y
+CONFIG_X86_MCE_INJECT=m
+CONFIG_X86_THERMAL_VECTOR=y
+# CONFIG_VM86 is not set
+CONFIG_X86_16BIT=y
+CONFIG_X86_ESPFIX64=y
+CONFIG_X86_VSYSCALL_EMULATION=y
+# CONFIG_I8K is not set
+CONFIG_MICROCODE=y
+CONFIG_MICROCODE_INTEL=y
+CONFIG_MICROCODE_AMD=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+CONFIG_X86_MSR=m
+CONFIG_X86_CPUID=m
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_X86_DIRECT_GBPAGES=y
+CONFIG_NUMA=y
+# CONFIG_AMD_NUMA is not set
+CONFIG_X86_64_ACPI_NUMA=y
+CONFIG_NODES_SPAN_OTHER_NODES=y
+# CONFIG_NUMA_EMU is not set
+CONFIG_NODES_SHIFT=6
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_ARCH_DISCARD_MEMBLOCK=y
+# CONFIG_MOVABLE_NODE is not set
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+# CONFIG_MEMORY_HOTPLUG is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK=y
+CONFIG_MEMORY_BALLOON=y
+# CONFIG_COMPACTION is not set
+CONFIG_MIGRATION=y
+CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_MMU_NOTIFIER=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+# CONFIG_MEMORY_FAILURE is not set
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CMA is not set
+# CONFIG_MEM_SOFT_DIRTY is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+CONFIG_ARCH_SUPPORTS_DEFERRED_STRUCT_PAGE_INIT=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_X86_PMEM_LEGACY is not set
+# CONFIG_X86_CHECK_BIOS_CORRUPTION is not set
+CONFIG_X86_RESERVE_LOW=64
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_ARCH_RANDOM=y
+CONFIG_X86_SMAP=y
+CONFIG_X86_INTEL_MPX=y
+CONFIG_EFI=y
+CONFIG_EFI_STUB=y
+# CONFIG_EFI_MIXED is not set
+CONFIG_SECCOMP=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+# CONFIG_KEXEC_FILE is not set
+CONFIG_CRASH_DUMP=y
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+# CONFIG_RANDOMIZE_BASE is not set
+CONFIG_PHYSICAL_ALIGN=0x200000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_BOOTPARAM_HOTPLUG_CPU0 is not set
+# CONFIG_DEBUG_HOTPLUG_CPU0 is not set
+# CONFIG_LEGACY_VSYSCALL_NATIVE is not set
+CONFIG_LEGACY_VSYSCALL_EMULATE=y
+# CONFIG_LEGACY_VSYSCALL_NONE is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MODIFY_LDT_SYSCALL=y
+CONFIG_HAVE_LIVEPATCH=y
+# CONFIG_LIVEPATCH is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_USE_PERCPU_NUMA_NODE_ID=y
+
+#
+# Power management and ACPI options
+#
+# CONFIG_SUSPEND is not set
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+# CONFIG_DPM_WATCHDOG is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_LEGACY_TABLES_LOOKUP=y
+CONFIG_ARCH_MIGHT_HAVE_ACPI_PDC=y
+CONFIG_ACPI_SYSTEM_POWER_STATES_SUPPORT=y
+# CONFIG_ACPI_DEBUGGER is not set
+# CONFIG_ACPI_PROCFS_POWER is not set
+CONFIG_ACPI_REV_OVERRIDE_POSSIBLE=y
+# CONFIG_ACPI_EC_DEBUGFS is not set
+# CONFIG_ACPI_AC is not set
+# CONFIG_ACPI_BATTERY is not set
+# CONFIG_ACPI_BUTTON is not set
+CONFIG_ACPI_FAN=m
+# CONFIG_ACPI_DOCK is not set
+CONFIG_ACPI_CPU_FREQ_PSS=y
+CONFIG_ACPI_PROCESSOR_IDLE=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_ACPI_IPMI=m
+CONFIG_ACPI_HOTPLUG_CPU=y
+CONFIG_ACPI_PROCESSOR_AGGREGATOR=m
+CONFIG_ACPI_THERMAL=m
+CONFIG_ACPI_NUMA=y
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+# CONFIG_ACPI_INITRD_TABLE_OVERRIDE is not set
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_PCI_SLOT=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_ACPI_HOTPLUG_IOAPIC=y
+# CONFIG_ACPI_SBS is not set
+CONFIG_ACPI_HED=y
+# CONFIG_ACPI_CUSTOM_METHOD is not set
+CONFIG_ACPI_BGRT=y
+# CONFIG_ACPI_REDUCED_HARDWARE_ONLY is not set
+# CONFIG_ACPI_NFIT is not set
+CONFIG_HAVE_ACPI_APEI=y
+CONFIG_HAVE_ACPI_APEI_NMI=y
+CONFIG_ACPI_APEI=y
+CONFIG_ACPI_APEI_GHES=y
+CONFIG_ACPI_APEI_PCIEAER=y
+# CONFIG_ACPI_APEI_EINJ is not set
+# CONFIG_ACPI_APEI_ERST_DEBUG is not set
+CONFIG_ACPI_EXTLOG=y
+# CONFIG_PMIC_OPREGION is not set
+CONFIG_SFI=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# CPU frequency scaling drivers
+#
+CONFIG_X86_INTEL_PSTATE=y
+CONFIG_X86_PCC_CPUFREQ=m
+CONFIG_X86_ACPI_CPUFREQ=m
+CONFIG_X86_ACPI_CPUFREQ_CPB=y
+# CONFIG_X86_POWERNOW_K8 is not set
+# CONFIG_X86_AMD_FREQ_SENSITIVITY is not set
+# CONFIG_X86_SPEEDSTEP_CENTRINO is not set
+# CONFIG_X86_P4_CLOCKMOD is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+CONFIG_INTEL_IDLE=y
+
+#
+# Memory power savings
+#
+# CONFIG_I7300_IDLE is not set
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+CONFIG_PCI_DIRECT=y
+# CONFIG_PCI_MMCONFIG is not set
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+CONFIG_PCIEAER_INJECT=m
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PME=y
+CONFIG_PCI_BUS_ADDR_T_64BIT=y
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+# CONFIG_PCI_DEBUG is not set
+CONFIG_PCI_REALLOC_ENABLE_AUTO=y
+CONFIG_PCI_STUB=m
+CONFIG_HT_IRQ=y
+CONFIG_PCI_ATS=y
+CONFIG_PCI_IOV=y
+CONFIG_PCI_PRI=y
+CONFIG_PCI_PASID=y
+CONFIG_PCI_LABEL=y
+
+#
+# PCI host controller drivers
+#
+CONFIG_ISA_DMA_API=y
+CONFIG_AMD_NB=y
+# CONFIG_PCCARD is not set
+# CONFIG_HOTPLUG_PCI is not set
+# CONFIG_RAPIDIO is not set
+# CONFIG_X86_SYSFB is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=m
+CONFIG_COREDUMP=y
+# CONFIG_IA32_EMULATION is not set
+# CONFIG_X86_X32 is not set
+CONFIG_X86_DEV_DMA_OPS=y
+CONFIG_PMC_ATOM=y
+CONFIG_NET=y
+CONFIG_NET_INGRESS=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_XFRM=y
+CONFIG_XFRM_ALGO=m
+CONFIG_XFRM_USER=m
+CONFIG_XFRM_SUB_POLICY=y
+CONFIG_XFRM_MIGRATE=y
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=m
+CONFIG_NET_KEY=m
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_TRIE_STATS=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE_DEMUX=m
+CONFIG_NET_IP_TUNNEL=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_SYN_COOKIES=y
+CONFIG_NET_IPVTI=m
+CONFIG_NET_UDP_TUNNEL=m
+CONFIG_NET_FOU=m
+CONFIG_NET_FOU_IP_TUNNELS=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_TUNNEL=m
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=m
+CONFIG_INET_XFRM_MODE_TUNNEL=m
+CONFIG_INET_XFRM_MODE_BEET=m
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_UDP_DIAG=y
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+# CONFIG_TCP_CONG_DCTCP is not set
+# CONFIG_TCP_CONG_CDG is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NET_PTP_CLASSIFY=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=m
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_INGRESS=y
+CONFIG_NETFILTER_NETLINK=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+# CONFIG_NF_CONNTRACK_MARK is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CT_NETLINK is not set
+# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+# CONFIG_NF_NAT_AMANDA is not set
+# CONFIG_NF_NAT_FTP is not set
+# CONFIG_NF_NAT_IRC is not set
+# CONFIG_NF_NAT_SIP is not set
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NF_NAT_REDIRECT is not set
+CONFIG_NF_TABLES=y
+CONFIG_NF_TABLES_NETDEV=y
+CONFIG_NFT_EXTHDR=y
+# CONFIG_NFT_META is not set
+# CONFIG_NFT_CT is not set
+# CONFIG_NFT_RBTREE is not set
+# CONFIG_NFT_HASH is not set
+# CONFIG_NFT_COUNTER is not set
+# CONFIG_NFT_LOG is not set
+# CONFIG_NFT_LIMIT is not set
+# CONFIG_NFT_MASQ is not set
+# CONFIG_NFT_REDIR is not set
+# CONFIG_NFT_NAT is not set
+# CONFIG_NFT_REJECT is not set
+CONFIG_NFT_COMPAT=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+# CONFIG_NETFILTER_XT_CONNMARK is not set
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+# CONFIG_NETFILTER_XT_TARGET_LOG is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+CONFIG_NETFILTER_XT_NAT=y
+# CONFIG_NETFILTER_XT_TARGET_NETMAP is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_REDIRECT is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y
+# CONFIG_NETFILTER_XT_MATCH_BPF is not set
+# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ECN is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+CONFIG_NETFILTER_XT_MATCH_HL=y
+# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+# CONFIG_NETFILTER_XT_MATCH_IPVS is not set
+# CONFIG_NETFILTER_XT_MATCH_L2TP is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+CONFIG_NETFILTER_XT_MATCH_RECENT=y
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+# CONFIG_NETFILTER_XT_MATCH_STATE is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_IP_SET is not set
+CONFIG_IP_VS=y
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+# CONFIG_IP_VS_PROTO_TCP is not set
+# CONFIG_IP_VS_PROTO_UDP is not set
+# CONFIG_IP_VS_PROTO_AH_ESP is not set
+# CONFIG_IP_VS_PROTO_ESP is not set
+# CONFIG_IP_VS_PROTO_AH is not set
+# CONFIG_IP_VS_PROTO_SCTP is not set
+
+#
+# IPVS scheduler
+#
+# CONFIG_IP_VS_RR is not set
+# CONFIG_IP_VS_WRR is not set
+# CONFIG_IP_VS_LC is not set
+# CONFIG_IP_VS_WLC is not set
+# CONFIG_IP_VS_FO is not set
+# CONFIG_IP_VS_OVF is not set
+# CONFIG_IP_VS_LBLC is not set
+# CONFIG_IP_VS_LBLCR is not set
+# CONFIG_IP_VS_DH is not set
+# CONFIG_IP_VS_SH is not set
+# CONFIG_IP_VS_SED is not set
+# CONFIG_IP_VS_NQ is not set
+
+#
+# IPVS SH scheduler
+#
+CONFIG_IP_VS_SH_TAB_BITS=8
+
+#
+# IPVS application helper
+#
+# CONFIG_IP_VS_NFCT is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_NF_TABLES_IPV4=y
+CONFIG_NFT_CHAIN_ROUTE_IPV4=y
+# CONFIG_NFT_REJECT_IPV4 is not set
+# CONFIG_NFT_DUP_IPV4 is not set
+CONFIG_NF_TABLES_ARP=y
+# CONFIG_NF_DUP_IPV4 is not set
+# CONFIG_NF_LOG_ARP is not set
+# CONFIG_NF_LOG_IPV4 is not set
+# CONFIG_NF_REJECT_IPV4 is not set
+CONFIG_NF_NAT_IPV4=y
+CONFIG_NFT_CHAIN_NAT_IPV4=y
+CONFIG_NF_NAT_MASQUERADE_IPV4=y
+# CONFIG_NF_NAT_PPTP is not set
+# CONFIG_NF_NAT_H323 is not set
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+CONFIG_IP_NF_FILTER=y
+# CONFIG_IP_NF_TARGET_REJECT is not set
+# CONFIG_IP_NF_TARGET_SYNPROXY is not set
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+# CONFIG_IP_NF_TARGET_NETMAP is not set
+# CONFIG_IP_NF_TARGET_REDIRECT is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+# CONFIG_IP_NF_ARP_MANGLE is not set
+# CONFIG_NF_TABLES_BRIDGE is not set
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+CONFIG_STP=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+# CONFIG_NET_SCH_FQ is not set
+# CONFIG_NET_SCH_HHF is not set
+# CONFIG_NET_SCH_PIE is not set
+# CONFIG_NET_SCH_PLUG is not set
+
+#
+# Classification
+#
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+# CONFIG_NET_CLS_BPF is not set
+# CONFIG_NET_CLS_FLOWER is not set
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_CLS_ACT is not set
+CONFIG_NET_SCH_FIFO=y
+CONFIG_DCB=y
+CONFIG_DNS_RESOLVER=m
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+CONFIG_NETLINK_DIAG=y
+CONFIG_MPLS=y
+# CONFIG_NET_MPLS_GSO is not set
+# CONFIG_MPLS_ROUTING is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_CGROUP_NET_CLASSID=y
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+CONFIG_BPF_JIT=y
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=m
+# CONFIG_NET_TCPPROBE is not set
+CONFIG_NET_DROP_MONITOR=m
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+# CONFIG_NET_9P_RDMA is not set
+# CONFIG_NET_9P_DEBUG is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_DST_CACHE=y
+CONFIG_HAVE_BPF_JIT=y
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_UEVENT_HELPER is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_GENERIC_CPU_VULNERABILITIES=y
+# CONFIG_DMA_SHARED_BUFFER is not set
+
+#
+# Bus devices
+#
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_OF is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG_MESSAGES is not set
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SKD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=18874368
+# CONFIG_BLK_DEV_RAM_DAX is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_VIRTIO_BLK is not set
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+# CONFIG_BLK_DEV_NVME is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_93CX6=m
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+
+#
+# Altera FPGA firmware download module
+#
+CONFIG_INTEL_MEI=m
+CONFIG_INTEL_MEI_ME=m
+# CONFIG_INTEL_MEI_TXE is not set
+# CONFIG_VMWARE_VMCI is not set
+
+#
+# Intel MIC Bus Driver
+#
+# CONFIG_INTEL_MIC_BUS is not set
+
+#
+# SCIF Bus Driver
+#
+# CONFIG_SCIF_BUS is not set
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+# CONFIG_GENWQE is not set
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_KERNEL_API is not set
+# CONFIG_CXL_EEH is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=m
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=m
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_MQ_DEFAULT is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=m
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_ZPODD=y
+# CONFIG_SATA_PMP is not set
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI=m
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+# CONFIG_ATA_SFF is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+CONFIG_MII=m
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_GENEVE is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+CONFIG_TUN=y
+# CONFIG_TUN_VNET_CROSS_LE is not set
+CONFIG_VETH=y
+CONFIG_VIRTIO_NET=y
+# CONFIG_NLMON is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_VHOST_NET=y
+CONFIG_VHOST_RING=y
+CONFIG_VHOST=y
+# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+CONFIG_ETHERNET=y
+CONFIG_MDIO=m
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_CADENCE is not set
+CONFIG_NET_VENDOR_BROADCOM=y
+CONFIG_B44=m
+CONFIG_B44_PCI_AUTOSELECT=y
+CONFIG_B44_PCICORE_AUTOSELECT=y
+CONFIG_B44_PCI=y
+CONFIG_BCMGENET=m
+CONFIG_BNX2=m
+CONFIG_CNIC=m
+CONFIG_TIGON3=m
+CONFIG_BNX2X=m
+CONFIG_BNX2X_SRIOV=y
+CONFIG_BNXT=m
+CONFIG_BNXT_SRIOV=y
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_CX_ECAT is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_HP is not set
+CONFIG_NET_VENDOR_INTEL=y
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IXGB is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGBEVF is not set
+CONFIG_I40E=m
+# CONFIG_I40E_DCB is not set
+CONFIG_I40EVF=m
+# CONFIG_FM10K is not set
+# CONFIG_NET_VENDOR_I825XX is not set
+# CONFIG_JME is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+CONFIG_MLX4_EN=m
+CONFIG_MLX4_EN_DCB=y
+CONFIG_MLX4_CORE=m
+CONFIG_MLX4_DEBUG=y
+CONFIG_MLX5_CORE=m
+CONFIG_MLX5_CORE_EN=y
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_SFC is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_NET_SB1000 is not set
+CONFIG_PHYLIB=m
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_AT803X_PHY is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_SMSC_PHY is not set
+CONFIG_BCM_NET_PHYLIB=m
+# CONFIG_BROADCOM_PHY is not set
+CONFIG_BCM7XXX_PHY=m
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+CONFIG_FIXED_PHY=m
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_OCTEON is not set
+# CONFIG_MDIO_BCM_UNIMAC is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Host-side USB support is needed for USB Network Adapter support
+#
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_FUJITSU_ES is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
+CONFIG_SERIO_I8042=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DMA=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_RSA=y
+# CONFIG_SERIAL_8250_FSL is not set
+# CONFIG_SERIAL_8250_DW is not set
+# CONFIG_SERIAL_8250_RT288X is not set
+# CONFIG_SERIAL_8250_FINTEK is not set
+# CONFIG_SERIAL_8250_MID is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+CONFIG_TTY_PRINTK=y
+# CONFIG_VIRTIO_CONSOLE is not set
+CONFIG_IPMI_HANDLER=m
+# CONFIG_IPMI_PANIC_EVENT is not set
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+# CONFIG_IPMI_SI_PROBE_DEFAULTS is not set
+# CONFIG_IPMI_SSIF is not set
+CONFIG_IPMI_WATCHDOG=m
+CONFIG_IPMI_POWEROFF=m
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_VIA=y
+CONFIG_HW_RANDOM_VIRTIO=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_MWAVE is not set
+CONFIG_RAW_DRIVER=m
+CONFIG_MAX_RAW_DEVS=256
+CONFIG_HPET=y
+CONFIG_HPET_MMAP=y
+CONFIG_HPET_MMAP_DEFAULT=y
+CONFIG_HANGCHECK_TIMER=y
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+# CONFIG_NTP_PPS is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+CONFIG_PPS_CLIENT_LDISC=m
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=m
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_CHERRYVIEW is not set
+# CONFIG_PINCTRL_BROXTON is not set
+# CONFIG_PINCTRL_SUNRISEPOINT is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_APPLESMC is not set
+# CONFIG_SENSORS_DELL_SMM is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_IBMAEM is not set
+# CONFIG_SENSORS_IBMPEX is not set
+CONFIG_SENSORS_I5500=m
+CONFIG_SENSORS_CORETEMP=m
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_NCT6683 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+
+#
+# ACPI drivers
+#
+CONFIG_SENSORS_ACPI_POWER=m
+# CONFIG_SENSORS_ATK0110 is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_THERMAL_GOV_BANG_BANG=y
+CONFIG_THERMAL_GOV_USER_SPACE=y
+# CONFIG_THERMAL_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_EMULATION is not set
+CONFIG_INTEL_POWERCLAMP=m
+CONFIG_X86_PKG_TEMP_THERMAL=m
+CONFIG_INTEL_SOC_DTS_IOSF_CORE=m
+CONFIG_INTEL_SOC_DTS_THERMAL=m
+CONFIG_INT340X_THERMAL=m
+CONFIG_ACPI_THERMAL_REL=m
+CONFIG_INTEL_PCH_THERMAL=m
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_ACQUIRE_WDT is not set
+# CONFIG_ADVANTECH_WDT is not set
+# CONFIG_ALIM1535_WDT is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_F71808E_WDT is not set
+# CONFIG_SP5100_TCO is not set
+# CONFIG_SBC_FITPC2_WATCHDOG is not set
+# CONFIG_EUROTECH_WDT is not set
+# CONFIG_IB700_WDT is not set
+# CONFIG_IBMASR is not set
+# CONFIG_WAFER_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_IE6XX_WDT is not set
+CONFIG_ITCO_WDT=m
+CONFIG_ITCO_VENDOR_SUPPORT=y
+# CONFIG_IT8712F_WDT is not set
+# CONFIG_IT87_WDT is not set
+# CONFIG_HP_WATCHDOG is not set
+# CONFIG_SC1200_WDT is not set
+# CONFIG_PC87413_WDT is not set
+# CONFIG_NV_TCO is not set
+# CONFIG_60XX_WDT is not set
+# CONFIG_CPU5_WDT is not set
+# CONFIG_SMSC_SCH311X_WDT is not set
+# CONFIG_SMSC37B787_WDT is not set
+# CONFIG_VIA_WDT is not set
+# CONFIG_W83627HF_WDT is not set
+# CONFIG_W83877F_WDT is not set
+# CONFIG_W83977F_WDT is not set
+# CONFIG_MACHZ_WDT is not set
+# CONFIG_SBC_EPX_C3_WATCHDOG is not set
+# CONFIG_BCM7038_WDT is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB=y
+CONFIG_SSB_SPROM=y
+CONFIG_SSB_PCIHOST_POSSIBLE=y
+CONFIG_SSB_PCIHOST=y
+# CONFIG_SSB_B43_PCI_BRIDGE is not set
+# CONFIG_SSB_HOST_SOC is not set
+# CONFIG_SSB_SILENT is not set
+# CONFIG_SSB_DEBUG is not set
+CONFIG_SSB_DRIVER_PCICORE_POSSIBLE=y
+CONFIG_SSB_DRIVER_PCICORE=y
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_INTEL_QUARK_I2C_GPIO is not set
+# CONFIG_LPC_ICH is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_INTEL_LPSS_ACPI is not set
+# CONFIG_MFD_INTEL_LPSS_PCI is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RTSX_USB is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_AGP is not set
+# CONFIG_VGA_ARB is not set
+# CONFIG_VGA_SWITCHEROO is not set
+# CONFIG_DRM is not set
+
+#
+# Frame buffer Devices
+#
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=25
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=m
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=m
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=m
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=m
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=m
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_USB_MON is not set
+CONFIG_USB_WUSB_CBAF=m
+# CONFIG_USB_WUSB_CBAF_DEBUG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=m
+CONFIG_USB_XHCI_PCI=m
+# CONFIG_USB_XHCI_PLATFORM is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_PCI=m
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+CONFIG_USB_OHCI_HCD=m
+CONFIG_USB_OHCI_HCD_PCI=m
+# CONFIG_USB_OHCI_HCD_SSB is not set
+# CONFIG_USB_OHCI_HCD_PLATFORM is not set
+CONFIG_USB_UHCI_HCD=m
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_SSB is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+# CONFIG_USB_STORAGE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+# CONFIG_USB_CHAOSKEY is not set
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_USB_PHY is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_INFINIBAND=m
+CONFIG_INFINIBAND_USER_MAD=m
+CONFIG_INFINIBAND_USER_ACCESS=m
+CONFIG_INFINIBAND_USER_MEM=y
+CONFIG_INFINIBAND_ON_DEMAND_PAGING=y
+CONFIG_INFINIBAND_ADDR_TRANS=y
+CONFIG_INFINIBAND_MTHCA=m
+CONFIG_INFINIBAND_MTHCA_DEBUG=y
+# CONFIG_INFINIBAND_QIB is not set
+CONFIG_MLX4_INFINIBAND=m
+CONFIG_MLX5_INFINIBAND=m
+# CONFIG_INFINIBAND_NES is not set
+# CONFIG_INFINIBAND_OCRDMA is not set
+# CONFIG_INFINIBAND_USNIC is not set
+CONFIG_INFINIBAND_IPOIB=m
+CONFIG_INFINIBAND_IPOIB_CM=y
+CONFIG_INFINIBAND_IPOIB_DEBUG=y
+# CONFIG_INFINIBAND_IPOIB_DEBUG_DATA is not set
+# CONFIG_INFINIBAND_SRP is not set
+# CONFIG_INFINIBAND_ISER is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_VIRTUAL_CHANNELS=m
+CONFIG_DMA_ACPI=y
+CONFIG_INTEL_IDMA64=m
+# CONFIG_INTEL_IOATDMA is not set
+# CONFIG_DW_DMAC is not set
+# CONFIG_DW_DMAC_PCI is not set
+
+#
+# DMA Clients
+#
+CONFIG_ASYNC_TX_DMA=y
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_UIO=m
+CONFIG_UIO_CIF=m
+# CONFIG_UIO_PDRV_GENIRQ is not set
+# CONFIG_UIO_DMEM_GENIRQ is not set
+CONFIG_UIO_AEC=m
+CONFIG_UIO_SERCOS3=m
+CONFIG_UIO_PCI_GENERIC=m
+CONFIG_UIO_NETX=m
+# CONFIG_UIO_PRUSS is not set
+CONFIG_UIO_MF624=m
+# CONFIG_VFIO is not set
+CONFIG_IRQ_BYPASS_MANAGER=y
+CONFIG_VIRT_DRIVERS=y
+CONFIG_VIRTIO=y
+
+#
+# Virtio drivers
+#
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO_PCI_LEGACY=y
+CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_INPUT=y
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_HYPERV is not set
+# CONFIG_STAGING is not set
+CONFIG_X86_PLATFORM_DEVICES=y
+# CONFIG_ACERHDF is not set
+# CONFIG_DELL_SMO8800 is not set
+# CONFIG_FUJITSU_TABLET is not set
+# CONFIG_HP_ACCEL is not set
+# CONFIG_HP_WIRELESS is not set
+# CONFIG_SENSORS_HDAPS is not set
+# CONFIG_INTEL_MENLOW is not set
+# CONFIG_ACPI_WMI is not set
+# CONFIG_TOPSTAR_LAPTOP is not set
+# CONFIG_TOSHIBA_BT_RFKILL is not set
+# CONFIG_TOSHIBA_HAPS is not set
+# CONFIG_ACPI_CMPC is not set
+CONFIG_INTEL_IPS=m
+CONFIG_IBM_RTL=m
+# CONFIG_SAMSUNG_Q10 is not set
+CONFIG_INTEL_RST=m
+CONFIG_INTEL_SMARTCONNECT=m
+CONFIG_PVPANIC=m
+CONFIG_INTEL_PMC_IPC=m
+# CONFIG_SURFACE_PRO3_BUTTON is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_COMMON_CLK_PXA is not set
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKEVT_I8253=y
+CONFIG_I8253_LOCK=y
+CONFIG_CLKBLD_I8253=y
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_API=y
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Generic IOMMU Pagetable Support
+#
+CONFIG_IOMMU_IOVA=y
+# CONFIG_AMD_IOMMU is not set
+CONFIG_DMAR_TABLE=y
+CONFIG_INTEL_IOMMU=y
+CONFIG_INTEL_IOMMU_SVM=y
+# CONFIG_INTEL_IOMMU_DEFAULT_ON is not set
+CONFIG_INTEL_IOMMU_FLOPPY_WA=y
+# CONFIG_IRQ_REMAP is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+CONFIG_PM_DEVFREQ=y
+
+#
+# DEVFREQ Governors
+#
+CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=m
+# CONFIG_DEVFREQ_GOV_PERFORMANCE is not set
+# CONFIG_DEVFREQ_GOV_POWERSAVE is not set
+# CONFIG_DEVFREQ_GOV_USERSPACE is not set
+
+#
+# DEVFREQ Drivers
+#
+# CONFIG_PM_DEVFREQ_EVENT is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_PWM is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+CONFIG_POWERCAP=y
+CONFIG_INTEL_RAPL=m
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_RAS=y
+# CONFIG_THUNDERBOLT is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_STM_DUMMY is not set
+# CONFIG_STM_SOURCE_CONSOLE is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# Firmware Drivers
+#
+CONFIG_EDD=m
+# CONFIG_EDD_OFF is not set
+CONFIG_FIRMWARE_MEMMAP=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+CONFIG_DMI_SYSFS=y
+CONFIG_DMI_SCAN_MACHINE_NON_EFI_FALLBACK=y
+# CONFIG_ISCSI_IBFT_FIND is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# EFI (Extensible Firmware Interface) Support
+#
+CONFIG_EFI_VARS=m
+CONFIG_EFI_ESRT=y
+CONFIG_EFI_VARS_PSTORE=m
+# CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE is not set
+CONFIG_EFI_RUNTIME_MAP=y
+# CONFIG_EFI_FAKE_MEMMAP is not set
+CONFIG_EFI_RUNTIME_WRAPPERS=y
+CONFIG_UEFI_CPER=y
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_ENCRYPTION is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+CONFIG_BTRFS_FS=y
+# CONFIG_BTRFS_FS_POSIX_ACL is not set
+# CONFIG_BTRFS_FS_CHECK_INTEGRITY is not set
+# CONFIG_BTRFS_FS_RUN_SANITY_TESTS is not set
+# CONFIG_BTRFS_DEBUG is not set
+# CONFIG_BTRFS_ASSERT is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_FS_DAX=y
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+CONFIG_OVERLAY_FS=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_PROC_CHILDREN=y
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_EFIVAR_FS=m
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_PSTORE=y
+# CONFIG_PSTORE_CONSOLE is not set
+# CONFIG_PSTORE_PMSG is not set
+# CONFIG_PSTORE_FTRACE is not set
+CONFIG_PSTORE_RAM=m
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+CONFIG_NFS_V2=m
+CONFIG_NFS_V3=m
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=m
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_NFS_DEBUG=y
+# CONFIG_NFSD is not set
+CONFIG_GRACE_PERIOD=m
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+CONFIG_SUNRPC_GSS=m
+CONFIG_SUNRPC_DEBUG=y
+# CONFIG_SUNRPC_XPRT_RDMA is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_INFO_SPLIT is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+# CONFIG_GDB_SCRIPTS is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=8192
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x01b6
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+CONFIG_PAGE_EXTENSION=y
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+CONFIG_HAVE_ARCH_KASAN=y
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_HARDLOCKUP_DETECTOR=y
+# CONFIG_BOOTPARAM_HARDLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE=0
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=60
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHED_INFO=y
+CONFIG_SCHEDSTATS=y
+CONFIG_SCHED_STACK_END_CHECK=y
+# CONFIG_DEBUG_TIMEKEEPING is not set
+# CONFIG_TIMER_STATS is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_LIST=y
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS=y
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_FENTRY=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACER_MAX_TRACE=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_RING_BUFFER_ALLOW_SWAP=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_TRACER_SNAPSHOT=y
+# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+CONFIG_STACK_TRACER=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_KPROBE_EVENT=y
+CONFIG_UPROBE_EVENT=y
+CONFIG_BPF_EVENTS=y
+CONFIG_PROBE_EVENTS=y
+CONFIG_DYNAMIC_FTRACE=y
+CONFIG_DYNAMIC_FTRACE_WITH_REGS=y
+# CONFIG_FUNCTION_PROFILER is not set
+CONFIG_FTRACE_MCOUNT_RECORD=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+CONFIG_MMIOTRACE=y
+# CONFIG_MMIOTRACE_TEST is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_TRACE_ENUM_MAP_FILE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+CONFIG_TEST_USER_COPY=m
+CONFIG_TEST_BPF=m
+CONFIG_TEST_FIRMWARE=m
+# CONFIG_TEST_UDELAY is not set
+CONFIG_MEMTEST=y
+CONFIG_TEST_STATIC_KEYS=m
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+CONFIG_EARLY_PRINTK_EFI=y
+CONFIG_X86_PTDUMP_CORE=y
+# CONFIG_X86_PTDUMP is not set
+# CONFIG_EFI_PGT_DUMP is not set
+CONFIG_DEBUG_RODATA=y
+# CONFIG_DEBUG_RODATA_TEST is not set
+CONFIG_DEBUG_WX=y
+CONFIG_DEBUG_SET_MODULE_RONX=y
+# CONFIG_DEBUG_NX_TEST is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_DEBUG_TLBFLUSH is not set
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+# CONFIG_X86_DECODER_SELFTEST is not set
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_IO_DELAY_0X80=y
+# CONFIG_IO_DELAY_0XED is not set
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+# CONFIG_DEBUG_BOOT_PARAMS is not set
+# CONFIG_CPA_DEBUG is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_ENTRY is not set
+# CONFIG_DEBUG_NMI_SELFTEST is not set
+# CONFIG_X86_DEBUG_STATIC_CPU_HAS is not set
+CONFIG_X86_DEBUG_FPU=y
+# CONFIG_PUNIT_ATOM_DEBUG is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_PAGE_TABLE_ISOLATION is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_INTEL_TXT is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_XOR_BLOCKS=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_AKCIPHER=m
+# CONFIG_CRYPTO_RSA is not set
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=m
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=m
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRC32_PCLMUL is not set
+CONFIG_CRYPTO_CRCT10DIF=y
+# CONFIG_CRYPTO_CRCT10DIF_PCLMUL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_POLY1305_X86_64 is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA1_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256_SSSE3 is not set
+# CONFIG_CRYPTO_SHA512_SSSE3 is not set
+# CONFIG_CRYPTO_SHA1_MB is not set
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=m
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_X86_64 is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_BLOWFISH_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAMELLIA_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST5_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_CAST6_AVX_X86_64 is not set
+CONFIG_CRYPTO_DES=m
+# CONFIG_CRYPTO_DES3_EDE_X86_64 is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_X86_64 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_CHACHA20_X86_64 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SERPENT_SSE2_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64 is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64_3WAY is not set
+# CONFIG_CRYPTO_TWOFISH_AVX_X86_64 is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_DRBG_MENU is not set
+# CONFIG_CRYPTO_JITTERENTROPY is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_PADLOCK is not set
+# CONFIG_CRYPTO_DEV_CCP is not set
+CONFIG_CRYPTO_DEV_QAT=m
+CONFIG_CRYPTO_DEV_QAT_DH895xCC=m
+CONFIG_CRYPTO_DEV_QAT_DH895xCCVF=m
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
+CONFIG_HAVE_KVM=y
+CONFIG_HAVE_KVM_IRQCHIP=y
+CONFIG_HAVE_KVM_IRQFD=y
+CONFIG_HAVE_KVM_IRQ_ROUTING=y
+CONFIG_HAVE_KVM_EVENTFD=y
+CONFIG_KVM_APIC_ARCHITECTURE=y
+CONFIG_KVM_MMIO=y
+CONFIG_KVM_ASYNC_PF=y
+CONFIG_HAVE_KVM_MSI=y
+CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT=y
+CONFIG_KVM_VFIO=y
+CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT=y
+CONFIG_HAVE_KVM_IRQ_BYPASS=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_KVM_INTEL=m
+# CONFIG_KVM_AMD is not set
+# CONFIG_KVM_MMU_AUDIT is not set
+# CONFIG_KVM_DEVICE_ASSIGNMENT is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_RAID6_PQ=y
+CONFIG_BITREVERSE=y
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_ARCH_HAS_FAST_MULTIPLIER=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=m
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_REED_SOLOMON=m
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_OID_REGISTRY=m
+CONFIG_UCS2_STRING=y
+CONFIG_FONT_SUPPORT=y
+CONFIG_FONT_8x16=y
+CONFIG_FONT_AUTOSELECT=y
+# CONFIG_SG_SPLIT is not set
+CONFIG_ARCH_HAS_SG_CHAIN=y
+CONFIG_ARCH_HAS_PMEM_API=y
+CONFIG_ARCH_HAS_MMIO_FLUSH=y
diff --git a/kernel/popcorn/configs/config_puzzlehype_mir_200514_2st_fix b/kernel/popcorn/configs/config_puzzlehype_mir_200514_2st_fix
new file mode 100644
index 000000000000..ba3620b93b9f
--- /dev/null
+++ b/kernel/popcorn/configs/config_puzzlehype_mir_200514_2st_fix
@@ -0,0 +1,3127 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/x86 4.4.137 Kernel Configuration
+#
+CONFIG_64BIT=y
+CONFIG_X86_64=y
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_PERF_EVENTS_INTEL_UNCORE=y
+CONFIG_OUTPUT_FORMAT="elf64-x86-64"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/x86_64_defconfig"
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+CONFIG_ZONE_DMA32=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_HAVE_INTEL_TXT=y
+CONFIG_X86_64_SMP=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PGTABLE_LEVELS=4
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION="-pop-hype"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KERNEL_XZ=y
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_FHANDLE=y
+CONFIG_USELIB=y
+CONFIG_AUDIT=y
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_VIRT_CPU_ACCOUNTING=y
+# CONFIG_TICK_CPU_ACCOUNTING is not set
+CONFIG_VIRT_CPU_ACCOUNTING_GEN=y
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_CONTEXT_TRACKING=y
+# CONFIG_CONTEXT_TRACKING_FORCE is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_EXPEDITE_BOOT is not set
+# CONFIG_BUILD_BIN2C is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=21
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=13
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
+CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH=y
+CONFIG_ARCH_SUPPORTS_INT128=y
+# CONFIG_NUMA_BALANCING is not set
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_PAGE_COUNTER=y
+CONFIG_MEMCG=y
+# CONFIG_MEMCG_KMEM is not set
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+CONFIG_CGROUP_WRITEBACK=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_RD_LZ4=y
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_HAVE_PCSPKR_PLATFORM=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+CONFIG_SGETMASK_SYSCALL=y
+CONFIG_SYSFS_SYSCALL=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_BPF_SYSCALL=y
+# CONFIG_BPF_JIT_ALWAYS_ON is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_USERFAULTFD=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_MEMBARRIER=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_KEXEC_CORE=y
+CONFIG_OPROFILE=m
+# CONFIG_OPROFILE_EVENT_MULTIPLEX is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_OPROFILE_NMI_TIMER=y
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+CONFIG_OPTPROBES=y
+CONFIG_KPROBES_ON_FTRACE=y
+CONFIG_UPROBES=y
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_KRETPROBES=y
+CONFIG_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_KPROBES_ON_FTRACE=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_ARCH_WANT_OLD_COMPAT_IPC=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR_NONE is not set
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+CONFIG_CC_STACKPROTECTOR_STRONG=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_HAVE_ARCH_HUGE_VMAP=y
+CONFIG_HAVE_ARCH_SOFT_DIRTY=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_COPY_THREAD_TLS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_BLK_DEV_THROTTLING=y
+# CONFIG_BLK_CMDLINE_PARSER is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+# CONFIG_CMDLINE_PARTITION is not set
+CONFIG_BLOCK_COMPAT=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_PREEMPT_NOTIFIERS=y
+CONFIG_ASN1=m
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_ARCH_USE_QUEUED_SPINLOCKS=y
+CONFIG_QUEUED_SPINLOCKS=y
+CONFIG_ARCH_USE_QUEUED_RWLOCKS=y
+CONFIG_QUEUED_RWLOCKS=y
+CONFIG_FREEZER=y
+
+#
+# Popcorn Distributed Execution Support
+#
+CONFIG_ARCH_SUPPORTS_POPCORN=y
+CONFIG_POPCORN=y
+CONFIG_POPCORN_HYPE=y
+# CONFIG_POPCORN_DEBUG is not set
+CONFIG_POPCORN_CHECK_SANITY=y
+# CONFIG_POPCORN_REMOTE_INFO is not set
+# CONFIG_POPCORN_STAT is not set
+CONFIG_POPCORN_KMSG=y
+CONFIG_POPCORN_KMSG_SOCKET=m
+CONFIG_POPCORN_KMSG_RDMA=m
+# CONFIG_POPCORN_KMSG_TEST is not set
+
+#
+# Processor type and features
+#
+CONFIG_ZONE_DMA=y
+CONFIG_SMP=y
+CONFIG_X86_FEATURE_NAMES=y
+CONFIG_X86_X2APIC=y
+CONFIG_X86_MPPARSE=y
+CONFIG_RETPOLINE=y
+# CONFIG_X86_EXTENDED_PLATFORM is not set
+CONFIG_X86_INTEL_LPSS=y
+CONFIG_X86_AMD_PLATFORM_DEVICE=y
+CONFIG_IOSF_MBI=y
+# CONFIG_IOSF_MBI_DEBUG is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+CONFIG_HYPERVISOR_GUEST=y
+CONFIG_PARAVIRT=y
+# CONFIG_PARAVIRT_DEBUG is not set
+CONFIG_PARAVIRT_SPINLOCKS=y
+# CONFIG_XEN is not set
+CONFIG_KVM_GUEST=y
+# CONFIG_KVM_DEBUG_FS is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+CONFIG_PARAVIRT_CLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MK8 is not set
+# CONFIG_MPSC is not set
+CONFIG_MCORE2=y
+# CONFIG_MATOM is not set
+# CONFIG_GENERIC_CPU is not set
+CONFIG_X86_INTERNODE_CACHE_SHIFT=6
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_INTEL_USERCOPY=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_X86_P6_NOP=y
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=64
+CONFIG_X86_DEBUGCTLMSR=y
+# CONFIG_PROCESSOR_SELECT is not set
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+# CONFIG_GART_IOMMU is not set
+# CONFIG_CALGARY_IOMMU is not set
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_MAXSMP is not set
+CONFIG_NR_CPUS=64
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_X86_MCE_THRESHOLD=y
+CONFIG_X86_MCE_INJECT=m
+CONFIG_X86_THERMAL_VECTOR=y
+# CONFIG_VM86 is not set
+CONFIG_X86_16BIT=y
+CONFIG_X86_ESPFIX64=y
+CONFIG_X86_VSYSCALL_EMULATION=y
+# CONFIG_I8K is not set
+CONFIG_MICROCODE=y
+CONFIG_MICROCODE_INTEL=y
+CONFIG_MICROCODE_AMD=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+CONFIG_X86_MSR=m
+CONFIG_X86_CPUID=m
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_X86_DIRECT_GBPAGES=y
+CONFIG_NUMA=y
+# CONFIG_AMD_NUMA is not set
+CONFIG_X86_64_ACPI_NUMA=y
+CONFIG_NODES_SPAN_OTHER_NODES=y
+# CONFIG_NUMA_EMU is not set
+CONFIG_NODES_SHIFT=6
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_ARCH_DISCARD_MEMBLOCK=y
+# CONFIG_MOVABLE_NODE is not set
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+# CONFIG_MEMORY_HOTPLUG is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK=y
+CONFIG_MEMORY_BALLOON=y
+# CONFIG_COMPACTION is not set
+CONFIG_MIGRATION=y
+CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_MMU_NOTIFIER=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+# CONFIG_MEMORY_FAILURE is not set
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CMA is not set
+# CONFIG_MEM_SOFT_DIRTY is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+CONFIG_ARCH_SUPPORTS_DEFERRED_STRUCT_PAGE_INIT=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_X86_PMEM_LEGACY is not set
+# CONFIG_X86_CHECK_BIOS_CORRUPTION is not set
+CONFIG_X86_RESERVE_LOW=64
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_ARCH_RANDOM=y
+CONFIG_X86_SMAP=y
+# CONFIG_X86_INTEL_MPX is not set
+CONFIG_EFI=y
+CONFIG_EFI_STUB=y
+# CONFIG_EFI_MIXED is not set
+CONFIG_SECCOMP=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+# CONFIG_KEXEC_FILE is not set
+CONFIG_CRASH_DUMP=y
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+# CONFIG_RANDOMIZE_BASE is not set
+CONFIG_PHYSICAL_ALIGN=0x200000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_BOOTPARAM_HOTPLUG_CPU0 is not set
+# CONFIG_DEBUG_HOTPLUG_CPU0 is not set
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_LEGACY_VSYSCALL_NATIVE is not set
+CONFIG_LEGACY_VSYSCALL_EMULATE=y
+# CONFIG_LEGACY_VSYSCALL_NONE is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MODIFY_LDT_SYSCALL=y
+CONFIG_HAVE_LIVEPATCH=y
+# CONFIG_LIVEPATCH is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_USE_PERCPU_NUMA_NODE_ID=y
+
+#
+# Power management and ACPI options
+#
+# CONFIG_SUSPEND is not set
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+# CONFIG_DPM_WATCHDOG is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_LEGACY_TABLES_LOOKUP=y
+CONFIG_ARCH_MIGHT_HAVE_ACPI_PDC=y
+CONFIG_ACPI_SYSTEM_POWER_STATES_SUPPORT=y
+# CONFIG_ACPI_DEBUGGER is not set
+# CONFIG_ACPI_PROCFS_POWER is not set
+CONFIG_ACPI_REV_OVERRIDE_POSSIBLE=y
+# CONFIG_ACPI_EC_DEBUGFS is not set
+# CONFIG_ACPI_AC is not set
+# CONFIG_ACPI_BATTERY is not set
+# CONFIG_ACPI_BUTTON is not set
+CONFIG_ACPI_FAN=m
+# CONFIG_ACPI_DOCK is not set
+CONFIG_ACPI_CPU_FREQ_PSS=y
+CONFIG_ACPI_PROCESSOR_IDLE=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_ACPI_IPMI=m
+CONFIG_ACPI_HOTPLUG_CPU=y
+CONFIG_ACPI_PROCESSOR_AGGREGATOR=m
+CONFIG_ACPI_THERMAL=m
+CONFIG_ACPI_NUMA=y
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+# CONFIG_ACPI_INITRD_TABLE_OVERRIDE is not set
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_PCI_SLOT=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_ACPI_HOTPLUG_IOAPIC=y
+# CONFIG_ACPI_SBS is not set
+CONFIG_ACPI_HED=y
+# CONFIG_ACPI_CUSTOM_METHOD is not set
+CONFIG_ACPI_BGRT=y
+# CONFIG_ACPI_REDUCED_HARDWARE_ONLY is not set
+# CONFIG_ACPI_NFIT is not set
+CONFIG_HAVE_ACPI_APEI=y
+CONFIG_HAVE_ACPI_APEI_NMI=y
+CONFIG_ACPI_APEI=y
+CONFIG_ACPI_APEI_GHES=y
+CONFIG_ACPI_APEI_PCIEAER=y
+# CONFIG_ACPI_APEI_EINJ is not set
+# CONFIG_ACPI_APEI_ERST_DEBUG is not set
+CONFIG_ACPI_EXTLOG=y
+# CONFIG_PMIC_OPREGION is not set
+CONFIG_SFI=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# CPU frequency scaling drivers
+#
+CONFIG_X86_INTEL_PSTATE=y
+CONFIG_X86_PCC_CPUFREQ=m
+CONFIG_X86_ACPI_CPUFREQ=m
+CONFIG_X86_ACPI_CPUFREQ_CPB=y
+# CONFIG_X86_POWERNOW_K8 is not set
+# CONFIG_X86_AMD_FREQ_SENSITIVITY is not set
+# CONFIG_X86_SPEEDSTEP_CENTRINO is not set
+# CONFIG_X86_P4_CLOCKMOD is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+CONFIG_INTEL_IDLE=y
+
+#
+# Memory power savings
+#
+# CONFIG_I7300_IDLE is not set
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+CONFIG_PCI_DIRECT=y
+# CONFIG_PCI_MMCONFIG is not set
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+CONFIG_PCIEAER_INJECT=m
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PME=y
+CONFIG_PCI_BUS_ADDR_T_64BIT=y
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+# CONFIG_PCI_DEBUG is not set
+CONFIG_PCI_REALLOC_ENABLE_AUTO=y
+CONFIG_PCI_STUB=m
+CONFIG_HT_IRQ=y
+CONFIG_PCI_ATS=y
+CONFIG_PCI_IOV=y
+CONFIG_PCI_PRI=y
+CONFIG_PCI_PASID=y
+CONFIG_PCI_LABEL=y
+
+#
+# PCI host controller drivers
+#
+CONFIG_ISA_DMA_API=y
+CONFIG_AMD_NB=y
+# CONFIG_PCCARD is not set
+# CONFIG_HOTPLUG_PCI is not set
+# CONFIG_RAPIDIO is not set
+# CONFIG_X86_SYSFB is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=m
+CONFIG_COREDUMP=y
+CONFIG_IA32_EMULATION=y
+# CONFIG_IA32_AOUT is not set
+# CONFIG_X86_X32 is not set
+CONFIG_COMPAT=y
+CONFIG_COMPAT_FOR_U64_ALIGNMENT=y
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_X86_DEV_DMA_OPS=y
+CONFIG_PMC_ATOM=y
+CONFIG_NET=y
+CONFIG_NET_INGRESS=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_XFRM=y
+CONFIG_XFRM_ALGO=m
+CONFIG_XFRM_USER=m
+CONFIG_XFRM_SUB_POLICY=y
+CONFIG_XFRM_MIGRATE=y
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=m
+CONFIG_NET_KEY=m
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_TRIE_STATS=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE_DEMUX=m
+CONFIG_NET_IP_TUNNEL=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_SYN_COOKIES=y
+CONFIG_NET_IPVTI=m
+CONFIG_NET_UDP_TUNNEL=m
+CONFIG_NET_FOU=m
+CONFIG_NET_FOU_IP_TUNNELS=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_TUNNEL=m
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=m
+CONFIG_INET_XFRM_MODE_TUNNEL=m
+CONFIG_INET_XFRM_MODE_BEET=m
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_UDP_DIAG=y
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+# CONFIG_TCP_CONG_DCTCP is not set
+# CONFIG_TCP_CONG_CDG is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NET_PTP_CLASSIFY=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=m
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_INGRESS=y
+CONFIG_NETFILTER_NETLINK=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+# CONFIG_NF_CONNTRACK_MARK is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CT_NETLINK is not set
+# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+# CONFIG_NF_NAT_AMANDA is not set
+# CONFIG_NF_NAT_FTP is not set
+# CONFIG_NF_NAT_IRC is not set
+# CONFIG_NF_NAT_SIP is not set
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NF_NAT_REDIRECT is not set
+CONFIG_NF_TABLES=y
+CONFIG_NF_TABLES_NETDEV=y
+CONFIG_NFT_EXTHDR=y
+# CONFIG_NFT_META is not set
+# CONFIG_NFT_CT is not set
+# CONFIG_NFT_RBTREE is not set
+# CONFIG_NFT_HASH is not set
+# CONFIG_NFT_COUNTER is not set
+# CONFIG_NFT_LOG is not set
+# CONFIG_NFT_LIMIT is not set
+# CONFIG_NFT_MASQ is not set
+# CONFIG_NFT_REDIR is not set
+# CONFIG_NFT_NAT is not set
+# CONFIG_NFT_REJECT is not set
+CONFIG_NFT_COMPAT=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+# CONFIG_NETFILTER_XT_CONNMARK is not set
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+# CONFIG_NETFILTER_XT_TARGET_LOG is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+CONFIG_NETFILTER_XT_NAT=y
+# CONFIG_NETFILTER_XT_TARGET_NETMAP is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_REDIRECT is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y
+# CONFIG_NETFILTER_XT_MATCH_BPF is not set
+# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ECN is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+CONFIG_NETFILTER_XT_MATCH_HL=y
+# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+# CONFIG_NETFILTER_XT_MATCH_IPVS is not set
+# CONFIG_NETFILTER_XT_MATCH_L2TP is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+CONFIG_NETFILTER_XT_MATCH_RECENT=y
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+# CONFIG_NETFILTER_XT_MATCH_STATE is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_IP_SET is not set
+CONFIG_IP_VS=y
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+# CONFIG_IP_VS_PROTO_TCP is not set
+# CONFIG_IP_VS_PROTO_UDP is not set
+# CONFIG_IP_VS_PROTO_AH_ESP is not set
+# CONFIG_IP_VS_PROTO_ESP is not set
+# CONFIG_IP_VS_PROTO_AH is not set
+# CONFIG_IP_VS_PROTO_SCTP is not set
+
+#
+# IPVS scheduler
+#
+# CONFIG_IP_VS_RR is not set
+# CONFIG_IP_VS_WRR is not set
+# CONFIG_IP_VS_LC is not set
+# CONFIG_IP_VS_WLC is not set
+# CONFIG_IP_VS_FO is not set
+# CONFIG_IP_VS_OVF is not set
+# CONFIG_IP_VS_LBLC is not set
+# CONFIG_IP_VS_LBLCR is not set
+# CONFIG_IP_VS_DH is not set
+# CONFIG_IP_VS_SH is not set
+# CONFIG_IP_VS_SED is not set
+# CONFIG_IP_VS_NQ is not set
+
+#
+# IPVS SH scheduler
+#
+CONFIG_IP_VS_SH_TAB_BITS=8
+
+#
+# IPVS application helper
+#
+# CONFIG_IP_VS_NFCT is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_NF_TABLES_IPV4=y
+CONFIG_NFT_CHAIN_ROUTE_IPV4=y
+# CONFIG_NFT_REJECT_IPV4 is not set
+# CONFIG_NFT_DUP_IPV4 is not set
+CONFIG_NF_TABLES_ARP=y
+# CONFIG_NF_DUP_IPV4 is not set
+# CONFIG_NF_LOG_ARP is not set
+# CONFIG_NF_LOG_IPV4 is not set
+# CONFIG_NF_REJECT_IPV4 is not set
+CONFIG_NF_NAT_IPV4=y
+CONFIG_NFT_CHAIN_NAT_IPV4=y
+CONFIG_NF_NAT_MASQUERADE_IPV4=y
+# CONFIG_NF_NAT_PPTP is not set
+# CONFIG_NF_NAT_H323 is not set
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+CONFIG_IP_NF_FILTER=y
+# CONFIG_IP_NF_TARGET_REJECT is not set
+# CONFIG_IP_NF_TARGET_SYNPROXY is not set
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+# CONFIG_IP_NF_TARGET_NETMAP is not set
+# CONFIG_IP_NF_TARGET_REDIRECT is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+# CONFIG_IP_NF_ARP_MANGLE is not set
+# CONFIG_NF_TABLES_BRIDGE is not set
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+CONFIG_STP=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+# CONFIG_NET_SCH_FQ is not set
+# CONFIG_NET_SCH_HHF is not set
+# CONFIG_NET_SCH_PIE is not set
+# CONFIG_NET_SCH_PLUG is not set
+
+#
+# Classification
+#
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+# CONFIG_NET_CLS_BPF is not set
+# CONFIG_NET_CLS_FLOWER is not set
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_CLS_ACT is not set
+CONFIG_NET_SCH_FIFO=y
+CONFIG_DCB=y
+CONFIG_DNS_RESOLVER=m
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+CONFIG_NETLINK_DIAG=y
+CONFIG_MPLS=y
+# CONFIG_NET_MPLS_GSO is not set
+# CONFIG_MPLS_ROUTING is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_CGROUP_NET_CLASSID=y
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+CONFIG_BPF_JIT=y
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=m
+# CONFIG_NET_TCPPROBE is not set
+CONFIG_NET_DROP_MONITOR=m
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+# CONFIG_NET_9P_RDMA is not set
+# CONFIG_NET_9P_DEBUG is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_DST_CACHE=y
+CONFIG_HAVE_BPF_JIT=y
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_UEVENT_HELPER is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_GENERIC_CPU_VULNERABILITIES=y
+# CONFIG_DMA_SHARED_BUFFER is not set
+
+#
+# Bus devices
+#
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_OF is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG_MESSAGES is not set
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SKD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=18874368
+# CONFIG_BLK_DEV_RAM_DAX is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_VIRTIO_BLK=y
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+# CONFIG_BLK_DEV_NVME is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_93CX6=m
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+
+#
+# Altera FPGA firmware download module
+#
+CONFIG_INTEL_MEI=m
+CONFIG_INTEL_MEI_ME=m
+# CONFIG_INTEL_MEI_TXE is not set
+# CONFIG_VMWARE_VMCI is not set
+
+#
+# Intel MIC Bus Driver
+#
+# CONFIG_INTEL_MIC_BUS is not set
+
+#
+# SCIF Bus Driver
+#
+# CONFIG_SCIF_BUS is not set
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+# CONFIG_GENWQE is not set
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_KERNEL_API is not set
+# CONFIG_CXL_EEH is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=m
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=m
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_MQ_DEFAULT is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=m
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_ZPODD=y
+# CONFIG_SATA_PMP is not set
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI=m
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+# CONFIG_ATA_SFF is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+CONFIG_MII=m
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_GENEVE is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+CONFIG_TUN=y
+# CONFIG_TUN_VNET_CROSS_LE is not set
+CONFIG_VETH=y
+CONFIG_VIRTIO_NET=y
+# CONFIG_NLMON is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_VHOST_NET=y
+CONFIG_VHOST_RING=y
+CONFIG_VHOST=y
+# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+CONFIG_ETHERNET=y
+CONFIG_MDIO=m
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_CADENCE is not set
+CONFIG_NET_VENDOR_BROADCOM=y
+CONFIG_B44=m
+CONFIG_B44_PCI_AUTOSELECT=y
+CONFIG_B44_PCICORE_AUTOSELECT=y
+CONFIG_B44_PCI=y
+CONFIG_BCMGENET=m
+CONFIG_BNX2=m
+CONFIG_CNIC=m
+CONFIG_TIGON3=m
+CONFIG_BNX2X=m
+CONFIG_BNX2X_SRIOV=y
+CONFIG_BNXT=m
+CONFIG_BNXT_SRIOV=y
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_CX_ECAT is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_HP is not set
+CONFIG_NET_VENDOR_INTEL=y
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IXGB is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGBEVF is not set
+CONFIG_I40E=m
+# CONFIG_I40E_DCB is not set
+CONFIG_I40EVF=m
+# CONFIG_FM10K is not set
+# CONFIG_NET_VENDOR_I825XX is not set
+# CONFIG_JME is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+CONFIG_MLX4_EN=m
+CONFIG_MLX4_EN_DCB=y
+CONFIG_MLX4_CORE=m
+CONFIG_MLX4_DEBUG=y
+CONFIG_MLX5_CORE=m
+CONFIG_MLX5_CORE_EN=y
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_SFC is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_NET_SB1000 is not set
+CONFIG_PHYLIB=m
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_AT803X_PHY is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_SMSC_PHY is not set
+CONFIG_BCM_NET_PHYLIB=m
+# CONFIG_BROADCOM_PHY is not set
+CONFIG_BCM7XXX_PHY=m
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+CONFIG_FIXED_PHY=m
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_OCTEON is not set
+# CONFIG_MDIO_BCM_UNIMAC is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Host-side USB support is needed for USB Network Adapter support
+#
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_FUJITSU_ES is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
+CONFIG_SERIO_I8042=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DMA=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_RSA=y
+# CONFIG_SERIAL_8250_FSL is not set
+# CONFIG_SERIAL_8250_DW is not set
+# CONFIG_SERIAL_8250_RT288X is not set
+# CONFIG_SERIAL_8250_FINTEK is not set
+# CONFIG_SERIAL_8250_MID is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+CONFIG_TTY_PRINTK=y
+CONFIG_HVC_DRIVER=y
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_IPMI_HANDLER=m
+# CONFIG_IPMI_PANIC_EVENT is not set
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+# CONFIG_IPMI_SI_PROBE_DEFAULTS is not set
+# CONFIG_IPMI_SSIF is not set
+CONFIG_IPMI_WATCHDOG=m
+CONFIG_IPMI_POWEROFF=m
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_VIA=y
+CONFIG_HW_RANDOM_VIRTIO=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_MWAVE is not set
+CONFIG_RAW_DRIVER=m
+CONFIG_MAX_RAW_DEVS=256
+CONFIG_HPET=y
+CONFIG_HPET_MMAP=y
+CONFIG_HPET_MMAP_DEFAULT=y
+CONFIG_HANGCHECK_TIMER=y
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+# CONFIG_NTP_PPS is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+CONFIG_PPS_CLIENT_LDISC=m
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=m
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_CHERRYVIEW is not set
+# CONFIG_PINCTRL_BROXTON is not set
+# CONFIG_PINCTRL_SUNRISEPOINT is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_APPLESMC is not set
+# CONFIG_SENSORS_DELL_SMM is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_IBMAEM is not set
+# CONFIG_SENSORS_IBMPEX is not set
+CONFIG_SENSORS_I5500=m
+CONFIG_SENSORS_CORETEMP=m
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_NCT6683 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+
+#
+# ACPI drivers
+#
+CONFIG_SENSORS_ACPI_POWER=m
+# CONFIG_SENSORS_ATK0110 is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_THERMAL_GOV_BANG_BANG=y
+CONFIG_THERMAL_GOV_USER_SPACE=y
+# CONFIG_THERMAL_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_EMULATION is not set
+CONFIG_INTEL_POWERCLAMP=m
+CONFIG_X86_PKG_TEMP_THERMAL=m
+CONFIG_INTEL_SOC_DTS_IOSF_CORE=m
+CONFIG_INTEL_SOC_DTS_THERMAL=m
+CONFIG_INT340X_THERMAL=m
+CONFIG_ACPI_THERMAL_REL=m
+CONFIG_INTEL_PCH_THERMAL=m
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_ACQUIRE_WDT is not set
+# CONFIG_ADVANTECH_WDT is not set
+# CONFIG_ALIM1535_WDT is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_F71808E_WDT is not set
+# CONFIG_SP5100_TCO is not set
+# CONFIG_SBC_FITPC2_WATCHDOG is not set
+# CONFIG_EUROTECH_WDT is not set
+# CONFIG_IB700_WDT is not set
+# CONFIG_IBMASR is not set
+# CONFIG_WAFER_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_IE6XX_WDT is not set
+CONFIG_ITCO_WDT=m
+CONFIG_ITCO_VENDOR_SUPPORT=y
+# CONFIG_IT8712F_WDT is not set
+# CONFIG_IT87_WDT is not set
+# CONFIG_HP_WATCHDOG is not set
+# CONFIG_SC1200_WDT is not set
+# CONFIG_PC87413_WDT is not set
+# CONFIG_NV_TCO is not set
+# CONFIG_60XX_WDT is not set
+# CONFIG_CPU5_WDT is not set
+# CONFIG_SMSC_SCH311X_WDT is not set
+# CONFIG_SMSC37B787_WDT is not set
+# CONFIG_VIA_WDT is not set
+# CONFIG_W83627HF_WDT is not set
+# CONFIG_W83877F_WDT is not set
+# CONFIG_W83977F_WDT is not set
+# CONFIG_MACHZ_WDT is not set
+# CONFIG_SBC_EPX_C3_WATCHDOG is not set
+# CONFIG_BCM7038_WDT is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB=y
+CONFIG_SSB_SPROM=y
+CONFIG_SSB_PCIHOST_POSSIBLE=y
+CONFIG_SSB_PCIHOST=y
+# CONFIG_SSB_B43_PCI_BRIDGE is not set
+# CONFIG_SSB_HOST_SOC is not set
+# CONFIG_SSB_SILENT is not set
+# CONFIG_SSB_DEBUG is not set
+CONFIG_SSB_DRIVER_PCICORE_POSSIBLE=y
+CONFIG_SSB_DRIVER_PCICORE=y
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_INTEL_QUARK_I2C_GPIO is not set
+# CONFIG_LPC_ICH is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_INTEL_LPSS_ACPI is not set
+# CONFIG_MFD_INTEL_LPSS_PCI is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RTSX_USB is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_AGP is not set
+# CONFIG_VGA_ARB is not set
+# CONFIG_VGA_SWITCHEROO is not set
+# CONFIG_DRM is not set
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FB_CMDLINE=y
+# CONFIG_FB_DDC is not set
+CONFIG_FB_BOOT_VESA_SUPPORT=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_VGA16 is not set
+CONFIG_FB_VESA=y
+# CONFIG_FB_EFI is not set
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SM712 is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=25
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=m
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=m
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=m
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=m
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=m
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_USB_MON is not set
+CONFIG_USB_WUSB_CBAF=m
+# CONFIG_USB_WUSB_CBAF_DEBUG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=m
+CONFIG_USB_XHCI_PCI=m
+# CONFIG_USB_XHCI_PLATFORM is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_PCI=m
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+CONFIG_USB_OHCI_HCD=m
+CONFIG_USB_OHCI_HCD_PCI=m
+# CONFIG_USB_OHCI_HCD_SSB is not set
+# CONFIG_USB_OHCI_HCD_PLATFORM is not set
+CONFIG_USB_UHCI_HCD=m
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_SSB is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+# CONFIG_USB_STORAGE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+# CONFIG_USB_CHAOSKEY is not set
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_USB_PHY is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_INFINIBAND=m
+CONFIG_INFINIBAND_USER_MAD=m
+CONFIG_INFINIBAND_USER_ACCESS=m
+CONFIG_INFINIBAND_USER_MEM=y
+CONFIG_INFINIBAND_ON_DEMAND_PAGING=y
+CONFIG_INFINIBAND_ADDR_TRANS=y
+CONFIG_INFINIBAND_MTHCA=m
+CONFIG_INFINIBAND_MTHCA_DEBUG=y
+# CONFIG_INFINIBAND_QIB is not set
+CONFIG_MLX4_INFINIBAND=m
+CONFIG_MLX5_INFINIBAND=m
+# CONFIG_INFINIBAND_NES is not set
+# CONFIG_INFINIBAND_OCRDMA is not set
+# CONFIG_INFINIBAND_USNIC is not set
+CONFIG_INFINIBAND_IPOIB=m
+CONFIG_INFINIBAND_IPOIB_CM=y
+CONFIG_INFINIBAND_IPOIB_DEBUG=y
+# CONFIG_INFINIBAND_IPOIB_DEBUG_DATA is not set
+# CONFIG_INFINIBAND_SRP is not set
+# CONFIG_INFINIBAND_ISER is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_VIRTUAL_CHANNELS=m
+CONFIG_DMA_ACPI=y
+CONFIG_INTEL_IDMA64=m
+# CONFIG_INTEL_IOATDMA is not set
+# CONFIG_DW_DMAC is not set
+# CONFIG_DW_DMAC_PCI is not set
+
+#
+# DMA Clients
+#
+CONFIG_ASYNC_TX_DMA=y
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_UIO=m
+CONFIG_UIO_CIF=m
+# CONFIG_UIO_PDRV_GENIRQ is not set
+# CONFIG_UIO_DMEM_GENIRQ is not set
+CONFIG_UIO_AEC=m
+CONFIG_UIO_SERCOS3=m
+CONFIG_UIO_PCI_GENERIC=m
+CONFIG_UIO_NETX=m
+# CONFIG_UIO_PRUSS is not set
+CONFIG_UIO_MF624=m
+# CONFIG_VFIO is not set
+CONFIG_IRQ_BYPASS_MANAGER=y
+CONFIG_VIRT_DRIVERS=y
+CONFIG_VIRTIO=y
+
+#
+# Virtio drivers
+#
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO_PCI_LEGACY=y
+CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_INPUT=y
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_HYPERV is not set
+# CONFIG_STAGING is not set
+CONFIG_X86_PLATFORM_DEVICES=y
+# CONFIG_ACERHDF is not set
+# CONFIG_DELL_SMO8800 is not set
+# CONFIG_FUJITSU_TABLET is not set
+# CONFIG_HP_ACCEL is not set
+# CONFIG_HP_WIRELESS is not set
+# CONFIG_SENSORS_HDAPS is not set
+# CONFIG_INTEL_MENLOW is not set
+# CONFIG_ACPI_WMI is not set
+# CONFIG_TOPSTAR_LAPTOP is not set
+# CONFIG_TOSHIBA_BT_RFKILL is not set
+# CONFIG_TOSHIBA_HAPS is not set
+# CONFIG_ACPI_CMPC is not set
+CONFIG_INTEL_IPS=m
+CONFIG_IBM_RTL=m
+# CONFIG_SAMSUNG_Q10 is not set
+CONFIG_INTEL_RST=m
+CONFIG_INTEL_SMARTCONNECT=m
+CONFIG_PVPANIC=m
+CONFIG_INTEL_PMC_IPC=m
+# CONFIG_SURFACE_PRO3_BUTTON is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_COMMON_CLK_PXA is not set
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKEVT_I8253=y
+CONFIG_I8253_LOCK=y
+CONFIG_CLKBLD_I8253=y
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_API=y
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Generic IOMMU Pagetable Support
+#
+CONFIG_IOMMU_IOVA=y
+# CONFIG_AMD_IOMMU is not set
+CONFIG_DMAR_TABLE=y
+CONFIG_INTEL_IOMMU=y
+CONFIG_INTEL_IOMMU_SVM=y
+# CONFIG_INTEL_IOMMU_DEFAULT_ON is not set
+CONFIG_INTEL_IOMMU_FLOPPY_WA=y
+# CONFIG_IRQ_REMAP is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+CONFIG_PM_DEVFREQ=y
+
+#
+# DEVFREQ Governors
+#
+CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=m
+# CONFIG_DEVFREQ_GOV_PERFORMANCE is not set
+# CONFIG_DEVFREQ_GOV_POWERSAVE is not set
+# CONFIG_DEVFREQ_GOV_USERSPACE is not set
+
+#
+# DEVFREQ Drivers
+#
+# CONFIG_PM_DEVFREQ_EVENT is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_PWM is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+CONFIG_POWERCAP=y
+CONFIG_INTEL_RAPL=m
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_RAS=y
+# CONFIG_THUNDERBOLT is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_STM_DUMMY is not set
+# CONFIG_STM_SOURCE_CONSOLE is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# Firmware Drivers
+#
+CONFIG_EDD=m
+# CONFIG_EDD_OFF is not set
+CONFIG_FIRMWARE_MEMMAP=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+CONFIG_DMI_SYSFS=y
+CONFIG_DMI_SCAN_MACHINE_NON_EFI_FALLBACK=y
+# CONFIG_ISCSI_IBFT_FIND is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# EFI (Extensible Firmware Interface) Support
+#
+CONFIG_EFI_VARS=m
+CONFIG_EFI_ESRT=y
+CONFIG_EFI_VARS_PSTORE=m
+# CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE is not set
+CONFIG_EFI_RUNTIME_MAP=y
+# CONFIG_EFI_FAKE_MEMMAP is not set
+CONFIG_EFI_RUNTIME_WRAPPERS=y
+CONFIG_UEFI_CPER=y
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_ENCRYPTION is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+CONFIG_BTRFS_FS=y
+# CONFIG_BTRFS_FS_POSIX_ACL is not set
+# CONFIG_BTRFS_FS_CHECK_INTEGRITY is not set
+# CONFIG_BTRFS_FS_RUN_SANITY_TESTS is not set
+# CONFIG_BTRFS_DEBUG is not set
+# CONFIG_BTRFS_ASSERT is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_FS_DAX=y
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+CONFIG_OVERLAY_FS=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_PROC_CHILDREN=y
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_EFIVAR_FS=m
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_PSTORE=y
+# CONFIG_PSTORE_CONSOLE is not set
+# CONFIG_PSTORE_PMSG is not set
+# CONFIG_PSTORE_FTRACE is not set
+CONFIG_PSTORE_RAM=m
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+CONFIG_NFS_V2=m
+CONFIG_NFS_V3=m
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=m
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_NFS_DEBUG=y
+# CONFIG_NFSD is not set
+CONFIG_GRACE_PERIOD=m
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+CONFIG_SUNRPC_GSS=m
+CONFIG_SUNRPC_DEBUG=y
+# CONFIG_SUNRPC_XPRT_RDMA is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_9P_FS=y
+# CONFIG_9P_FS_POSIX_ACL is not set
+# CONFIG_9P_FS_SECURITY is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_INFO_SPLIT is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+# CONFIG_GDB_SCRIPTS is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=8192
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x01b6
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+CONFIG_PAGE_EXTENSION=y
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+CONFIG_HAVE_ARCH_KASAN=y
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_HARDLOCKUP_DETECTOR=y
+# CONFIG_BOOTPARAM_HARDLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE=0
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=60
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHED_INFO=y
+CONFIG_SCHEDSTATS=y
+CONFIG_SCHED_STACK_END_CHECK=y
+# CONFIG_DEBUG_TIMEKEEPING is not set
+# CONFIG_TIMER_STATS is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_LIST=y
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS=y
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_FENTRY=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACER_MAX_TRACE=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_RING_BUFFER_ALLOW_SWAP=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_TRACER_SNAPSHOT=y
+# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+CONFIG_STACK_TRACER=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_KPROBE_EVENT=y
+CONFIG_UPROBE_EVENT=y
+CONFIG_BPF_EVENTS=y
+CONFIG_PROBE_EVENTS=y
+CONFIG_DYNAMIC_FTRACE=y
+CONFIG_DYNAMIC_FTRACE_WITH_REGS=y
+# CONFIG_FUNCTION_PROFILER is not set
+CONFIG_FTRACE_MCOUNT_RECORD=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+CONFIG_MMIOTRACE=y
+# CONFIG_MMIOTRACE_TEST is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_TRACE_ENUM_MAP_FILE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+CONFIG_TEST_USER_COPY=m
+CONFIG_TEST_BPF=m
+CONFIG_TEST_FIRMWARE=m
+# CONFIG_TEST_UDELAY is not set
+CONFIG_MEMTEST=y
+CONFIG_TEST_STATIC_KEYS=m
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+CONFIG_EARLY_PRINTK_EFI=y
+CONFIG_X86_PTDUMP_CORE=y
+# CONFIG_X86_PTDUMP is not set
+# CONFIG_EFI_PGT_DUMP is not set
+CONFIG_DEBUG_RODATA=y
+# CONFIG_DEBUG_RODATA_TEST is not set
+CONFIG_DEBUG_WX=y
+CONFIG_DEBUG_SET_MODULE_RONX=y
+# CONFIG_DEBUG_NX_TEST is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_DEBUG_TLBFLUSH is not set
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+# CONFIG_X86_DECODER_SELFTEST is not set
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_IO_DELAY_0X80=y
+# CONFIG_IO_DELAY_0XED is not set
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+# CONFIG_DEBUG_BOOT_PARAMS is not set
+# CONFIG_CPA_DEBUG is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_ENTRY is not set
+# CONFIG_DEBUG_NMI_SELFTEST is not set
+# CONFIG_X86_DEBUG_STATIC_CPU_HAS is not set
+CONFIG_X86_DEBUG_FPU=y
+# CONFIG_PUNIT_ATOM_DEBUG is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_COMPAT=y
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_PAGE_TABLE_ISOLATION is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_INTEL_TXT is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_XOR_BLOCKS=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_AKCIPHER=m
+# CONFIG_CRYPTO_RSA is not set
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=m
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=m
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRC32_PCLMUL is not set
+CONFIG_CRYPTO_CRCT10DIF=y
+# CONFIG_CRYPTO_CRCT10DIF_PCLMUL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_POLY1305_X86_64 is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA1_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256_SSSE3 is not set
+# CONFIG_CRYPTO_SHA512_SSSE3 is not set
+# CONFIG_CRYPTO_SHA1_MB is not set
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=m
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_X86_64 is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_BLOWFISH_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAMELLIA_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST5_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_CAST6_AVX_X86_64 is not set
+CONFIG_CRYPTO_DES=m
+# CONFIG_CRYPTO_DES3_EDE_X86_64 is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_X86_64 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_CHACHA20_X86_64 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SERPENT_SSE2_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64 is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64_3WAY is not set
+# CONFIG_CRYPTO_TWOFISH_AVX_X86_64 is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_DRBG_MENU is not set
+# CONFIG_CRYPTO_JITTERENTROPY is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_PADLOCK is not set
+# CONFIG_CRYPTO_DEV_CCP is not set
+CONFIG_CRYPTO_DEV_QAT=m
+CONFIG_CRYPTO_DEV_QAT_DH895xCC=m
+CONFIG_CRYPTO_DEV_QAT_DH895xCCVF=m
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
+CONFIG_HAVE_KVM=y
+CONFIG_HAVE_KVM_IRQCHIP=y
+CONFIG_HAVE_KVM_IRQFD=y
+CONFIG_HAVE_KVM_IRQ_ROUTING=y
+CONFIG_HAVE_KVM_EVENTFD=y
+CONFIG_KVM_APIC_ARCHITECTURE=y
+CONFIG_KVM_MMIO=y
+CONFIG_KVM_ASYNC_PF=y
+CONFIG_HAVE_KVM_MSI=y
+CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT=y
+CONFIG_KVM_VFIO=y
+CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT=y
+CONFIG_KVM_COMPAT=y
+CONFIG_HAVE_KVM_IRQ_BYPASS=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_KVM_INTEL=m
+# CONFIG_KVM_AMD is not set
+# CONFIG_KVM_MMU_AUDIT is not set
+# CONFIG_KVM_DEVICE_ASSIGNMENT is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_RAID6_PQ=y
+CONFIG_BITREVERSE=y
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_ARCH_HAS_FAST_MULTIPLIER=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=m
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_REED_SOLOMON=m
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_OID_REGISTRY=m
+CONFIG_UCS2_STRING=y
+CONFIG_FONT_SUPPORT=y
+CONFIG_FONT_8x16=y
+CONFIG_FONT_AUTOSELECT=y
+# CONFIG_SG_SPLIT is not set
+CONFIG_ARCH_HAS_SG_CHAIN=y
+CONFIG_ARCH_HAS_PMEM_API=y
+CONFIG_ARCH_HAS_MMIO_FLUSH=y
diff --git a/kernel/popcorn/configs/config_puzzlehype_mir_200524_v3_working b/kernel/popcorn/configs/config_puzzlehype_mir_200524_v3_working
new file mode 100644
index 000000000000..a5b68b924890
--- /dev/null
+++ b/kernel/popcorn/configs/config_puzzlehype_mir_200524_v3_working
@@ -0,0 +1,3132 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/x86 4.4.137 Kernel Configuration
+#
+CONFIG_64BIT=y
+CONFIG_X86_64=y
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_PERF_EVENTS_INTEL_UNCORE=y
+CONFIG_OUTPUT_FORMAT="elf64-x86-64"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/x86_64_defconfig"
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+CONFIG_ZONE_DMA32=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_HAVE_INTEL_TXT=y
+CONFIG_X86_64_SMP=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PGTABLE_LEVELS=4
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION="-pop-hype"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KERNEL_XZ=y
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_FHANDLE=y
+CONFIG_USELIB=y
+CONFIG_AUDIT=y
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_VIRT_CPU_ACCOUNTING=y
+# CONFIG_TICK_CPU_ACCOUNTING is not set
+CONFIG_VIRT_CPU_ACCOUNTING_GEN=y
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_CONTEXT_TRACKING=y
+# CONFIG_CONTEXT_TRACKING_FORCE is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_EXPEDITE_BOOT is not set
+# CONFIG_BUILD_BIN2C is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=21
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=13
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
+CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH=y
+CONFIG_ARCH_SUPPORTS_INT128=y
+# CONFIG_NUMA_BALANCING is not set
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_PAGE_COUNTER=y
+CONFIG_MEMCG=y
+# CONFIG_MEMCG_KMEM is not set
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+CONFIG_CGROUP_WRITEBACK=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_RD_LZ4=y
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_HAVE_PCSPKR_PLATFORM=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+CONFIG_SGETMASK_SYSCALL=y
+CONFIG_SYSFS_SYSCALL=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_BPF_SYSCALL=y
+# CONFIG_BPF_JIT_ALWAYS_ON is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_USERFAULTFD=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_MEMBARRIER=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_KEXEC_CORE=y
+CONFIG_OPROFILE=m
+# CONFIG_OPROFILE_EVENT_MULTIPLEX is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_OPROFILE_NMI_TIMER=y
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+CONFIG_OPTPROBES=y
+CONFIG_KPROBES_ON_FTRACE=y
+CONFIG_UPROBES=y
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_KRETPROBES=y
+CONFIG_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_KPROBES_ON_FTRACE=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_ARCH_WANT_OLD_COMPAT_IPC=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR_NONE is not set
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+CONFIG_CC_STACKPROTECTOR_STRONG=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_HAVE_ARCH_HUGE_VMAP=y
+CONFIG_HAVE_ARCH_SOFT_DIRTY=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_COPY_THREAD_TLS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_BLK_DEV_THROTTLING=y
+# CONFIG_BLK_CMDLINE_PARSER is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+# CONFIG_CMDLINE_PARTITION is not set
+CONFIG_BLOCK_COMPAT=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_PREEMPT_NOTIFIERS=y
+CONFIG_ASN1=m
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_ARCH_USE_QUEUED_SPINLOCKS=y
+CONFIG_QUEUED_SPINLOCKS=y
+CONFIG_ARCH_USE_QUEUED_RWLOCKS=y
+CONFIG_QUEUED_RWLOCKS=y
+CONFIG_FREEZER=y
+
+#
+# Popcorn Distributed Execution Support
+#
+CONFIG_ARCH_SUPPORTS_POPCORN=y
+CONFIG_POPCORN=y
+CONFIG_POPCORN_HYPE=y
+# CONFIG_POPCORN_DEBUG is not set
+CONFIG_POPCORN_CHECK_SANITY=y
+# CONFIG_POPCORN_REMOTE_INFO is not set
+CONFIG_POPCORN_STAT=y
+CONFIG_POPCORN_STAT_PGFAULTS=y
+# CONFIG_POPCORN_STAT_MSG is not set
+CONFIG_POPCORN_KMSG=y
+CONFIG_POPCORN_KMSG_SOCKET=m
+CONFIG_POPCORN_KMSG_RDMA=m
+# CONFIG_POPCORN_KMSG_TEST is not set
+
+#
+# Processor type and features
+#
+CONFIG_ZONE_DMA=y
+CONFIG_SMP=y
+CONFIG_X86_FEATURE_NAMES=y
+CONFIG_X86_X2APIC=y
+CONFIG_X86_MPPARSE=y
+CONFIG_RETPOLINE=y
+# CONFIG_X86_EXTENDED_PLATFORM is not set
+CONFIG_X86_INTEL_LPSS=y
+CONFIG_X86_AMD_PLATFORM_DEVICE=y
+CONFIG_IOSF_MBI=y
+# CONFIG_IOSF_MBI_DEBUG is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+CONFIG_HYPERVISOR_GUEST=y
+CONFIG_PARAVIRT=y
+# CONFIG_PARAVIRT_DEBUG is not set
+# CONFIG_PARAVIRT_SPINLOCKS is not set
+# CONFIG_XEN is not set
+CONFIG_KVM_GUEST=y
+# CONFIG_KVM_DEBUG_FS is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+CONFIG_PARAVIRT_CLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MK8 is not set
+# CONFIG_MPSC is not set
+CONFIG_MCORE2=y
+# CONFIG_MATOM is not set
+# CONFIG_GENERIC_CPU is not set
+CONFIG_X86_INTERNODE_CACHE_SHIFT=6
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_INTEL_USERCOPY=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_X86_P6_NOP=y
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=64
+CONFIG_X86_DEBUGCTLMSR=y
+# CONFIG_PROCESSOR_SELECT is not set
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+# CONFIG_GART_IOMMU is not set
+# CONFIG_CALGARY_IOMMU is not set
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_MAXSMP is not set
+CONFIG_NR_CPUS=64
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_X86_MCE_THRESHOLD=y
+CONFIG_X86_MCE_INJECT=m
+CONFIG_X86_THERMAL_VECTOR=y
+# CONFIG_VM86 is not set
+CONFIG_X86_16BIT=y
+CONFIG_X86_ESPFIX64=y
+CONFIG_X86_VSYSCALL_EMULATION=y
+# CONFIG_I8K is not set
+CONFIG_MICROCODE=y
+CONFIG_MICROCODE_INTEL=y
+CONFIG_MICROCODE_AMD=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+CONFIG_X86_MSR=m
+CONFIG_X86_CPUID=m
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_X86_DIRECT_GBPAGES=y
+CONFIG_NUMA=y
+# CONFIG_AMD_NUMA is not set
+CONFIG_X86_64_ACPI_NUMA=y
+CONFIG_NODES_SPAN_OTHER_NODES=y
+CONFIG_NUMA_EMU=y
+CONFIG_NODES_SHIFT=6
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_ARCH_DISCARD_MEMBLOCK=y
+# CONFIG_MOVABLE_NODE is not set
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+# CONFIG_MEMORY_HOTPLUG is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK=y
+CONFIG_MEMORY_BALLOON=y
+# CONFIG_COMPACTION is not set
+CONFIG_MIGRATION=y
+CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_MMU_NOTIFIER=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+# CONFIG_MEMORY_FAILURE is not set
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CMA is not set
+# CONFIG_MEM_SOFT_DIRTY is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+CONFIG_ARCH_SUPPORTS_DEFERRED_STRUCT_PAGE_INIT=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_X86_PMEM_LEGACY is not set
+# CONFIG_X86_CHECK_BIOS_CORRUPTION is not set
+CONFIG_X86_RESERVE_LOW=64
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_ARCH_RANDOM=y
+CONFIG_X86_SMAP=y
+# CONFIG_X86_INTEL_MPX is not set
+CONFIG_EFI=y
+CONFIG_EFI_STUB=y
+# CONFIG_EFI_MIXED is not set
+CONFIG_SECCOMP=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+# CONFIG_KEXEC_FILE is not set
+CONFIG_CRASH_DUMP=y
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+# CONFIG_RANDOMIZE_BASE is not set
+CONFIG_PHYSICAL_ALIGN=0x200000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_BOOTPARAM_HOTPLUG_CPU0 is not set
+# CONFIG_DEBUG_HOTPLUG_CPU0 is not set
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_LEGACY_VSYSCALL_NATIVE is not set
+CONFIG_LEGACY_VSYSCALL_EMULATE=y
+# CONFIG_LEGACY_VSYSCALL_NONE is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MODIFY_LDT_SYSCALL=y
+CONFIG_HAVE_LIVEPATCH=y
+# CONFIG_LIVEPATCH is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_USE_PERCPU_NUMA_NODE_ID=y
+
+#
+# Power management and ACPI options
+#
+# CONFIG_SUSPEND is not set
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+# CONFIG_DPM_WATCHDOG is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_LEGACY_TABLES_LOOKUP=y
+CONFIG_ARCH_MIGHT_HAVE_ACPI_PDC=y
+CONFIG_ACPI_SYSTEM_POWER_STATES_SUPPORT=y
+# CONFIG_ACPI_DEBUGGER is not set
+# CONFIG_ACPI_PROCFS_POWER is not set
+CONFIG_ACPI_REV_OVERRIDE_POSSIBLE=y
+# CONFIG_ACPI_EC_DEBUGFS is not set
+# CONFIG_ACPI_AC is not set
+# CONFIG_ACPI_BATTERY is not set
+# CONFIG_ACPI_BUTTON is not set
+CONFIG_ACPI_FAN=m
+# CONFIG_ACPI_DOCK is not set
+CONFIG_ACPI_CPU_FREQ_PSS=y
+CONFIG_ACPI_PROCESSOR_IDLE=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_ACPI_IPMI=m
+CONFIG_ACPI_HOTPLUG_CPU=y
+CONFIG_ACPI_PROCESSOR_AGGREGATOR=m
+CONFIG_ACPI_THERMAL=m
+CONFIG_ACPI_NUMA=y
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+# CONFIG_ACPI_INITRD_TABLE_OVERRIDE is not set
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_PCI_SLOT=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_ACPI_HOTPLUG_IOAPIC=y
+# CONFIG_ACPI_SBS is not set
+CONFIG_ACPI_HED=y
+# CONFIG_ACPI_CUSTOM_METHOD is not set
+CONFIG_ACPI_BGRT=y
+# CONFIG_ACPI_REDUCED_HARDWARE_ONLY is not set
+# CONFIG_ACPI_NFIT is not set
+CONFIG_HAVE_ACPI_APEI=y
+CONFIG_HAVE_ACPI_APEI_NMI=y
+CONFIG_ACPI_APEI=y
+CONFIG_ACPI_APEI_GHES=y
+CONFIG_ACPI_APEI_PCIEAER=y
+# CONFIG_ACPI_APEI_EINJ is not set
+# CONFIG_ACPI_APEI_ERST_DEBUG is not set
+CONFIG_ACPI_EXTLOG=y
+# CONFIG_PMIC_OPREGION is not set
+CONFIG_SFI=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# CPU frequency scaling drivers
+#
+CONFIG_X86_INTEL_PSTATE=y
+CONFIG_X86_PCC_CPUFREQ=m
+CONFIG_X86_ACPI_CPUFREQ=m
+CONFIG_X86_ACPI_CPUFREQ_CPB=y
+# CONFIG_X86_POWERNOW_K8 is not set
+# CONFIG_X86_AMD_FREQ_SENSITIVITY is not set
+# CONFIG_X86_SPEEDSTEP_CENTRINO is not set
+# CONFIG_X86_P4_CLOCKMOD is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+CONFIG_INTEL_IDLE=y
+
+#
+# Memory power savings
+#
+# CONFIG_I7300_IDLE is not set
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+CONFIG_PCI_DIRECT=y
+# CONFIG_PCI_MMCONFIG is not set
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+CONFIG_PCIEAER_INJECT=m
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PME=y
+CONFIG_PCI_BUS_ADDR_T_64BIT=y
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+# CONFIG_PCI_DEBUG is not set
+CONFIG_PCI_REALLOC_ENABLE_AUTO=y
+CONFIG_PCI_STUB=m
+CONFIG_HT_IRQ=y
+CONFIG_PCI_ATS=y
+CONFIG_PCI_IOV=y
+CONFIG_PCI_PRI=y
+CONFIG_PCI_PASID=y
+CONFIG_PCI_LABEL=y
+
+#
+# PCI host controller drivers
+#
+CONFIG_ISA_DMA_API=y
+CONFIG_AMD_NB=y
+# CONFIG_PCCARD is not set
+# CONFIG_HOTPLUG_PCI is not set
+# CONFIG_RAPIDIO is not set
+# CONFIG_X86_SYSFB is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=m
+CONFIG_COREDUMP=y
+CONFIG_IA32_EMULATION=y
+# CONFIG_IA32_AOUT is not set
+# CONFIG_X86_X32 is not set
+CONFIG_COMPAT=y
+CONFIG_COMPAT_FOR_U64_ALIGNMENT=y
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_X86_DEV_DMA_OPS=y
+CONFIG_PMC_ATOM=y
+CONFIG_NET=y
+CONFIG_NET_INGRESS=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_XFRM=y
+CONFIG_XFRM_ALGO=m
+CONFIG_XFRM_USER=m
+CONFIG_XFRM_SUB_POLICY=y
+CONFIG_XFRM_MIGRATE=y
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=m
+CONFIG_NET_KEY=m
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_TRIE_STATS=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE_DEMUX=m
+CONFIG_NET_IP_TUNNEL=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_SYN_COOKIES=y
+CONFIG_NET_IPVTI=m
+CONFIG_NET_UDP_TUNNEL=m
+CONFIG_NET_FOU=m
+CONFIG_NET_FOU_IP_TUNNELS=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_TUNNEL=m
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=m
+CONFIG_INET_XFRM_MODE_TUNNEL=m
+CONFIG_INET_XFRM_MODE_BEET=m
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_UDP_DIAG=y
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+# CONFIG_TCP_CONG_DCTCP is not set
+# CONFIG_TCP_CONG_CDG is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NET_PTP_CLASSIFY=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=m
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_INGRESS=y
+CONFIG_NETFILTER_NETLINK=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+# CONFIG_NF_CONNTRACK_MARK is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CT_NETLINK is not set
+# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+# CONFIG_NF_NAT_AMANDA is not set
+# CONFIG_NF_NAT_FTP is not set
+# CONFIG_NF_NAT_IRC is not set
+# CONFIG_NF_NAT_SIP is not set
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NF_NAT_REDIRECT is not set
+CONFIG_NF_TABLES=y
+CONFIG_NF_TABLES_NETDEV=y
+CONFIG_NFT_EXTHDR=y
+# CONFIG_NFT_META is not set
+# CONFIG_NFT_CT is not set
+# CONFIG_NFT_RBTREE is not set
+# CONFIG_NFT_HASH is not set
+# CONFIG_NFT_COUNTER is not set
+# CONFIG_NFT_LOG is not set
+# CONFIG_NFT_LIMIT is not set
+# CONFIG_NFT_MASQ is not set
+# CONFIG_NFT_REDIR is not set
+# CONFIG_NFT_NAT is not set
+# CONFIG_NFT_REJECT is not set
+CONFIG_NFT_COMPAT=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+# CONFIG_NETFILTER_XT_CONNMARK is not set
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+# CONFIG_NETFILTER_XT_TARGET_LOG is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+CONFIG_NETFILTER_XT_NAT=y
+# CONFIG_NETFILTER_XT_TARGET_NETMAP is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_REDIRECT is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y
+# CONFIG_NETFILTER_XT_MATCH_BPF is not set
+# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ECN is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+CONFIG_NETFILTER_XT_MATCH_HL=y
+# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+# CONFIG_NETFILTER_XT_MATCH_IPVS is not set
+# CONFIG_NETFILTER_XT_MATCH_L2TP is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+CONFIG_NETFILTER_XT_MATCH_RECENT=y
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+# CONFIG_NETFILTER_XT_MATCH_STATE is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_IP_SET is not set
+CONFIG_IP_VS=y
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+# CONFIG_IP_VS_PROTO_TCP is not set
+# CONFIG_IP_VS_PROTO_UDP is not set
+# CONFIG_IP_VS_PROTO_AH_ESP is not set
+# CONFIG_IP_VS_PROTO_ESP is not set
+# CONFIG_IP_VS_PROTO_AH is not set
+# CONFIG_IP_VS_PROTO_SCTP is not set
+
+#
+# IPVS scheduler
+#
+# CONFIG_IP_VS_RR is not set
+# CONFIG_IP_VS_WRR is not set
+# CONFIG_IP_VS_LC is not set
+# CONFIG_IP_VS_WLC is not set
+# CONFIG_IP_VS_FO is not set
+# CONFIG_IP_VS_OVF is not set
+# CONFIG_IP_VS_LBLC is not set
+# CONFIG_IP_VS_LBLCR is not set
+# CONFIG_IP_VS_DH is not set
+# CONFIG_IP_VS_SH is not set
+# CONFIG_IP_VS_SED is not set
+# CONFIG_IP_VS_NQ is not set
+
+#
+# IPVS SH scheduler
+#
+CONFIG_IP_VS_SH_TAB_BITS=8
+
+#
+# IPVS application helper
+#
+# CONFIG_IP_VS_NFCT is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_NF_TABLES_IPV4=y
+CONFIG_NFT_CHAIN_ROUTE_IPV4=y
+# CONFIG_NFT_REJECT_IPV4 is not set
+# CONFIG_NFT_DUP_IPV4 is not set
+CONFIG_NF_TABLES_ARP=y
+# CONFIG_NF_DUP_IPV4 is not set
+# CONFIG_NF_LOG_ARP is not set
+# CONFIG_NF_LOG_IPV4 is not set
+# CONFIG_NF_REJECT_IPV4 is not set
+CONFIG_NF_NAT_IPV4=y
+CONFIG_NFT_CHAIN_NAT_IPV4=y
+CONFIG_NF_NAT_MASQUERADE_IPV4=y
+# CONFIG_NF_NAT_PPTP is not set
+# CONFIG_NF_NAT_H323 is not set
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+CONFIG_IP_NF_FILTER=y
+# CONFIG_IP_NF_TARGET_REJECT is not set
+# CONFIG_IP_NF_TARGET_SYNPROXY is not set
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+# CONFIG_IP_NF_TARGET_NETMAP is not set
+# CONFIG_IP_NF_TARGET_REDIRECT is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+# CONFIG_IP_NF_ARP_MANGLE is not set
+# CONFIG_NF_TABLES_BRIDGE is not set
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+CONFIG_STP=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+# CONFIG_NET_SCH_FQ is not set
+# CONFIG_NET_SCH_HHF is not set
+# CONFIG_NET_SCH_PIE is not set
+# CONFIG_NET_SCH_PLUG is not set
+
+#
+# Classification
+#
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+# CONFIG_NET_CLS_BPF is not set
+# CONFIG_NET_CLS_FLOWER is not set
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_CLS_ACT is not set
+CONFIG_NET_SCH_FIFO=y
+CONFIG_DCB=y
+CONFIG_DNS_RESOLVER=m
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+CONFIG_NETLINK_DIAG=y
+CONFIG_MPLS=y
+# CONFIG_NET_MPLS_GSO is not set
+# CONFIG_MPLS_ROUTING is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_CGROUP_NET_CLASSID=y
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+CONFIG_BPF_JIT=y
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=m
+# CONFIG_NET_TCPPROBE is not set
+CONFIG_NET_DROP_MONITOR=m
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+# CONFIG_NET_9P_RDMA is not set
+# CONFIG_NET_9P_DEBUG is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_DST_CACHE=y
+CONFIG_HAVE_BPF_JIT=y
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_UEVENT_HELPER is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_GENERIC_CPU_VULNERABILITIES=y
+# CONFIG_DMA_SHARED_BUFFER is not set
+
+#
+# Bus devices
+#
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_OF is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG_MESSAGES is not set
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SKD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=18874368
+# CONFIG_BLK_DEV_RAM_DAX is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_VIRTIO_BLK=y
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+# CONFIG_BLK_DEV_NVME is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_93CX6=m
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+
+#
+# Altera FPGA firmware download module
+#
+CONFIG_INTEL_MEI=m
+CONFIG_INTEL_MEI_ME=m
+# CONFIG_INTEL_MEI_TXE is not set
+# CONFIG_VMWARE_VMCI is not set
+
+#
+# Intel MIC Bus Driver
+#
+# CONFIG_INTEL_MIC_BUS is not set
+
+#
+# SCIF Bus Driver
+#
+# CONFIG_SCIF_BUS is not set
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+# CONFIG_GENWQE is not set
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_KERNEL_API is not set
+# CONFIG_CXL_EEH is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=m
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=m
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_MQ_DEFAULT is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=m
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_ZPODD=y
+# CONFIG_SATA_PMP is not set
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI=m
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+# CONFIG_ATA_SFF is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+CONFIG_MII=m
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_GENEVE is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+CONFIG_TUN=y
+# CONFIG_TUN_VNET_CROSS_LE is not set
+CONFIG_VETH=y
+CONFIG_VIRTIO_NET=y
+# CONFIG_NLMON is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_VHOST_NET=y
+CONFIG_VHOST_RING=y
+CONFIG_VHOST=y
+# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+CONFIG_ETHERNET=y
+CONFIG_MDIO=m
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_CADENCE is not set
+CONFIG_NET_VENDOR_BROADCOM=y
+CONFIG_B44=m
+CONFIG_B44_PCI_AUTOSELECT=y
+CONFIG_B44_PCICORE_AUTOSELECT=y
+CONFIG_B44_PCI=y
+CONFIG_BCMGENET=m
+CONFIG_BNX2=m
+CONFIG_CNIC=m
+CONFIG_TIGON3=m
+CONFIG_BNX2X=m
+CONFIG_BNX2X_SRIOV=y
+CONFIG_BNXT=m
+CONFIG_BNXT_SRIOV=y
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_CX_ECAT is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_HP is not set
+CONFIG_NET_VENDOR_INTEL=y
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IXGB is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGBEVF is not set
+CONFIG_I40E=m
+# CONFIG_I40E_DCB is not set
+CONFIG_I40EVF=m
+# CONFIG_FM10K is not set
+# CONFIG_NET_VENDOR_I825XX is not set
+# CONFIG_JME is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+CONFIG_MLX4_EN=m
+CONFIG_MLX4_EN_DCB=y
+CONFIG_MLX4_CORE=m
+CONFIG_MLX4_DEBUG=y
+CONFIG_MLX5_CORE=m
+CONFIG_MLX5_CORE_EN=y
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_SFC is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_NET_SB1000 is not set
+CONFIG_PHYLIB=m
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_AT803X_PHY is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_SMSC_PHY is not set
+CONFIG_BCM_NET_PHYLIB=m
+# CONFIG_BROADCOM_PHY is not set
+CONFIG_BCM7XXX_PHY=m
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+CONFIG_FIXED_PHY=m
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_OCTEON is not set
+# CONFIG_MDIO_BCM_UNIMAC is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Host-side USB support is needed for USB Network Adapter support
+#
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_FUJITSU_ES is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
+CONFIG_SERIO_I8042=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DMA=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_RSA=y
+# CONFIG_SERIAL_8250_FSL is not set
+# CONFIG_SERIAL_8250_DW is not set
+# CONFIG_SERIAL_8250_RT288X is not set
+# CONFIG_SERIAL_8250_FINTEK is not set
+# CONFIG_SERIAL_8250_MID is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+CONFIG_TTY_PRINTK=y
+CONFIG_HVC_DRIVER=y
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_IPMI_HANDLER=m
+# CONFIG_IPMI_PANIC_EVENT is not set
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+# CONFIG_IPMI_SI_PROBE_DEFAULTS is not set
+# CONFIG_IPMI_SSIF is not set
+CONFIG_IPMI_WATCHDOG=m
+CONFIG_IPMI_POWEROFF=m
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_VIA=y
+CONFIG_HW_RANDOM_VIRTIO=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_MWAVE is not set
+CONFIG_RAW_DRIVER=m
+CONFIG_MAX_RAW_DEVS=256
+CONFIG_HPET=y
+CONFIG_HPET_MMAP=y
+CONFIG_HPET_MMAP_DEFAULT=y
+CONFIG_HANGCHECK_TIMER=y
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=y
+# CONFIG_PPS_DEBUG is not set
+CONFIG_NTP_PPS=y
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+CONFIG_PPS_CLIENT_LDISC=y
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=m
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_CHERRYVIEW is not set
+# CONFIG_PINCTRL_BROXTON is not set
+# CONFIG_PINCTRL_SUNRISEPOINT is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_APPLESMC is not set
+# CONFIG_SENSORS_DELL_SMM is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_IBMAEM is not set
+# CONFIG_SENSORS_IBMPEX is not set
+CONFIG_SENSORS_I5500=m
+CONFIG_SENSORS_CORETEMP=m
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_NCT6683 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+
+#
+# ACPI drivers
+#
+CONFIG_SENSORS_ACPI_POWER=m
+# CONFIG_SENSORS_ATK0110 is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_THERMAL_GOV_BANG_BANG=y
+CONFIG_THERMAL_GOV_USER_SPACE=y
+# CONFIG_THERMAL_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_EMULATION is not set
+CONFIG_INTEL_POWERCLAMP=m
+CONFIG_X86_PKG_TEMP_THERMAL=m
+CONFIG_INTEL_SOC_DTS_IOSF_CORE=m
+CONFIG_INTEL_SOC_DTS_THERMAL=m
+CONFIG_INT340X_THERMAL=m
+CONFIG_ACPI_THERMAL_REL=m
+CONFIG_INTEL_PCH_THERMAL=m
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_ACQUIRE_WDT is not set
+# CONFIG_ADVANTECH_WDT is not set
+# CONFIG_ALIM1535_WDT is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_F71808E_WDT is not set
+# CONFIG_SP5100_TCO is not set
+# CONFIG_SBC_FITPC2_WATCHDOG is not set
+# CONFIG_EUROTECH_WDT is not set
+# CONFIG_IB700_WDT is not set
+# CONFIG_IBMASR is not set
+# CONFIG_WAFER_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_IE6XX_WDT is not set
+CONFIG_ITCO_WDT=m
+CONFIG_ITCO_VENDOR_SUPPORT=y
+# CONFIG_IT8712F_WDT is not set
+# CONFIG_IT87_WDT is not set
+# CONFIG_HP_WATCHDOG is not set
+# CONFIG_SC1200_WDT is not set
+# CONFIG_PC87413_WDT is not set
+# CONFIG_NV_TCO is not set
+# CONFIG_60XX_WDT is not set
+# CONFIG_CPU5_WDT is not set
+# CONFIG_SMSC_SCH311X_WDT is not set
+# CONFIG_SMSC37B787_WDT is not set
+# CONFIG_VIA_WDT is not set
+# CONFIG_W83627HF_WDT is not set
+# CONFIG_W83877F_WDT is not set
+# CONFIG_W83977F_WDT is not set
+# CONFIG_MACHZ_WDT is not set
+# CONFIG_SBC_EPX_C3_WATCHDOG is not set
+# CONFIG_BCM7038_WDT is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB=y
+CONFIG_SSB_SPROM=y
+CONFIG_SSB_PCIHOST_POSSIBLE=y
+CONFIG_SSB_PCIHOST=y
+# CONFIG_SSB_B43_PCI_BRIDGE is not set
+# CONFIG_SSB_HOST_SOC is not set
+# CONFIG_SSB_SILENT is not set
+# CONFIG_SSB_DEBUG is not set
+CONFIG_SSB_DRIVER_PCICORE_POSSIBLE=y
+CONFIG_SSB_DRIVER_PCICORE=y
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_INTEL_QUARK_I2C_GPIO is not set
+# CONFIG_LPC_ICH is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_INTEL_LPSS_ACPI is not set
+# CONFIG_MFD_INTEL_LPSS_PCI is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RTSX_USB is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_AGP is not set
+# CONFIG_VGA_ARB is not set
+# CONFIG_VGA_SWITCHEROO is not set
+# CONFIG_DRM is not set
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FB_CMDLINE=y
+# CONFIG_FB_DDC is not set
+CONFIG_FB_BOOT_VESA_SUPPORT=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_VGA16 is not set
+CONFIG_FB_VESA=y
+# CONFIG_FB_EFI is not set
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SM712 is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=25
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=m
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=m
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=m
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=m
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=m
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_USB_MON is not set
+CONFIG_USB_WUSB_CBAF=m
+# CONFIG_USB_WUSB_CBAF_DEBUG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=m
+CONFIG_USB_XHCI_PCI=m
+# CONFIG_USB_XHCI_PLATFORM is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_PCI=m
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+CONFIG_USB_OHCI_HCD=m
+CONFIG_USB_OHCI_HCD_PCI=m
+# CONFIG_USB_OHCI_HCD_SSB is not set
+# CONFIG_USB_OHCI_HCD_PLATFORM is not set
+CONFIG_USB_UHCI_HCD=m
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_SSB is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+# CONFIG_USB_STORAGE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+# CONFIG_USB_CHAOSKEY is not set
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_USB_PHY is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_INFINIBAND=m
+CONFIG_INFINIBAND_USER_MAD=m
+CONFIG_INFINIBAND_USER_ACCESS=m
+CONFIG_INFINIBAND_USER_MEM=y
+CONFIG_INFINIBAND_ON_DEMAND_PAGING=y
+CONFIG_INFINIBAND_ADDR_TRANS=y
+CONFIG_INFINIBAND_MTHCA=m
+CONFIG_INFINIBAND_MTHCA_DEBUG=y
+# CONFIG_INFINIBAND_QIB is not set
+CONFIG_MLX4_INFINIBAND=m
+CONFIG_MLX5_INFINIBAND=m
+# CONFIG_INFINIBAND_NES is not set
+# CONFIG_INFINIBAND_OCRDMA is not set
+# CONFIG_INFINIBAND_USNIC is not set
+CONFIG_INFINIBAND_IPOIB=m
+CONFIG_INFINIBAND_IPOIB_CM=y
+CONFIG_INFINIBAND_IPOIB_DEBUG=y
+# CONFIG_INFINIBAND_IPOIB_DEBUG_DATA is not set
+# CONFIG_INFINIBAND_SRP is not set
+# CONFIG_INFINIBAND_ISER is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_VIRTUAL_CHANNELS=m
+CONFIG_DMA_ACPI=y
+CONFIG_INTEL_IDMA64=m
+# CONFIG_INTEL_IOATDMA is not set
+# CONFIG_DW_DMAC is not set
+# CONFIG_DW_DMAC_PCI is not set
+
+#
+# DMA Clients
+#
+CONFIG_ASYNC_TX_DMA=y
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_UIO=m
+CONFIG_UIO_CIF=m
+# CONFIG_UIO_PDRV_GENIRQ is not set
+# CONFIG_UIO_DMEM_GENIRQ is not set
+CONFIG_UIO_AEC=m
+CONFIG_UIO_SERCOS3=m
+CONFIG_UIO_PCI_GENERIC=m
+CONFIG_UIO_NETX=m
+# CONFIG_UIO_PRUSS is not set
+CONFIG_UIO_MF624=m
+# CONFIG_VFIO is not set
+CONFIG_IRQ_BYPASS_MANAGER=y
+CONFIG_VIRT_DRIVERS=y
+CONFIG_VIRTIO=y
+
+#
+# Virtio drivers
+#
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO_PCI_LEGACY=y
+CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_INPUT=y
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_HYPERV is not set
+# CONFIG_STAGING is not set
+CONFIG_X86_PLATFORM_DEVICES=y
+# CONFIG_ACERHDF is not set
+# CONFIG_DELL_SMO8800 is not set
+# CONFIG_FUJITSU_TABLET is not set
+# CONFIG_HP_ACCEL is not set
+# CONFIG_HP_WIRELESS is not set
+# CONFIG_SENSORS_HDAPS is not set
+# CONFIG_INTEL_MENLOW is not set
+# CONFIG_ACPI_WMI is not set
+# CONFIG_TOPSTAR_LAPTOP is not set
+# CONFIG_TOSHIBA_BT_RFKILL is not set
+# CONFIG_TOSHIBA_HAPS is not set
+# CONFIG_ACPI_CMPC is not set
+CONFIG_INTEL_IPS=m
+CONFIG_IBM_RTL=m
+# CONFIG_SAMSUNG_Q10 is not set
+CONFIG_INTEL_RST=m
+CONFIG_INTEL_SMARTCONNECT=m
+CONFIG_PVPANIC=m
+CONFIG_INTEL_PMC_IPC=m
+# CONFIG_SURFACE_PRO3_BUTTON is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_COMMON_CLK_PXA is not set
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKEVT_I8253=y
+CONFIG_I8253_LOCK=y
+CONFIG_CLKBLD_I8253=y
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_API=y
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Generic IOMMU Pagetable Support
+#
+CONFIG_IOMMU_IOVA=y
+# CONFIG_AMD_IOMMU is not set
+CONFIG_DMAR_TABLE=y
+CONFIG_INTEL_IOMMU=y
+CONFIG_INTEL_IOMMU_SVM=y
+# CONFIG_INTEL_IOMMU_DEFAULT_ON is not set
+CONFIG_INTEL_IOMMU_FLOPPY_WA=y
+# CONFIG_IRQ_REMAP is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+CONFIG_PM_DEVFREQ=y
+
+#
+# DEVFREQ Governors
+#
+CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=m
+# CONFIG_DEVFREQ_GOV_PERFORMANCE is not set
+# CONFIG_DEVFREQ_GOV_POWERSAVE is not set
+# CONFIG_DEVFREQ_GOV_USERSPACE is not set
+
+#
+# DEVFREQ Drivers
+#
+# CONFIG_PM_DEVFREQ_EVENT is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_PWM is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+CONFIG_POWERCAP=y
+CONFIG_INTEL_RAPL=m
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_RAS=y
+# CONFIG_THUNDERBOLT is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_STM_DUMMY is not set
+# CONFIG_STM_SOURCE_CONSOLE is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# Firmware Drivers
+#
+CONFIG_EDD=m
+# CONFIG_EDD_OFF is not set
+CONFIG_FIRMWARE_MEMMAP=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+CONFIG_DMI_SYSFS=y
+CONFIG_DMI_SCAN_MACHINE_NON_EFI_FALLBACK=y
+# CONFIG_ISCSI_IBFT_FIND is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# EFI (Extensible Firmware Interface) Support
+#
+CONFIG_EFI_VARS=m
+CONFIG_EFI_ESRT=y
+CONFIG_EFI_VARS_PSTORE=m
+# CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE is not set
+CONFIG_EFI_RUNTIME_MAP=y
+# CONFIG_EFI_FAKE_MEMMAP is not set
+CONFIG_EFI_RUNTIME_WRAPPERS=y
+CONFIG_UEFI_CPER=y
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_ENCRYPTION is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+CONFIG_BTRFS_FS=y
+# CONFIG_BTRFS_FS_POSIX_ACL is not set
+# CONFIG_BTRFS_FS_CHECK_INTEGRITY is not set
+# CONFIG_BTRFS_FS_RUN_SANITY_TESTS is not set
+# CONFIG_BTRFS_DEBUG is not set
+# CONFIG_BTRFS_ASSERT is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_FS_DAX=y
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+CONFIG_OVERLAY_FS=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_PROC_CHILDREN=y
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_EFIVAR_FS=m
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_PSTORE=y
+# CONFIG_PSTORE_CONSOLE is not set
+# CONFIG_PSTORE_PMSG is not set
+# CONFIG_PSTORE_FTRACE is not set
+CONFIG_PSTORE_RAM=m
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+CONFIG_NFS_V2=m
+CONFIG_NFS_V3=m
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=m
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_NFS_DEBUG=y
+# CONFIG_NFSD is not set
+CONFIG_GRACE_PERIOD=m
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+CONFIG_SUNRPC_GSS=m
+CONFIG_SUNRPC_DEBUG=y
+# CONFIG_SUNRPC_XPRT_RDMA is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_9P_FS=y
+# CONFIG_9P_FS_POSIX_ACL is not set
+# CONFIG_9P_FS_SECURITY is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_INFO_SPLIT is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+# CONFIG_GDB_SCRIPTS is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=8192
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x01b6
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+CONFIG_PAGE_EXTENSION=y
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+CONFIG_HAVE_ARCH_KASAN=y
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_HARDLOCKUP_DETECTOR=y
+# CONFIG_BOOTPARAM_HARDLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE=0
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=60
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHED_INFO=y
+CONFIG_SCHEDSTATS=y
+CONFIG_SCHED_STACK_END_CHECK=y
+# CONFIG_DEBUG_TIMEKEEPING is not set
+# CONFIG_TIMER_STATS is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_LIST=y
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS=y
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_FENTRY=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACER_MAX_TRACE=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_RING_BUFFER_ALLOW_SWAP=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_TRACER_SNAPSHOT=y
+# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+CONFIG_STACK_TRACER=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_KPROBE_EVENT=y
+CONFIG_UPROBE_EVENT=y
+CONFIG_BPF_EVENTS=y
+CONFIG_PROBE_EVENTS=y
+CONFIG_DYNAMIC_FTRACE=y
+CONFIG_DYNAMIC_FTRACE_WITH_REGS=y
+# CONFIG_FUNCTION_PROFILER is not set
+CONFIG_FTRACE_MCOUNT_RECORD=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+CONFIG_MMIOTRACE=y
+# CONFIG_MMIOTRACE_TEST is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_TRACE_ENUM_MAP_FILE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+CONFIG_TEST_USER_COPY=m
+CONFIG_TEST_BPF=m
+CONFIG_TEST_FIRMWARE=m
+# CONFIG_TEST_UDELAY is not set
+CONFIG_MEMTEST=y
+CONFIG_TEST_STATIC_KEYS=m
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+CONFIG_EARLY_PRINTK_EFI=y
+CONFIG_X86_PTDUMP_CORE=y
+# CONFIG_X86_PTDUMP is not set
+# CONFIG_EFI_PGT_DUMP is not set
+CONFIG_DEBUG_RODATA=y
+# CONFIG_DEBUG_RODATA_TEST is not set
+CONFIG_DEBUG_WX=y
+CONFIG_DEBUG_SET_MODULE_RONX=y
+# CONFIG_DEBUG_NX_TEST is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_DEBUG_TLBFLUSH is not set
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+# CONFIG_X86_DECODER_SELFTEST is not set
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_IO_DELAY_0X80=y
+# CONFIG_IO_DELAY_0XED is not set
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+# CONFIG_DEBUG_BOOT_PARAMS is not set
+# CONFIG_CPA_DEBUG is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_ENTRY is not set
+# CONFIG_DEBUG_NMI_SELFTEST is not set
+# CONFIG_X86_DEBUG_STATIC_CPU_HAS is not set
+# CONFIG_X86_DEBUG_FPU is not set
+# CONFIG_PUNIT_ATOM_DEBUG is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_COMPAT=y
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_PAGE_TABLE_ISOLATION is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_INTEL_TXT is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_XOR_BLOCKS=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_AKCIPHER=m
+# CONFIG_CRYPTO_RSA is not set
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=m
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=m
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRC32_PCLMUL is not set
+CONFIG_CRYPTO_CRCT10DIF=y
+# CONFIG_CRYPTO_CRCT10DIF_PCLMUL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_POLY1305_X86_64 is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA1_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256_SSSE3 is not set
+# CONFIG_CRYPTO_SHA512_SSSE3 is not set
+# CONFIG_CRYPTO_SHA1_MB is not set
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=m
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_X86_64 is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_BLOWFISH_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAMELLIA_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST5_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_CAST6_AVX_X86_64 is not set
+CONFIG_CRYPTO_DES=m
+# CONFIG_CRYPTO_DES3_EDE_X86_64 is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_X86_64 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_CHACHA20_X86_64 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SERPENT_SSE2_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64 is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64_3WAY is not set
+# CONFIG_CRYPTO_TWOFISH_AVX_X86_64 is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_DRBG_MENU is not set
+# CONFIG_CRYPTO_JITTERENTROPY is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_PADLOCK is not set
+# CONFIG_CRYPTO_DEV_CCP is not set
+CONFIG_CRYPTO_DEV_QAT=m
+CONFIG_CRYPTO_DEV_QAT_DH895xCC=m
+CONFIG_CRYPTO_DEV_QAT_DH895xCCVF=m
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
+CONFIG_HAVE_KVM=y
+CONFIG_HAVE_KVM_IRQCHIP=y
+CONFIG_HAVE_KVM_IRQFD=y
+CONFIG_HAVE_KVM_IRQ_ROUTING=y
+CONFIG_HAVE_KVM_EVENTFD=y
+CONFIG_KVM_APIC_ARCHITECTURE=y
+CONFIG_KVM_MMIO=y
+CONFIG_KVM_ASYNC_PF=y
+CONFIG_HAVE_KVM_MSI=y
+CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT=y
+CONFIG_KVM_VFIO=y
+CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT=y
+CONFIG_KVM_COMPAT=y
+CONFIG_HAVE_KVM_IRQ_BYPASS=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_KVM_INTEL=m
+# CONFIG_KVM_AMD is not set
+# CONFIG_KVM_MMU_AUDIT is not set
+# CONFIG_KVM_DEVICE_ASSIGNMENT is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_RAID6_PQ=y
+CONFIG_BITREVERSE=y
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_ARCH_HAS_FAST_MULTIPLIER=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=m
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_REED_SOLOMON=m
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_OID_REGISTRY=m
+CONFIG_UCS2_STRING=y
+CONFIG_FONT_SUPPORT=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_SG_SPLIT is not set
+CONFIG_ARCH_HAS_SG_CHAIN=y
+CONFIG_ARCH_HAS_PMEM_API=y
+CONFIG_ARCH_HAS_MMIO_FLUSH=y
diff --git a/kernel/popcorn/configs/config_puzzlehype_mir_210216_v4 b/kernel/popcorn/configs/config_puzzlehype_mir_210216_v4
new file mode 100644
index 000000000000..df4b0324010e
--- /dev/null
+++ b/kernel/popcorn/configs/config_puzzlehype_mir_210216_v4
@@ -0,0 +1,3170 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/x86 4.4.137 Kernel Configuration
+#
+CONFIG_64BIT=y
+CONFIG_X86_64=y
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_PERF_EVENTS_INTEL_UNCORE=y
+CONFIG_OUTPUT_FORMAT="elf64-x86-64"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/x86_64_defconfig"
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+CONFIG_ZONE_DMA32=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_HAVE_INTEL_TXT=y
+CONFIG_X86_64_SMP=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PGTABLE_LEVELS=4
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION="-pop-hype"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KERNEL_XZ=y
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_FHANDLE=y
+CONFIG_USELIB=y
+CONFIG_AUDIT=y
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_VIRT_CPU_ACCOUNTING=y
+# CONFIG_TICK_CPU_ACCOUNTING is not set
+CONFIG_VIRT_CPU_ACCOUNTING_GEN=y
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_CONTEXT_TRACKING=y
+# CONFIG_CONTEXT_TRACKING_FORCE is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_EXPEDITE_BOOT is not set
+# CONFIG_BUILD_BIN2C is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=21
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=13
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
+CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH=y
+CONFIG_ARCH_SUPPORTS_INT128=y
+# CONFIG_NUMA_BALANCING is not set
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_PAGE_COUNTER=y
+CONFIG_MEMCG=y
+# CONFIG_MEMCG_KMEM is not set
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+CONFIG_CGROUP_WRITEBACK=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_RD_LZ4=y
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_HAVE_PCSPKR_PLATFORM=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+CONFIG_SGETMASK_SYSCALL=y
+CONFIG_SYSFS_SYSCALL=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_BPF_SYSCALL=y
+# CONFIG_BPF_JIT_ALWAYS_ON is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_USERFAULTFD=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_MEMBARRIER=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_KEXEC_CORE=y
+CONFIG_OPROFILE=m
+# CONFIG_OPROFILE_EVENT_MULTIPLEX is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_OPROFILE_NMI_TIMER=y
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+CONFIG_OPTPROBES=y
+CONFIG_KPROBES_ON_FTRACE=y
+CONFIG_UPROBES=y
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_KRETPROBES=y
+CONFIG_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_KPROBES_ON_FTRACE=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_ARCH_WANT_OLD_COMPAT_IPC=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR_NONE is not set
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+CONFIG_CC_STACKPROTECTOR_STRONG=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_HAVE_ARCH_HUGE_VMAP=y
+CONFIG_HAVE_ARCH_SOFT_DIRTY=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_COPY_THREAD_TLS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_BLK_DEV_THROTTLING=y
+# CONFIG_BLK_CMDLINE_PARSER is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+# CONFIG_CMDLINE_PARTITION is not set
+CONFIG_BLOCK_COMPAT=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_PREEMPT_NOTIFIERS=y
+CONFIG_ASN1=m
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_ARCH_USE_QUEUED_SPINLOCKS=y
+CONFIG_QUEUED_SPINLOCKS=y
+CONFIG_ARCH_USE_QUEUED_RWLOCKS=y
+CONFIG_QUEUED_RWLOCKS=y
+CONFIG_FREEZER=y
+
+#
+# Popcorn Distributed Execution Support
+#
+CONFIG_ARCH_SUPPORTS_POPCORN=y
+CONFIG_POPCORN=y
+CONFIG_POPCORN_HYPE=y
+# CONFIG_POPCORN_DEBUG is not set
+# CONFIG_POPCORN_CHECK_SANITY is not set
+# CONFIG_POPCORN_REMOTE_INFO is not set
+# CONFIG_POPCORN_STAT is not set
+CONFIG_POPCORN_KMSG=y
+CONFIG_POPCORN_KMSG_SOCKET=m
+CONFIG_POPCORN_KMSG_RDMA=m
+# CONFIG_POPCORN_KMSG_TEST is not set
+
+#
+# Processor type and features
+#
+CONFIG_ZONE_DMA=y
+CONFIG_SMP=y
+CONFIG_X86_FEATURE_NAMES=y
+CONFIG_X86_X2APIC=y
+CONFIG_X86_MPPARSE=y
+CONFIG_RETPOLINE=y
+# CONFIG_X86_EXTENDED_PLATFORM is not set
+CONFIG_X86_INTEL_LPSS=y
+CONFIG_X86_AMD_PLATFORM_DEVICE=y
+CONFIG_IOSF_MBI=y
+# CONFIG_IOSF_MBI_DEBUG is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+CONFIG_HYPERVISOR_GUEST=y
+CONFIG_PARAVIRT=y
+# CONFIG_PARAVIRT_DEBUG is not set
+# CONFIG_PARAVIRT_SPINLOCKS is not set
+# CONFIG_XEN is not set
+CONFIG_KVM_GUEST=y
+# CONFIG_KVM_DEBUG_FS is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+CONFIG_PARAVIRT_CLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MK8 is not set
+# CONFIG_MPSC is not set
+CONFIG_MCORE2=y
+# CONFIG_MATOM is not set
+# CONFIG_GENERIC_CPU is not set
+CONFIG_X86_INTERNODE_CACHE_SHIFT=6
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_INTEL_USERCOPY=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_X86_P6_NOP=y
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=64
+CONFIG_X86_DEBUGCTLMSR=y
+# CONFIG_PROCESSOR_SELECT is not set
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+# CONFIG_GART_IOMMU is not set
+# CONFIG_CALGARY_IOMMU is not set
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_MAXSMP is not set
+CONFIG_NR_CPUS=64
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_X86_MCE_THRESHOLD=y
+CONFIG_X86_MCE_INJECT=m
+CONFIG_X86_THERMAL_VECTOR=y
+# CONFIG_VM86 is not set
+CONFIG_X86_16BIT=y
+CONFIG_X86_ESPFIX64=y
+CONFIG_X86_VSYSCALL_EMULATION=y
+# CONFIG_I8K is not set
+CONFIG_MICROCODE=y
+CONFIG_MICROCODE_INTEL=y
+CONFIG_MICROCODE_AMD=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+CONFIG_X86_MSR=m
+CONFIG_X86_CPUID=m
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_X86_DIRECT_GBPAGES=y
+CONFIG_NUMA=y
+# CONFIG_AMD_NUMA is not set
+CONFIG_X86_64_ACPI_NUMA=y
+CONFIG_NODES_SPAN_OTHER_NODES=y
+CONFIG_NUMA_EMU=y
+CONFIG_NODES_SHIFT=6
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_ARCH_DISCARD_MEMBLOCK=y
+# CONFIG_MOVABLE_NODE is not set
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+# CONFIG_MEMORY_HOTPLUG is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK=y
+CONFIG_MEMORY_BALLOON=y
+# CONFIG_COMPACTION is not set
+CONFIG_MIGRATION=y
+CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_MMU_NOTIFIER=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+# CONFIG_MEMORY_FAILURE is not set
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CMA is not set
+# CONFIG_MEM_SOFT_DIRTY is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+CONFIG_ARCH_SUPPORTS_DEFERRED_STRUCT_PAGE_INIT=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_X86_PMEM_LEGACY is not set
+# CONFIG_X86_CHECK_BIOS_CORRUPTION is not set
+CONFIG_X86_RESERVE_LOW=64
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_ARCH_RANDOM=y
+CONFIG_X86_SMAP=y
+# CONFIG_X86_INTEL_MPX is not set
+CONFIG_EFI=y
+CONFIG_EFI_STUB=y
+# CONFIG_EFI_MIXED is not set
+CONFIG_SECCOMP=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+# CONFIG_KEXEC_FILE is not set
+CONFIG_CRASH_DUMP=y
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+# CONFIG_RANDOMIZE_BASE is not set
+CONFIG_PHYSICAL_ALIGN=0x200000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_BOOTPARAM_HOTPLUG_CPU0 is not set
+# CONFIG_DEBUG_HOTPLUG_CPU0 is not set
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_LEGACY_VSYSCALL_NATIVE is not set
+CONFIG_LEGACY_VSYSCALL_EMULATE=y
+# CONFIG_LEGACY_VSYSCALL_NONE is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MODIFY_LDT_SYSCALL=y
+CONFIG_HAVE_LIVEPATCH=y
+# CONFIG_LIVEPATCH is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_USE_PERCPU_NUMA_NODE_ID=y
+
+#
+# Power management and ACPI options
+#
+# CONFIG_SUSPEND is not set
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+# CONFIG_DPM_WATCHDOG is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_LEGACY_TABLES_LOOKUP=y
+CONFIG_ARCH_MIGHT_HAVE_ACPI_PDC=y
+CONFIG_ACPI_SYSTEM_POWER_STATES_SUPPORT=y
+# CONFIG_ACPI_DEBUGGER is not set
+# CONFIG_ACPI_PROCFS_POWER is not set
+CONFIG_ACPI_REV_OVERRIDE_POSSIBLE=y
+# CONFIG_ACPI_EC_DEBUGFS is not set
+# CONFIG_ACPI_AC is not set
+# CONFIG_ACPI_BATTERY is not set
+# CONFIG_ACPI_BUTTON is not set
+CONFIG_ACPI_FAN=m
+# CONFIG_ACPI_DOCK is not set
+CONFIG_ACPI_CPU_FREQ_PSS=y
+CONFIG_ACPI_PROCESSOR_IDLE=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_ACPI_IPMI=m
+CONFIG_ACPI_HOTPLUG_CPU=y
+CONFIG_ACPI_PROCESSOR_AGGREGATOR=m
+CONFIG_ACPI_THERMAL=m
+CONFIG_ACPI_NUMA=y
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+# CONFIG_ACPI_INITRD_TABLE_OVERRIDE is not set
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_PCI_SLOT=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_ACPI_HOTPLUG_IOAPIC=y
+# CONFIG_ACPI_SBS is not set
+CONFIG_ACPI_HED=y
+# CONFIG_ACPI_CUSTOM_METHOD is not set
+CONFIG_ACPI_BGRT=y
+# CONFIG_ACPI_REDUCED_HARDWARE_ONLY is not set
+# CONFIG_ACPI_NFIT is not set
+CONFIG_HAVE_ACPI_APEI=y
+CONFIG_HAVE_ACPI_APEI_NMI=y
+CONFIG_ACPI_APEI=y
+CONFIG_ACPI_APEI_GHES=y
+CONFIG_ACPI_APEI_PCIEAER=y
+# CONFIG_ACPI_APEI_EINJ is not set
+# CONFIG_ACPI_APEI_ERST_DEBUG is not set
+CONFIG_ACPI_EXTLOG=y
+# CONFIG_PMIC_OPREGION is not set
+CONFIG_SFI=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# CPU frequency scaling drivers
+#
+CONFIG_X86_INTEL_PSTATE=y
+CONFIG_X86_PCC_CPUFREQ=m
+CONFIG_X86_ACPI_CPUFREQ=m
+CONFIG_X86_ACPI_CPUFREQ_CPB=y
+# CONFIG_X86_POWERNOW_K8 is not set
+# CONFIG_X86_AMD_FREQ_SENSITIVITY is not set
+# CONFIG_X86_SPEEDSTEP_CENTRINO is not set
+# CONFIG_X86_P4_CLOCKMOD is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+CONFIG_INTEL_IDLE=y
+
+#
+# Memory power savings
+#
+# CONFIG_I7300_IDLE is not set
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+CONFIG_PCI_DIRECT=y
+# CONFIG_PCI_MMCONFIG is not set
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+CONFIG_PCIEAER_INJECT=m
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PME=y
+CONFIG_PCI_BUS_ADDR_T_64BIT=y
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+# CONFIG_PCI_DEBUG is not set
+CONFIG_PCI_REALLOC_ENABLE_AUTO=y
+CONFIG_PCI_STUB=m
+CONFIG_HT_IRQ=y
+CONFIG_PCI_ATS=y
+CONFIG_PCI_IOV=y
+CONFIG_PCI_PRI=y
+CONFIG_PCI_PASID=y
+CONFIG_PCI_LABEL=y
+
+#
+# PCI host controller drivers
+#
+CONFIG_ISA_DMA_API=y
+CONFIG_AMD_NB=y
+# CONFIG_PCCARD is not set
+# CONFIG_HOTPLUG_PCI is not set
+# CONFIG_RAPIDIO is not set
+# CONFIG_X86_SYSFB is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=m
+CONFIG_COREDUMP=y
+CONFIG_IA32_EMULATION=y
+# CONFIG_IA32_AOUT is not set
+# CONFIG_X86_X32 is not set
+CONFIG_COMPAT=y
+CONFIG_COMPAT_FOR_U64_ALIGNMENT=y
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_X86_DEV_DMA_OPS=y
+CONFIG_PMC_ATOM=y
+CONFIG_NET=y
+CONFIG_NET_INGRESS=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_XFRM=y
+CONFIG_XFRM_ALGO=m
+CONFIG_XFRM_USER=m
+CONFIG_XFRM_SUB_POLICY=y
+CONFIG_XFRM_MIGRATE=y
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=m
+CONFIG_NET_KEY=m
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_TRIE_STATS=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE_DEMUX=m
+CONFIG_NET_IP_TUNNEL=y
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_SYN_COOKIES=y
+CONFIG_NET_IPVTI=m
+CONFIG_NET_UDP_TUNNEL=y
+CONFIG_NET_FOU=y
+CONFIG_NET_FOU_IP_TUNNELS=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_TUNNEL=m
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=m
+CONFIG_INET_XFRM_MODE_TUNNEL=m
+CONFIG_INET_XFRM_MODE_BEET=m
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_UDP_DIAG=y
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+# CONFIG_TCP_CONG_DCTCP is not set
+# CONFIG_TCP_CONG_CDG is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+CONFIG_IPV6_MIP6=y
+# CONFIG_IPV6_ILA is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+# CONFIG_IPV6_VTI is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_GRE is not set
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IPV6_PIMSM_V2=y
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NET_PTP_CLASSIFY=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=m
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_INGRESS=y
+CONFIG_NETFILTER_NETLINK=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+# CONFIG_NF_CONNTRACK_MARK is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CT_NETLINK is not set
+# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+# CONFIG_NF_NAT_AMANDA is not set
+# CONFIG_NF_NAT_FTP is not set
+# CONFIG_NF_NAT_IRC is not set
+# CONFIG_NF_NAT_SIP is not set
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NF_NAT_REDIRECT is not set
+CONFIG_NF_TABLES=y
+# CONFIG_NF_TABLES_INET is not set
+CONFIG_NF_TABLES_NETDEV=y
+CONFIG_NFT_EXTHDR=y
+# CONFIG_NFT_META is not set
+# CONFIG_NFT_CT is not set
+# CONFIG_NFT_RBTREE is not set
+# CONFIG_NFT_HASH is not set
+# CONFIG_NFT_COUNTER is not set
+# CONFIG_NFT_LOG is not set
+# CONFIG_NFT_LIMIT is not set
+# CONFIG_NFT_MASQ is not set
+# CONFIG_NFT_REDIR is not set
+# CONFIG_NFT_NAT is not set
+# CONFIG_NFT_REJECT is not set
+CONFIG_NFT_COMPAT=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+# CONFIG_NETFILTER_XT_CONNMARK is not set
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+# CONFIG_NETFILTER_XT_TARGET_LOG is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+CONFIG_NETFILTER_XT_NAT=y
+# CONFIG_NETFILTER_XT_TARGET_NETMAP is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_REDIRECT is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y
+# CONFIG_NETFILTER_XT_MATCH_BPF is not set
+# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ECN is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+CONFIG_NETFILTER_XT_MATCH_HL=y
+# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+# CONFIG_NETFILTER_XT_MATCH_IPVS is not set
+# CONFIG_NETFILTER_XT_MATCH_L2TP is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+CONFIG_NETFILTER_XT_MATCH_RECENT=y
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+# CONFIG_NETFILTER_XT_MATCH_STATE is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_IP_SET is not set
+CONFIG_IP_VS=y
+# CONFIG_IP_VS_IPV6 is not set
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+# CONFIG_IP_VS_PROTO_TCP is not set
+# CONFIG_IP_VS_PROTO_UDP is not set
+# CONFIG_IP_VS_PROTO_AH_ESP is not set
+# CONFIG_IP_VS_PROTO_ESP is not set
+# CONFIG_IP_VS_PROTO_AH is not set
+# CONFIG_IP_VS_PROTO_SCTP is not set
+
+#
+# IPVS scheduler
+#
+# CONFIG_IP_VS_RR is not set
+# CONFIG_IP_VS_WRR is not set
+# CONFIG_IP_VS_LC is not set
+# CONFIG_IP_VS_WLC is not set
+# CONFIG_IP_VS_FO is not set
+# CONFIG_IP_VS_OVF is not set
+# CONFIG_IP_VS_LBLC is not set
+# CONFIG_IP_VS_LBLCR is not set
+# CONFIG_IP_VS_DH is not set
+# CONFIG_IP_VS_SH is not set
+# CONFIG_IP_VS_SED is not set
+# CONFIG_IP_VS_NQ is not set
+
+#
+# IPVS SH scheduler
+#
+CONFIG_IP_VS_SH_TAB_BITS=8
+
+#
+# IPVS application helper
+#
+# CONFIG_IP_VS_NFCT is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_NF_TABLES_IPV4=y
+CONFIG_NFT_CHAIN_ROUTE_IPV4=y
+# CONFIG_NFT_REJECT_IPV4 is not set
+# CONFIG_NFT_DUP_IPV4 is not set
+CONFIG_NF_TABLES_ARP=y
+# CONFIG_NF_DUP_IPV4 is not set
+# CONFIG_NF_LOG_ARP is not set
+# CONFIG_NF_LOG_IPV4 is not set
+# CONFIG_NF_REJECT_IPV4 is not set
+CONFIG_NF_NAT_IPV4=y
+CONFIG_NFT_CHAIN_NAT_IPV4=y
+CONFIG_NF_NAT_MASQUERADE_IPV4=y
+# CONFIG_NF_NAT_PPTP is not set
+# CONFIG_NF_NAT_H323 is not set
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+CONFIG_IP_NF_FILTER=y
+# CONFIG_IP_NF_TARGET_REJECT is not set
+# CONFIG_IP_NF_TARGET_SYNPROXY is not set
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+# CONFIG_IP_NF_TARGET_NETMAP is not set
+# CONFIG_IP_NF_TARGET_REDIRECT is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+# CONFIG_IP_NF_ARP_MANGLE is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV6 is not set
+# CONFIG_NF_CONNTRACK_IPV6 is not set
+# CONFIG_NF_TABLES_IPV6 is not set
+# CONFIG_NF_DUP_IPV6 is not set
+# CONFIG_NF_REJECT_IPV6 is not set
+# CONFIG_NF_LOG_IPV6 is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_NF_TABLES_BRIDGE is not set
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+CONFIG_STP=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+CONFIG_NET_SCH_NETEM=y
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+# CONFIG_NET_SCH_FQ is not set
+# CONFIG_NET_SCH_HHF is not set
+# CONFIG_NET_SCH_PIE is not set
+# CONFIG_NET_SCH_PLUG is not set
+
+#
+# Classification
+#
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+# CONFIG_NET_CLS_BPF is not set
+# CONFIG_NET_CLS_FLOWER is not set
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_CLS_ACT is not set
+CONFIG_NET_SCH_FIFO=y
+CONFIG_DCB=y
+CONFIG_DNS_RESOLVER=m
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+CONFIG_NETLINK_DIAG=y
+CONFIG_MPLS=y
+# CONFIG_NET_MPLS_GSO is not set
+# CONFIG_MPLS_ROUTING is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_CGROUP_NET_CLASSID=y
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+CONFIG_BPF_JIT=y
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=m
+# CONFIG_NET_TCPPROBE is not set
+CONFIG_NET_DROP_MONITOR=m
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+# CONFIG_NET_9P_RDMA is not set
+# CONFIG_NET_9P_DEBUG is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_DST_CACHE=y
+CONFIG_HAVE_BPF_JIT=y
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_UEVENT_HELPER is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_GENERIC_CPU_VULNERABILITIES=y
+# CONFIG_DMA_SHARED_BUFFER is not set
+
+#
+# Bus devices
+#
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_OF is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG_MESSAGES is not set
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SKD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=18874368
+# CONFIG_BLK_DEV_RAM_DAX is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_VIRTIO_BLK=y
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+# CONFIG_BLK_DEV_NVME is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_93CX6=m
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+
+#
+# Altera FPGA firmware download module
+#
+CONFIG_INTEL_MEI=m
+CONFIG_INTEL_MEI_ME=m
+# CONFIG_INTEL_MEI_TXE is not set
+# CONFIG_VMWARE_VMCI is not set
+
+#
+# Intel MIC Bus Driver
+#
+# CONFIG_INTEL_MIC_BUS is not set
+
+#
+# SCIF Bus Driver
+#
+# CONFIG_SCIF_BUS is not set
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+# CONFIG_GENWQE is not set
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_KERNEL_API is not set
+# CONFIG_CXL_EEH is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=m
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=m
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_MQ_DEFAULT is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=m
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_ZPODD=y
+# CONFIG_SATA_PMP is not set
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI=m
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+# CONFIG_ATA_SFF is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+CONFIG_MII=m
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_GENEVE is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+CONFIG_TUN=y
+# CONFIG_TUN_VNET_CROSS_LE is not set
+CONFIG_VETH=y
+CONFIG_VIRTIO_NET=y
+# CONFIG_NLMON is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_VHOST_NET=y
+CONFIG_VHOST_RING=y
+CONFIG_VHOST=y
+# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+CONFIG_ETHERNET=y
+CONFIG_MDIO=m
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_CADENCE is not set
+CONFIG_NET_VENDOR_BROADCOM=y
+CONFIG_B44=m
+CONFIG_B44_PCI_AUTOSELECT=y
+CONFIG_B44_PCICORE_AUTOSELECT=y
+CONFIG_B44_PCI=y
+CONFIG_BCMGENET=m
+CONFIG_BNX2=m
+CONFIG_CNIC=m
+CONFIG_TIGON3=m
+CONFIG_BNX2X=m
+CONFIG_BNX2X_SRIOV=y
+CONFIG_BNXT=m
+CONFIG_BNXT_SRIOV=y
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_CX_ECAT is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_HP is not set
+CONFIG_NET_VENDOR_INTEL=y
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IXGB is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGBEVF is not set
+CONFIG_I40E=m
+# CONFIG_I40E_DCB is not set
+CONFIG_I40EVF=m
+# CONFIG_FM10K is not set
+# CONFIG_NET_VENDOR_I825XX is not set
+# CONFIG_JME is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+CONFIG_MLX4_EN=m
+CONFIG_MLX4_EN_DCB=y
+CONFIG_MLX4_CORE=m
+CONFIG_MLX4_DEBUG=y
+CONFIG_MLX5_CORE=m
+CONFIG_MLX5_CORE_EN=y
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_SFC is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_NET_SB1000 is not set
+CONFIG_PHYLIB=m
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_AT803X_PHY is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_SMSC_PHY is not set
+CONFIG_BCM_NET_PHYLIB=m
+# CONFIG_BROADCOM_PHY is not set
+CONFIG_BCM7XXX_PHY=m
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+CONFIG_FIXED_PHY=m
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_OCTEON is not set
+# CONFIG_MDIO_BCM_UNIMAC is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Host-side USB support is needed for USB Network Adapter support
+#
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_FUJITSU_ES is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
+CONFIG_SERIO_I8042=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DMA=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_RSA=y
+# CONFIG_SERIAL_8250_FSL is not set
+# CONFIG_SERIAL_8250_DW is not set
+# CONFIG_SERIAL_8250_RT288X is not set
+# CONFIG_SERIAL_8250_FINTEK is not set
+# CONFIG_SERIAL_8250_MID is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+CONFIG_TTY_PRINTK=y
+CONFIG_HVC_DRIVER=y
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_IPMI_HANDLER=m
+# CONFIG_IPMI_PANIC_EVENT is not set
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+# CONFIG_IPMI_SI_PROBE_DEFAULTS is not set
+# CONFIG_IPMI_SSIF is not set
+CONFIG_IPMI_WATCHDOG=m
+CONFIG_IPMI_POWEROFF=m
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_VIA=y
+CONFIG_HW_RANDOM_VIRTIO=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_MWAVE is not set
+CONFIG_RAW_DRIVER=m
+CONFIG_MAX_RAW_DEVS=256
+CONFIG_HPET=y
+CONFIG_HPET_MMAP=y
+CONFIG_HPET_MMAP_DEFAULT=y
+CONFIG_HANGCHECK_TIMER=y
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=y
+# CONFIG_PPS_DEBUG is not set
+CONFIG_NTP_PPS=y
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+CONFIG_PPS_CLIENT_LDISC=y
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=m
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_CHERRYVIEW is not set
+# CONFIG_PINCTRL_BROXTON is not set
+# CONFIG_PINCTRL_SUNRISEPOINT is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_APPLESMC is not set
+# CONFIG_SENSORS_DELL_SMM is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_IBMAEM is not set
+# CONFIG_SENSORS_IBMPEX is not set
+CONFIG_SENSORS_I5500=m
+CONFIG_SENSORS_CORETEMP=m
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_NCT6683 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+
+#
+# ACPI drivers
+#
+CONFIG_SENSORS_ACPI_POWER=m
+# CONFIG_SENSORS_ATK0110 is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_THERMAL_GOV_BANG_BANG=y
+CONFIG_THERMAL_GOV_USER_SPACE=y
+# CONFIG_THERMAL_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_EMULATION is not set
+CONFIG_INTEL_POWERCLAMP=m
+CONFIG_X86_PKG_TEMP_THERMAL=m
+CONFIG_INTEL_SOC_DTS_IOSF_CORE=m
+CONFIG_INTEL_SOC_DTS_THERMAL=m
+CONFIG_INT340X_THERMAL=m
+CONFIG_ACPI_THERMAL_REL=m
+CONFIG_INTEL_PCH_THERMAL=m
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_ACQUIRE_WDT is not set
+# CONFIG_ADVANTECH_WDT is not set
+# CONFIG_ALIM1535_WDT is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_F71808E_WDT is not set
+# CONFIG_SP5100_TCO is not set
+# CONFIG_SBC_FITPC2_WATCHDOG is not set
+# CONFIG_EUROTECH_WDT is not set
+# CONFIG_IB700_WDT is not set
+# CONFIG_IBMASR is not set
+# CONFIG_WAFER_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_IE6XX_WDT is not set
+CONFIG_ITCO_WDT=m
+CONFIG_ITCO_VENDOR_SUPPORT=y
+# CONFIG_IT8712F_WDT is not set
+# CONFIG_IT87_WDT is not set
+# CONFIG_HP_WATCHDOG is not set
+# CONFIG_SC1200_WDT is not set
+# CONFIG_PC87413_WDT is not set
+# CONFIG_NV_TCO is not set
+# CONFIG_60XX_WDT is not set
+# CONFIG_CPU5_WDT is not set
+# CONFIG_SMSC_SCH311X_WDT is not set
+# CONFIG_SMSC37B787_WDT is not set
+# CONFIG_VIA_WDT is not set
+# CONFIG_W83627HF_WDT is not set
+# CONFIG_W83877F_WDT is not set
+# CONFIG_W83977F_WDT is not set
+# CONFIG_MACHZ_WDT is not set
+# CONFIG_SBC_EPX_C3_WATCHDOG is not set
+# CONFIG_BCM7038_WDT is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB=y
+CONFIG_SSB_SPROM=y
+CONFIG_SSB_PCIHOST_POSSIBLE=y
+CONFIG_SSB_PCIHOST=y
+# CONFIG_SSB_B43_PCI_BRIDGE is not set
+# CONFIG_SSB_HOST_SOC is not set
+# CONFIG_SSB_SILENT is not set
+# CONFIG_SSB_DEBUG is not set
+CONFIG_SSB_DRIVER_PCICORE_POSSIBLE=y
+CONFIG_SSB_DRIVER_PCICORE=y
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_INTEL_QUARK_I2C_GPIO is not set
+# CONFIG_LPC_ICH is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_INTEL_LPSS_ACPI is not set
+# CONFIG_MFD_INTEL_LPSS_PCI is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RTSX_USB is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_AGP is not set
+# CONFIG_VGA_ARB is not set
+# CONFIG_VGA_SWITCHEROO is not set
+# CONFIG_DRM is not set
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FB_CMDLINE=y
+# CONFIG_FB_DDC is not set
+CONFIG_FB_BOOT_VESA_SUPPORT=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_VGA16 is not set
+CONFIG_FB_VESA=y
+# CONFIG_FB_EFI is not set
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SM712 is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=25
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=m
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=m
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=m
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=m
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=m
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_USB_MON is not set
+CONFIG_USB_WUSB_CBAF=m
+# CONFIG_USB_WUSB_CBAF_DEBUG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=m
+CONFIG_USB_XHCI_PCI=m
+# CONFIG_USB_XHCI_PLATFORM is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_PCI=m
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+CONFIG_USB_OHCI_HCD=m
+CONFIG_USB_OHCI_HCD_PCI=m
+# CONFIG_USB_OHCI_HCD_SSB is not set
+# CONFIG_USB_OHCI_HCD_PLATFORM is not set
+CONFIG_USB_UHCI_HCD=m
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_SSB is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+# CONFIG_USB_STORAGE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+# CONFIG_USB_CHAOSKEY is not set
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_USB_PHY is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_INFINIBAND=m
+CONFIG_INFINIBAND_USER_MAD=m
+CONFIG_INFINIBAND_USER_ACCESS=m
+CONFIG_INFINIBAND_USER_MEM=y
+CONFIG_INFINIBAND_ON_DEMAND_PAGING=y
+CONFIG_INFINIBAND_ADDR_TRANS=y
+CONFIG_INFINIBAND_MTHCA=m
+CONFIG_INFINIBAND_MTHCA_DEBUG=y
+# CONFIG_INFINIBAND_QIB is not set
+CONFIG_MLX4_INFINIBAND=m
+CONFIG_MLX5_INFINIBAND=m
+# CONFIG_INFINIBAND_NES is not set
+# CONFIG_INFINIBAND_OCRDMA is not set
+# CONFIG_INFINIBAND_USNIC is not set
+CONFIG_INFINIBAND_IPOIB=m
+CONFIG_INFINIBAND_IPOIB_CM=y
+CONFIG_INFINIBAND_IPOIB_DEBUG=y
+# CONFIG_INFINIBAND_IPOIB_DEBUG_DATA is not set
+# CONFIG_INFINIBAND_SRP is not set
+# CONFIG_INFINIBAND_ISER is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_VIRTUAL_CHANNELS=m
+CONFIG_DMA_ACPI=y
+CONFIG_INTEL_IDMA64=m
+# CONFIG_INTEL_IOATDMA is not set
+# CONFIG_DW_DMAC is not set
+# CONFIG_DW_DMAC_PCI is not set
+
+#
+# DMA Clients
+#
+CONFIG_ASYNC_TX_DMA=y
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_UIO=m
+CONFIG_UIO_CIF=m
+# CONFIG_UIO_PDRV_GENIRQ is not set
+# CONFIG_UIO_DMEM_GENIRQ is not set
+CONFIG_UIO_AEC=m
+CONFIG_UIO_SERCOS3=m
+CONFIG_UIO_PCI_GENERIC=m
+CONFIG_UIO_NETX=m
+# CONFIG_UIO_PRUSS is not set
+CONFIG_UIO_MF624=m
+# CONFIG_VFIO is not set
+CONFIG_IRQ_BYPASS_MANAGER=y
+CONFIG_VIRT_DRIVERS=y
+CONFIG_VIRTIO=y
+
+#
+# Virtio drivers
+#
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO_PCI_LEGACY=y
+CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_INPUT=y
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_HYPERV is not set
+# CONFIG_STAGING is not set
+CONFIG_X86_PLATFORM_DEVICES=y
+# CONFIG_ACERHDF is not set
+# CONFIG_DELL_SMO8800 is not set
+# CONFIG_FUJITSU_TABLET is not set
+# CONFIG_HP_ACCEL is not set
+# CONFIG_HP_WIRELESS is not set
+# CONFIG_SENSORS_HDAPS is not set
+# CONFIG_INTEL_MENLOW is not set
+# CONFIG_ACPI_WMI is not set
+# CONFIG_TOPSTAR_LAPTOP is not set
+# CONFIG_TOSHIBA_BT_RFKILL is not set
+# CONFIG_TOSHIBA_HAPS is not set
+# CONFIG_ACPI_CMPC is not set
+CONFIG_INTEL_IPS=m
+CONFIG_IBM_RTL=m
+# CONFIG_SAMSUNG_Q10 is not set
+CONFIG_INTEL_RST=m
+CONFIG_INTEL_SMARTCONNECT=m
+CONFIG_PVPANIC=m
+CONFIG_INTEL_PMC_IPC=m
+# CONFIG_SURFACE_PRO3_BUTTON is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_COMMON_CLK_PXA is not set
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKEVT_I8253=y
+CONFIG_I8253_LOCK=y
+CONFIG_CLKBLD_I8253=y
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_API=y
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Generic IOMMU Pagetable Support
+#
+CONFIG_IOMMU_IOVA=y
+# CONFIG_AMD_IOMMU is not set
+CONFIG_DMAR_TABLE=y
+CONFIG_INTEL_IOMMU=y
+CONFIG_INTEL_IOMMU_SVM=y
+# CONFIG_INTEL_IOMMU_DEFAULT_ON is not set
+CONFIG_INTEL_IOMMU_FLOPPY_WA=y
+# CONFIG_IRQ_REMAP is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+CONFIG_PM_DEVFREQ=y
+
+#
+# DEVFREQ Governors
+#
+CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=m
+# CONFIG_DEVFREQ_GOV_PERFORMANCE is not set
+# CONFIG_DEVFREQ_GOV_POWERSAVE is not set
+# CONFIG_DEVFREQ_GOV_USERSPACE is not set
+
+#
+# DEVFREQ Drivers
+#
+# CONFIG_PM_DEVFREQ_EVENT is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_PWM is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+CONFIG_POWERCAP=y
+CONFIG_INTEL_RAPL=m
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_RAS=y
+# CONFIG_THUNDERBOLT is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_STM_DUMMY is not set
+# CONFIG_STM_SOURCE_CONSOLE is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# Firmware Drivers
+#
+CONFIG_EDD=m
+# CONFIG_EDD_OFF is not set
+CONFIG_FIRMWARE_MEMMAP=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+CONFIG_DMI_SYSFS=y
+CONFIG_DMI_SCAN_MACHINE_NON_EFI_FALLBACK=y
+# CONFIG_ISCSI_IBFT_FIND is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# EFI (Extensible Firmware Interface) Support
+#
+CONFIG_EFI_VARS=m
+CONFIG_EFI_ESRT=y
+CONFIG_EFI_VARS_PSTORE=m
+# CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE is not set
+CONFIG_EFI_RUNTIME_MAP=y
+# CONFIG_EFI_FAKE_MEMMAP is not set
+CONFIG_EFI_RUNTIME_WRAPPERS=y
+CONFIG_UEFI_CPER=y
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_ENCRYPTION is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+CONFIG_BTRFS_FS=y
+# CONFIG_BTRFS_FS_POSIX_ACL is not set
+# CONFIG_BTRFS_FS_CHECK_INTEGRITY is not set
+# CONFIG_BTRFS_FS_RUN_SANITY_TESTS is not set
+# CONFIG_BTRFS_DEBUG is not set
+# CONFIG_BTRFS_ASSERT is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_FS_DAX=y
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+CONFIG_OVERLAY_FS=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_PROC_CHILDREN=y
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_EFIVAR_FS=m
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_PSTORE=y
+# CONFIG_PSTORE_CONSOLE is not set
+# CONFIG_PSTORE_PMSG is not set
+# CONFIG_PSTORE_FTRACE is not set
+CONFIG_PSTORE_RAM=m
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+CONFIG_NFS_V2=m
+CONFIG_NFS_V3=m
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=m
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_NFS_DEBUG=y
+# CONFIG_NFSD is not set
+CONFIG_GRACE_PERIOD=m
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+CONFIG_SUNRPC_GSS=m
+CONFIG_SUNRPC_DEBUG=y
+# CONFIG_SUNRPC_XPRT_RDMA is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_9P_FS=y
+# CONFIG_9P_FS_POSIX_ACL is not set
+# CONFIG_9P_FS_SECURITY is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_INFO_SPLIT is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+# CONFIG_GDB_SCRIPTS is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=8192
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x01b6
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+CONFIG_PAGE_EXTENSION=y
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+CONFIG_HAVE_ARCH_KASAN=y
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_HARDLOCKUP_DETECTOR=y
+# CONFIG_BOOTPARAM_HARDLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE=0
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=60
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHED_INFO=y
+CONFIG_SCHEDSTATS=y
+CONFIG_SCHED_STACK_END_CHECK=y
+# CONFIG_DEBUG_TIMEKEEPING is not set
+# CONFIG_TIMER_STATS is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_LIST=y
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS=y
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_FENTRY=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACER_MAX_TRACE=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_RING_BUFFER_ALLOW_SWAP=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_TRACER_SNAPSHOT=y
+# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+CONFIG_STACK_TRACER=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_KPROBE_EVENT=y
+CONFIG_UPROBE_EVENT=y
+CONFIG_BPF_EVENTS=y
+CONFIG_PROBE_EVENTS=y
+CONFIG_DYNAMIC_FTRACE=y
+CONFIG_DYNAMIC_FTRACE_WITH_REGS=y
+# CONFIG_FUNCTION_PROFILER is not set
+CONFIG_FTRACE_MCOUNT_RECORD=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+CONFIG_MMIOTRACE=y
+# CONFIG_MMIOTRACE_TEST is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_TRACE_ENUM_MAP_FILE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+CONFIG_TEST_USER_COPY=m
+CONFIG_TEST_BPF=m
+CONFIG_TEST_FIRMWARE=m
+# CONFIG_TEST_UDELAY is not set
+CONFIG_MEMTEST=y
+CONFIG_TEST_STATIC_KEYS=m
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+CONFIG_EARLY_PRINTK_EFI=y
+CONFIG_X86_PTDUMP_CORE=y
+# CONFIG_X86_PTDUMP is not set
+# CONFIG_EFI_PGT_DUMP is not set
+CONFIG_DEBUG_RODATA=y
+# CONFIG_DEBUG_RODATA_TEST is not set
+CONFIG_DEBUG_WX=y
+CONFIG_DEBUG_SET_MODULE_RONX=y
+# CONFIG_DEBUG_NX_TEST is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_DEBUG_TLBFLUSH is not set
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+# CONFIG_X86_DECODER_SELFTEST is not set
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_IO_DELAY_0X80=y
+# CONFIG_IO_DELAY_0XED is not set
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+# CONFIG_DEBUG_BOOT_PARAMS is not set
+# CONFIG_CPA_DEBUG is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_ENTRY is not set
+# CONFIG_DEBUG_NMI_SELFTEST is not set
+# CONFIG_X86_DEBUG_STATIC_CPU_HAS is not set
+# CONFIG_X86_DEBUG_FPU is not set
+# CONFIG_PUNIT_ATOM_DEBUG is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_COMPAT=y
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_PAGE_TABLE_ISOLATION is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_INTEL_TXT is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_XOR_BLOCKS=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_AKCIPHER=m
+# CONFIG_CRYPTO_RSA is not set
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=m
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=m
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRC32_PCLMUL is not set
+CONFIG_CRYPTO_CRCT10DIF=y
+# CONFIG_CRYPTO_CRCT10DIF_PCLMUL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_POLY1305_X86_64 is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA1_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256_SSSE3 is not set
+# CONFIG_CRYPTO_SHA512_SSSE3 is not set
+# CONFIG_CRYPTO_SHA1_MB is not set
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=m
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_X86_64 is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_BLOWFISH_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAMELLIA_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST5_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_CAST6_AVX_X86_64 is not set
+CONFIG_CRYPTO_DES=m
+# CONFIG_CRYPTO_DES3_EDE_X86_64 is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_X86_64 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_CHACHA20_X86_64 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SERPENT_SSE2_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64 is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64_3WAY is not set
+# CONFIG_CRYPTO_TWOFISH_AVX_X86_64 is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_DRBG_MENU is not set
+# CONFIG_CRYPTO_JITTERENTROPY is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_PADLOCK is not set
+# CONFIG_CRYPTO_DEV_CCP is not set
+CONFIG_CRYPTO_DEV_QAT=m
+CONFIG_CRYPTO_DEV_QAT_DH895xCC=m
+CONFIG_CRYPTO_DEV_QAT_DH895xCCVF=m
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
+CONFIG_HAVE_KVM=y
+CONFIG_HAVE_KVM_IRQCHIP=y
+CONFIG_HAVE_KVM_IRQFD=y
+CONFIG_HAVE_KVM_IRQ_ROUTING=y
+CONFIG_HAVE_KVM_EVENTFD=y
+CONFIG_KVM_APIC_ARCHITECTURE=y
+CONFIG_KVM_MMIO=y
+CONFIG_KVM_ASYNC_PF=y
+CONFIG_HAVE_KVM_MSI=y
+CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT=y
+CONFIG_KVM_VFIO=y
+CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT=y
+CONFIG_KVM_COMPAT=y
+CONFIG_HAVE_KVM_IRQ_BYPASS=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_KVM_INTEL=m
+# CONFIG_KVM_AMD is not set
+# CONFIG_KVM_MMU_AUDIT is not set
+# CONFIG_KVM_DEVICE_ASSIGNMENT is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_RAID6_PQ=y
+CONFIG_BITREVERSE=y
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_ARCH_HAS_FAST_MULTIPLIER=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=m
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_REED_SOLOMON=m
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_OID_REGISTRY=m
+CONFIG_UCS2_STRING=y
+CONFIG_FONT_SUPPORT=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_SG_SPLIT is not set
+CONFIG_ARCH_HAS_SG_CHAIN=y
+CONFIG_ARCH_HAS_PMEM_API=y
+CONFIG_ARCH_HAS_MMIO_FLUSH=y
diff --git a/kernel/popcorn/configs/config_puzzlehype_mir_210407 b/kernel/popcorn/configs/config_puzzlehype_mir_210407
new file mode 100644
index 000000000000..1611f2e27064
--- /dev/null
+++ b/kernel/popcorn/configs/config_puzzlehype_mir_210407
@@ -0,0 +1,3365 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/x86 4.4.137 Kernel Configuration
+#
+CONFIG_64BIT=y
+CONFIG_X86_64=y
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_PERF_EVENTS_INTEL_UNCORE=y
+CONFIG_OUTPUT_FORMAT="elf64-x86-64"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/x86_64_defconfig"
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+CONFIG_ZONE_DMA32=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_HAVE_INTEL_TXT=y
+CONFIG_X86_64_SMP=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PGTABLE_LEVELS=4
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION="-pop-hype"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KERNEL_XZ=y
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_FHANDLE=y
+CONFIG_USELIB=y
+CONFIG_AUDIT=y
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_EXPEDITE_BOOT is not set
+CONFIG_BUILD_BIN2C=y
+CONFIG_IKCONFIG=m
+# CONFIG_IKCONFIG_PROC is not set
+CONFIG_LOG_BUF_SHIFT=21
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
+CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH=y
+CONFIG_ARCH_SUPPORTS_INT128=y
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_PIDS is not set
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_PAGE_COUNTER=y
+CONFIG_MEMCG=y
+# CONFIG_MEMCG_KMEM is not set
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+CONFIG_CGROUP_WRITEBACK=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_RD_LZ4=y
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_HAVE_PCSPKR_PLATFORM=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+CONFIG_SGETMASK_SYSCALL=y
+CONFIG_SYSFS_SYSCALL=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_BPF_SYSCALL is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_USERFAULTFD is not set
+CONFIG_PCI_QUIRKS=y
+CONFIG_MEMBARRIER=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_KEXEC_CORE=y
+# CONFIG_OPROFILE is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_OPROFILE_NMI_TIMER=y
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+CONFIG_OPTPROBES=y
+CONFIG_KPROBES_ON_FTRACE=y
+CONFIG_UPROBES=y
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_KRETPROBES=y
+CONFIG_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_KPROBES_ON_FTRACE=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_ARCH_WANT_OLD_COMPAT_IPC=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR_NONE is not set
+CONFIG_CC_STACKPROTECTOR_REGULAR=y
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_HAVE_ARCH_HUGE_VMAP=y
+CONFIG_HAVE_ARCH_SOFT_DIRTY=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_COPY_THREAD_TLS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_BLK_DEV_THROTTLING=y
+# CONFIG_BLK_CMDLINE_PARSER is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+# CONFIG_CMDLINE_PARTITION is not set
+CONFIG_BLOCK_COMPAT=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_PREEMPT_NOTIFIERS=y
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_ARCH_USE_QUEUED_SPINLOCKS=y
+CONFIG_QUEUED_SPINLOCKS=y
+CONFIG_ARCH_USE_QUEUED_RWLOCKS=y
+CONFIG_QUEUED_RWLOCKS=y
+CONFIG_FREEZER=y
+
+#
+# Popcorn Distributed Execution Support
+#
+CONFIG_ARCH_SUPPORTS_POPCORN=y
+CONFIG_POPCORN=y
+CONFIG_POPCORN_HYPE=y
+CONFIG_POPCORN_DEBUG=y
+CONFIG_POPCORN_DEBUG_PROCESS_SERVER=y
+CONFIG_POPCORN_DEBUG_PAGE_SERVER=y
+CONFIG_POPCORN_DEBUG_VMA_SERVER=y
+CONFIG_POPCORN_DEBUG_VERBOSE=y
+CONFIG_POPCORN_DEBUG_HYPE=y
+CONFIG_POPCORN_DEBUG_HYPE_EPT=y
+# CONFIG_POPCORN_DEBUG_HYPE_EPT_MORE is not set
+CONFIG_POPCORN_DEBUG_HYPE_EPT_VERBOSE=y
+CONFIG_POPCORN_DEBUG_DEBUG=y
+CONFIG_POPCORN_CHECK_SANITY=y
+# CONFIG_POPCORN_REMOTE_INFO is not set
+CONFIG_POPCORN_STAT=y
+CONFIG_POPCORN_STAT_PGFAULTS=y
+# CONFIG_POPCORN_STAT_MSG is not set
+CONFIG_POPCORN_KMSG=y
+CONFIG_POPCORN_KMSG_SOCKET=m
+CONFIG_POPCORN_KMSG_RDMA=m
+CONFIG_POPCORN_KMSG_TEST=m
+CONFIG_POPCORN_DEBUG_MSG_LAYER=y
+
+#
+# Processor type and features
+#
+CONFIG_ZONE_DMA=y
+CONFIG_SMP=y
+CONFIG_X86_FEATURE_NAMES=y
+CONFIG_X86_X2APIC=y
+CONFIG_X86_MPPARSE=y
+CONFIG_RETPOLINE=y
+# CONFIG_X86_EXTENDED_PLATFORM is not set
+CONFIG_X86_INTEL_LPSS=y
+# CONFIG_X86_AMD_PLATFORM_DEVICE is not set
+CONFIG_IOSF_MBI=m
+# CONFIG_IOSF_MBI_DEBUG is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+CONFIG_HYPERVISOR_GUEST=y
+CONFIG_PARAVIRT=y
+# CONFIG_PARAVIRT_DEBUG is not set
+# CONFIG_PARAVIRT_SPINLOCKS is not set
+CONFIG_XEN=y
+CONFIG_XEN_DOM0=y
+CONFIG_XEN_PVHVM=y
+CONFIG_XEN_512GB=y
+CONFIG_XEN_SAVE_RESTORE=y
+# CONFIG_XEN_DEBUG_FS is not set
+CONFIG_XEN_PVH=y
+CONFIG_KVM_GUEST=y
+# CONFIG_KVM_DEBUG_FS is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+CONFIG_PARAVIRT_CLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MK8 is not set
+# CONFIG_MPSC is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MATOM is not set
+CONFIG_GENERIC_CPU=y
+CONFIG_X86_INTERNODE_CACHE_SHIFT=6
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=64
+CONFIG_X86_DEBUGCTLMSR=y
+# CONFIG_PROCESSOR_SELECT is not set
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+CONFIG_GART_IOMMU=y
+CONFIG_CALGARY_IOMMU=y
+CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT=y
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_MAXSMP is not set
+CONFIG_NR_CPUS=64
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_X86_MCE_THRESHOLD=y
+# CONFIG_X86_MCE_INJECT is not set
+CONFIG_X86_THERMAL_VECTOR=y
+# CONFIG_VM86 is not set
+CONFIG_X86_16BIT=y
+CONFIG_X86_ESPFIX64=y
+CONFIG_X86_VSYSCALL_EMULATION=y
+# CONFIG_I8K is not set
+CONFIG_MICROCODE=y
+CONFIG_MICROCODE_INTEL=y
+CONFIG_MICROCODE_AMD=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+# CONFIG_X86_MSR is not set
+# CONFIG_X86_CPUID is not set
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_X86_DIRECT_GBPAGES=y
+CONFIG_NUMA=y
+CONFIG_AMD_NUMA=y
+CONFIG_X86_64_ACPI_NUMA=y
+CONFIG_NODES_SPAN_OTHER_NODES=y
+CONFIG_NUMA_EMU=y
+CONFIG_NODES_SHIFT=6
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_ARCH_DISCARD_MEMBLOCK=y
+CONFIG_MEMORY_ISOLATION=y
+# CONFIG_MOVABLE_NODE is not set
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+# CONFIG_MEMORY_HOTPLUG is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK=y
+CONFIG_MEMORY_BALLOON=y
+# CONFIG_COMPACTION is not set
+# CONFIG_MIGRATION is not set
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_MMU_NOTIFIER=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_MEMORY_FAILURE=y
+# CONFIG_HWPOISON_INJECT is not set
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CMA is not set
+CONFIG_MEM_SOFT_DIRTY=y
+# CONFIG_ZPOOL is not set
+CONFIG_ZBUD=y
+CONFIG_ZSMALLOC=y
+# CONFIG_PGTABLE_MAPPING is not set
+# CONFIG_ZSMALLOC_STAT is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+CONFIG_ARCH_SUPPORTS_DEFERRED_STRUCT_PAGE_INIT=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_X86_PMEM_LEGACY is not set
+# CONFIG_X86_CHECK_BIOS_CORRUPTION is not set
+CONFIG_X86_RESERVE_LOW=64
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_ARCH_RANDOM=y
+CONFIG_X86_SMAP=y
+# CONFIG_X86_INTEL_MPX is not set
+CONFIG_EFI=y
+CONFIG_EFI_STUB=y
+CONFIG_EFI_MIXED=y
+CONFIG_SECCOMP=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+# CONFIG_RANDOMIZE_BASE is not set
+CONFIG_PHYSICAL_ALIGN=0x200000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_BOOTPARAM_HOTPLUG_CPU0 is not set
+# CONFIG_DEBUG_HOTPLUG_CPU0 is not set
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_LEGACY_VSYSCALL_NATIVE is not set
+CONFIG_LEGACY_VSYSCALL_EMULATE=y
+# CONFIG_LEGACY_VSYSCALL_NONE is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MODIFY_LDT_SYSCALL=y
+CONFIG_HAVE_LIVEPATCH=y
+# CONFIG_LIVEPATCH is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_USE_PERCPU_NUMA_NODE_ID=y
+
+#
+# Power management and ACPI options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+CONFIG_HIBERNATE_CALLBACKS=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+# CONFIG_PM_TEST_SUSPEND is not set
+CONFIG_PM_SLEEP_DEBUG=y
+# CONFIG_DPM_WATCHDOG is not set
+# CONFIG_PM_TRACE_RTC is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_LEGACY_TABLES_LOOKUP=y
+CONFIG_ARCH_MIGHT_HAVE_ACPI_PDC=y
+CONFIG_ACPI_SYSTEM_POWER_STATES_SUPPORT=y
+# CONFIG_ACPI_DEBUGGER is not set
+CONFIG_ACPI_SLEEP=y
+# CONFIG_ACPI_PROCFS_POWER is not set
+CONFIG_ACPI_REV_OVERRIDE_POSSIBLE=y
+# CONFIG_ACPI_EC_DEBUGFS is not set
+# CONFIG_ACPI_AC is not set
+# CONFIG_ACPI_BATTERY is not set
+CONFIG_ACPI_BUTTON=m
+# CONFIG_ACPI_FAN is not set
+CONFIG_ACPI_DOCK=y
+CONFIG_ACPI_CPU_FREQ_PSS=y
+CONFIG_ACPI_PROCESSOR_IDLE=y
+CONFIG_ACPI_PROCESSOR=m
+# CONFIG_ACPI_IPMI is not set
+CONFIG_ACPI_HOTPLUG_CPU=y
+CONFIG_ACPI_PROCESSOR_AGGREGATOR=m
+# CONFIG_ACPI_THERMAL is not set
+CONFIG_ACPI_NUMA=y
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+CONFIG_ACPI_INITRD_TABLE_OVERRIDE=y
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_PCI_SLOT=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_ACPI_HOTPLUG_IOAPIC=y
+# CONFIG_ACPI_SBS is not set
+CONFIG_ACPI_HED=y
+# CONFIG_ACPI_CUSTOM_METHOD is not set
+CONFIG_ACPI_BGRT=y
+# CONFIG_ACPI_REDUCED_HARDWARE_ONLY is not set
+# CONFIG_ACPI_NFIT is not set
+CONFIG_HAVE_ACPI_APEI=y
+CONFIG_HAVE_ACPI_APEI_NMI=y
+CONFIG_ACPI_APEI=y
+CONFIG_ACPI_APEI_GHES=y
+CONFIG_ACPI_APEI_PCIEAER=y
+CONFIG_ACPI_APEI_MEMORY_FAILURE=y
+# CONFIG_ACPI_APEI_EINJ is not set
+# CONFIG_ACPI_APEI_ERST_DEBUG is not set
+CONFIG_ACPI_EXTLOG=y
+# CONFIG_PMIC_OPREGION is not set
+CONFIG_SFI=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+# CONFIG_CPU_FREQ_STAT is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# CPU frequency scaling drivers
+#
+CONFIG_X86_INTEL_PSTATE=y
+# CONFIG_X86_PCC_CPUFREQ is not set
+# CONFIG_X86_ACPI_CPUFREQ is not set
+# CONFIG_X86_SPEEDSTEP_CENTRINO is not set
+# CONFIG_X86_P4_CLOCKMOD is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+CONFIG_INTEL_IDLE=y
+
+#
+# Memory power savings
+#
+# CONFIG_I7300_IDLE is not set
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCI_XEN=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_HOTPLUG_PCI_PCIE=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIEAER_INJECT is not set
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PME=y
+CONFIG_PCI_BUS_ADDR_T_64BIT=y
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+# CONFIG_PCI_DEBUG is not set
+CONFIG_PCI_REALLOC_ENABLE_AUTO=y
+# CONFIG_PCI_STUB is not set
+# CONFIG_XEN_PCIDEV_FRONTEND is not set
+CONFIG_HT_IRQ=y
+CONFIG_PCI_ATS=y
+CONFIG_PCI_IOV=y
+CONFIG_PCI_PRI=y
+CONFIG_PCI_PASID=y
+CONFIG_PCI_LABEL=y
+
+#
+# PCI host controller drivers
+#
+CONFIG_ISA_DMA_API=y
+CONFIG_AMD_NB=y
+# CONFIG_PCCARD is not set
+CONFIG_HOTPLUG_PCI=y
+CONFIG_HOTPLUG_PCI_ACPI=y
+# CONFIG_HOTPLUG_PCI_ACPI_IBM is not set
+CONFIG_HOTPLUG_PCI_CPCI=y
+# CONFIG_HOTPLUG_PCI_CPCI_ZT5550 is not set
+# CONFIG_HOTPLUG_PCI_CPCI_GENERIC is not set
+CONFIG_HOTPLUG_PCI_SHPC=m
+# CONFIG_RAPIDIO is not set
+# CONFIG_X86_SYSFB is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=m
+CONFIG_COREDUMP=y
+CONFIG_IA32_EMULATION=y
+CONFIG_IA32_AOUT=y
+CONFIG_X86_X32=y
+CONFIG_COMPAT=y
+CONFIG_COMPAT_FOR_U64_ALIGNMENT=y
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_X86_DEV_DMA_OPS=y
+CONFIG_PMC_ATOM=y
+CONFIG_NET=y
+CONFIG_NET_INGRESS=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+CONFIG_XFRM_SUB_POLICY=y
+CONFIG_XFRM_MIGRATE=y
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_TRIE_STATS=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_NET_IP_TUNNEL is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_SYN_COOKIES=y
+# CONFIG_NET_UDP_TUNNEL is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_UDP_DIAG=y
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+# CONFIG_TCP_CONG_DCTCP is not set
+# CONFIG_TCP_CONG_CDG is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+CONFIG_IPV6_MIP6=y
+# CONFIG_IPV6_ILA is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_BEET is not set
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+# CONFIG_IPV6_SIT is not set
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_GRE is not set
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IPV6_PIMSM_V2=y
+# CONFIG_NETLABEL is not set
+CONFIG_NETWORK_SECMARK=y
+CONFIG_NET_PTP_CLASSIFY=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+# CONFIG_BRIDGE_NETFILTER is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_INGRESS=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NF_CONNTRACK is not set
+# CONFIG_NF_TABLES is not set
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+# CONFIG_NETFILTER_XT_TARGET_LOG is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_SECMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_BPF is not set
+# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ECN is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HL is not set
+# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
+# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
+# CONFIG_NETFILTER_XT_MATCH_L2TP is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+# CONFIG_NETFILTER_XT_MATCH_LIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+# CONFIG_NF_DUP_IPV4 is not set
+# CONFIG_NF_LOG_ARP is not set
+# CONFIG_NF_LOG_IPV4 is not set
+# CONFIG_NF_REJECT_IPV4 is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV6 is not set
+# CONFIG_NF_DUP_IPV6 is not set
+# CONFIG_NF_REJECT_IPV6 is not set
+# CONFIG_NF_LOG_IPV6 is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+CONFIG_STP=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+# CONFIG_NET_SCH_FQ is not set
+# CONFIG_NET_SCH_HHF is not set
+# CONFIG_NET_SCH_PIE is not set
+# CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_PLUG is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+# CONFIG_NET_CLS_BPF is not set
+# CONFIG_NET_CLS_FLOWER is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+# CONFIG_NET_EMATCH_U32 is not set
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_ACT_VLAN is not set
+# CONFIG_NET_ACT_BPF is not set
+CONFIG_NET_SCH_FIFO=y
+CONFIG_DCB=y
+CONFIG_DNS_RESOLVER=m
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+CONFIG_NETLINK_DIAG=y
+CONFIG_MPLS=y
+CONFIG_NET_MPLS_GSO=y
+# CONFIG_MPLS_ROUTING is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_CGROUP_NET_CLASSID=y
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+CONFIG_BPF_JIT=y
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+# CONFIG_NET_9P_RDMA is not set
+# CONFIG_NET_9P_DEBUG is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_LWTUNNEL is not set
+# CONFIG_DST_CACHE is not set
+CONFIG_HAVE_BPF_JIT=y
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_GENERIC_CPU_VULNERABILITIES=y
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_FENCE_TRACE is not set
+
+#
+# Bus devices
+#
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_OF is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG_MESSAGES is not set
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_ZRAM is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_SKD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_XEN_BLKDEV_FRONTEND is not set
+CONFIG_VIRTIO_BLK=y
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+# CONFIG_BLK_DEV_NVME is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_INTEL_MEI=m
+CONFIG_INTEL_MEI_ME=m
+# CONFIG_INTEL_MEI_TXE is not set
+# CONFIG_VMWARE_VMCI is not set
+
+#
+# Intel MIC Bus Driver
+#
+# CONFIG_INTEL_MIC_BUS is not set
+
+#
+# SCIF Bus Driver
+#
+# CONFIG_SCIF_BUS is not set
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+# CONFIG_GENWQE is not set
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_KERNEL_API is not set
+# CONFIG_CXL_EEH is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=m
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=m
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_MQ_DEFAULT is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_SCSI_ESAS2R is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT3SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_VMWARE_PVSCSI is not set
+# CONFIG_XEN_SCSI_FRONTEND is not set
+# CONFIG_SCSI_SNIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_ISCI is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_WD719X is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_VIRTIO is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=m
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_ZPODD=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI=m
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+# CONFIG_ATA_SFF is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_BCACHE is not set
+# CONFIG_BLK_DEV_DM is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+# CONFIG_IFB is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+CONFIG_TUN=y
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_VETH is not set
+CONFIG_VIRTIO_NET=y
+# CONFIG_NLMON is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+# CONFIG_VHOST_NET is not set
+# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+CONFIG_ETHERNET=y
+CONFIG_MDIO=m
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_CX_ECAT is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_HP is not set
+CONFIG_NET_VENDOR_INTEL=y
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IXGB is not set
+CONFIG_IXGBE=m
+CONFIG_IXGBE_HWMON=y
+CONFIG_IXGBE_DCA=y
+CONFIG_IXGBE_DCB=y
+# CONFIG_IXGBEVF is not set
+# CONFIG_I40E is not set
+# CONFIG_I40EVF is not set
+# CONFIG_FM10K is not set
+CONFIG_NET_VENDOR_I825XX=y
+# CONFIG_JME is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+CONFIG_MLX5_CORE=m
+CONFIG_MLX5_CORE_EN=y
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_SFC is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_NET_SB1000 is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Host-side USB support is needed for USB Network Adapter support
+#
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_XEN_NETDEV_FRONTEND is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_FUJITSU_ES is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
+CONFIG_SERIO_I8042=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVMEM is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DMA=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_RSA=y
+# CONFIG_SERIAL_8250_FSL is not set
+# CONFIG_SERIAL_8250_DW is not set
+# CONFIG_SERIAL_8250_RT288X is not set
+# CONFIG_SERIAL_8250_FINTEK is not set
+# CONFIG_SERIAL_8250_MID is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_TTY_PRINTK is not set
+CONFIG_HVC_DRIVER=y
+# CONFIG_HVC_XEN is not set
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_IPMI_HANDLER=m
+# CONFIG_IPMI_PANIC_EVENT is not set
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+# CONFIG_IPMI_SI_PROBE_DEFAULTS is not set
+# CONFIG_IPMI_SSIF is not set
+CONFIG_IPMI_WATCHDOG=m
+CONFIG_IPMI_POWEROFF=m
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_VIA=y
+CONFIG_HW_RANDOM_VIRTIO=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_MWAVE is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_HPET=y
+CONFIG_HPET_MMAP=y
+CONFIG_HPET_MMAP_DEFAULT=y
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_MUX=m
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=m
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+CONFIG_I2C_I801=m
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_ISMT is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# ACPI drivers
+#
+# CONFIG_I2C_SCMI is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+# CONFIG_NTP_PPS is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=m
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_CHERRYVIEW is not set
+# CONFIG_PINCTRL_BROXTON is not set
+# CONFIG_PINCTRL_SUNRISEPOINT is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_APPLESMC is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_DELL_SMM is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_G762 is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_IBMAEM is not set
+# CONFIG_SENSORS_IBMPEX is not set
+# CONFIG_SENSORS_I5500 is not set
+CONFIG_SENSORS_CORETEMP=m
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_POWR1220 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LTC2945 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4222 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4260 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MAX31790 is not set
+# CONFIG_SENSORS_HTU21 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_NCT6683 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_NCT7802 is not set
+# CONFIG_SENSORS_NCT7904 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SHTC1 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_ADC128D818 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_TC74 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP103 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+
+#
+# ACPI drivers
+#
+CONFIG_SENSORS_ACPI_POWER=m
+# CONFIG_SENSORS_ATK0110 is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_THERMAL_GOV_BANG_BANG=y
+CONFIG_THERMAL_GOV_USER_SPACE=y
+# CONFIG_THERMAL_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_EMULATION is not set
+CONFIG_INTEL_POWERCLAMP=m
+CONFIG_X86_PKG_TEMP_THERMAL=m
+# CONFIG_INTEL_SOC_DTS_THERMAL is not set
+# CONFIG_INT340X_THERMAL is not set
+# CONFIG_INTEL_PCH_THERMAL is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_ACQUIRE_WDT is not set
+# CONFIG_ADVANTECH_WDT is not set
+# CONFIG_ALIM1535_WDT is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_F71808E_WDT is not set
+# CONFIG_SP5100_TCO is not set
+# CONFIG_SBC_FITPC2_WATCHDOG is not set
+# CONFIG_EUROTECH_WDT is not set
+# CONFIG_IB700_WDT is not set
+# CONFIG_IBMASR is not set
+# CONFIG_WAFER_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_IE6XX_WDT is not set
+CONFIG_ITCO_WDT=m
+CONFIG_ITCO_VENDOR_SUPPORT=y
+# CONFIG_IT8712F_WDT is not set
+# CONFIG_IT87_WDT is not set
+# CONFIG_HP_WATCHDOG is not set
+# CONFIG_SC1200_WDT is not set
+# CONFIG_PC87413_WDT is not set
+# CONFIG_NV_TCO is not set
+# CONFIG_60XX_WDT is not set
+# CONFIG_CPU5_WDT is not set
+# CONFIG_SMSC_SCH311X_WDT is not set
+# CONFIG_SMSC37B787_WDT is not set
+# CONFIG_VIA_WDT is not set
+# CONFIG_W83627HF_WDT is not set
+# CONFIG_W83877F_WDT is not set
+# CONFIG_W83977F_WDT is not set
+# CONFIG_MACHZ_WDT is not set
+# CONFIG_SBC_EPX_C3_WATCHDOG is not set
+# CONFIG_BCM7038_WDT is not set
+# CONFIG_XEN_WDT is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=m
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_INTEL_QUARK_I2C_GPIO is not set
+CONFIG_LPC_ICH=m
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_INTEL_LPSS_ACPI is not set
+# CONFIG_MFD_INTEL_LPSS_PCI is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RTSX_USB is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_AGP is not set
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_VGA_SWITCHEROO=y
+CONFIG_DRM=m
+CONFIG_DRM_KMS_HELPER=m
+CONFIG_DRM_KMS_FB_HELPER=y
+CONFIG_DRM_FBDEV_EMULATION=y
+CONFIG_DRM_LOAD_EDID_FIRMWARE=y
+
+#
+# I2C encoder or helper chips
+#
+# CONFIG_DRM_I2C_ADV7511 is not set
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I2C_NXP_TDA998X is not set
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_AMDGPU is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_I915 is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_DRM_VGEM is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_GMA500 is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_MGAG200 is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_QXL is not set
+# CONFIG_DRM_BOCHS is not set
+# CONFIG_DRM_VIRTIO_GPU is not set
+CONFIG_DRM_BRIDGE=y
+
+#
+# Display Interface Bridges
+#
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+CONFIG_FB_CMDLINE=y
+# CONFIG_FB_DDC is not set
+CONFIG_FB_BOOT_VESA_SUPPORT=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_VGA16 is not set
+CONFIG_FB_VESA=y
+CONFIG_FB_EFI=y
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_XEN_FBDEV_FRONTEND=y
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SM712 is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+CONFIG_HDMI=y
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=25
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=m
+# CONFIG_HID_BATTERY_STRENGTH is not set
+CONFIG_HIDRAW=y
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=m
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=m
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=m
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=m
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=m
+CONFIG_USB_XHCI_PCI=m
+# CONFIG_USB_XHCI_PLATFORM is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_PCI=m
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+# CONFIG_USB_STORAGE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+# CONFIG_USB_CHAOSKEY is not set
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_USB_PHY is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_INFINIBAND=m
+CONFIG_INFINIBAND_USER_MAD=m
+CONFIG_INFINIBAND_USER_ACCESS=m
+CONFIG_INFINIBAND_USER_MEM=y
+CONFIG_INFINIBAND_ON_DEMAND_PAGING=y
+CONFIG_INFINIBAND_ADDR_TRANS=y
+# CONFIG_INFINIBAND_MTHCA is not set
+# CONFIG_INFINIBAND_QIB is not set
+# CONFIG_MLX4_INFINIBAND is not set
+CONFIG_MLX5_INFINIBAND=m
+# CONFIG_INFINIBAND_NES is not set
+# CONFIG_INFINIBAND_OCRDMA is not set
+# CONFIG_INFINIBAND_USNIC is not set
+CONFIG_INFINIBAND_IPOIB=m
+CONFIG_INFINIBAND_IPOIB_CM=y
+# CONFIG_INFINIBAND_IPOIB_DEBUG is not set
+# CONFIG_INFINIBAND_SRP is not set
+# CONFIG_INFINIBAND_ISER is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_EDAC=y
+CONFIG_EDAC_LEGACY_SYSFS=y
+# CONFIG_EDAC_DEBUG is not set
+# CONFIG_EDAC_DECODE_MCE is not set
+CONFIG_EDAC_MM_EDAC=m
+# CONFIG_EDAC_E752X is not set
+# CONFIG_EDAC_I82975X is not set
+# CONFIG_EDAC_I3000 is not set
+# CONFIG_EDAC_I3200 is not set
+# CONFIG_EDAC_IE31200 is not set
+# CONFIG_EDAC_X38 is not set
+# CONFIG_EDAC_I5400 is not set
+# CONFIG_EDAC_I7CORE is not set
+# CONFIG_EDAC_I5000 is not set
+# CONFIG_EDAC_I5100 is not set
+# CONFIG_EDAC_I7300 is not set
+CONFIG_EDAC_SBRIDGE=m
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12057 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_ACPI=y
+# CONFIG_INTEL_IDMA64 is not set
+CONFIG_INTEL_IOATDMA=m
+# CONFIG_DW_DMAC is not set
+# CONFIG_DW_DMAC_PCI is not set
+
+#
+# DMA Clients
+#
+CONFIG_ASYNC_TX_DMA=y
+# CONFIG_DMATEST is not set
+CONFIG_DMA_ENGINE_RAID=y
+CONFIG_DCA=m
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VFIO is not set
+CONFIG_IRQ_BYPASS_MANAGER=y
+CONFIG_VIRT_DRIVERS=y
+CONFIG_VIRTIO=y
+
+#
+# Virtio drivers
+#
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO_PCI_LEGACY=y
+CONFIG_VIRTIO_BALLOON=y
+# CONFIG_VIRTIO_INPUT is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_HYPERV is not set
+
+#
+# Xen driver support
+#
+# CONFIG_XEN_BALLOON is not set
+# CONFIG_XEN_DEV_EVTCHN is not set
+# CONFIG_XEN_BACKEND is not set
+# CONFIG_XENFS is not set
+# CONFIG_XEN_SYS_HYPERVISOR is not set
+CONFIG_XEN_XENBUS_FRONTEND=y
+# CONFIG_XEN_GNTDEV is not set
+# CONFIG_XEN_GRANT_DEV_ALLOC is not set
+CONFIG_SWIOTLB_XEN=y
+CONFIG_XEN_PRIVCMD=m
+# CONFIG_XEN_ACPI_PROCESSOR is not set
+# CONFIG_XEN_MCE_LOG is not set
+CONFIG_XEN_HAVE_PVMMU=y
+CONFIG_XEN_EFI=y
+CONFIG_XEN_AUTO_XLATE=y
+CONFIG_XEN_ACPI=y
+CONFIG_XEN_HAVE_VPMU=y
+# CONFIG_STAGING is not set
+CONFIG_X86_PLATFORM_DEVICES=y
+# CONFIG_ACERHDF is not set
+# CONFIG_DELL_WMI is not set
+# CONFIG_DELL_WMI_AIO is not set
+# CONFIG_DELL_SMO8800 is not set
+# CONFIG_FUJITSU_TABLET is not set
+# CONFIG_HP_ACCEL is not set
+# CONFIG_HP_WIRELESS is not set
+# CONFIG_HP_WMI is not set
+# CONFIG_SENSORS_HDAPS is not set
+CONFIG_ACPI_WMI=m
+# CONFIG_TOPSTAR_LAPTOP is not set
+# CONFIG_TOSHIBA_BT_RFKILL is not set
+# CONFIG_TOSHIBA_HAPS is not set
+# CONFIG_TOSHIBA_WMI is not set
+# CONFIG_ACPI_CMPC is not set
+# CONFIG_INTEL_IPS is not set
+# CONFIG_IBM_RTL is not set
+CONFIG_MXM_WMI=m
+# CONFIG_SAMSUNG_Q10 is not set
+# CONFIG_INTEL_RST is not set
+# CONFIG_INTEL_SMARTCONNECT is not set
+# CONFIG_PVPANIC is not set
+# CONFIG_INTEL_PMC_IPC is not set
+# CONFIG_SURFACE_PRO3_BUTTON is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_PXA is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKEVT_I8253=y
+CONFIG_I8253_LOCK=y
+CONFIG_CLKBLD_I8253=y
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_API=y
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Generic IOMMU Pagetable Support
+#
+CONFIG_IOMMU_IOVA=y
+CONFIG_AMD_IOMMU=y
+# CONFIG_AMD_IOMMU_STATS is not set
+CONFIG_AMD_IOMMU_V2=y
+CONFIG_DMAR_TABLE=y
+CONFIG_INTEL_IOMMU=y
+# CONFIG_INTEL_IOMMU_SVM is not set
+# CONFIG_INTEL_IOMMU_DEFAULT_ON is not set
+CONFIG_INTEL_IOMMU_FLOPPY_WA=y
+CONFIG_IRQ_REMAP=y
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+CONFIG_PM_DEVFREQ=y
+
+#
+# DEVFREQ Governors
+#
+# CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND is not set
+# CONFIG_DEVFREQ_GOV_PERFORMANCE is not set
+# CONFIG_DEVFREQ_GOV_POWERSAVE is not set
+# CONFIG_DEVFREQ_GOV_USERSPACE is not set
+
+#
+# DEVFREQ Drivers
+#
+# CONFIG_PM_DEVFREQ_EVENT is not set
+# CONFIG_EXTCON is not set
+CONFIG_MEMORY=y
+# CONFIG_IIO is not set
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_PWM is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+CONFIG_POWERCAP=y
+CONFIG_INTEL_RAPL=m
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_RAS=y
+# CONFIG_THUNDERBOLT is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_STM_DUMMY is not set
+# CONFIG_STM_SOURCE_CONSOLE is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+CONFIG_FIRMWARE_MEMMAP=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+CONFIG_DMI_SYSFS=y
+CONFIG_DMI_SCAN_MACHINE_NON_EFI_FALLBACK=y
+# CONFIG_ISCSI_IBFT_FIND is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# EFI (Extensible Firmware Interface) Support
+#
+# CONFIG_EFI_VARS is not set
+CONFIG_EFI_ESRT=y
+CONFIG_EFI_RUNTIME_MAP=y
+# CONFIG_EFI_FAKE_MEMMAP is not set
+CONFIG_EFI_RUNTIME_WRAPPERS=y
+CONFIG_UEFI_CPER=y
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_ENCRYPTION is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_FS_DAX is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+# CONFIG_FANOTIFY_ACCESS_PERMISSIONS is not set
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+CONFIG_PRINT_QUOTA_WARNING=y
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTACTL=y
+CONFIG_QUOTACTL_COMPAT=y
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_PROC_CHILDREN=y
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_EFIVAR_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_PSTORE=y
+# CONFIG_PSTORE_CONSOLE is not set
+# CONFIG_PSTORE_PMSG is not set
+# CONFIG_PSTORE_FTRACE is not set
+# CONFIG_PSTORE_RAM is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+# CONFIG_NFS_V2 is not set
+# CONFIG_NFS_V3 is not set
+CONFIG_NFS_V4=m
+CONFIG_NFS_SWAP=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_PNFS_FILE_LAYOUT=m
+CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN="kernel.org"
+# CONFIG_NFS_V4_1_MIGRATION is not set
+CONFIG_NFS_V4_SECURITY_LABEL=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_NFS_DEBUG=y
+# CONFIG_NFSD is not set
+CONFIG_GRACE_PERIOD=m
+CONFIG_LOCKD=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+CONFIG_SUNRPC_GSS=m
+CONFIG_SUNRPC_BACKCHANNEL=y
+CONFIG_SUNRPC_SWAP=y
+CONFIG_SUNRPC_DEBUG=y
+# CONFIG_SUNRPC_XPRT_RDMA is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_9P_FS=y
+# CONFIG_9P_FS_POSIX_ACL is not set
+# CONFIG_9P_FS_SECURITY is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_INFO_SPLIT is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+# CONFIG_GDB_SCRIPTS is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=8192
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_READABLE_ASM is not set
+CONFIG_UNUSED_SYMBOLS=y
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x01b6
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+CONFIG_HAVE_ARCH_KASAN=y
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_HARDLOCKUP_DETECTOR=y
+# CONFIG_BOOTPARAM_HARDLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE=0
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=60
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHED_INFO=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+CONFIG_TIMER_STATS=y
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+CONFIG_DEBUG_RT_MUTEXES=y
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_MUTEXES=y
+CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y
+CONFIG_DEBUG_LOCK_ALLOC=y
+CONFIG_PROVE_LOCKING=y
+CONFIG_LOCKDEP=y
+CONFIG_LOCK_STAT=y
+CONFIG_DEBUG_LOCKDEP=y
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+CONFIG_TRACE_IRQFLAGS=y
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+CONFIG_PROVE_RCU=y
+# CONFIG_PROVE_RCU_REPEATEDLY is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS=y
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_FENTRY=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACER_MAX_TRACE=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_TRACER_SNAPSHOT=y
+# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+CONFIG_STACK_TRACER=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_KPROBE_EVENT=y
+CONFIG_UPROBE_EVENT=y
+CONFIG_PROBE_EVENTS=y
+CONFIG_DYNAMIC_FTRACE=y
+CONFIG_DYNAMIC_FTRACE_WITH_REGS=y
+# CONFIG_FUNCTION_PROFILER is not set
+CONFIG_FTRACE_MCOUNT_RECORD=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+# CONFIG_MMIOTRACE is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_TRACE_ENUM_MAP_FILE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_UDELAY is not set
+CONFIG_MEMTEST=y
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+CONFIG_EARLY_PRINTK_EFI=y
+# CONFIG_X86_PTDUMP_CORE is not set
+# CONFIG_X86_PTDUMP is not set
+# CONFIG_EFI_PGT_DUMP is not set
+CONFIG_DEBUG_RODATA=y
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_WX is not set
+CONFIG_DEBUG_SET_MODULE_RONX=y
+# CONFIG_DEBUG_NX_TEST is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_DEBUG_TLBFLUSH is not set
+# CONFIG_IOMMU_DEBUG is not set
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+# CONFIG_X86_DECODER_SELFTEST is not set
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_IO_DELAY_0X80=y
+# CONFIG_IO_DELAY_0XED is not set
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+# CONFIG_DEBUG_BOOT_PARAMS is not set
+# CONFIG_CPA_DEBUG is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_ENTRY is not set
+# CONFIG_DEBUG_NMI_SELFTEST is not set
+# CONFIG_X86_DEBUG_STATIC_CPU_HAS is not set
+CONFIG_X86_DEBUG_FPU=y
+# CONFIG_PUNIT_ATOM_DEBUG is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_COMPAT=y
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+CONFIG_PAGE_TABLE_ISOLATION=y
+CONFIG_SECURITYFS=y
+# CONFIG_SECURITY_NETWORK is not set
+# CONFIG_SECURITY_PATH is not set
+# CONFIG_INTEL_TXT is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_APPARMOR is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_INTEGRITY is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+# CONFIG_CRYPTO_RSA is not set
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRC32_PCLMUL is not set
+CONFIG_CRYPTO_CRCT10DIF=y
+# CONFIG_CRYPTO_CRCT10DIF_PCLMUL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_POLY1305_X86_64 is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA1_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256_SSSE3 is not set
+# CONFIG_CRYPTO_SHA512_SSSE3 is not set
+# CONFIG_CRYPTO_SHA1_MB is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_X86_64 is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_BLOWFISH_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAMELLIA_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST5_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_CAST6_AVX_X86_64 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_DES3_EDE_X86_64 is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_X86_64 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_CHACHA20_X86_64 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SERPENT_SSE2_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64 is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64_3WAY is not set
+# CONFIG_CRYPTO_TWOFISH_AVX_X86_64 is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_DRBG_MENU is not set
+# CONFIG_CRYPTO_JITTERENTROPY is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
+CONFIG_HAVE_KVM=y
+CONFIG_HAVE_KVM_IRQCHIP=y
+CONFIG_HAVE_KVM_IRQFD=y
+CONFIG_HAVE_KVM_IRQ_ROUTING=y
+CONFIG_HAVE_KVM_EVENTFD=y
+CONFIG_KVM_APIC_ARCHITECTURE=y
+CONFIG_KVM_MMIO=y
+CONFIG_KVM_ASYNC_PF=y
+CONFIG_HAVE_KVM_MSI=y
+CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT=y
+CONFIG_KVM_VFIO=y
+CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT=y
+CONFIG_KVM_COMPAT=y
+CONFIG_HAVE_KVM_IRQ_BYPASS=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_KVM_INTEL=m
+# CONFIG_KVM_AMD is not set
+# CONFIG_KVM_MMU_AUDIT is not set
+# CONFIG_KVM_DEVICE_ASSIGNMENT is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_ARCH_HAS_FAST_MULTIPLIER=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_CHECK_SIGNATURE=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_OID_REGISTRY=m
+CONFIG_UCS2_STRING=y
+CONFIG_FONT_SUPPORT=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_SG_SPLIT is not set
+CONFIG_ARCH_HAS_SG_CHAIN=y
+CONFIG_ARCH_HAS_PMEM_API=y
+CONFIG_ARCH_HAS_MMIO_FLUSH=y
diff --git a/kernel/popcorn/hype_file.c b/kernel/popcorn/hype_file.c
new file mode 100644
index 000000000000..f0a77c5eb85d
--- /dev/null
+++ b/kernel/popcorn/hype_file.c
@@ -0,0 +1,344 @@
+/*
+ * hype_file.c
+ * Copyright (C) 2019 Ho-Ren (Jack) Chuang <horenc@vt.edu>
+ *
+ * Distributed under terms of the MIT license.
+ */
+
+#include <popcorn/hype_file.h>
+
+
+
+/******************************************************************************
+ * File operations -
+ * 		origin: origin has opened
+ * 		remote: skipped open
+ */
+int popcorn_open(const char __user *filename, int flags, umode_t mode, int fd)
+{
+	if (!current->at_remote) { // origin - broadcast
+		printk("TODO: implement\n");
+		//BUG();
+	} else { // remote - delegation and reply
+		remote_open_request_t *req = kmalloc(sizeof(*req), GFP_KERNEL);
+		struct wait_station *ws = get_wait_station(current);
+		remote_open_response_t *res;
+		struct remote_context *rc = current->mm->remote;
+		int dfd = AT_FDCWD;
+		int tmp_fd = -999;
+		BUG_ON(!rc);
+
+		// wait ws
+		BUG_ON(!req);
+		req->from_pid = current->pid;
+		req->origin_pid = rc->remote_tgids[0];
+		req->ws = ws->id;
+		req->flags = flags;
+		req->mode = mode;
+		fd = -1;
+		req->fd = fd;
+
+        if (copy_from_user(req->filename, filename, MAX_PCN_NAME_LEN) != 0)
+			BUG();
+
+		printk("[%d] #working# [[open]]- delegating to origin "
+							"\"%s\" flags %d mode %d req->fd %d\n",
+							current->pid, req->filename, flags, mode, req->fd);
+
+        pcn_kmsg_send(PCN_KMSG_TYPE_REMOTE_OPEN_REQUEST,
+									0, req, sizeof(*req));
+		res = wait_at_station(ws);
+		//BUG_ON(res->ret);
+		BUG_ON(res->fd < 0);
+
+
+		// mapping using
+		printk("[%d] #working# [[open]] - replaying and matching "
+				"origin replys res->fd [[%d]] with struct file* for "
+											"\"%s\" at remote\n",
+								current->pid, res->fd, req->filename);
+		// do open
+		// but use res->fd; to map with file_struct
+		tmp_fd = do_sys_open_tsk_req(current, dfd,
+							req->filename, flags, mode, res->fd);
+		printk("[%d] replay returns tmp_fd [[%d]]\n", current->pid, tmp_fd);
+
+		kfree(req);
+		pcn_kmsg_done(res);
+		return tmp_fd;
+	}
+	return 0;
+}
+
+
+/******************************************************************************
+ * MSG handlers -
+ * 		open
+ *
+ *
+ */
+// from remote
+static void process_remote_open_request(struct work_struct *work)
+{
+    START_KMSG_WORK(remote_open_request_t, req, work);
+    remote_open_response_t *res = pcn_kmsg_get(sizeof(*res));
+    int from_nid = PCN_KMSG_FROM_NID(req);
+    struct task_struct *tsk = __get_task_struct(req->origin_pid);
+//    struct mm_struct *mm;
+	int dfd = AT_FDCWD;
+	int flags = req->flags; //
+	int mode = req->mode; //
+	int fd = req->fd; //
+	char *filename = req->filename; //
+
+	printk("[from%d/origin%d]#working# [[open]] at origin \"%s\" "
+										"flags %d mode %d fd %d\n",
+			req->from_pid, req->origin_pid, filename, flags, mode, fd);
+
+	BUG_ON(!tsk && "No task exist");
+	BUG_ON(tsk->at_remote);
+
+	//printk("[from%d/origin%d]\n", req->from_pid, tsk->pid);
+
+	// do_sys_open()
+    res->fd = do_sys_open_tsk_req(tsk, dfd, filename, flags, mode, fd); // TODO still using lots ""current""
+
+    res->from_pid = req->from_pid;
+	res->ws = req->ws;
+    //res->ret = 0;
+
+	printk("#working# [[open]] at origin DONE fd %d \"%s\" ->\n",
+												res->fd, filename);
+    pcn_kmsg_post(PCN_KMSG_TYPE_REMOTE_OPEN_RESPONSE,
+							from_nid, res, sizeof(*res));
+    END_KMSG_WORK(req);
+}
+
+static int handle_remote_open_response(struct pcn_kmsg_message *msg)
+{
+    remote_open_response_t *res = (remote_open_response_t *)msg;
+    struct wait_station *ws = wait_station(res->ws);
+
+    ws->private = res;
+
+	complete(&ws->pendings);
+    return 0;
+}
+#if 0
+// just wakeup example, not passing res back to the wait_station()
+static int handle_remote_page_flush_ack(struct pcn_kmsg_message *msg)
+{
+    remote_page_flush_ack_t *req = (remote_page_flush_ack_t *)msg;
+    struct wait_station *ws = wait_station(req->remote_ws);
+
+    complete(&ws->pendings);
+
+    pcn_kmsg_done(req);
+    return 0;
+}
+#endif
+
+
+/******************************************************************************
+ * delegate read/write
+ *
+ * read: char *buf
+ * write: const char *buf
+ */
+ssize_t popcorn_delegate_rw(unsigned int fd, char *buf, size_t count, bool is_read)
+{
+	int msg_size;
+	ssize_t ret;
+	if (!current->at_remote) { // origin - broadcast
+		printk("TODO: implement\n");
+		BUG_ON("TODO: implement");
+	} else { // remote - delegation and reply
+		delegate_rw_response_t *res;
+		delegate_rw_request_t *req = kmalloc(sizeof(*req), GFP_KERNEL);
+		struct wait_station *ws = get_wait_station(current);
+		struct remote_context *rc = current->mm->remote;
+		//int dfd = AT_FDCWD;
+		//int tmp_fd = -999;
+		BUG_ON(!rc);
+
+		// wait ws
+		BUG_ON(!req);
+		req->from_pid = current->pid;
+		req->origin_pid = rc->remote_tgids[0];
+		req->ws = ws->id;
+		//req->flags = flags;
+		//req->mode = mode;
+
+		req->count = count;
+		req->fd = fd;
+		if (!is_read)
+			BUG_ON(copy_from_user(req->buf, buf, MAX_POPCONR_FILE_RW_SIZE));
+
+		printk("[%d] #working# [[rw]] - delegating to origin req-> "
+							//"buf \"%s\" "
+							"count %lu fd %d (%c)\n",
+							current->pid,
+							//req->buf,
+							req->count, req->fd,
+							is_read ? 'R' : 'W');
+
+		if (is_read)
+			msg_size = sizeof(*req) - (sizeof(char) * MAX_POPCONR_FILE_RW_SIZE);
+		else
+			msg_size = sizeof(*req); /* can optimize */
+
+        pcn_kmsg_send(PCN_KMSG_TYPE_DELEGATE_RW_REQUEST, 0, req, msg_size);
+		res = wait_at_station(ws);
+
+		printk("[%d] #working# [[rw]] - check ret "
+				"<*> -> ret [[%d]] for fd %d (%c)\n",
+							current->pid, res->ret, fd,
+									is_read ? 'R' : 'W');
+		if (is_read)
+			BUG_ON(copy_to_user(buf, res->buf, MAX_POPCONR_FILE_RW_SIZE));
+
+		BUG_ON(res->ret < 0);
+		ret = res->ret;
+
+		// mapping using
+//		printk("[%d] #working# [[open]] - replaying and matching "
+//				"origin replys res->fd [[%d]] with struct file* for "
+//											"\"%s\" at remote\n",
+//								current->pid, res->fd, req->filename);
+		// do open
+		// but use res->fd; to map with file_struct
+//		tmp_fd = do_sys_open_tsk_req(current, dfd,
+//							req->filename, flags, mode, res->fd);
+//		printk("[%d] replay returns tmp_fd [[%d]]\n", current->pid, tmp_fd);
+
+		kfree(req);
+		pcn_kmsg_done(res);
+		//return tmp_fd;
+	}
+	return ret;
+}
+
+/****
+ * handler
+ */
+static void process_delegate_rw_request(struct work_struct *work)
+{
+    START_KMSG_WORK(delegate_rw_request_t, req, work);
+    delegate_rw_response_t *res = pcn_kmsg_get(sizeof(*res));
+    int from_nid = PCN_KMSG_FROM_NID(req);
+    struct task_struct *tsk = __get_task_struct(req->origin_pid);
+	//int fd = req->fd; //
+	//char *buf = req->buf;
+	//ssize_t count = req->count;
+	int msg_size;
+
+	printk("\n\t=> [from%d/origin%d]#working# [[rw]] delating <*> "
+							//"buf \"%s\" "
+							"fd %d count %lu (%c)\n",
+							req->from_pid, req->origin_pid,
+							//req->buf,
+							req->fd, req->count, req->is_read ? 'R' : 'W');
+
+	BUG_ON(!tsk && "No task exist");
+	BUG_ON(tsk->at_remote); // delegate
+
+	//printk("[from%d/origin%d]\n", req->from_pid, tsk->pid);
+
+	// do_sys_open()
+	if (req->is_read)
+		res->ret = do_tsk_delegate_rw(tsk, req->fd, res->buf,
+									req->count, req->is_read);
+	else
+		res->ret = do_tsk_delegate_rw(tsk, req->fd, req->buf,
+									req->count, req->is_read);
+
+    res->from_pid = req->from_pid;
+	res->ws = req->ws;
+
+	printk("#working# [[%c]] <*> DONE fd %d \"%s\" %d =ACK>\n",
+								req->is_read ? 'R' : 'W',
+								req->fd,
+								req->is_read ? res->buf : req->buf,
+								res->ret);
+	if (req->is_read)
+		msg_size = sizeof(*res); /* can optimize */
+	else
+		msg_size = sizeof(*res) - (sizeof(char) * MAX_POPCONR_FILE_RW_SIZE);
+
+	pcn_kmsg_post(PCN_KMSG_TYPE_DELEGATE_RW_RESPONSE,
+								from_nid, res, msg_size);
+    END_KMSG_WORK(req);
+}
+
+
+static int handle_delegate_rw_response(struct pcn_kmsg_message *msg)
+{
+    delegate_rw_response_t *res = (delegate_rw_response_t *)msg;
+    struct wait_station *ws = wait_station(res->ws);
+
+    ws->private = res;
+
+	complete(&ws->pendings);
+    return 0;
+}
+
+
+/******************************************************************************
+ *
+ *
+ */
+DEFINE_KMSG_WQ_HANDLER(remote_open_request);
+DEFINE_KMSG_WQ_HANDLER(delegate_rw_request);
+int __init popcorn_hype_file_init(void)
+{
+	// open
+    REGISTER_KMSG_WQ_HANDLER(
+            PCN_KMSG_TYPE_REMOTE_OPEN_REQUEST, remote_open_request);
+    REGISTER_KMSG_HANDLER(
+            PCN_KMSG_TYPE_REMOTE_OPEN_RESPONSE, remote_open_response);
+
+	// rw
+    REGISTER_KMSG_WQ_HANDLER(
+            PCN_KMSG_TYPE_DELEGATE_RW_REQUEST, delegate_rw_request);
+    REGISTER_KMSG_HANDLER(
+            PCN_KMSG_TYPE_DELEGATE_RW_RESPONSE, delegate_rw_response);
+
+	return 0;
+}
+
+#if 0
+int vma_server_munmap_origin(unsigned long start, size_t len, int nid_except)
+{
+    int nid;
+    vma_op_request_t *req = __alloc_vma_op_request(VMA_OP_MUNMAP);
+    struct remote_context *rc = get_task_remote(current);
+
+    req->start = start;
+    req->len = len;
+
+    for (nid = 0; nid < MAX_POPCORN_NODES; nid++) {
+        struct wait_station *ws;
+        vma_op_response_t *res;
+
+        if (!get_popcorn_node_online(nid) || !rc->remote_tgids[nid]) continue;
+
+        if (nid == my_nid || nid == nid_except) continue;
+
+        ws = get_wait_station(current);
+        req->remote_ws = ws->id;
+        req->origin_pid = rc->remote_tgids[nid];
+
+        VSPRINTK("  [%d] ->munmap [%d/%d] %lx+%lx (%lx)\n", current->pid,
+                req->origin_pid, nid, start, len,
+                instruction_pointer(current_pt_regs()));
+        pcn_kmsg_send(PCN_KMSG_TYPE_VMA_OP_REQUEST, nid, req, sizeof(*req));
+        res = wait_at_station(ws);
+        pcn_kmsg_done(res);
+    }
+    put_task_remote(current);
+    kfree(req);
+
+    vm_munmap(start, len);
+    return 0;
+}
+#endif
diff --git a/kernel/popcorn/hype_kvm.c b/kernel/popcorn/hype_kvm.c
new file mode 100644
index 000000000000..494f57ff9268
--- /dev/null
+++ b/kernel/popcorn/hype_kvm.c
@@ -0,0 +1,4339 @@
+/**
+ * @file hype_kvm.c
+ *
+ *
+ * @author Ho-Ren (Jack) Chuang, SSRG Virginia Tech 2019
+ *
+ * Distributed under terms of the MIT license.
+ */
+#include <popcorn/hype_kvm.h>
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/mod_devicetable.h>
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/highmem.h>
+#include <linux/sched.h>
+#include <linux/trace_events.h>
+#include <linux/slab.h>
+
+#include <asm/perf_event.h>
+#include <asm/tlbflush.h>
+#include <asm/desc.h>
+#include <asm/debugreg.h>
+#include <asm/kvm_para.h>
+#include <asm/nospec-branch.h>
+
+#include <asm/virtext.h>
+
+#include <linux/kvm.h>
+#include <linux/kvm_para.h>
+#include <linux/kvm_host.h>
+
+#include <linux/kvm_types.h>
+
+#include <kvm/iodev.h>
+
+#include <linux/mm.h>
+#include <linux/tboot.h>
+#include <linux/hrtimer.h>
+#include <linux/nospec.h>
+
+#include <asm/kvm_host.h>
+#include <asm/cpu.h>
+#include <asm/io.h>
+#include <asm/desc.h>
+#include <asm/vmx.h>
+#include <asm/virtext.h>
+#include <asm/mce.h>
+#include <asm/fpu/internal.h>
+#include <asm/perf_event.h>
+#include <asm/debugreg.h>
+#include <asm/kexec.h>
+#include <asm/apic.h>
+#include <asm/irq_remapping.h>
+
+#include <linux/file.h>
+#include <linux/delay.h>
+
+#include "../arch/x86/kvm/lapic.h" // Jack arch
+#include "../arch/x86/kvm/x86.h" // Jack arch
+#include <linux/smpboot.h>
+
+#include <linux/syscalls.h>
+
+//#include <linux/skbuff.h> // vhost-net optimication
+
+#include <linux/netdevice.h> // pophype - net optimize
+#include <linux/virtio_net.h>
+
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+//static unsigned long all_cnt = 0;
+unsigned long all_cnt = 0;
+unsigned long *kvaddr;
+#define DEBUG_THRESHOLD_LOW 3500
+#define DEBUG_THRESHOLD_UP 4000
+#endif
+
+/* Maintain remote vCPU thread PIDs at origin
+			in order for broadcasting signals */
+//struct pophype_vcpu_info[MAX_POPCORN_VCPU] = {
+//	int node; // note == my_nid => at_remote
+//	int pid;
+//	struct kvm_vcpu *vcpu_at_origin;
+//}
+
+struct hype_node_info_t *hype_node_info[MAX_POPCORN_NODES][MAX_POPCORN_VCPU]; /* Attention: [MY_NID][FD] */ /* extern in ./include/popcorn/hype_kvm.h */
+
+extern int replay_kvm_dev_ioctl_create_vm_tsk(struct task_struct *tsk, unsigned long type);
+//struct popcorn_vcpu_info popcorn_vcpu_infos[MAX_POPCORN_VCPU];
+
+/* smp on/offline */
+bool my_hype_cpu[MAX_POPCORN_VCPU];
+
+/* smp testing points by dsm instead of printk */
+bool **hype_callin_dynamic_alloc;
+bool hype_callin[HYPE_DEBUG_POINT_MAX + 1][MAX_POPCORN_NODES]; /* since from 1 */
+//              { false, false, false, false, false, false, false };
+
+int g_popcorn_vcpu_cnt = 0;
+int first_fd_after_vcpufd = 0;
+/* if -a 1 -b 2 =>
+	-a 1: gvcpu_to_nid[0] = 0(node),
+	-b 2: gvcpu_to_nid[1]: 1(node) gvcpu_to_nid[2]: 1(node) */
+//int gvcpu_to_nid[MAX_POPCORN_VCPU];
+atomic64_t gvcpu_to_nid[MAX_POPCORN_VCPU] = ATOMIC64_INIT(0);
+//atomic64_read(&gvcpu_to_nid[vcpu_id]);
+//atomic64_set(&gvcpu_to_nid[vcpu_id], 0);
+
+/* pophype migration */
+static spinlock_t phmigrate;
+//spin_lock(&phmigrate);
+//spin_unlock(&phmigrate);
+
+
+/***
+ * Statistic
+ */
+unsigned long eventfd_delegate_cnt = 0;
+atomic64_t eventfd_delegated_cnt = ATOMIC64_INIT(0);
+
+/*******************************************************************************
+ * Utils
+ */
+/* ref: ./Documentation/x86/x86_64/mm.txt
+		./arch/x86/include/asm/pgtable_64_types.h */
+// ffffc90000022ee8
+bool is_valid_rbp (u64 next_rbp_gva) {
+	if (!next_rbp_gva || next_rbp_gva == (0UL - 1)
+		|| !((next_rbp_gva >= 0xffff880000000000 && next_rbp_gva <= 0xffffc7ffffffffff) /* O - direct mapping of all phys e.g. 0xffff880xxxxxxxxx = rsp */
+			|| (next_rbp_gva >= 0xffffffff80000000 && next_rbp_gva <= 0xffffffffa0000000) /* O - kernel text mapping, from phys 0 e.g. ffffffff81xxxxxx  = rip */
+			|| (next_rbp_gva >= 0xffffc90000000000 && next_rbp_gva <= 0xffffe8ffffffffff)) /* teseting - vmalloc/ioremap space  e.g. rsp = ffffc900000xxxxx */
+		) {
+		return false;
+	}
+	return true;
+}
+/* VM stack walk */
+void vm_stack_walk(struct kvm_regs *kvm_regs, dsm_traffic_t *_dsm_traffic, int fd) {
+	/*
+	 * VM addr translation refs: include/linux/kvm_host.h
+	 */
+	/* walk stack
+	 *	Ref: ./arch/x86/kernel/dumpstack.c
+	 *			print_context_stack()
+	 *			print_context_stack_bp()
+	 *  User: backtrace()
+	 *	More: grbp 0x0 -> grbp_hva 0x7ffac0000000 (base)
+	 *
+	 *	----------------| ...				|	H
+	 *	ebp + 8bytes -> | old eip (ret addr)|
+	 *	ebp + 0bytes -> | old ebp			| <----------
+	 *					| ...				|			|
+	 *			rsp ->	| ...				|			|
+	 *	----------------| ...				|			|
+	 *	ebp + 8bytes -> | old eip (ret addr)|			|
+	 *	ebp + 0bytes -> | old ebp-----------|------------ copy_from_usr()
+	 *					| ...				|	L
+	 * Push (H->L): add item + rsp--
+	 * Pop (L->H): remove item + rsp++
+	 *
+	 *
+	 * first rbp is on ffff88xxxxxxxxxx, then ffffffff81xxxxxx
+	 */
+	/* gva -> gpa - ref:  arch/x86/kvm/x86.c kvm_mmu_gva_to_gpa_system() */
+	int cnt = 0, i;
+	//int err_cnt = 0;
+	struct kvm_translation tr;
+	unsigned long *frame; /* stack frame page in host kvaddr */
+	//unsigned long *kvaddr, *frame; /* stack frame page in host kvaddr */
+	unsigned long gpa, gfn, ofs, grbp_hva;
+	unsigned long next_rbp_gva = kvm_regs->rbp;
+
+#if DEBUG_VMDSM_TRACE_SKIP_STACK
+	goto err_skip;
+#endif
+
+	all_cnt++;
+	if (((kvm_regs->rip >> PAGE_SHIFT) == 0xffffffff81198) // TODO USE FINCTION NAME
+		&& (all_cnt > DEBUG_THRESHOLD_LOW  && all_cnt < DEBUG_THRESHOLD_UP)) {
+		VM_DSM_COLLECT_PK("\t%lu %d: - 1 rip 0x%llx [rbp 0x%lx] "
+						"dbg (0x%llx ?= 0 0x%llx 0x%lx)\n",
+						all_cnt, cnt, kvm_regs->rip, next_rbp_gva,
+						(kvm_regs->rip >> PAGE_SHIFT ^ 0xffffffff81198),
+						kvm_regs->rip >> PAGE_SHIFT, 0xffffffff81198);
+	}
+
+	if (!is_valid_rbp(next_rbp_gva))
+		goto err;
+
+	/* guest pgt walk */
+	tr.linear_address = next_rbp_gva;
+	kvm_arch_vcpu_ioctl_translate(
+				hype_node_info[my_nid][fd]->vcpu, &tr);
+	gpa = tr.physical_address;
+
+	if (gpa == 0UL - 1)
+		goto __err;
+
+	if (((kvm_regs->rip >> PAGE_SHIFT) == 0xffffffff81198)
+		&& (all_cnt > DEBUG_THRESHOLD_LOW  && all_cnt < DEBUG_THRESHOLD_UP)) {
+		VM_DSM_COLLECT_PK("\t%lu %d: - 2 rip 0x%llx [rbp 0x%lx] gpa 0x%lx\n",
+							all_cnt, cnt, kvm_regs->rip, next_rbp_gva, gpa);
+	}
+	/* host - gpa -> gfn */
+	gfn = gpa >> PAGE_SHIFT;
+	ofs = gpa % PAGE_SIZE;
+	grbp_hva = kvm_vcpu_gfn_to_hva(
+				hype_node_info[my_nid][fd]->vcpu, gfn);
+	grbp_hva += ofs;
+	if (((kvm_regs->rip >> PAGE_SHIFT) == 0xffffffff81198)
+		&& (all_cnt > DEBUG_THRESHOLD_LOW  && all_cnt < DEBUG_THRESHOLD_UP)) {
+		VM_DSM_COLLECT_PK("\t%lu %d: - 3 rip 0x%llx "
+							"[rbp 0x%lx] start grbp_hva 0x%lx\n",
+							all_cnt, cnt, kvm_regs->rip, next_rbp_gva, grbp_hva);
+	}
+
+	if (copy_from_user(kvaddr,
+				(const void __user *)grbp_hva, sizeof(long) * 2)) {
+		printk(KERN_ERR "%lu %d: [BUG] rip 0x%llx next_rbp_gva 0x%lx -> "
+				"gpa 0x%lx -> grbp_hva 0x%lx while copying\n",
+				all_cnt, cnt, kvm_regs->rip, next_rbp_gva, gpa, grbp_hva);
+		goto _err;
+	}
+
+	frame = (unsigned long *)kvaddr;
+	do { /* vaniila walk stack code */
+		unsigned long ret_addr = *(frame + 1);
+		unsigned long next_rbp_gva = *frame;
+		if (((kvm_regs->rip >> PAGE_SHIFT) == 0xffffffff81198)
+			&& (all_cnt > DEBUG_THRESHOLD_LOW  && all_cnt < DEBUG_THRESHOLD_UP)) {
+			VM_DSM_COLLECT_PK("\t%lu %d: - 4 rip 0x%llx "
+							"next_rbp 0x%lx ret_addr [0x%lx]\n",
+							all_cnt, cnt, kvm_regs->rip, next_rbp_gva, ret_addr);
+		}
+		_dsm_traffic->stack[cnt] = ret_addr;
+		cnt++;
+
+		/* Check next ptr */
+		if (!is_valid_rbp(next_rbp_gva))
+			goto err;
+
+		/* Start translate */
+		/* gva -> gpa */
+		tr.linear_address = next_rbp_gva;
+		kvm_arch_vcpu_ioctl_translate(
+					hype_node_info[my_nid][fd]->vcpu, &tr);
+		gpa = tr.physical_address;
+
+		if (((kvm_regs->rip >> PAGE_SHIFT) == 0xffffffff81198)
+			&& (all_cnt > DEBUG_THRESHOLD_LOW  && all_cnt < DEBUG_THRESHOLD_UP)) {
+			VM_DSM_COLLECT_PK("\t\t%lu %d: - 5 rip 0x%llx "
+								"[next rbp] gva 0x%lx -> gpa 0x%lx\n",
+								all_cnt, cnt, kvm_regs->rip, next_rbp_gva, gpa);
+		}
+
+		if (gpa == 0UL - 1)
+			goto __err;
+
+		/* gva -> gfn */
+		gfn = (gpa) >> PAGE_SHIFT;
+		ofs = (gpa) % PAGE_SIZE;
+		/* gva -> gfn -> hva */
+		grbp_hva = kvm_vcpu_gfn_to_hva(
+					hype_node_info[my_nid][fd]->vcpu, gfn);
+		grbp_hva += ofs;
+		/* hva */
+		/* copy */
+		if (copy_from_user(kvaddr,
+				(const void __user *)grbp_hva, sizeof(long) * 2)) {
+			printk(KERN_ERR "%lu %d: [BUG] rip 0x%llx next_rbp_gva 0x%lx -> "
+				"gpa 0x%lx -> grbp_hva 0x%lx while copying\n",
+				all_cnt, cnt, kvm_regs->rip, next_rbp_gva, gpa, grbp_hva);
+			goto _err;
+		}
+		frame = kvaddr;
+	} while (cnt < MAX_VM_STACK_DEBUG);
+
+	if (((kvm_regs->rip >> PAGE_SHIFT) == 0xffffffff81198)
+		&& (all_cnt > DEBUG_THRESHOLD_LOW  && all_cnt < DEBUG_THRESHOLD_UP)) {
+		VM_DSM_COLLECT_PK("\t%lu %d: - 6 rip 0x%llx [rbp 0x%llx] done\n",
+						all_cnt, cnt, kvm_regs->rip, kvm_regs->rbp);
+		VM_DSM_COLLECT_PK("\n");
+	}
+	return;
+
+err: /* !is_valid_rbp */
+	/* if you see rsp = ffffxxxxxxxxxxxx and rbp = dddddddddddddddd, check
+	 * ./Documentation/x86/x86_64/mm.txt to find where is the rsp from
+	 * and try to filter it out or mark it.
+	 * And,
+	 * rsp = 7fffffffxxxx + rbp = dddddddddddddddd is from userspace
+	 */
+	for (i = cnt; i < MAX_VM_STACK_DEBUG; i++)
+		_dsm_traffic->stack[i] = 0xdddddddddddddddd;
+	if (((kvm_regs->rip >> PAGE_SHIFT) == 0xffffffff81198)
+		&& (all_cnt > DEBUG_THRESHOLD_LOW  && all_cnt < DEBUG_THRESHOLD_UP)) {
+		VM_DSM_COLLECT_PK("\n");
+	}
+	return;
+
+_err:
+	for (i = cnt; i < MAX_VM_STACK_DEBUG; i++)
+		_dsm_traffic->stack[i] = 0xeeeeeeeeeeeeeeee;
+	if (((kvm_regs->rip >> PAGE_SHIFT) == 0xffffffff81198)
+		&& (all_cnt > DEBUG_THRESHOLD_LOW  && all_cnt < DEBUG_THRESHOLD_UP)) {
+		VM_DSM_COLLECT_PK("\n");
+	}
+	return;
+
+__err:
+	for (i = cnt; i < MAX_VM_STACK_DEBUG; i++)
+		_dsm_traffic->stack[i] = 0UL - 1;
+	if (((kvm_regs->rip >> PAGE_SHIFT) == 0xffffffff81198)
+		&& (all_cnt > DEBUG_THRESHOLD_LOW  && all_cnt < DEBUG_THRESHOLD_UP)) {
+		VM_DSM_COLLECT_PK("\n");
+	}
+	return;
+
+err_skip:
+	for (i = cnt; i < MAX_VM_STACK_DEBUG; i++)
+		_dsm_traffic->stack[i] = 0xaaaaaaaaaaaaaaaa;
+	return;
+}
+
+/* For dumping vm regs
+ *	Ref:
+ *		Kern: ./arch/x86/kvm/x86.c kvm_arch_vcpu_ioctl_get_regs()
+ *		Usr:
+ *			signal(SIGUSR1, handle_sigusr1);
+ *			static void handle_sigusr1(int sig) {
+ *				kvm_cpu__show_registers(vcpu)
+ *			}
+ *			search: SIGUSR1
+ *			stack:
+ *				x86/kvm-cpu.c: kvm_cpu__show_code()
+ *					kvm__dump_mem() // walk stack
+ */
+//struct kvm_vcpu *pophype_vcpu[MAX_POPCORN_VCPU];
+//unsigned long pophype_show_guest_rip_rsp(unsigned long host_addr)
+dsm_traffic_t pophype_show_guest_rip_rsp(unsigned long host_addr, bool show, struct kvm_vcpu *vcpu)
+{
+	int i;
+	bool found = false;
+	//unsigned long inst = -1;
+	//struct dsm_pgfault *;
+		//.inst = 0,
+	struct kvm_regs *kvm_regs;
+	dsm_traffic_t _dsm_traffic = {
+		.rip = 0,
+		.addr = 0,
+		.rbp = 0,
+		.rsp = 0,
+		//.stack[] = {0, 0, 0, 0, 0},
+		.cnt = 1,
+		//.time = 0
+	};
+	for (i = 0; i < MAX_VM_STACK_DEBUG; i++) {
+		_dsm_traffic.stack[i] = 0;
+	}
+
+	kvm_regs = kzalloc(sizeof(struct kvm_regs), GFP_ATOMIC);
+	BUG_ON(!kvm_regs);
+
+	/* TODO: use kvm_vcpu struct directly.... */
+	for (i = 0; i < MAX_POPCORN_VCPU; i++) {
+		//if (hype_node_info[my_nid][i]->on_mynid) /* fastpath -
+		//													not implemented */
+		if (my_nid == popcorn_vcpuid_to_nid(i)) {
+			int fd = i + VCPU_FD_BASE; /* TODO - this is a HACK.
+									Use syscall to get correct info from usr */
+			if (hype_node_info[my_nid][fd]->vcpu) {
+				BUG_ON(vcpu != hype_node_info[my_nid][fd]->vcpu);
+				BUG_ON(vcpu->vcpu_id !=					/* post-prelim check */
+						hype_node_info[my_nid][fd]->vcpu->vcpu_id);
+				kvm_arch_vcpu_ioctl_get_regs(
+					hype_node_info[my_nid][fd]->vcpu, kvm_regs); /* TODO BUG
+															THIS IS A HACK */
+				found = true;
+
+				/* RSP walk stack */
+				vm_stack_walk(kvm_regs, &_dsm_traffic, fd);
+
+#if HYPE_PERF_CRITICAL_DSM_TRAFFIC_PRINTK
+				if (show) {
+					POP_PK("pophype: dsm dbg: 0x%lx guest-vcpu%d "
+							"ip 0x%llx sp 0x%llx rbp 0x%llx\n",
+							host_addr, i, kvm_regs->rip,
+							kvm_regs->rsp, kvm_regs->rbp);
+				}
+#endif
+			}
+			break;
+		}
+	}
+	if (found) {
+		_dsm_traffic.rip = kvm_regs->rip;
+		_dsm_traffic.rsp = kvm_regs->rsp;
+		_dsm_traffic.rbp = kvm_regs->rbp;
+		//_dsm_traffic.stack[0] = ;
+	}
+	kfree(kvm_regs);
+#if HYPE_PERF_CRITICAL_DSM_TRAFFIC_PRINTK
+	//printk("=======\n=======\n\n");
+#endif
+	return _dsm_traffic;
+}
+
+#ifdef CONFIG_POPCORN_STAT
+/* Stat */
+atomic64_t apic_reg_write_ns = ATOMIC64_INIT(0);
+atomic64_t apic_reg_write_cnt = ATOMIC64_INIT(0);
+atomic64_t apic_reg_write_handle_ns = ATOMIC64_INIT(0);
+atomic64_t apic_reg_write_handle_cnt = ATOMIC64_INIT(0);
+
+atomic64_t ipi_ns = ATOMIC64_INIT(0);
+atomic64_t ipi_cnt = ATOMIC64_INIT(0);
+atomic64_t ipi_handle_ns = ATOMIC64_INIT(0);
+atomic64_t ipi_handle_cnt = ATOMIC64_INIT(0);
+atomic64_t update_vcpu_ns = ATOMIC64_INIT(0);
+atomic64_t update_vcpu_cnt = ATOMIC64_INIT(0);
+atomic64_t update_vcpu_handle_ns = ATOMIC64_INIT(0);
+atomic64_t update_vcpu_handle_cnt = ATOMIC64_INIT(0);
+atomic64_t update_vcpu_run_handle_ns = ATOMIC64_INIT(0);
+atomic64_t update_vcpu_run_handle_cnt = ATOMIC64_INIT(0);
+
+atomic64_t sig_ns = ATOMIC64_INIT(0);
+atomic64_t sig_cnt = ATOMIC64_INIT(0);
+atomic64_t sig_handle_ns = ATOMIC64_INIT(0);
+atomic64_t sig_handle_cnt = ATOMIC64_INIT(0);
+#endif
+//atomic64_inc(&mm_cnt);
+#if 0 /* example */
+atomic64_t invh_ns = ATOMIC64_INIT(0);
+atomic64_t invh_cnt = ATOMIC64_INIT(0);
+
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	ktime_t dt, invh_end, invh_start = ktime_get();
+#endif
+
+	...(target)...
+
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	invh_end = ktime_get();
+	dt = ktime_sub(invh_end, invh_start);
+	atomic64_add(ktime_to_ns(dt), &invh_ns);
+	atomic64_inc(&invh_cnt);
+#endif
+#endif
+
+void pophype_set_cpu(int cpu)
+{
+    cpumask_var_t new_mask;
+	u64 vcpu_id = cpu, retried = 0;
+
+	might_sleep();
+	BUG_ON(!alloc_cpumask_var(&new_mask, GFP_KERNEL)); /* return -ENOMEM; */
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t\tpophype: %s(): in_atomic() %d current <%d> future <%llu>\n",
+						__func__, in_atomic(), smp_processor_id(), vcpu_id);
+#endif
+	while (smp_processor_id() != vcpu_id) {
+		//BUG_ON(cpumask_parse_user("1", 2, new_value));
+		cpumask_clear(new_mask);
+		cpumask_set_cpu(vcpu_id, new_mask); /* vcpu 0x0 = cpumask 0x01 */
+
+		/* thread affinity */
+		sched_setaffinity(current->pid, new_mask);
+
+		/* XXX */
+		if (retried) {
+			volatile int i, j;
+			for (i = 0; i < 1000*1000*1000; i++)
+				for (j = 0; j < 10; j++)
+					; //io_schedule(); cannot sleep
+		}
+
+		retried++;
+	}
+    free_cpumask_var(new_mask);
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t\tpophype: %s(): on <%d> retried %llu\n",
+				__func__, smp_processor_id(), retried);
+#endif
+}
+
+void pophype_set_cpu0(void)
+{
+#if !POPHYPE_HOST_KERNEL
+    // typedef struct cpumask { DECLARE_BITMAP(bits, NR_CPUS); } cpumask_t;
+    // typedef struct cpumask *cpumask_var_t;
+	//int ret;
+    cpumask_var_t new_mask;
+	u64 vcpu_id = 0, retried = 0;
+
+	might_sleep();
+	BUG_ON(!alloc_cpumask_var(&new_mask, GFP_KERNEL)); /* return -ENOMEM; */
+
+	POP_PK("\t\tpophype: %s(): current <%d> future <%llu>\n",
+						__func__, smp_processor_id(), vcpu_id);
+	while (smp_processor_id() != vcpu_id) {
+		//BUG_ON(cpumask_parse_user("1", 2, new_value));
+		cpumask_clear(new_mask);
+		cpumask_set_cpu(vcpu_id, new_mask); /* vcpu 0x0 = cpumask 0x01 */
+
+		/* thread affinity */
+		sched_setaffinity(current->pid, new_mask);
+
+		/* XXX */
+		if (retried)
+			io_schedule();
+
+		retried++;
+	}
+    free_cpumask_var(new_mask);
+	POP_PK("\t\tpophype: %s(): on <%d> retried %llu\n",
+				__func__, smp_processor_id(), retried);
+
+	/* irq affinity */
+	// struct irq_desc *desc = irq_to_desc(irq);
+//	if (desc) {
+//		if (desc->irq_data.chip) {
+//			if (desc->irq_data.chip->irq_set_affinity) {
+//				AFFPRINTK("%s() check: smp_irq_set_affinity_callback() %p name %s\n",
+//						__func__, desc->irq_data.chip->irq_set_affinity,
+//									desc->irq_data.chip->name);
+//			} else {
+//				AFFPRINTK("%s() check: !smp_irq_set_affinity_callback() \n", __func__);
+//			}
+//		} else {
+//			AFFPRINTK("%s() check: !desc->irq_data.chip case\n", __func__);
+//		}
+//	} else {
+//		AFFPRINTK("%s() check: !desc case\n", __func__);
+//	}
+	//ret = irq_set_affinity(port->irq, new_value);
+	//if (ret < 0)
+	//	printk(KERN_ERR "\n\n\t\t\tERROR: [%d] %s(): cannot set irq\n\n\n",
+	//												current->pid, __func__);
+#endif
+}
+
+/*
+ * lkvm user space version - vcpuid_to_nid();
+ */
+int popcorn_vcpuid_to_nid(int vcpu_id)
+{
+	if (atomic64_read(&gvcpu_to_nid[vcpu_id]) >= 0) {
+		/* debug */
+		//printk("asking vcpu_id %d returning nid %ld\n",
+		//				vcpu_id, atomic64_read(&gvcpu_to_nid[vcpu_id]));
+		return atomic64_read(&gvcpu_to_nid[vcpu_id]);
+	}
+
+	printk(KERN_ERR "vcpu_id %d is not registered\n", vcpu_id);
+	dump_stack();
+	BUG();
+}
+
+inline void popcorn_show_gcpu_table(void) {
+	/* Only suppor 4vcpu now */
+#if HPMIGRATION_DEBUG /* debug */
+	printk("%s(): atomic64_read(&gvcpu_to_nid[0-4] %ld %ld %ld %ld\n",
+#else
+	PHMIGRATEPRINTK("%s(): atomic64_read(&gvcpu_to_nid[0-4] %ld %ld %ld %ld\n",
+#endif
+			__func__,
+			atomic64_read(&gvcpu_to_nid[0]), atomic64_read(&gvcpu_to_nid[1]),
+			atomic64_read(&gvcpu_to_nid[2]), atomic64_read(&gvcpu_to_nid[3]));
+}
+
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+inline bool popcorn_on_right_nid(int vcpu_id)
+{
+	if (my_nid == popcorn_vcpuid_to_nid(vcpu_id))
+		return true;
+	return false;
+}
+#else
+inline bool popcorn_on_right_node(int vcpu)
+{
+	return true;
+}
+#endif
+
+
+/* caller must have installed gvcpu_to_nid[] */
+int pophype_available_vcpu(void)
+{
+	int i, accu_cnt = 0;
+		for (i = 0; i < MAX_POPCORN_VCPU; i++) {
+			if (atomic64_read(&gvcpu_to_nid[i]) >= 0) {
+				accu_cnt++;
+			}
+		}
+	//printk("pophype total vcpu %d\n", accu_cnt);
+	return accu_cnt;
+}
+
+
+/*******************************
+ * Debug utils
+ *******************************/
+/* Call this function in hypervisor only (NOT USEFUL printk works already) */
+//#define MAX_NID 8
+#include <linux/fdtable.h>
+//extern int sys_close(unsigned int fd);
+//#define LEN 255
+int popcorn_get_hnid(void)
+{
+#if 0
+    int i, fd, flags = O_RDONLY;
+	char init_echo_name[] = "/jack_echo"; // TODO fox
+	char path[LEN];
+
+	//for (i = 0; i <= MAX_POPCORN_NODES; i++) {
+	for (i = 4; i <= 5; i++) {
+		int ofs = 0;
+		memset(path, 0, LEN);
+		ofs += snprintf(path, LEN,
+				//(sizeof(init_echo_name) - 0) * sizeof(*init_echo_name),
+													"%s", init_echo_name);
+		//ofs += snprintf(path + ofs, sizeof(char), "%d", i);
+		ofs += snprintf(path + ofs, LEN, "%d", i);
+		printk("try open \"%s\" size %lu ofs %d\n", path,
+			(sizeof(init_echo_name) - 0) * sizeof(*init_echo_name), ofs);
+		fd = do_sys_open(AT_FDCWD , path, flags, 0);
+		if (fd >= 0) {
+			sys_close(fd);
+			return i;
+		}
+	}
+#endif
+	return -1;
+}
+
+/* ref fd_install() */
+int popcorn_file_to_fd(struct task_struct *tsk, struct file *file, bool is_vcpu)
+{
+	struct fdtable *fdt = rcu_dereference_sched(tsk->files->fdt);
+	int fd = -1, max_fd;
+	bool good = false;
+	BUG_ON(!file);
+
+	if (is_vcpu)
+		max_fd = MAX_POPCORN_VCPU;
+	else
+		max_fd = MAX_POPCORN_FD;
+
+	/* This is not precise */
+	for (fd = FD_START; fd < max_fd; fd++) {
+		//printk("fd %d fdt->fd[fd] %p file %p\n", fd, fdt ? fdt->fd[fd] : NULL, file);
+		if (fdt->fd[fd]) {
+			if (fdt->fd[fd] == file) {
+				good = true;
+				break;
+			}
+		} else
+			break; /* fastpath - continuous fd assumption */
+	}
+	rcu_read_unlock_sched();
+	if (!good) {
+		printk(KERN_ERR "Cannot find the fd for file %p\n", file);
+		//BUG_ON(!good);
+	}
+	return fd;
+}
+
+/*******************************
+ * NID VCPU mapping
+ *******************************/
+/* register this vcpu to my node */
+void register_local_vcpu(int vcpu_id)
+{
+	my_hype_cpu[vcpu_id] = true;
+}
+
+/* lookup - is vcpu_id on mynid? */
+bool is_local_vcpu(int vcpu_id)
+{
+	return my_hype_cpu[vcpu_id];
+}
+
+
+/*******************************
+ * Delegations  *reqs & handlers)
+ *******************************/
+// This kernel implementation is not being used. Instead user solution is taken.
+// popcorn version of kvm_dev_ioctl_create_vm()
+// TODO am I using?
+// NOT USEING
+int popcorn_kvm_dev_ioctl_create_vm_tsk(unsigned long type)
+{
+	/******************************************************/
+	BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG();
+	BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG();
+	BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG();
+	BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG();
+	/******************************************************/
+
+	if (!current->at_remote) { // origin - broadcast
+		printk("TODO: implement\n");
+		BUG();
+	} else { // remote - delegation and reply
+		remote_kvm_create_request_t *req = kmalloc(sizeof(*req), GFP_KERNEL);
+		struct wait_station *ws = get_wait_station(current);
+		remote_kvm_create_response_t *res;
+		struct remote_context *rc = current->mm->remote;
+		//int dfd = AT_FDCWD;
+		int tmp_fd = -999;
+		BUG_ON(!rc || !req);
+		req->from_pid = current->pid;
+		req->origin_pid = rc->remote_tgids[0]; // lookup the pid on origin
+		req->ws = ws->id;
+
+		req->type = type;
+
+		HPPRINTK("[%d] #working# [[kvm_create]]- delegating to origin "
+							"req->type %lu\n", current->pid, req->type);
+        pcn_kmsg_send(PCN_KMSG_TYPE_REMOTE_KVM_CREATE_REQUEST,
+									0, req, sizeof(*req));
+		res = wait_at_station(ws);
+
+		// anon mapping using
+		HPPRINTK("[%d] #working# [[kvm_create]] - replaying and matching "
+				"origin replys res->fd [[%d]] with struct file* for "
+				" at remote\n", current->pid, res->fd);
+		// replay kvm_create but use res->fd; to map with file_struct
+		tmp_fd = replay_kvm_dev_ioctl_create_vm_tsk(current, type);
+
+		HPPRINTK("[%d] replay returns tmp_fd [[%d]] at remote\n\n",
+												current->pid, tmp_fd);
+
+		kfree(req);
+		pcn_kmsg_done(res);
+		return tmp_fd;
+	}
+	return -999;
+}
+
+
+static void process_remote_kvm_create_request(struct work_struct *work)
+{
+    START_KMSG_WORK(remote_kvm_create_request_t, req, work);
+    remote_kvm_create_response_t *res = pcn_kmsg_get(sizeof(*res));
+    int from_nid = PCN_KMSG_FROM_NID(req);
+    struct task_struct *tsk = __get_task_struct(req->origin_pid);
+	unsigned long type = req->type;
+
+	HPPRINTK("[from%d/origin%d]#working# [[kvm_create]] at origin\n",
+										req->from_pid, req->origin_pid);
+
+	BUG_ON(!tsk && "No task exist");
+	BUG_ON(tsk->at_remote);
+
+	HPPRINTK("[from%d/origin%d]\n", req->from_pid, tsk->pid);
+
+	/* remote is trying to create a vm */
+	res->fd = replay_kvm_dev_ioctl_create_vm_tsk(tsk, type);
+
+    res->from_pid = req->from_pid;
+	res->ws = req->ws;
+
+	HPPRINTK("#working# [[kvm_create]] at origin DONE fd %d ->\n\n",
+												res->fd);
+    pcn_kmsg_post(PCN_KMSG_TYPE_REMOTE_KVM_CREATE_RESPONSE,
+							from_nid, res, sizeof(*res));
+    END_KMSG_WORK(req);
+}
+
+static int handle_remote_kvm_create_response(struct pcn_kmsg_message *msg)
+{
+    remote_kvm_create_response_t *res = (remote_kvm_create_response_t *)msg;
+    struct wait_station *ws = wait_station(res->ws);
+
+    ws->private = res;
+
+	complete(&ws->pendings);
+    return 0;
+}
+
+int vcpuid_to_fd(int vcpu_id)
+{
+	return VCPU_FD_BASE + vcpu_id;
+}
+
+/* Only partial req will be broadcast now: APIC_DFR(don't care vcpu?) */
+/* //TODO rename now is bidirection - Bidirection now */ // no need
+/* TODO rename: vcpu_id -> from vcpu_id (broadcasting this info to every other nodes) */
+void popcorn_broadcast_apic_reg_write(int vcpu_id, u32 reg, u32 val)
+{
+	origin_broadcast_apic_reg_write_response_t *res;
+	origin_broadcast_apic_reg_write_request_t *req;
+	struct remote_context *rc = current->mm->remote;
+	struct wait_station *ws;
+	int nid;
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	ktime_t dt, apic_reg_write_end, apic_reg_write_start = ktime_get();
+#endif
+
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	BUG_ON(!rc);
+#endif
+
+	POP_PK("%s(): => <brodcast> for registering apic->vcpu_id %d\n",
+													__func__, vcpu_id);
+
+	req = kmalloc(sizeof(*req), GFP_KERNEL);
+	BUG_ON(!req);
+
+	req->from_pid = current->pid;
+
+	req->fd = vcpuid_to_fd(vcpu_id);
+	req->vcpu_id = vcpu_id;
+	req->reg = reg;
+	req->val = val;
+
+	for (nid = 0; nid < get_popcorn_nodes(); nid++) {
+		if (nid == my_nid) continue;
+		POP_PK("%s(): pop_hype broadcast reg %x val %x => [%d] <%d>\n",
+										__func__, reg, val, nid, vcpu_id);
+		ws = get_wait_station(current);
+		req->ws = ws->id;
+		req->remote_pid = rc->remote_tgids[nid];
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+		if (!req->remote_pid) {
+			printk(KERN_ERR "req->remote_pid %d to [%d]", req->remote_pid, nid);
+			BUG_ON(!req->remote_pid); // seems buggy at remote
+		}
+#endif
+
+		pcn_kmsg_send(PCN_KMSG_TYPE_ORIGIN_BROADCAST_APIC_REG_WRITE_REQUEST,
+													nid, req, sizeof(*req));
+		res = wait_at_station(ws);
+		BUG_ON(res->ret);
+		pcn_kmsg_done(res);
+	}
+
+	kfree(req);
+#ifdef CONFIG_POPCORN_STAT
+	apic_reg_write_end = ktime_get();
+	dt = ktime_sub(apic_reg_write_end, apic_reg_write_start);
+	atomic64_add(ktime_to_ns(dt), &apic_reg_write_ns);
+	atomic64_inc(&apic_reg_write_cnt);
+#endif
+}
+
+
+
+/***
+ * vhost-net: eventfd table (e.g. eventfd ctx, fd)
+ */
+int eventfd_ctx_to_fd(struct eventfd_ctx *eventfd_ctx)
+{
+	int i;
+	CRITICALNETPK("\t\t%s(): eventfd_ctx %p to fd ?\n",
+							__func__, eventfd_ctx);
+	for (i = FD_START; i < MAX_POPCORN_FD; i++) {
+		if (!hype_eventfd_info[i]) continue;
+		if (hype_eventfd_info[i]->eventfd_ctx == eventfd_ctx) {
+			CRITICALNETPK("\t\t%s(): matched - eventfd_ctx %p fd %d\n",
+									__func__, eventfd_ctx, i);
+			return i;
+		}
+	}
+	BUG();
+	return -1;
+}
+
+struct eventfd_ctx *eventfd_fd_to_ctx(int eventfd_fd)
+{
+	//struct eventfd_ctx *eventfd_ctx;
+	int retry, retry_limit = 1000000;
+
+retry:
+	if (likely(hype_eventfd_info[eventfd_fd])) {
+		CRITICALNETPK("retrive ctx %p for fd %d\n",
+			hype_eventfd_info[eventfd_fd]->eventfd_ctx, eventfd_fd);
+		return hype_eventfd_info[eventfd_fd]->eventfd_ctx;
+	} else {
+		retry++;
+		if (retry < retry_limit) {
+			io_schedule();
+			goto retry;
+		}
+		/* When it happens, usually it's not race condition. */
+		printk(KERN_ERR "CANNOT FIND eventfd ctx for fd %d\n", eventfd_fd);
+		dump_stack();
+		BUG();
+	}
+}
+
+#define SKIP_EVENTFD_DELEGATE_RESPONSE 1
+/* 11/05/19 add #if 0 to implement nonblocking */
+__u64 pophype_eventfd_delegate(int eventfd_fd, __u64 n)
+{
+	delegate_eventfd_request_t *req;
+#if !SKIP_EVENTFD_DELEGATE_RESPONSE
+	delegate_eventfd_response_t *res;
+	struct wait_station *ws;
+#endif
+	struct remote_context *rc = current->mm->remote;
+	int dst_nid = POPCORN_HOST_NID; /* delegation */
+	__u64 res_n;
+	/* Common done */
+	static int cnt = 0;
+	///int abc;
+
+	CRITICALNETPK("\n[DELEG EVENTFD] %s(): fd %d =>\n",
+							__func__, eventfd_fd);
+	/* Common */
+	if (my_nid == dst_nid) {
+		printk(KERN_ERR "skip this self delegation... #%d\n", ++cnt);
+		return 100000; /* prevented from outside as well */
+	}
+	req = kmalloc(sizeof(*req), GFP_KERNEL);
+	BUG_ON(!req || !rc);
+#if !SKIP_EVENTFD_DELEGATE_RESPONSE
+	ws = get_wait_station(current);
+	req->ws = ws->id;
+#endif
+	req->from_pid = current->pid;
+
+	/* customize */
+	req->eventfd_fd = eventfd_fd; /* will be converted to ctx */
+	req->n = n;
+
+	req->remote_pid = rc->remote_tgids[dst_nid];
+	pcn_kmsg_send(PCN_KMSG_TYPE_DELEGATE_EVENTFD_REQUEST,
+								dst_nid, req, sizeof(*req));
+#ifdef CONFIG_POPCORN_STAT
+	eventfd_delegate_cnt++;
+#endif
+
+#if !SKIP_EVENTFD_DELEGATE_RESPONSE
+	res = wait_at_station(ws);
+	res_n = res->n;
+	pcn_kmsg_done(res);
+	res_n = res->n;
+#else
+	res_n = n;
+#endif
+	kfree(req);
+
+	/* self checking */
+	if (res_n != n)
+		CRITICALNETPK("[WATCHOUT] n has been changed!!!\n");
+	return res_n;
+}
+
+/* 11/05/19 add #if 0 to implement nonblocking */
+extern __u64 pophype_eventfd_signal(struct eventfd_ctx *ctx, __u64 n);
+static void process_eventfd_delegate_request(struct work_struct *work)
+{
+    START_KMSG_WORK(delegate_eventfd_request_t, req, work);
+#if !SKIP_EVENTFD_DELEGATE_RESPONSE
+    delegate_eventfd_response_t *res = pcn_kmsg_get(sizeof(*res));
+    int from_nid = PCN_KMSG_FROM_NID(req);
+#endif
+    //struct task_struct *tsk = __get_task_struct(req->remote_pid);
+	//
+	static int cnt = 0;
+	struct eventfd_ctx *eventfd_ctx;
+	__u64 n;
+
+#ifdef CONFIG_POPCORN_STAT
+	atomic64_inc(&eventfd_delegated_cnt);
+	cnt++;
+#endif
+
+	CRITICALNETPK("\n => [DELEG EVENTFD] %s(): fd %d #%d\n",
+							__func__, req->eventfd_fd, cnt);
+	/* Convert */
+	eventfd_ctx = eventfd_fd_to_ctx(req->eventfd_fd);
+
+	/* Perform delegation work */
+	n = pophype_eventfd_signal(eventfd_ctx, req->n);
+
+#if !SKIP_EVENTFD_DELEGATE_RESPONSE
+	res->n = n;
+	res->eventfd_fd = req->eventfd_fd;
+
+	//res->ret = ret;
+    res->from_pid = req->from_pid;
+	res->ws = req->ws;
+	pcn_kmsg_post(PCN_KMSG_TYPE_DELEGATE_EVENTFD_RESPONSE,
+								from_nid, res, sizeof(*res));
+#endif
+    END_KMSG_WORK(req);
+}
+
+static int handle_eventfd_delegate_response(struct pcn_kmsg_message *msg)
+{
+	delegate_eventfd_response_t *res = (delegate_eventfd_response_t *)msg;
+    struct wait_station *ws = wait_station(res->ws);
+	/* common done */
+	static int cnt = 0;
+	cnt++;
+#if SKIP_EVENTFD_DELEGATE_RESPONSE
+	BUG();
+#endif
+	/* customize */
+	CRITICALNETPK("\n<< [DELEG EVENTFD] %s(): fd %d n %llu #%d\n",
+							__func__, res->eventfd_fd, res->n, cnt);
+
+	/* common */
+    ws->private = res;
+	complete(&ws->pendings);
+
+	/* customize */
+    return res->n;
+}
+
+
+/*******************************************************************************
+ * MSG
+ */
+
+///* origin_ : initiated by origin
+// * remote_ : initiated by remote */
+extern int popcorn_apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val);
+static void process_origin_broadcast_apic_reg_write_request(struct work_struct *work)
+{
+    START_KMSG_WORK(origin_broadcast_apic_reg_write_request_t, req, work);
+    origin_broadcast_apic_reg_write_response_t *res = pcn_kmsg_get(sizeof(*res));
+    int from_nid = PCN_KMSG_FROM_NID(req);
+    struct task_struct *tsk = __get_task_struct(req->remote_pid);
+	struct kvm_lapic *apic;
+	struct fd __fd;
+	unsigned long v;
+	struct file *filp;
+	struct kvm_vcpu *vcpu;
+	int ret = 0;
+	u32 reg = req->reg;
+	u32 val = req->val;
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	ktime_t dt, apic_reg_write_handle_end, apic_reg_write_handle_start = ktime_get();
+#endif
+
+	if (!tsk) {
+		printk(KERN_ERR "from [%d/%d]\n\n\n", from_nid, req->remote_pid);
+		BUG_ON(!tsk && "No task exist");
+	}
+	IPIINITPRINTK("%s(): fd fd fd %d tsk->files %p\n",
+				__func__, req->fd, tsk->files);
+				///////////////tsk??????? but how remote can do it...
+	//struct fd __fd = fdget(req->fd);
+	v = fget_light_tsk(tsk, req->fd, FMODE_PATH);
+	__fd = (struct fd){(struct file *)(v & ~3),v & 3};
+	IPIINITPRINTK("%s(): struct fd &__fd %p\n", __func__, (void *)&__fd);
+	filp = __fd.file;
+	BUG_ON(!filp); /* check run.sh lkvm argv
+						highly likely you don't have enough CPU online */
+	vcpu = filp->private_data;
+	BUG_ON(!vcpu);
+	fdput(__fd);
+	IPIINITPRINTK("%s(): reg 0x%x val 0x%x ***fd %d <%d>***\n",
+					__func__, reg, val, req->fd, vcpu->vcpu_id);
+
+	//BUG_ON(from_nid || !tsk->at_remote);
+	BUG_ON(req->fd < 0);
+
+	apic = vcpu->arch.apic;
+	BUG_ON(!apic);
+
+	/* Popcorn proxy */
+	ret = popcorn_apic_reg_write(apic, reg, val);
+
+	IPIINITPRINTK("%s(): apic %p reg 0x%x val 0x%x ret (%s)\n",
+				__func__, apic, reg, val, !ret ? "GOOD" : "BAD");
+
+	res->ret = ret;
+    res->from_pid = req->from_pid;
+	res->ws = req->ws;
+	pcn_kmsg_post(PCN_KMSG_TYPE_ORIGIN_BROADCAST_APIC_REG_WRITE_RESPONSE,
+											from_nid, res, sizeof(*res));
+    END_KMSG_WORK(req);
+
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	apic_reg_write_handle_end = ktime_get();
+	dt = ktime_sub(apic_reg_write_handle_end, apic_reg_write_handle_start);
+	atomic64_add(ktime_to_ns(dt), &apic_reg_write_handle_ns);
+	atomic64_inc(&apic_reg_write_handle_cnt);
+#endif
+}
+
+static int handle_origin_broadcast_apic_reg_write_response(struct pcn_kmsg_message *msg)
+{
+    origin_broadcast_apic_reg_write_response_t *res =
+		(origin_broadcast_apic_reg_write_response_t *)msg;
+    struct wait_station *ws = wait_station(res->ws);
+
+    ws->private = res;
+
+	complete(&ws->pendings);
+
+    return 0;
+}
+
+/* SIPI */
+/* TODO rename vcpu_id to target_vcpu_id */
+/* TODO rename: DONT USE BROADCAST. this is a redirect */
+/* NOT USED */
+void popcorn_broadcast_accept_irq(int vcpu_id, int delivery_mode, int vector, int level, int trig_mode, int dest_map)
+{
+	origin_broadcast_accept_irq_response_t *res;
+	origin_broadcast_accept_irq_request_t *req;
+	struct remote_context *rc = current->mm->remote;
+	struct wait_station *ws;
+	int nid;
+
+	/******************************************************/
+	BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG();
+	BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG();
+	BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG();
+	BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG();
+	/******************************************************/
+
+	BUG_ON("NOT USED");
+
+	if (!rc)
+		return;
+
+	req = kmalloc(sizeof(*req), GFP_ATOMIC);
+	ws = get_wait_station(current);
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	if (current->at_remote || my_nid > 0 || !req || vcpu_id <= 0) {
+		printk("[%d/%d] req %p BUG()\n", my_nid, current->pid, req);
+		BUG();
+	}
+#endif
+
+	req->from_pid = current->pid;
+	nid = popcorn_vcpuid_to_nid(vcpu_id);
+	POP_PK("%s(): => [%d] <%d>\n", __func__, nid, vcpu_id);
+	req->remote_pid = rc->remote_tgids[nid];
+	req->ws = ws->id;
+
+	req->fd = vcpuid_to_fd(vcpu_id); /* HACK TODO */
+	req->vcpu_id = vcpu_id;
+	req->delivery_mode = delivery_mode;
+	req->vector = vector;
+	req->level = level;
+	req->trig_mode = trig_mode;
+	req->dest_map = dest_map;
+
+	pcn_kmsg_send(PCN_KMSG_TYPE_ORIGIN_BROADCAST_ACCEPT_IRQ_REQUEST,
+												nid, req, sizeof(*req));
+#if 0
+//	printk("%s(): TESTING NOT TO SLEEP WHILE SENDING IPI to remote\n", __func__);
+//	int cnt, loop = 1000000*100; // 100000000*100=60s so ~600m
+//    for (cnt = 0; cnt < loop; cnt++) {
+//        cpu_relax();
+//    }
+//	printk("%s(): FORGET ABOUT res THIS IS A BUG\n", __func__);
+//	kfree(req);
+//	rcu_read_unlock();
+	res = wait_at_station(ws);
+	BUG_ON(res->ret);
+
+	kfree(req);
+	pcn_kmsg_done(res);
+//	rcu_read_lock();
+#else
+	res = wait_at_station(ws);
+	BUG_ON(res->ret);
+
+	kfree(req);
+	pcn_kmsg_done(res);
+#endif
+}
+
+///* origin_ : initiated by origin
+// * remote_ : initiated by remote */
+/* Similar to __apic_accept_irq() */
+static void process_origin_broadcast_accept_irq_request(struct work_struct *work)
+{
+    START_KMSG_WORK(origin_broadcast_accept_irq_request_t, req, work);
+    origin_broadcast_accept_irq_response_t *res = pcn_kmsg_get(sizeof(*res));
+    int from_nid = PCN_KMSG_FROM_NID(req);
+    struct task_struct *tsk = __get_task_struct(req->remote_pid);
+	struct fd __fd = fdget(req->fd);
+	struct file *filp = __fd.file;
+	struct kvm_vcpu *vcpu = filp->private_data;
+	struct kvm_lapic *apic;
+	int ret = 0;
+	int delivery_mode = req->delivery_mode;
+	fdput(__fd);
+
+	/******************************************************/
+	BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG();
+	BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG();
+	BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG();
+	BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG();
+	/******************************************************/
+	BUG_ON("NOT USED");
+
+	BUG_ON(!tsk && "No task exist");
+	BUG_ON(from_nid || !tsk->at_remote || !my_nid);
+	BUG_ON(req->fd < 0);
+	BUG_ON(!filp);
+
+	BUG_ON(!vcpu);
+	apic = vcpu->arch.apic;
+	BUG_ON(!apic);
+
+	printk("\t\t-> GOT IPI IRQ mode %d from origin: "
+					"fd %d vid %d filp %p vcpu %p\n",
+					delivery_mode, req->fd, req->vcpu_id, filp, vcpu);
+
+	//popcorn_apic_accept_irq(apic, delivery_mode,
+	//						vector, level, trig_mode, dest_map);
+	ret = popcorn_apic_accept_irq(apic, delivery_mode, 0, 0, 0, NULL);
+
+	res->ret = ret;
+    res->from_pid = req->from_pid;
+	res->ws = req->ws;
+	pcn_kmsg_post(PCN_KMSG_TYPE_ORIGIN_BROADCAST_ACCEPT_IRQ_RESPONSE,
+											from_nid, res, sizeof(*res));
+    END_KMSG_WORK(req);
+}
+
+static int handle_origin_broadcast_accept_irq_response(struct pcn_kmsg_message *msg)
+{
+    origin_broadcast_accept_irq_response_t *res =
+		(origin_broadcast_accept_irq_response_t *)msg;
+    struct wait_station *ws = wait_station(res->ws);
+
+    ws->private = res;
+
+	complete(&ws->pendings);
+
+    return 0;
+}
+
+/* NOT USED */
+void popcorn_send_sipi(int vcpu_id, int vector)
+{
+	origin_sipi_response_t *res;
+	origin_sipi_request_t *req;
+	struct remote_context *rc = current->mm->remote;
+	struct wait_station *ws;
+	int nid;
+
+	/******************************************************/
+	BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG();
+	BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG();
+	BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG();
+	BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG(); BUG();
+	/******************************************************/
+	BUG(); BUG(); BUG(); /* TODO: BUG */
+	BUG(); BUG(); BUG(); /* TODO: BUG */
+	BUG(); BUG(); BUG(); /* TODO: BUG */
+	if (!rc)
+		return;
+
+	req = kmalloc(sizeof(*req), GFP_KERNEL);
+	ws = get_wait_station(current);
+	BUG_ON(current->at_remote);
+	BUG_ON(!req);
+
+	req->from_pid = current->pid;
+	printk("\t%s(): TODO give right node ttable for vcpu->node&fd\n", __func__);
+	printk("\t%s(): TODO give right node ttable for vcpu->node&fd\n", __func__);
+	printk("\t%s(): TODO give right node ttable for vcpu->node&fd\n", __func__);
+	nid = popcorn_vcpuid_to_nid(vcpu_id);
+	req->remote_pid = rc->remote_tgids[nid]; /* look for remote worker pid */
+	req->ws = ws->id;
+
+	/*  BUG TODO get the right fd  kvm 4 vcpu12*/
+	printk("\t%s(): TODO giving right fd (now fixed 12)\n", __func__);
+	printk("\t%s(): TODO giving right fd (now fixed 12)\n", __func__);
+	printk("\t%s(): TODO giving right fd (now fixed 12)\n", __func__);
+	req->fd = 12;
+	req->vcpu_id = vcpu_id;
+	req->vector = vector;
+
+	pcn_kmsg_send(PCN_KMSG_TYPE_ORIGIN_SIPI_REQUEST,
+								nid, req, sizeof(*req));
+	res = wait_at_station(ws);
+	BUG_ON(res->ret);
+
+	kfree(req);
+	pcn_kmsg_done(res);
+}
+
+
+/* origin_ : initiated by origin
+ * remote_ : initiated by remote */
+static void process_origin_sipi_request(struct work_struct *work)
+{
+    START_KMSG_WORK(origin_sipi_request_t, req, work);
+    origin_sipi_response_t *res = pcn_kmsg_get(sizeof(*res));
+    int from_nid = PCN_KMSG_FROM_NID(req);
+    struct task_struct *tsk = __get_task_struct(req->remote_pid);
+	struct fd __fd = fdget(req->fd);
+	struct file *filp = __fd.file;
+	/* DEPENDS ON fd 12/kvm_fd*/
+	//struct kvm *kvm = filp->private_data;
+	struct kvm_vcpu *vcpu = filp->private_data;
+//fdput(__fd);
+	struct kvm_lapic *apic;
+
+	BUG_ON(from_nid);
+	BUG_ON(!tsk && "No task exist");
+	BUG_ON(!tsk->at_remote);
+	BUG_ON(req->fd < 0);
+	BUG_ON(!filp);
+//	BUG_ON(!kvm);
+
+	printk("%s(): req [fd %d vcpu_id %d] to get *filp %p (matched???) vcpu %p\n",
+								__func__, req->fd, req->vcpu_id, __fd.file, vcpu);
+//	printk("  [%d] (using) treat as \"%s\"\n", current->pid, path);
+
+	//struct kvm_vcpu *vcpu = kvm_get_vcpu_by_id(kvm, req->vcpu_id);
+	BUG_ON(!vcpu);
+	apic = vcpu->arch.apic;
+	BUG_ON(!apic);
+
+	/* hacking!!!!!!!!!!!!! - post init (APIC_DM_INIT) */
+	BUG(); BUG(); BUG(); /* TODO: BUG */
+#if 0
+	static int cnt = 0;
+	if (!cnt) { // only does 1 time to prove im right
+		/* assumes that there are only KVM_APIC_INIT/SIPI */
+		apic->pending_events = (1UL << KVM_APIC_INIT);
+		smp_wmb();
+		kvm_make_request(KVM_REQ_EVENT, vcpu);
+		kvm_vcpu_kick(vcpu);
+		cnt = 1;
+	}
+#endif
+
+	/* start sipi */
+	printk("%s(): [%d]->req fd %d vcpu %d vector 0x%x\n",
+			__func__, from_nid, req->fd, req->vcpu_id, req->vector);
+	apic->sipi_vector = req->vector; /* AP will read it. */
+	/* make sure sipi_vector is visible for the receiver */
+	smp_wmb();
+	set_bit(KVM_APIC_SIPI, &apic->pending_events);
+	kvm_make_request(KVM_REQ_EVENT, vcpu);
+	kvm_vcpu_kick(vcpu);
+
+	res->ret = 0;
+    res->from_pid = req->from_pid;
+	res->ws = req->ws;
+	pcn_kmsg_post(PCN_KMSG_TYPE_ORIGIN_SIPI_RESPONSE,
+							from_nid, res, sizeof(*res));
+    END_KMSG_WORK(req);
+	fdput(__fd);
+}
+
+// send
+static int handle_origin_sipi_response(struct pcn_kmsg_message *msg)
+{
+    origin_sipi_response_t *res = (origin_sipi_response_t *)msg;
+    struct wait_station *ws = wait_station(res->ws);
+
+    ws->private = res;
+
+	complete(&ws->pendings);
+
+    return 0;
+}
+
+/****
+ * rack info
+ */
+static void process_origin_broadcast_cpu_table_request(struct work_struct *work)
+{
+    START_KMSG_WORK(origin_broadcast_cpu_table_request_t, req, work);
+    origin_broadcast_cpu_table_response_t *res = pcn_kmsg_get(sizeof(*res));
+    int from_nid = PCN_KMSG_FROM_NID(req);
+    struct task_struct *tsk = __get_task_struct(req->remote_pid);
+	int ret = 0, i;
+
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	BUG_ON(!tsk);
+#endif
+
+	POP_PK("\t\t => %s(): [%d/%d]\n", __func__, my_nid, req->remote_pid);
+
+	/* load to my (remote) gvcpu_to_nid */
+	//memcpy(gvcpu_to_nid, req->vcpu_to_nid, sizeof(*gvcpu_to_nid) * MAX_POPCORN_VCPU);
+	for (i = 0; i < MAX_POPCORN_VCPU; i++) {
+		atomic64_set(&gvcpu_to_nid[i], req->vcpu_to_nid[i]);
+	}
+
+	{
+		g_popcorn_vcpu_cnt = pophype_available_vcpu();
+		POP_PK("\t(remote) %s(): calculated g_popcorn_vcpu_cnt = %d\n",
+				__func__, g_popcorn_vcpu_cnt);
+		first_fd_after_vcpufd = g_popcorn_vcpu_cnt + VCPU_FD_BASE;
+	}
+
+	res->ret = ret;
+    res->from_pid = req->from_pid;
+	res->ws = req->ws;
+	pcn_kmsg_post(PCN_KMSG_TYPE_ORIGIN_BROADCAST_CPU_TABLE_RESPONSE,
+											from_nid, res, sizeof(*res));
+    END_KMSG_WORK(req);
+}
+
+static int handle_origin_broadcast_cpu_table_response(struct pcn_kmsg_message *msg)
+{
+    origin_broadcast_cpu_table_response_t *res =
+		(origin_broadcast_cpu_table_response_t *)msg;
+    struct wait_station *ws = wait_station(res->ws);
+
+    ws->private = res;
+
+	complete(&ws->pendings);
+	POP_PK("%s():\n", __func__);
+
+    return 0;
+}
+
+// <*> only origin does it
+SYSCALL_DEFINE1(popcorn_broadcast_cpu_table, int __user *, vcpu_to_nid)
+{
+	origin_broadcast_cpu_table_request_t *req;
+	struct remote_context *rc = current->mm->remote;
+	struct wait_station *ws;
+	int i;
+
+	req = kmalloc(sizeof(*req), GFP_KERNEL);
+	BUG_ON(current->at_remote || !req || !rc); /* check your msg_layer!! */
+	req->from_pid = current->pid;
+
+	//POP_PK("\t%s(): TODO give right node table for vcpu->node&fd\n", __func__);
+
+	/* customize */
+	{
+		int lvcpu_to_nid[MAX_POPCORN_VCPU];
+		POP_PK("%s(): nodes %d / %d\n", __func__, get_popcorn_nodes(), MAX_POPCORN_VCPU);
+		if (copy_from_user(lvcpu_to_nid, vcpu_to_nid, sizeof(int) * MAX_POPCORN_VCPU))
+			BUG(); /* or return -EFAULT; */
+		for (i = 0; i < MAX_POPCORN_VCPU; i++) {
+			atomic64_set(&gvcpu_to_nid[i], lvcpu_to_nid[i]);
+		}
+
+		g_popcorn_vcpu_cnt = pophype_available_vcpu();
+
+		POP_PK("\t(origin) %s(): calculated g_popcorn_vcpu_cnt = %d\n",
+				__func__, g_popcorn_vcpu_cnt);
+		first_fd_after_vcpufd = g_popcorn_vcpu_cnt + VCPU_FD_BASE;
+		POP_PK("%s(): all set\n\n", __func__);
+
+		/* for ingroming remotes' tables */
+		memcpy(req->vcpu_to_nid, lvcpu_to_nid, sizeof(*lvcpu_to_nid) * MAX_POPCORN_VCPU);
+	}
+
+
+	for (i = 0; i < get_popcorn_nodes(); i++) {
+		origin_broadcast_cpu_table_response_t *res;
+		if (my_nid == i) continue;
+		ws = get_wait_station(current);
+		req->ws = ws->id;
+		req->remote_pid = rc->remote_tgids[i]; /* look for remote worker pid */
+		while (!req->remote_pid) {
+			printk(KERN_ERR "\tOrigin runs too fast. "
+					"Wait for remote thread inited. "
+					"Or forgot migrating thread before calling this func!\n");
+			msleep(100);
+			req->remote_pid = rc->remote_tgids[i];
+		}
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+		BUG_ON(!req->remote_pid);
+#endif
+
+		POP_PK("\t\t%s(): => [%d/%d]\n", __func__, i, req->remote_pid);
+		pcn_kmsg_send(PCN_KMSG_TYPE_ORIGIN_BROADCAST_CPU_TABLE_REQUEST,
+													i, req, sizeof(*req));
+		res = wait_at_station(ws);
+		BUG_ON(res->ret);
+		pcn_kmsg_done(res);
+	}
+
+	kfree(req);
+//////////////////////////////////
+
+	return false;
+}
+
+/* README: move to other place
+we need to register vcpu thread pid table at origin and remote.
+pophype_checkin_vcpu_pid: TODO
+pophype_origin_checkin_vcpu_pid: origin saves remote's pid (and respond with its)
+	Remote migrates back to origin and invoke this function sending the pid to the remote node.
+
+*/
+
+/* <*> only origin does it
+	rename to origin BROADCAST vcpu pid
+	from_nid is the node id asking origin to perform this function */
+SYSCALL_DEFINE1(pophype_origin_checkin_vcpu_pid, int __user, from_nid)
+{
+	pophype_request_t *req;
+	struct remote_context *rc = current->mm->remote;
+	struct wait_station *ws;
+	int nid;
+	pophype_response_t *res;
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	BUG_ON(my_nid);
+#endif
+	SIGVPRINTK("\t\t%s(): pid %d\n",
+			__func__,  current->pid);
+
+	// argument not used.
+	//hype_node_info[from_nid][VCPU_FD_BASE + from_nid]->origin_pid =
+	//													current->pid;
+
+	req = kmalloc(sizeof(*req), GFP_KERNEL);
+	BUG_ON(!req);
+	req->from_pid = current->pid;
+
+	/* The remove nid asking origin to broadcast this */
+	//req->from_nid = from_nid;
+
+	nid = from_nid;
+	BUG_ON(nid == my_nid);
+	// only to from_nid or every one?
+	//for (nid = 0; nid < get_popcorn_nodes(); nid++) {
+	//	if (nid == my_nid) continue;
+		ws = get_wait_station(current);
+		req->ws = ws->id;
+		req->remote_pid = rc->remote_tgids[nid];
+
+		pcn_kmsg_send(PCN_KMSG_TYPE_ORIGIN_CHECKIN_VCPU_PID_REQUEST,
+										nid, req, sizeof(*req));
+		res = wait_at_station(ws);
+		BUG_ON(res->ret);
+		pcn_kmsg_done(res);
+	//}
+
+	kfree(req);
+	return false;
+}
+
+/* <!*> only remote does it */
+/* TODO rename corresponding to remote_checkin_vcpu_pid not checkin_vcpu_pid
+	pid: tgid/group id, so that the signal converting can always succeed
+*/
+SYSCALL_DEFINE1(pophype_remote_checkin_vcpu_pid, int __user, pid)
+{
+	pophype_request_t *req;
+	struct remote_context *rc = current->mm->remote;
+	struct wait_station *ws;
+	int origin = 0;
+	pophype_response_t *res;
+
+	req = kmalloc(sizeof(*req), GFP_KERNEL);
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	BUG_ON(!my_nid || !current->at_remote || !req || !rc);
+#endif
+	req->from_pid = current->pid;
+
+	/* customize */
+	// none
+
+	ws = get_wait_station(current);
+	req->ws = ws->id;
+	req->from_pid = current->pid;
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	BUG_ON(!req->remote_pid);
+
+	{
+	struct task_struct *p;
+	p = find_task_by_vpid(current->pid);
+	SIGVPRINTK("\t\t<< %s(): sanity check p %p curr->pid %d\n",
+			__func__, p,  current->pid);
+	}
+#endif
+
+//	SIGVPRINTK("\t\t%s(): checkin "
+//			"this vcpu thread's pid %d at origin => origin\n",
+//			__func__,  current->pid);
+	pcn_kmsg_send(PCN_KMSG_TYPE_REMOTE_CHECKIN_VCPU_PID_REQUEST,
+										origin, req, sizeof(*req));
+
+	// Optimization - no need to sync
+	res = wait_at_station(ws);
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	BUG_ON(res->ret);
+#endif
+	pcn_kmsg_done(res);
+
+	/* 1st[] indicates the pid on this node
+		2nd[] indicates the vcpu id */
+	hype_node_info[my_nid][VCPU_FD_BASE + origin]->remote_pid =
+												current->pid;
+	//hype_node_info[my_nid][VCPU_FD_BASE + my_nid]->origin_pid =
+	//											res->origin_pid;
+	SIGVPRINTK("\t\t<< %s(): checkin curr->pid %d "
+			"install hype_node_info[%d][%d]->remote_pid %d\n",
+			//"install hype_node_info[%d][%d]->remote_pid %d ->origin_pid %d\n",
+			__func__,  current->pid,
+			my_nid, VCPU_FD_BASE + my_nid, current->pid);
+			//, res->origin_pid);
+
+	kfree(req);
+	return false;
+}
+
+
+/*
+// called in host userspace x86#: 381
+// TODO: rename to pophype_prepare_vcpu_migrate
+	Refere to pophype migration from VM : KVM_HC_POPHYPE_MIGRATE
+		arch/x86/kvm/x86.c
+ */
+SYSCALL_DEFINE1(pophype_migrate_on_hostusr, int, vcpu_id)
+{
+    int fd = vcpu_id + VCPU_FD_BASE;
+    struct kvm_vcpu *vcpu = hype_node_info[my_nid][fd]->vcpu;
+
+	BUG_ON(!vcpu);
+    PHGMIGRATEPRINTK("[%d] <%d> %s %d %s(): Start save <%d> "
+			"(=pophype_prepare_vcpu_migrate())\n",
+            current->pid, smp_processor_id(),
+            __FILE__, __LINE__, __func__, vcpu->vcpu_id);
+
+    /******/
+    /* save state for pophype migration */
+    /******/
+    /* uhype states */
+    pophype_save_vcpu_states(vcpu);
+
+	/* debug */
+	pophype_vcpu_check_vmcs(vcpu);
+	pophype_dump_vmcs();
+
+    PHGMIGRATEPRINTK("[%d] <%d> %s %d %s(): Done save <%d> - "
+            "you can now call migrate from host user "
+			"(=pophype_prepare_vcpu_migrate())\n",
+            current->pid, smp_processor_id(),
+            __FILE__, __LINE__, __func__, vcpu->vcpu_id);
+	PHMIGRATEPRINTK("\n\n\n\n\n\n\n");
+
+    return 0;
+}
+
+/* Because the invoker is not the target vcpu thread */
+SYSCALL_DEFINE1(pophype_vcpu_migrate_trigger, int __user, vcpu_id)
+{
+	int fd = vcpu_id + VCPU_FD_BASE; /* TODO - this is a HACK. */
+	struct kvm_vcpu *vcpu = hype_node_info[my_nid][fd]->vcpu;
+
+	SIGVPRINTK("\t\t[%d] %s(): I wanna migrate vcpu<%d> %p\n",
+				current->pid, __func__, vcpu_id, vcpu);
+	BUG_ON(!vcpu);
+
+	smp_wmb();
+	//set_bit(KVM_APIC_SIPI, &apic->pending_events); //TODO MY bit but not sure tihs will make vm exit to usr
+/////////
+	// case APIC_DM_REMRD:
+	vcpu->arch.pv.pv_unhalted = 1;
+	kvm_make_request(KVM_REQ_EVENT, vcpu);
+	kvm_vcpu_kick(vcpu);
+
+	kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);
+	kvm_vcpu_kick(vcpu);
+/////////
+	kvm_make_request(KVM_REQ_VCPU_MIGRATION, vcpu);
+	//set_bit(KVM_REQ_VCPU_MIGRATION, &vcpu->requests);
+	kvm_vcpu_kick(vcpu);
+	kvm_make_request(KVM_REQ_VCPU_MIGRATION, vcpu);
+	kvm_vcpu_kick(vcpu);
+	kvm_make_request(KVM_REQ_VCPU_MIGRATION, vcpu);
+	kvm_vcpu_kick(vcpu);
+	//kvm_arch_vcpu_should_kick(vcpu);
+	//smp_send_reschedule(vcpu->vcpu_id);
+	smp_send_reschedule(vcpu->cpu);
+	//smp_send_reschedule(get_cpu());
+	//smp_send_reschedule(vcpu->vcpu_id);
+	{
+		int me;
+		int cpu = vcpu->cpu;
+		wait_queue_head_t *wqp;
+
+		wqp = kvm_arch_vcpu_wq(vcpu);
+		if (waitqueue_active(wqp)) {
+			wake_up_interruptible(wqp);
+			++vcpu->stat.halt_wakeup;
+		}
+
+		me = get_cpu();
+		printk("vcpu->cpu %d me %d vcpu->vcpu_id %d cpu_online() = \"%s\"\n",
+				cpu, me, vcpu->vcpu_id, cpu_online(cpu) ? "ONLINE" : "OFFLINE");
+		if (cpu != me && (unsigned)cpu < nr_cpu_ids && cpu_online(cpu))
+			if (kvm_arch_vcpu_should_kick(vcpu))
+				smp_send_reschedule(cpu);
+		put_cpu();
+
+	}
+	SIGVPRINTK("\t\t[%d] %s(): kicked vcpu<%d> %p\n",
+			current->pid, __func__, vcpu->vcpu_id, vcpu);
+
+#if 0
+	{
+//#include <kvm/iodev.h>
+//#include <kvm/ioapic.h>
+//#include "../arch/x86/kvm/ioapic.h" // Jack arch
+//#include "../arch/x86/kvm/irq_comm.c" // Jack arch
+#include "../arch/x86/kvm/irq.h" // Jack arch
+//#include <asm/kvm_host.h>
+//#include <linux/kvm_host.h>
+//#include <linux/kvm_host.h>
+//#include <linux/slab.h>
+//#include <linux/export.h>
+//#include <trace/events/kvm.h>
+		int apicid = vcpu->vcpu_id;
+		struct kvm_lapic_irq lapic_irq;
+
+		lapic_irq.shorthand = 0;
+		lapic_irq.dest_mode = 0;
+		lapic_irq.dest_id = apicid;
+		lapic_irq.msi_redir_hint = false;
+
+		lapic_irq.delivery_mode = APIC_DM_REMRD;
+		kvm_irq_delivery_to_apic(vcpu->kvm, NULL, &lapic_irq, NULL);
+
+		SIGVPRINTK("\t\t[%d] %s(): kicked vcpu<%d> - 2\n",
+					current->pid, __func__, vcpu->vcpu_id);
+	}
+#endif
+	return 0;
+}
+
+/* Update vcpu - let other remote nodes know the current global vCPU view */
+static void popcorn_update_cpu_table(int migrated_vcpu, int migrate_to_nid)
+{
+	int nid;
+	/* Testing my protection implementation in
+			__build_and_check_msg() pcn_kmsg.c
+		Test optimization. */
+	for (nid = 0; nid < MAX_POPCORN_NODES; nid++) {
+	//for (nid = 0; nid < get_popcorn_nodes(); nid++) {
+			update_cpu_table_request_t *req; // new
+		if (nid == migrate_to_nid || nid == my_nid) continue; /* handled in migration routines */
+		//update_cpu_table_request_t *req; // origin
+		req = pcn_kmsg_get(sizeof(*req)); // new
+		// test online
+
+		//req = pcn_kmsg_get(sizeof(*req));
+		/* Custom */
+		req->migrated_vcpu = migrated_vcpu;
+		req->migrate_to_nid = migrate_to_nid;
+		//req->migrate_from_nid = my_nid; /* always from me to others */
+
+		/* This will release req!! */
+		if(pcn_kmsg_post(PCN_KMSG_TYPE_UPDATE_CPU_TABLE_REQUEST_FIELDS,
+										nid, req, sizeof(*req))) {
+			PHMIGRATEPRINTK("FAIL: %s %d %s(): to [%d]\n",
+						__FILE__, __LINE__, __func__, nid); /* debug */
+		}
+		//pcn_kmsg_put(req); // origin
+	}
+}
+
+/* (remote) -  */
+static void process_update_cpu_table_request(struct work_struct *work)
+{
+	START_KMSG_WORK(update_cpu_table_request_t, req, work);
+
+	atomic64_set(&gvcpu_to_nid[req->migrated_vcpu], req->migrate_to_nid);
+	PHMIGRATEPRINTK("-> got vcpu table updated gvcpu_to_nid[%d] = %d\n",
+								req->migrated_vcpu, req->migrate_to_nid);
+#if HPMIGRATION_DEBUG /* debug */
+	{
+		static int cnt = 0;
+		cnt++;
+		POP_PK("\t-> <%d> on [%d] #%d\n",
+				req->migrated_vcpu, req->migrate_to_nid, cnt);
+		popcorn_show_gcpu_table();
+	}
+#endif
+
+	END_KMSG_WORK(req);
+}
+
+/*
+ * KVM_IPI - needed since cannot know dst_cpu until kvm_irq_delivery_to_apic_fast()
+ * ret: succ cnt
+ */
+int popcorn_send_ipi(struct kvm_vcpu *dst_vcpu, struct kvm_lapic_irq *irq, unsigned long *dest_map)
+{
+	ipi_response_t *res; /* kvm_ipi_req/res */
+	ipi_request_t *req;
+	struct remote_context *rc = current->mm->remote;
+	struct wait_station *ws;
+	int r = 0, dst_nid = popcorn_vcpuid_to_nid(dst_vcpu->vcpu_id);
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	ktime_t dt, ipi_end, ipi_start = ktime_get();
+#endif
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	static int popcorn_ipi_at_atomic_cnt = 0;
+	if (in_interrupt() || in_atomic() || irqs_disabled()) {
+		popcorn_ipi_at_atomic_cnt++;
+		if (popcorn_ipi_at_atomic_cnt < 1000 ||
+			!(popcorn_ipi_at_atomic_cnt % 10000) ) {
+			FTPRINTK("%s(): my_nid %d dst_vcpu %d [%d] "
+				"in int %s atomic %s irq_disable %s #%d\n",
+				__func__, my_nid, dst_vcpu->vcpu_id, dst_nid,
+				in_interrupt() ? "O":"X", in_atomic() ? "O":"X",
+				irqs_disabled() ? "O":"X", popcorn_ipi_at_atomic_cnt);
+			//dump_stack(); // at runtime from vhost-net's handle_rx
+		}
+	}
+#endif
+	if (my_nid == dst_nid) return r; /* prevented at the outside as well */
+
+	//req = kmalloc(sizeof(*req), GFP_KERNEL);
+	req = kmalloc(sizeof(*req), GFP_ATOMIC);
+	ws = get_wait_station(current);
+	//BUG_ON(current->at_remote || !req || !rc);
+	BUG_ON(!req || !rc);
+	req->from_pid = current->pid;
+	req->ws = ws->id;
+
+	/* customize */
+
+	req->fd = vcpuid_to_fd(dst_vcpu->vcpu_id);
+
+	/* This is my assumption (always !dest_map except our pophype request)
+											for using REMOTE_APIC */
+	BUG_ON(dest_map);
+
+	/* No pte inside */
+	memcpy(&req->irq, irq, sizeof(*irq));
+
+	/* p2p */
+	//BUG_ON(my_nid == dst_vcpu) continue;
+	IPIVPRINTK("\t\t%s(): =kvmipi> [%d] <%d> irq->delivery_mode 0x%x "
+				"->dest_id <%u>\n",
+				__func__, dst_nid, dst_vcpu->vcpu_id,
+				irq->delivery_mode, irq->dest_id);
+	req->remote_pid = rc->remote_tgids[dst_nid];
+	pcn_kmsg_send(PCN_KMSG_TYPE_IPI_REQUEST, dst_nid, req, sizeof(*req));
+	res = wait_at_station(ws);
+	r += res->ret;
+	pcn_kmsg_done(res);
+
+	kfree(req);
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	ipi_end = ktime_get();
+	dt = ktime_sub(ipi_end, ipi_start);
+	atomic64_add(ktime_to_ns(dt), &ipi_ns);
+	atomic64_inc(&ipi_cnt);
+#endif
+
+	return r;
+}
+
+static void process_ipi_request(struct work_struct *work)
+{
+    START_KMSG_WORK(ipi_request_t, req, work);
+    ipi_response_t *res = pcn_kmsg_get(sizeof(*res));
+    int from_nid = PCN_KMSG_FROM_NID(req);
+    struct task_struct *tsk = __get_task_struct(req->remote_pid);
+	int ret = 0;
+	struct fd dst_fd;
+	unsigned long v;
+	struct file *filp;
+	struct kvm_vcpu *vcpu; // TODO rename to dst_vcpu
+	struct kvm_lapic *apic; /* Source vcpu's apic */
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	ktime_t dt, ipi_handle_end, ipi_handle_start = ktime_get();
+#endif
+	//struct kvm_lapic *apic;
+	/* cust */
+	//int *lcpus = req->cpus;
+	//int lcpus[255];
+	//u32 reg = req->reg;
+
+	/* Do remotely */
+	//struct kvm_vcpu *vcpu;
+	struct kvm_lapic_irq *irq = &req->irq;
+	unsigned long *dest_map = NULL; // TODO no need to support so far
+	BUG_ON(!tsk && "No task exist");
+
+	v = fget_light_tsk(tsk, req->fd, FMODE_PATH);
+	dst_fd = (struct fd){(struct file *)(v & ~3),v & 3};
+	filp = dst_fd.file;
+	BUG_ON(!filp);
+	vcpu = filp->private_data;
+	BUG_ON(!vcpu);
+	fdput(dst_fd);
+
+	// too many mode=0
+	if (irq->delivery_mode) { // dbg
+		IPIVPRINTK("\t\t => %s(): -> irq->dest_id <%d> **fd %d <%d>** "
+					"irq->delivery_mode 0x%x\n",
+					__func__, irq->dest_id, req->fd,
+					vcpu->vcpu_id, irq->delivery_mode);
+	}
+
+	/* Source vcpu's apic */
+	apic = vcpu->arch.apic;
+
+	/* HACK? not really? just for my convenience */
+	/* trick: at this moment irq->delivery_mode alredy defined */
+	/* TODO */
+	/* BUG TODO now it redo on all cpus..... */
+	/* BUG should I do tsk struct? but the ipi is just one cpu TODO TOD TODO BUG */
+	// BUG
+	// BUG
+	if (irq->delivery_mode == APIC_DM_STARTUP ||
+		irq->delivery_mode == APIC_DM_INIT) { // ICR's two SIPI (1..., 2...)
+		// a INIT-SIPI-SIPI (ISS) sequence
+		ret = popcorn_kvm_apic_set_irq(vcpu, irq, dest_map);
+	} else { /* other ICRs and others (watchout including 0 APIC_DM_FIXED) */
+		/* DM_FIXED means broadcast and low priority? (from kvm_irq_delivery_to_apic()) */
+#if HYPE_PERF_CRITICAL_DEBUG
+		static unsigned long dm_fixed_cnt = 0;
+		if (irq->delivery_mode == APIC_DM_FIXED) {
+			dm_fixed_cnt++;
+			if (dm_fixed_cnt < 300 || !(dm_fixed_cnt % 10000)) {
+				POP_PK("\t => from remote got APIC_DM_FIXED #%lu\n", dm_fixed_cnt);
+			}
+		} else {
+			printk(KERN_ERR "\t => From remote. " /* Never */
+					"These are the delivery_mode that I don't know 0x%x\n",
+														irq->delivery_mode);
+		}
+#endif
+
+		ret = popcorn_apic_inject_ipi(apic, irq, vcpu->vcpu_id);
+	}
+
+	IPIVPRINTK("\t\t >> %s(): done ***fd %d <%d>***\n",
+					__func__, req->fd, vcpu->vcpu_id);
+
+	// THIS IS FOR DEBUGGIN PLZ KILL (TODO also kill in types.h)
+	//memcpy(&res->irq, irq, sizeof(*irq));
+
+	res->ret = ret;
+    res->from_pid = req->from_pid;
+	res->ws = req->ws;
+	pcn_kmsg_post(PCN_KMSG_TYPE_IPI_RESPONSE,
+					from_nid, res, sizeof(*res));
+    END_KMSG_WORK(req);
+
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	ipi_handle_end = ktime_get();
+	dt = ktime_sub(ipi_handle_end, ipi_handle_start);
+	atomic64_add(ktime_to_ns(dt), &ipi_handle_ns);
+	atomic64_inc(&ipi_handle_cnt);
+#endif
+}
+
+static int handle_ipi_response(struct pcn_kmsg_message *msg)
+{
+	ipi_response_t *res = (ipi_response_t *)msg;
+    struct wait_station *ws = wait_station(res->ws);
+
+	// THIS IS FOR DEBUGGIN PLZ KILL (also in types.h)
+	struct kvm_lapic_irq *irq = &res->irq;
+	static int cnt = 0;
+	cnt++;
+
+    ws->private = res;
+
+	complete(&ws->pendings);
+	if (irq->delivery_mode) {
+		IPIVPRINTK("\t\t << %s(): mode 0x%x #%d\n", __func__, irq->delivery_mode, cnt);
+	}
+
+    return res->ret;
+}
+
+/**
+ * Pophype signal broadcast (redirection to all remote nodes)
+ * Important:
+#if 0
+ */
+int popcorn_broadcast_sig(int usr_sig)
+{
+	sig_response_t *res;
+	sig_request_t *req;
+	struct remote_context *rc = current->mm->remote;
+	struct wait_station *ws;
+	int r = 0, nid;
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	ktime_t dt, sig_end, sig_start = ktime_get();
+#endif
+
+	req = kmalloc(sizeof(*req), GFP_KERNEL);
+	//BUG_ON(current->at_remote || !req || !rc);
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	BUG_ON(!req || !rc);
+#endif
+	req->from_pid = current->pid;
+
+	/* customize */
+	//req->fd = vcpuid_to_fd(dst_vcpu->vcpu_id);
+	req->usr_sig = usr_sig;
+	/* do_tkill */
+	//struct siginfo info = {};
+	req->siginfo.si_signo = usr_sig;
+	req->siginfo.si_errno = 0;
+	req->siginfo.si_code = SI_TKILL;
+	//req->siginfo.si_pid = task_tgid_vnr(current);
+	//req->siginfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());
+
+
+	for (nid = 0; nid < get_popcorn_nodes(); nid++) {
+		if (nid == my_nid) continue;
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+		BUG_ON(!hype_node_info[nid][VCPU_FD_BASE + nid]);
+#endif
+		SIGVPRINTK("%s(): pop_hype broadcast => [%d] "
+				"(expect pid  = origin tsk %p remote %d)\n",
+				__func__, nid,
+				hype_node_info[nid][VCPU_FD_BASE + nid]->tsk,
+				//hype_node_info[nid][VCPU_FD_BASE + nid]->tsk->pid,
+				hype_node_info[nid][VCPU_FD_BASE + nid]->remote_pid); /* Attention: aAssuming 1 vcpu on 1 node */
+		ws = get_wait_station(current);
+		req->ws = ws->id;
+
+		/* customize */
+		//req->remote_pid = rc->remote_tgids[nid];
+		//req->siginfo.si_pid = rc->remote_tgids[nid];
+		req->remote_pid =
+				hype_node_info[nid][VCPU_FD_BASE + nid]->remote_pid;
+		req->siginfo.si_pid =
+				hype_node_info[nid][VCPU_FD_BASE + nid]->remote_pid;
+		/* Permission - need updated at remote */
+		//req->siginfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());
+		//req->target_pid = rc->remote_tgids[nid];
+		//req->target_tgid = rc->remote_tgids[nid];
+		req->target_pid = hype_node_info[nid][VCPU_FD_BASE + nid]->remote_pid;
+		req->target_tgid = hype_node_info[nid][VCPU_FD_BASE + nid]->remote_pid;
+		printk("TODO BUG should be right at remote or just put a # <= 0\n");
+		printk("TODO: req->targetpid/tgid are hacking\n");
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+		if (!req->remote_pid) {
+			printk(KERN_ERR "req->remote_pid %d to [%d]", req->remote_pid, nid);
+			BUG_ON(!req->remote_pid); // seems buggy at remote
+		}
+#endif
+
+		pcn_kmsg_send(PCN_KMSG_TYPE_SIG_REQUEST,
+						nid, req, sizeof(*req));
+		res = wait_at_station(ws);
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+		//BUG_ON(res->ret);
+#endif
+		r += res->ret;
+		pcn_kmsg_done(res);
+	}
+
+
+	kfree(req);
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	sig_end = ktime_get();
+	dt = ktime_sub(sig_end, sig_start);
+	atomic64_add(ktime_to_ns(dt), &sig_ns);
+	atomic64_inc(&sig_cnt);
+#endif
+
+	return r;
+}
+
+static void process_sig_request(struct work_struct *work)
+{
+    START_KMSG_WORK(sig_request_t, req, work);
+    sig_response_t *res = pcn_kmsg_get(sizeof(*res));
+    int from_nid = PCN_KMSG_FROM_NID(req);
+   // struct task_struct *tsk = __get_task_struct(req->remote_pid);
+	struct task_struct *tsk = __get_task_struct(req->target_pid);
+	int ret = 0;
+	//struct fd dst_fd;
+	//unsigned long v;
+	//struct file *filp;
+	//struct kvm_vcpu *vcpu; // TODO rename to dst_vcpu
+	//struct kvm_lapic *apic; /* Source vcpu's apic */
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	ktime_t dt, sig_handle_end, sig_handle_start = ktime_get();
+#endif
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	BUG_ON(!my_nid);
+#endif
+
+	/* Reply signal operationsy */
+	//struct siginfo *siginfo = &req->siginfo;
+	SIGVPRINTK("\t\t -> %s(): call pophype_do_send_specific_at_remote() "
+				"with usr_sig %d target tgid %d [pid %d]\n",
+					__func__, req->usr_sig, req->target_tgid, req->target_pid);
+
+	// uid: check __task_cred(task) at include/linux/cred.h
+	// ns: check
+	//struct task_struct *tsk = __get_task_struct(req->remote_pid);
+	//struct user_namespace *ns = task_active_pid_ns(__get_task_struct(target_pid));
+	//req->siginfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());
+	//req->siginfo.si_uid = from_kuid_munged(&init_user_ns, current_uid());
+	req->siginfo.si_uid = from_kuid_munged(&init_user_ns, task_uid(tsk));
+	SIGVPRINTK("\t\t %s(): trying si_uid %d\n",
+					__func__, req->siginfo.si_uid);
+	ret = pophype_do_send_specific_at_remote(req->target_tgid,
+					req->target_pid, req->usr_sig, &req->siginfo);
+	SIGVPRINTK("\t\t >> %s(): done ret = %d\n", __func__, ret);
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	//BUG_ON(ret);
+#endif
+
+	/* ACK results */
+	res->ret = ret;
+    res->from_pid = req->from_pid;
+	res->ws = req->ws;
+	pcn_kmsg_post(PCN_KMSG_TYPE_SIG_RESPONSE,
+					from_nid, res, sizeof(*res));
+    END_KMSG_WORK(req);
+
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	sig_handle_end = ktime_get();
+	dt = ktime_sub(sig_handle_end, sig_handle_start);
+	atomic64_add(ktime_to_ns(dt), &sig_handle_ns);
+	atomic64_inc(&sig_handle_cnt);
+#endif
+}
+
+static int handle_sig_response(struct pcn_kmsg_message *msg)
+{
+	sig_response_t *res = (sig_response_t *)msg;
+    struct wait_station *ws = wait_station(res->ws);
+
+	// THIS IS FOR DEBUGGIN PLZ KILL (also in types.h)
+	static int cnt = 0;
+	cnt++;
+
+    ws->private = res;
+
+	complete(&ws->pendings);
+	SIGVPRINTK("\t\t << %s(): #%d\n", __func__, cnt);
+
+    return res->ret;
+}
+
+/*****/
+static void process_checkin_vcpu_pid_request(struct work_struct *work)
+{
+    START_KMSG_WORK(pophype_request_t, req, work);
+    pophype_response_t *res = pcn_kmsg_get(sizeof(*res));
+    int from_nid = PCN_KMSG_FROM_NID(req);
+   // struct task_struct *tsk = __get_task_struct(req->remote_pid);
+	int ret = 0;
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	BUG_ON(my_nid);
+#endif
+
+	/* assumption: 1 vcpu on 1 node */
+	SIGVPRINTK("\t\t -> %s(): [%d] install vcpu<%d> pid %d at origin. "
+				"My pid %d (hype_node_info[][]->remote_pid %d\n",
+				__func__, current->pid, from_nid, req->from_pid,
+				current->pid, req->from_pid);
+	/* current->pid is wrong. use rc */
+
+	hype_node_info[from_nid][VCPU_FD_BASE + from_nid]->remote_pid =
+														req->from_pid;
+	//res->origin_pid = current->pid;
+
+	SIGVPRINTK("\t\t << %s(): done\n", __func__);
+
+
+
+	/* ACK results */
+	res->ret = ret;
+    res->from_pid = req->from_pid;
+	res->ws = req->ws;
+	pcn_kmsg_post(PCN_KMSG_TYPE_REMOTE_CHECKIN_VCPU_PID_RESPONSE,
+					from_nid, res, sizeof(*res));
+    END_KMSG_WORK(req);
+}
+
+static int handle_checkin_vcpu_pid_response(struct pcn_kmsg_message *msg)
+{
+	pophype_response_t *res = (pophype_response_t *)msg;
+    struct wait_station *ws = wait_station(res->ws);
+
+	// THIS IS FOR DEBUGGIN PLZ KILL (also in types.h)
+	static int cnt = 0;
+	cnt++;
+
+    ws->private = res;
+
+	complete(&ws->pendings);
+	//SIGVPRINTK("\t\t << %s(): res->origin_pid %d #%d\n",
+	//						__func__, res->origin_pid, cnt);
+	SIGVPRINTK("\t\t << %s():#%d\n", __func__, cnt);
+
+    return res->ret;
+}
+
+/*****/
+static void process_origin_checkin_vcpu_pid_request(struct work_struct *work)
+{
+    START_KMSG_WORK(pophype_request_t, req, work);
+    pophype_response_t *res = pcn_kmsg_get(sizeof(*res));
+    int from_nid = PCN_KMSG_FROM_NID(req);
+   // struct task_struct *tsk = __get_task_struct(req->remote_pid);
+	int ret = 0;
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	BUG_ON(!my_nid);
+#endif
+
+	/* assumption: 1 vcpu on 1 node */
+	SIGVPRINTK("\t\t -> %s(): [%d] install vcpu<%d> pid %d at remote. "
+				"My pid %d (hype_node_info[%d][%d]->origin_pid "
+				"= req->from_pid %d)\n",
+					__func__, current->pid, from_nid,
+					req->from_pid, current->pid,
+					from_nid, VCPU_FD_BASE + from_nid,
+					req->from_pid);
+	/* current->pid is wrong. use rc */
+
+	BUG_ON(from_nid); /* only from origin */
+	hype_node_info[from_nid][VCPU_FD_BASE + from_nid]->origin_pid =
+														req->from_pid;
+
+	SIGVPRINTK("\t\t << %s(): done\n", __func__);
+
+	/* ACK results */
+	res->ret = ret;
+    res->from_pid = req->from_pid;
+	res->ws = req->ws;
+	pcn_kmsg_post(PCN_KMSG_TYPE_ORIGIN_CHECKIN_VCPU_PID_RESPONSE,
+					from_nid, res, sizeof(*res));
+    END_KMSG_WORK(req);
+}
+
+static int handle_origin_checkin_vcpu_pid_response(struct pcn_kmsg_message *msg)
+{
+	pophype_response_t *res = (pophype_response_t *)msg;
+    struct wait_station *ws = wait_station(res->ws);
+
+	// THIS IS FOR DEBUGGIN PLZ KILL (also in types.h)
+	static int cnt = 0;
+	cnt++;
+
+    ws->private = res;
+
+	complete(&ws->pendings);
+	SIGVPRINTK("\t\t << %s(): #%d\n",
+						__func__, cnt);
+
+    return res->ret;
+}
+
+/************
+ * Pophype migration - copy kvm/vcpu states
+ */
+/* for arch/x86/kvm/vmx.c to call (fail)
+ * TODO check how arch/x86/kvm/vmx.c call a function from outside.
+ */
+
+void show_cpu_states(struct kvm_vcpu *dst_vcpu, struct kvm_vcpu *src_vcpu)
+{
+#if POPHYPE_MIGRATE_DEBUG
+	BUG_ON(!src_vcpu);
+	if (!dst_vcpu)
+		dst_vcpu = src_vcpu;
+	PHMIGRATEPRINTK("\n------- %s(): vcpu states (common) start (not up-to-date) -------\n", __func__);
+	PHMIGRATEPRINTK("\t[ck] [vcpu] [old] -> [new]\n");
+	PHMIGRATEPRINTK("\t[ck] [vcpu] *kvm *%p -?> %p\n", dst_vcpu->kvm, src_vcpu->kvm);
+#ifdef CONFIG_PREEMPT_NOTIFIERS
+	PHMIGRATEPRINTK("\t[ck] [vcpu] &vcpu->preempt_notifier *%p -?> %p (changed)\n", &dst_vcpu->preempt_notifier, &src_vcpu->preempt_notifier);
+#endif
+	PHMIGRATEPRINTK("\t[ck] [vcpu] cpu %d -?> %d\n", dst_vcpu->cpu, src_vcpu->cpu);
+	PHMIGRATEPRINTK("\t[ck] [vcpu] vcpu_id %d -?> %d\n", dst_vcpu->vcpu_id, src_vcpu->vcpu_id);
+#ifdef CONFIG_POPCORN_HYPE
+	PHMIGRATEPRINTK("\t[ck] [vcpu] nid %d -?> %d (todo)\n", dst_vcpu->nid, src_vcpu->nid);
+	PHMIGRATEPRINTK("\t[ck] [vcpu] vaddr %lx -?> %lx\n", dst_vcpu->vaddr, src_vcpu->vaddr);
+#endif
+	PHMIGRATEPRINTK("\t[ck] [vcpu] srcu_idx %d -?> %d (changed)\n", dst_vcpu->srcu_idx, src_vcpu->srcu_idx);
+	PHMIGRATEPRINTK("\t[ck] [vcpu] mode %d -?> %d\n", dst_vcpu->mode, src_vcpu->mode);
+	PHMIGRATEPRINTK("\t[ck] [vcpu] requests %lu -?> %lu\n", dst_vcpu->requests, src_vcpu->requests);
+	PHMIGRATEPRINTK("\t[ck] [vcpu] guest_debug %lu -?> %lu\n", dst_vcpu->guest_debug, src_vcpu->guest_debug);
+
+	PHMIGRATEPRINTK("\t[ck] [vcpu] pre_pcpu %d -?> %d\n", dst_vcpu->pre_pcpu, src_vcpu->pre_pcpu);
+	//PHMIGRATEPRINTK("\t[ck] [vcpu] &blocked_vcpu_list %p -?> %p\n", dst_vcpu, src_vcpu);
+
+	//PHMIGRATEPRINTK("\t[ck] [vcpu] &mutex %p -?> %p\n", dst_vcpu, src_vcpu);
+	PHMIGRATEPRINTK("\t[ck] [vcpu] *run *%p -?> %p\n", dst_vcpu->run, src_vcpu->run);
+
+	PHMIGRATEPRINTK("\t[ck] [vcpu] fpu_active %d -?> %d\n", dst_vcpu->fpu_active, src_vcpu->fpu_active);
+	PHMIGRATEPRINTK("\t[ck] [vcpu] guest_fpu_loaded %d -?> %d\n", dst_vcpu->guest_fpu_loaded, src_vcpu->guest_fpu_loaded);
+	PHMIGRATEPRINTK("\t[ck] [vcpu] guest_xcr0_loaded %d -?> %d\n", dst_vcpu->guest_xcr0_loaded, src_vcpu->guest_xcr0_loaded);
+	PHMIGRATEPRINTK("\t[ck] [vcpu] fpu_counter %c -?> %c\n", dst_vcpu->fpu_counter, src_vcpu->fpu_counter);
+	//PHMIGRATEPRINTK("\t[ck] [vcpu] &wq %p -?> \n", dst_vcpu, src_vcpu);
+	PHMIGRATEPRINTK("\t[ck] [vcpu] *pid %p -?> %p (fine)\n", dst_vcpu->pid, src_vcpu->pid);
+	PHMIGRATEPRINTK("\t[ck] [vcpu] sigset_active %d -?> %d\n", dst_vcpu->sigset_active, src_vcpu->sigset_active);
+	//PHMIGRATEPRINTK("\t[ck] [vcpu] &sigset %p -?> \n", dst_vcpu, src_vcpu);
+	//PHMIGRATEPRINTK("\t[ck] [vcpu] &stat %p -?> \n", dst_vcpu, src_vcpu);
+	PHMIGRATEPRINTK("\t[ck] [vcpu] halt_poll_ns %u -?> %u\n", dst_vcpu->halt_poll_ns, src_vcpu->halt_poll_ns);
+
+#ifdef CONFIG_HAS_IOMEM
+	PHMIGRATEPRINTK("\t[ck] [vcpu] mmio_needed %d -?> %d\n", dst_vcpu->mmio_needed, src_vcpu->mmio_needed);
+	PHMIGRATEPRINTK("\t[ck] [vcpu] mmio_read_completed %d -?> %d\n", dst_vcpu->mmio_read_completed, src_vcpu->mmio_read_completed);
+	PHMIGRATEPRINTK("\t[ck] [vcpu] mmio_is_write %d -?> %d\n", dst_vcpu->mmio_is_write, src_vcpu->mmio_is_write);
+	PHMIGRATEPRINTK("\t[ck] [vcpu] mmio_cur_fragment %d -?> %d\n", dst_vcpu->mmio_cur_fragment, src_vcpu->mmio_cur_fragment);
+	PHMIGRATEPRINTK("\t[ck] [vcpu] mmio_nr_fragments %d -?> %d\n", dst_vcpu->mmio_nr_fragments, src_vcpu->mmio_nr_fragments);
+	//PHMIGRATEPRINTK("\t[ck] [vcpu] &mmio_fragments[KVM_MAX_MMIO_FRAGMENTS] %p -?> \n", dst_vcpu, src_vcpu);
+#endif
+
+#ifdef CONFIG_KVM_ASYNC_PF
+	//PHMIGRATEPRINTK("\t[ck] [vcpu] &async_pf %p -?> \n", dst_vcpu, src_vcpu);
+#endif
+#ifdef CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT
+	//PHMIGRATEPRINTK("\t[ck] [vcpu] &spin_loop %p -?> \n", dst_vcpu, src_vcpu);
+#endif
+	PHMIGRATEPRINTK("\t[ck] [vcpu] preempted %d -?> %d\n", dst_vcpu->preempted, src_vcpu->preempted);
+	//PHMIGRATEPRINTK("\t[ck] [vcpu] &arch %p -?> %p\n", &dst_vcpu->arch, &src_vcpu->arch);
+#if 0
+	PHMIGRATEPRINTK("\t[ck] [vcpu]  -?> \n", dst_vcpu, src_vcpu);
+	PHMIGRATEPRINTK("\t[ck] [vcpu]  -?> \n", dst_vcpu, src_vcpu);
+	PHMIGRATEPRINTK("\t[ck] [vcpu]  -?> \n", dst_vcpu, src_vcpu);
+#endif
+	PHMIGRATEPRINTK("--------- vcpu->arch.mmu ----------\n");
+	PHMIGRATEPRINTK("\t[ck] dst_vcpu->arch.mmu *%p != %p (nonsense)\n",
+							 &dst_vcpu->arch.mmu, &src_vcpu->arch.mmu);
+	PHMIGRATEPRINTK("\t[ck] dst_vcpu->arch.mmu.page_fault *%p == %p\n",
+				dst_vcpu->arch.mmu.page_fault, src_vcpu->arch.mmu.page_fault);
+
+	PHMIGRATEPRINTK("\t[ck] dst_vcpu->arch.mmu.set_cr3 *%p != %p "
+		"(checking now init_kvm_tdp_mmu) [host kernel function ptr*, DONT NOT OVERWRITE] \n",
+					dst_vcpu->arch.mmu.set_cr3, src_vcpu->arch.mmu.set_cr3);
+	PHMIGRATEPRINTK("\t[ck] dst_vcpu->arch.mmu.get_pdptr *%p == %p\n",
+					dst_vcpu->arch.mmu.get_pdptr, src_vcpu->arch.mmu.get_pdptr);
+	PHMIGRATEPRINTK("\t[ck] dst_vcpu->arch.mmu.inject_page_fault *%p == %p\n",
+					dst_vcpu->arch.mmu.inject_page_fault,
+					src_vcpu->arch.mmu.inject_page_fault);
+	PHMIGRATEPRINTK("\t[ck] dst_vcpu->arch.mmu.gva_to_gpa *%p != %p (checking init_kvm_tdp_mmu)\n",
+			dst_vcpu->arch.mmu.gva_to_gpa, src_vcpu->arch.mmu.gva_to_gpa);
+	PHMIGRATEPRINTK("\t[ck] dst_vcpu->arch.mmu.translate_gpa *%p == %p\n",
+		dst_vcpu->arch.mmu.translate_gpa, src_vcpu->arch.mmu.translate_gpa);
+	PHMIGRATEPRINTK("\t[ck] dst_vcpu->arch.mmu.sync_page *%p == %p\n",
+				dst_vcpu->arch.mmu.sync_page, src_vcpu->arch.mmu.sync_page);
+	PHMIGRATEPRINTK("\t[ck] dst_vcpu->arch.mmu.invlpg *%p == %p\n",
+					dst_vcpu->arch.mmu.invlpg, src_vcpu->arch.mmu.invlpg);
+	PHMIGRATEPRINTK("\t[ck] dst_vcpu->arch.mmu.update_pte *%p == %p\n",
+			dst_vcpu->arch.mmu.update_pte, src_vcpu->arch.mmu.update_pte);
+
+	PHMIGRATEPRINTK("\t[installed] dst_vcpu->arch.mmu.root_hpa 0%llx != 0x%llx "
+					"(ept root)(from vcpu->arch.mmu.pae_root)\n",
+					dst_vcpu->arch.mmu.root_hpa, src_vcpu->arch.mmu.root_hpa);
+	PHMIGRATEPRINTK("\t[installed] dst_vcpu->arch.mmu.root_level %d != %d (will be set in init_kvm_tdp_mmu)\n",
+					dst_vcpu->arch.mmu.root_level, src_vcpu->arch.mmu.root_level);
+	PHMIGRATEPRINTK("\t[ck] dst_vcpu->arch.mmu.shadow_root_level %d == %d (checking now init_kvm_tdp_mmu)\n",
+					dst_vcpu->arch.mmu.shadow_root_level, src_vcpu->arch.mmu.shadow_root_level);
+	PHMIGRATEPRINTK("\t[ck] dst_vcpu->arch.mmu.direct_map %d == %d\n",
+					dst_vcpu->arch.mmu.direct_map, src_vcpu->arch.mmu.direct_map);
+	PHMIGRATEPRINTK("\t[installed] dst_vcpu->arch.mmu.pae_root (ptr*) *%p != %p (to arch.mmu.root_hpa)\n",
+					dst_vcpu->arch.mmu.pae_root, src_vcpu->arch.mmu.pae_root);
+	{
+		int i;
+		for (i = 0; i < 4; ++i) {
+			PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.pae_root[%d] %llx "
+							"(*pae_root check retmoe)\n",
+							i, dst_vcpu->arch.mmu.pae_root[i]);
+		}
+	}
+
+	PHMIGRATEPRINTK("--------- vcpu->arch.mmu.base_role ----------\n");
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.base_role\n");
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.base_role.level %u %u\n",
+					dst_vcpu->arch.mmu.base_role.level, src_vcpu->arch.mmu.base_role.level);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.base_role.direct %u %u\n",
+					dst_vcpu->arch.mmu.base_role.direct, src_vcpu->arch.mmu.base_role.direct);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.base_role.cr4_pae %u %u\n",
+					dst_vcpu->arch.mmu.base_role.cr4_pae, src_vcpu->arch.mmu.base_role.cr4_pae);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.base_role.access %u %u\n",
+					dst_vcpu->arch.mmu.base_role.access, src_vcpu->arch.mmu.base_role.access);
+
+	PHMIGRATEPRINTK("--------- vcpu->arch ----------\n");
+	//vcpu->arch.regs_dirty // cpu_run rwiil reload guest states .........so my states will be gone?
+	PHMIGRATEPRINTK("\t[ck] vcpu->arch.regs_dirty %x %x (bitmap, check if = 1)\n",
+					dst_vcpu->arch.regs_dirty, src_vcpu->arch.regs_dirty);
+	//PHMIGRATEPRINTK("\t [ck] vcpu->kvm.arch.mmu_page_hash[0] %llx %llx\n",
+	//				dst_vcpu->kvm->arch.mmu_page_hash[0], src_vcpu->kvm->arch.mmu_page_hash[0]);
+					// struct hlist_head mmu_page_hash[KVM_NUM_MMU_PAGES]; // Hash table of struct kvm_mmu_page.
+	PHMIGRATEPRINTK("\t [ck] vcpu->kvm.arch.mmu_page_hash *%p %p ([KVM_NUM_MMU_PAGES])\n",
+					dst_vcpu->kvm->arch.mmu_page_hash,
+					src_vcpu->kvm->arch.mmu_page_hash);
+
+	{ int i;
+		for (i = 0; i < 4; ++i) {
+			PHMIGRATEPRINTK("\t [ck] vcpu->arch.walk_mmu->pdptrs[%d] %llx %llx\n", i,
+					dst_vcpu->arch.walk_mmu->pdptrs[i], src_vcpu->arch.walk_mmu->pdptrs[i]);
+		}
+	}
+
+
+//	PHMIGRATEPRINTK("\t [ck] vcpu->arch. %u %u\n",
+//					dst_vcpu->arch., src_vcpu->arch.);
+//	PHMIGRATEPRINTK("\t [ck] vcpu->arch. %u %u\n",
+//					dst_vcpu->arch., src_vcpu->arch.);
+	//PHMIGRATEPRINTK("\t [ck] vcpu->arch. %u %u\n",
+	//				dst_vcpu->arch., src_vcpu->arch.);
+	PHMIGRATEPRINTK("more?\n");
+
+	PHMIGRATEPRINTK("--------- %s(): vcpu states (common) end (not up-to-date) ----------\n", __func__);
+#endif
+}
+
+/*
+ * Ask a target node to update their vcpu info by using this nodes's vcpu info
+ * ret:
+ * caller: ier vcpu on my node and invoke this func to broascast
+ */
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+//extern void pophype_dump_vmcs(void);
+extern bool is_saved_vcpu;
+#endif
+int popcorn_update_remote_vcpu(int dst_nid, int dst_vcpu)
+//struct kvm_vcpu *dst_vcpu, struct kvm_lapic_irq *irq, unsigned long *dest_map)
+{
+	update_vcpu_response_t *res; /* kvm_ipi_req/res */
+	update_vcpu_request_t *req;
+	struct remote_context *rc = current->mm->remote;
+	struct wait_station *ws;
+	int r = 0;
+	struct kvm_vcpu *vcpu;
+	//, dst_nid = popcorn_vcpuid_to_nid(dst_vcpu->vcpu_id);
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	ktime_t dt, update_vcpu_end, update_vcpu_start = ktime_get();
+#endif
+#if HPMIGRATION_DEBUG /* debug */
+	static int cnt = 0;
+	cnt++;
+	printk("%s(): <%d> pophype migration to [%d] START START START #%d\n",
+									__func__, dst_vcpu, dst_nid, cnt);
+#endif
+
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	BUG_ON(!is_saved_vcpu);
+#endif
+
+	/* common */
+//#ifdef CONFIG_POPCORN_CHECK_SANITY
+	if (my_nid == dst_nid) {
+		printk(KERN_ERR "ERROR: %s(): my_nid == dst_nid\n", __func__);
+		BUG_ON(my_nid == dst_nid);
+	}
+//#endif
+	req = kmalloc(sizeof(*req), GFP_KERNEL);
+	ws = get_wait_station(current);
+	BUG_ON(!req || !rc);
+	req->from_pid = current->pid;
+	req->ws = ws->id;
+
+	/* customize */
+
+	PHMIGRATEPRINTK("%s(): do popcorn_update_cpu_table()\n", __func__);
+	/* lock everywhere */
+	atomic64_set(&gvcpu_to_nid[dst_vcpu], dst_nid);
+	popcorn_update_cpu_table(dst_vcpu, dst_nid);
+
+	/* Use req->fd to indicate which vcpu it should use */
+	req->fd = vcpuid_to_fd(dst_vcpu); /* assumption: 1 vcpu on 1 node */
+	vcpu = hype_node_info[my_nid][req->fd]->vcpu;
+	BUG_ON(vcpu != hype_node_info[my_nid][VCPU_FD_BASE + dst_vcpu]->vcpu); /* assumption: 1 vcpu on 1 node */
+
+	memcpy(&req->vcpu, vcpu, sizeof(*vcpu)); ////LOOKS WRONG. am I using it?
+	PHMIGRATEPRINTK("%s(): *********memcopy vcpu*********** \n", __func__);
+	PHMIGRATEPRINTK("%s(): *********memcopy vcpu*********** \n", __func__);
+	PHMIGRATEPRINTK("%s(): *********memcopy vcpu*********** \n", __func__);
+	PHMIGRATEPRINTK("%s(): HACK hardcode vcpu 1 now (fix it)\n", __func__);
+
+
+	PHMIGRATEPRINTK("\n=========== %s(): <%d> [ck] start "
+					"(this is outdated state, too late, just as refs) "
+					"=================\n", __func__, current->pid);
+	show_cpu_states(NULL, vcpu); // this is too late
+	/* define arch/x86/include/asm/kvm_host.h */
+	pophype_dump_vmcs();
+
+	{
+		/* Re-order */
+		struct kvm_mp_state *mp_state = pophype_get_mp_state(vcpu->vcpu_id);
+		struct kvm_regs *regs = pophype_get_regs(vcpu->vcpu_id);
+		struct kvm_sregs *sregs = pophype_get_sregs(vcpu->vcpu_id);
+		struct kvm_fpu *fpu = pophype_get_fpu(vcpu->vcpu_id);
+		struct kvm_xcrs *xcrs = pophype_get_xcrs(vcpu->vcpu_id);
+		struct kvm_lapic_state *lapic = pophype_get_lapic(vcpu->vcpu_id);
+		struct kvm_xsave *xsave = pophype_get_xsave(vcpu->vcpu_id);
+		struct kvm_vcpu_events *vcpu_events = pophype_get_vcpu_event(vcpu->vcpu_id);
+		//struct kvm_msrs *msrs = pophype_get_msrs(); // use mine which has enough memory
+		struct pophype_kvm_msrs *msrs = pophype_get_msrs(vcpu->vcpu_id);
+
+		PHMIGRATEPRINTK("[pophype] set req - get kvm_mpstate (=vcpu->arch.?)\n");
+		memcpy(&req->mp_state, mp_state, sizeof(*mp_state));
+		PHMIGRATEPRINTK("\t\t\t get kvm_mpstate mp_state %d (=vcpu->arch.?)\n", mp_state->mp_state);
+		PHMIGRATEPRINTK("[pophype] set req - get kvm_regs (=vcpu->arch.regs)\n");
+		memcpy(&req->regs, regs, sizeof(*regs));
+		PHMIGRATEPRINTK("[pophype] set req - get kvm_sregs (=vcpu->arch.?)\n");
+		memcpy(&req->sregs, sregs, sizeof(*sregs));
+		PHMIGRATEPRINTK("[pophype] set req - get kvm_fpu (=vcpu->arch.?)\n");
+		memcpy(&req->fpu, fpu, sizeof(*fpu));
+
+		PHMIGRATEPRINTK("[pophype] set req - get kvm_xcrs\n");
+		memcpy(&req->xcrs, xcrs, sizeof(*xcrs));
+		PHMIGRATEPRINTK("[pophype] set req - get kvm_lapic\n");
+		memcpy(&req->lapic, lapic, sizeof(*lapic));
+		PHMIGRATEPRINTK("[pophype] set req - get xsave\n");
+		memcpy(&req->xsave, xsave, sizeof(*xsave));
+		PHMIGRATEPRINTK("[pophype] set req - get vcpu_events\n");
+		memcpy(&req->vcpu_events, vcpu_events, sizeof(*vcpu_events));
+		PHMIGRATEPRINTK("[pophype] set req - get msrs\n");
+		memcpy(&req->msrs, msrs, sizeof(*msrs));
+		PHMIGRATEPRINTK("\t\t*msrs check size %d in req %d\n", msrs->nmsrs, req->msrs.nmsrs);
+
+		PHMIGRATEPRINTK("[pophype***] rip ret %llx req %llx\n",
+									regs->rip, req->regs.rip);
+		PHMIGRATEPRINTK("[pophype***] cr0 ret %llx req %llx\n",
+									sregs->cr0, req->sregs.cr0);
+		PHMIGRATEPRINTK("[pophype***] cr3 ret %llx req %llx\n",
+									sregs->cr3, req->sregs.cr3);
+
+
+		PHMIGRATEPRINTK("DON'T GET STATES HERE (WRONG STATES). "
+				"Do it in arch/x86/kvm/x86.c KVM_RET_POPHYPE_MIGRATE\n");
+	}
+
+	/* check */
+	PHMIGRATEPRINTK("\n============ show ================\n");
+	PHMIGRATEPRINTK("%s(): vcpu %d %p (->)\n", __func__, vcpu->vcpu_id, vcpu);
+	PHMIGRATEPRINTK(" [ins] INSTALL [ck] CHECK\n");
+
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.cr0 %lx\n", vcpu->arch.cr0);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.cr2 %lx\n", vcpu->arch.cr2);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.cr3 %lx\n", vcpu->arch.cr3);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.cr4 %lx\n", vcpu->arch.cr4);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.cr8 %lx\n", vcpu->arch.cr8);
+
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.apic %p\n", vcpu->arch.apic);
+
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mp_state %u\n", vcpu->arch.mp_state);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.ia32_misc_enable_msr %llu\n", vcpu->arch.ia32_misc_enable_msr);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.smbase %llx\n", vcpu->arch.smbase);
+
+	{	int i = 0;
+		PHMIGRATEPRINTK("\n\t vcpu->arch.regs[i] (kvm_register_write) "
+						"enum kvm_reg {"
+						"RAX, RCX, RDX, RBX, RSP[4] "
+						"RBP RSI RDI R8 R9[9] "
+						"R10 R11 R12 R13 R14 R15 RIP }\n");
+		for (i = 0; i < NR_VCPU_REGS; i++) {
+			PHMIGRATEPRINTK("\t vcpu->arch.regs[%d] 0x%lx\n",
+										i, vcpu->arch.regs[i]);
+		}
+		PHMIGRATEPRINTK("\n\n");
+	}
+
+	PHMIGRATEPRINTK("------- pointers notes -----\n");
+	PHMIGRATEPRINTK("\t-> [ck] vcpu->* [pointers] *kvm *run *pid \n");
+	PHMIGRATEPRINTK("\t-> [ck] vcpu->arch.* [pointers] [*apic] *walk_mmu *pio_data *mce_banks\n");
+	PHMIGRATEPRINTK("----------------------\n");
+	PHMIGRATEPRINTK("\n");
+
+	PHMIGRATEPRINTK("\n");
+	PHMIGRATEPRINTK("\t -- [local only] arch.apic->* [local only] -- \n");
+	PHMIGRATEPRINTK("\t -- [local only] arch.apic->* (CANNOT DIRECTLY CPY) [local only] -- \n");
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.apic->base_address %lx\n", vcpu->arch.apic->base_address);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.apic->sw_enabled %d\n", vcpu->arch.apic->sw_enabled);
+	PHMIGRATEPRINTK("\t [ck]*** vcpu->arch.apic_base %llx\n", vcpu->arch.apic_base);
+	PHMIGRATEPRINTK("\t [ck]*** arch.efer %llx\n", vcpu->arch.efer);
+	//nmi*
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.apic->vapic_addr %llx\n", vcpu->arch.apic->vapic_addr);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.apic->vcpu %p (check)\n", vcpu->arch.apic->vcpu);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.apic->regs %p\n", vcpu->arch.apic->regs);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.apic->pending_events %lx\n", vcpu->arch.apic->pending_events);
+	PHMIGRATEPRINTK("\n");
+
+
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu %p\n", &vcpu->arch.mmu);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.page_fault %p\n", vcpu->arch.mmu.page_fault);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.root_hpa 0x%llx\n", vcpu->arch.mmu.root_hpa);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.walk_mmu %p\n", vcpu->arch.walk_mmu);
+
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.exit_qualification %lx\n", vcpu->arch.exit_qualification);
+
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.pending_external_vector %d\n", vcpu->arch.pending_external_vector);
+
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.set_cr3 %p (=kvm_x86_ops->set_tdp_cr3)\n", vcpu->arch.mmu.set_cr3);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.get_pdptr %p\n", vcpu->arch.mmu.get_pdptr);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.inject_page_fault %p\n", vcpu->arch.mmu.inject_page_fault);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.gva_to_gpa %p\n", vcpu->arch.mmu.gva_to_gpa);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.translate_gpa %p\n", vcpu->arch.mmu.translate_gpa);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.sync_page %p\n", vcpu->arch.mmu.sync_page);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.invlpg %p\n", vcpu->arch.mmu.invlpg);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.update_pte %p\n", vcpu->arch.mmu.update_pte);
+
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.root_hpa 0x%llx (ept root?) (from pae_root)\n", vcpu->arch.mmu.root_hpa);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.root_level %d\n", vcpu->arch.mmu.root_level);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.shadow_root_level %d ((checking now init_kvm_tdp_mmu))\n", vcpu->arch.mmu.shadow_root_level);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.direct_map %d\n", vcpu->arch.mmu.direct_map);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.pae_root %p (to root_hpa) [TODO this is a ptr, so memcpy]\n", vcpu->arch.mmu.pae_root);
+	{ int i;
+		for (i = 0; i < 4; ++i)
+			PHMIGRATEPRINTK("\t [ck] vcpu->arch.mmu.pae_root[%d] %llx\n", i, vcpu->arch.mmu.pae_root[i]);
+	}
+
+	PHMIGRATEPRINTK("=========== show end =============\n\n\n");
+
+	PHMIGRATEPRINTK("\t\tPCN_KMSG_TYPE_UPDATE_VCPU_REQUEST ->\n\n\n");
+	/* common */
+	req->remote_pid = rc->remote_tgids[dst_nid];
+	pcn_kmsg_send(PCN_KMSG_TYPE_UPDATE_VCPU_REQUEST,
+							dst_nid, req, sizeof(*req));
+	res = wait_at_station(ws);
+	r = res->ret;
+	pcn_kmsg_done(res);
+
+	kfree(req);
+
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	update_vcpu_end = ktime_get();
+	dt = ktime_sub(update_vcpu_end, update_vcpu_start);
+	atomic64_add(ktime_to_ns(dt), &update_vcpu_ns);
+	atomic64_inc(&update_vcpu_cnt);
+#endif
+#if HPMIGRATION_DEBUG /* debug */
+	printk("%s(): <%d> pophype migration to [%d] END END END #%d\n\n\n\n\n",
+									__func__, dst_vcpu, dst_nid, cnt);
+#endif
+
+	return r;
+}
+
+
+static void process_update_vcpu_request(struct work_struct *work)
+{
+    START_KMSG_WORK(update_vcpu_request_t, req, work);
+    update_vcpu_response_t *res = pcn_kmsg_get(sizeof(*res));
+    int from_nid = PCN_KMSG_FROM_NID(req);
+    struct task_struct *tsk = __get_task_struct(req->remote_pid);
+	int ret = 0, overwrite = 1;
+	struct fd dst_fd;
+	unsigned long v;
+	struct file *filp;
+	struct kvm_vcpu *dst_vcpu;
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	ktime_t dt, update_vcpu_handle_end, update_vcpu_handle_start = ktime_get();
+#endif
+#if HPMIGRATION_DEBUG /* debug */
+	static int cnt = 0;
+#endif
+	BUG_ON(!tsk && "No task exist");
+
+	/* fd to kvm_vcpu struct */
+	v = fget_light_tsk(tsk, req->fd, FMODE_PATH);
+	dst_fd = (struct fd){(struct file *)(v & ~3),v & 3};
+	filp = dst_fd.file;
+	BUG_ON(!filp);
+	dst_vcpu = filp->private_data;
+	BUG_ON(!dst_vcpu);
+	fdput(dst_fd);
+
+#if HPMIGRATION_DEBUG /* debug */
+	cnt++;
+	PHMIGRATEPRINTK("\n\n\n\n\n\t\t"
+					"=> %s(): migrating vcpu <%d> %p START START START #%d\n",
+					__func__, dst_vcpu->vcpu_id, dst_vcpu, cnt);
+#endif
+
+	/* lock everywhere
+		My node will provide this vCPU */
+	atomic64_set(&gvcpu_to_nid[dst_vcpu->vcpu_id], my_nid);
+
+	PHMIGRATEPRINTK("\n======== [%d] [ck] start ==========\n", current->pid);
+	pophype_dump_vmcs(); /* maybe not that important */
+	PHMIGRATEPRINTK("\n\n\n\n");
+
+	/* P.S. vmcs write will check host inkernel metadata like apic */
+	/* Change in-kernel data */
+	PHMIGRATEPRINTK("-> [ins] INSTALL [ck] CHECK\n");
+	PHMIGRATEPRINTK("--------- registers ----------\n");
+	// move to update_vmcs
+	{	int i = 0;
+		PHMIGRATEPRINTK("\n\t vcpu->arch.regs[i] (kvm_register_write) "
+						"enum kvm_reg {"
+						"RAX, RCX, RDX, RBX, RSP[4] "
+						"RBP RSI RDI R8 R9[9] "
+						"R10 R11 R12 R13 R14 R15 RIP }\n");
+		for (i = 0; i < NR_VCPU_REGS; i++) {
+			PHMIGRATEPRINTK("\t vcpu->arch.regs[%d] [old] 0x%lx -> "
+						"[new] 0x%lx\n",
+						i, dst_vcpu->arch.regs[i], req->vcpu.arch.regs[i]);
+////			dst_vcpu->arch.regs[i] = req->vcpu.arch.regs[i];
+		}
+		PHMIGRATEPRINTK("\n\n");
+	}
+
+	PHMIGRATEPRINTK("--------- segment registers ----------\n");
+	PHMIGRATEPRINTK("cs ss ds es fs gs tr ldt (dtable) gdt idt\n"); // TODO segments
+
+	PHMIGRATEPRINTK("--------- APIC ----------\n");
+	//efer*
+	//nmi*
+	PHMIGRATEPRINTK("\t [check] arch.apic [old] *%p != %p [new]\n",
+					dst_vcpu->arch.apic, req->vcpu.arch.apic);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.apic->vcpu *%p ?= %p(check)\n",
+					dst_vcpu->arch.apic->vcpu, req->vcpu.arch.apic->vcpu);
+	PHMIGRATEPRINTK("\t-> [check] arch.apic->regs *%p != %p\n",
+					dst_vcpu->arch.apic->regs, req->vcpu.arch.apic->regs);
+	PHMIGRATEPRINTK("\t-> [check] arch.apic->pending_events %lx -> %lx\n",
+		dst_vcpu->arch.apic->pending_events, req->vcpu.arch.apic->pending_events);
+
+	PHMIGRATEPRINTK("\t [check]* arch.apic_base %llx -> %llx (out dated) (done in sregs)\n",
+					dst_vcpu->arch.apic_base, req->vcpu.arch.apic_base);
+
+	PHMIGRATEPRINTK("\t -- arch.apic->* (CANNOT DIRECTLY CPY) [local only] -- \n");
+	PHMIGRATEPRINTK("\t [check] arch.apic->vapic_addr %llx -> %llx\n",
+					dst_vcpu->arch.apic->vapic_addr, req->vcpu.arch.apic->vapic_addr);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.apic->sw_enabled [old] %d %d [new]\n",
+			dst_vcpu->arch.apic->sw_enabled, req->vcpu.arch.apic->sw_enabled);
+	PHMIGRATEPRINTK("\t [ck] vcpu->arch.apic->base_address %lx\n",
+					dst_vcpu->arch.apic->base_address);
+
+	PHMIGRATEPRINTK("\t-> [ins] arch.efer %llx -> %llx *** (out dated) (done in sregs)\n",
+					dst_vcpu->arch.efer, req->vcpu.arch.efer);
+//	dst_vcpu->arch.efer = req->vcpu.arch.efer; // testing guest efer
+	PHMIGRATEPRINTK("\t-> [ins] arch.mp_state %d -> %d\n",
+					dst_vcpu->arch.mp_state, req->vcpu.arch.mp_state);
+	//dst_vcpu->arch.mp_state = req->vcpu.arch.mp_state;
+//	dst_vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;
+	PHMIGRATEPRINTK("\t-> [ins] arch.ia32_misc_enable_msr %llu -> %llu\n",
+					dst_vcpu->arch.ia32_misc_enable_msr,
+					req->vcpu.arch.ia32_misc_enable_msr);
+//	dst_vcpu->arch.ia32_misc_enable_msr = req->vcpu.arch.ia32_misc_enable_msr; //tesing guest efer
+	PHMIGRATEPRINTK("\t-> [check] arch.smbase %llx == %llx\n",
+					dst_vcpu->arch.smbase, req->vcpu.arch.smbase);
+
+	// TODO sregs->interrupt_bitmap?
+
+	PHMIGRATEPRINTK("\n");
+
+
+	PHMIGRATEPRINTK("------- pointers notes -----\n");
+	PHMIGRATEPRINTK("\t-> [ck] vcpu->* [pointers] *kvm *run *pid \n");
+	PHMIGRATEPRINTK("\t-> [ck] vcpu->arch.* [pointers] [*apic] *walk_mmu *pio_data *mce_banks\n");
+	PHMIGRATEPRINTK("----------------------\n");
+	PHMIGRATEPRINTK("\n");
+	PHMIGRATEPRINTK("\t-> [ck] dst_vcpu->arch.walk_mmu *ptr %p != %p\n",
+						dst_vcpu->arch.walk_mmu, req->vcpu.arch.walk_mmu);
+
+	//PHMIGRATEPRINTK("\t-> [ck] dst_vcpu->arch.mmu 0x%lx != 0x%lx\n",
+	//						 dst_vcpu->arch.mmu, req->vcpu.arch.mmu);
+	PHMIGRATEPRINTK("\t-> [ck] dst_vcpu->arch.mmu *0x%p != 0x%p\n",
+							 &dst_vcpu->arch.mmu, &req->vcpu.arch.mmu);
+	PHMIGRATEPRINTK("\t-> [ck] dst_vcpu->arch.mmu.page_fault *%p == %p\n",
+				dst_vcpu->arch.mmu.page_fault, req->vcpu.arch.mmu.page_fault);
+
+	PHMIGRATEPRINTK("\t-> [ck] dst_vcpu->arch.mmu.set_cr3 *%p != %p (checking now init_kvm_tdp_mmu) [host kernel function ptr*, DONT NOT OVERWRITE] \n",
+						dst_vcpu->arch.mmu.set_cr3, req->vcpu.arch.mmu.set_cr3);
+	//PHMIGRATEPRINTK("\t-> [ins] dst_vcpu->arch.mmu.set_cr3 %p != %p (checking now init_kvm_tdp_mmu)\n",
+	//					dst_vcpu->arch.mmu.set_cr3, req->vcpu.arch.mmu.set_cr3);
+	//dst_vcpu->arch.mmu.set_cr3, req->vcpu.arch.mmu.set_cr3; // not important // don't set
+	PHMIGRATEPRINTK("\t-> [check] dst_vcpu->arch.mmu.get_pdptr *%p == %p\n",
+						dst_vcpu->arch.mmu.get_pdptr, req->vcpu.arch.mmu.get_pdptr);
+	PHMIGRATEPRINTK("\t-> [check] dst_vcpu->arch.mmu.inject_page_fault *%p == %p\n",
+						dst_vcpu->arch.mmu.inject_page_fault, req->vcpu.arch.mmu.inject_page_fault);
+	PHMIGRATEPRINTK("\t-> [check] dst_vcpu->arch.mmu.gva_to_gpa *%p != %p (checking init_kvm_tdp_mmu)\n",
+						dst_vcpu->arch.mmu.gva_to_gpa, req->vcpu.arch.mmu.gva_to_gpa);
+	PHMIGRATEPRINTK("\t-> [check] dst_vcpu->arch.mmu.translate_gpa *%p == %p\n",
+						dst_vcpu->arch.mmu.translate_gpa, req->vcpu.arch.mmu.translate_gpa);
+	PHMIGRATEPRINTK("\t-> [check] dst_vcpu->arch.mmu.sync_page *%p == %p\n",
+						dst_vcpu->arch.mmu.sync_page, req->vcpu.arch.mmu.sync_page);
+	PHMIGRATEPRINTK("\t-> [check] dst_vcpu->arch.mmu.invlpg *%p == %p\n",
+						dst_vcpu->arch.mmu.invlpg, req->vcpu.arch.mmu.invlpg);
+	PHMIGRATEPRINTK("\t-> [check] dst_vcpu->arch.mmu.update_pte *%p == %p\n",
+						dst_vcpu->arch.mmu.update_pte, req->vcpu.arch.mmu.update_pte);
+
+	PHMIGRATEPRINTK("\t-> [ins] dst_vcpu->arch.mmu.root_hpa 0%llx != 0x%llx (ept root)(not from vcpu->arch.mmu.pae_root)\n",
+				dst_vcpu->arch.mmu.root_hpa, req->vcpu.arch.mmu.root_hpa);
+////	dst_vcpu->arch.mmu.root_hpa = req->vcpu.arch.mmu.root_hpa;
+	PHMIGRATEPRINTK("\t-> [ins] dst_vcpu->arch.mmu.root_level %d != %d (will be set in init_kvm_tdp_mmu)\n",
+				dst_vcpu->arch.mmu.root_level, req->vcpu.arch.mmu.root_level);
+////	dst_vcpu->arch.mmu.root_level = req->vcpu.arch.mmu.root_level;
+	PHMIGRATEPRINTK("\t-> [check] dst_vcpu->arch.mmu.shadow_root_level %d == %d (checking now init_kvm_tdp_mmu)\n",
+				dst_vcpu->arch.mmu.shadow_root_level,
+				req->vcpu.arch.mmu.shadow_root_level);
+	PHMIGRATEPRINTK("\t-> [check] dst_vcpu->arch.mmu.direct_map %d == %d\n",
+				dst_vcpu->arch.mmu.direct_map, req->vcpu.arch.mmu.direct_map);
+	//PHMIGRATEPRINTK("\t-> [ins] dst_vcpu->arch.mmu.pae_root %p != %p (not to arch.mmu.root_hpa)\n",
+	//					dst_vcpu->arch.mmu.pae_root, req->vcpu.arch.mmu.pae_root);
+////	//dst_vcpu->arch.mmu.pae_root = req->vcpu.arch.mmu.pae_root;
+	/* vcpu->arch.mmu.root_hpa = __pa(vcpu->arch.mmu.pae_root); in mmu_alloc_direct_roots() */
+	// overwrite
+	//{ int i;
+	//	for (i = 0; i < 4; ++i) {
+	//		PHMIGRATEPRINTK("\t\t[ins] vcpu->arch.mmu.pae_root[%d] %llx %llx\n", i,
+	//			//dst_vcpu->arch.mmu.pae_root[i], req->vcpu.arch.mmu.pae_root[i]); /* *ptr - don't use */
+	//			dst_vcpu->arch.mmu.pae_root[i] = req->pae_root[i];
+	//	}
+	//}
+
+
+	PHMIGRATEPRINTK("\t-> [install] arch.exit_qualification %lx -> %lx\n",
+		dst_vcpu->arch.exit_qualification, req->vcpu.arch.exit_qualification);
+////	dst_vcpu->arch.exit_qualification = req->vcpu.arch.exit_qualification;
+
+	PHMIGRATEPRINTK("\t-> [check] arch.pending_external_vector %d -> %d\n",
+						dst_vcpu->arch.pending_external_vector,
+						req->vcpu.arch.pending_external_vector);
+
+	PHMIGRATEPRINTK("--------- arch-spec registers ----------\n");
+	PHMIGRATEPRINTK("1. from req->vcpu.arch.cr*\n");
+	PHMIGRATEPRINTK("\t-> [ins] arch.cr0 %lx -> %lx\n",
+					dst_vcpu->arch.cr0, req->vcpu.arch.cr0);
+	PHMIGRATEPRINTK("\t-> [ins] arch.cr2 %lx -> %lx\n",
+					dst_vcpu->arch.cr2, req->vcpu.arch.cr2);
+	PHMIGRATEPRINTK("\t-> [ins] arch.cr3 %lx -> %lx\n",
+					dst_vcpu->arch.cr3, req->vcpu.arch.cr3);
+	PHMIGRATEPRINTK("\t-> [ins] arch.cr4 %lx -> %lx\n",
+					dst_vcpu->arch.cr4, req->vcpu.arch.cr4);
+	PHMIGRATEPRINTK("\t-> [ins] arch.cr8 %lx -> %lx\n",
+					dst_vcpu->arch.cr8, req->vcpu.arch.cr8);
+	PHMIGRATEPRINTK("\n");
+	PHMIGRATEPRINTK("2. from req->sregs.cr*\n");
+	PHMIGRATEPRINTK("\t-> [ins] arch.cr0 %lx -> %llx\n",
+					dst_vcpu->arch.cr0, req->sregs.cr0);
+	PHMIGRATEPRINTK("\t-> [ins] arch.cr2 %lx -> %llx\n",
+					dst_vcpu->arch.cr2, req->sregs.cr2);
+	PHMIGRATEPRINTK("\t-> [ins] arch.cr3 %lx -> %llx\n",
+					dst_vcpu->arch.cr3, req->sregs.cr3);
+	PHMIGRATEPRINTK("\t-> [ins] arch.cr4 %lx -> %llx\n",
+					dst_vcpu->arch.cr4, req->sregs.cr4);
+	PHMIGRATEPRINTK("\t-> [ins] arch.cr8 %lx -> %llx\n",
+					dst_vcpu->arch.cr8, req->sregs.cr8);
+
+	PHMIGRATEPRINTK("--- arch-spec registers: select src 2. ---\n");
+	PHMIGRATEPRINTK("[rip from req %llx]\n", req->regs.rip);
+	PHMIGRATEPRINTK("[cr0 from req %llx]\n", req->sregs.cr0);
+
+	/* ========================== */
+	/* ===== overwrite start ==== */
+	/* ========================== */
+	/* vmcs write will check host inkernel metadata like apic */
+	{ /* check vmcs, start to overwrite vmcs */
+		struct kvm_vcpu *vcpu = hype_node_info[my_nid][req->fd]->vcpu; /* VMCS load to the right vCPU */
+		struct kvm_regs *regs = &req->regs;
+		struct kvm_mp_state *mp_state = &req->mp_state;
+		struct kvm_sregs *sregs = &req->sregs;
+		struct kvm_fpu *fpu = &req->fpu;
+
+		struct kvm_xcrs *xcrs = &req->xcrs;
+		struct kvm_lapic_state *lapic = &req->lapic;
+		struct kvm_xsave *xsave = &req->xsave;
+		struct kvm_vcpu_events *vcpu_events = &req->vcpu_events;
+		struct pophype_kvm_msrs *msrs = &req->msrs; // ./arch/x86/include/uapi/asm/kvm.h
+		//struct kvm_run* kvm_run = &req->kvm_run;
+
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+		BUG_ON(vcpu != dst_vcpu);
+#endif
+
+		if (overwrite) {
+			//int cpu = dst_vcpu->vcpu_id; //TODO harcode
+			//int cpu = 1; //TODO harcode
+			int cpu = smp_processor_id(); // TODO TESTING I THINK THIS IS RIGHT cuz vmcs is per cpu and sohuld match with current cpu. Let vmx_vcpu_load to reload the current host(smp) cpu
+			//int cpu = get_cpu(); // upgraded. Remember put_cpu();
+			//int cpu = 1; // TODO NO NO NO we need to know which host CPU will be used...........
+//			int cpu;
+
+			PHMIGRATEPRINTK("\n[phmigrate] ---------------------------------------------\n");
+			PHMIGRATEPRINTK("[phmigrate] ---------------------------------------------\n");
+			PHMIGRATEPRINTK("[phmigrate] ------------- vcpu_load on host cpu %d ---------\n", cpu);
+			PHMIGRATEPRINTK("[phmigrate] ---------------------------------------------\n");
+			PHMIGRATEPRINTK("[phmigrate] ---------------------------------------------\n");
+			PHMIGRATEPRINTK("[phmigrate] (start) ***load vmcx*** for (dst_vcpu) so that I can write (TODO cpu=hardcode)\n");
+#if 1
+			{ /* Remember to unlock */
+				/* Since ft, I'm trying to use wrapper functions
+				of kvm_arch_vcpu_load(). Testing now. */
+
+				/// 111111
+				/// 111111
+				/// 111111
+//				cpu = get_cpu();
+				kvm_arch_vcpu_load(dst_vcpu, cpu); /* change vcpu->cpu and load vmcs*/ /* IMPORTANT: match kvm_arch_vcpu_put */
+//				put_cpu();
+
+
+//				/// 2222222
+//				/// 2222222
+//				/// 2222222
+////				int _cpu;
+//
+//				//if (mutex_lock_killable(&vcpu->mutex))
+//				//	return -EINTR;
+//				BUG_ON(mutex_lock_killable(&vcpu->mutex));
+//
+//				cpu = get_cpu();
+////				_cpu = get_cpu();
+//				preempt_notifier_register(&vcpu->preempt_notifier);
+//				kvm_arch_vcpu_load(dst_vcpu, cpu);
+////				put_cpu();
+			}
+#else
+
+			BUG_ON(vcpu_load(dst_vcpu));
+#endif
+			PHMIGRATEPRINTK("[phmigrate] (done) load vmcx for (dst_vcpu) so that I can write (TODO cpu=hardcode)\n");
+			//if it works, move pophype_update_vmcs related to cpu to here
+			//PHMIGRATEPRINTK("[phmigrate] (mp_state overwrite)\n");
+			//vcpu->arch.mp_state = KVM_MP_STATE_UNINITIALIZED;
+			//vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE; // will be overwritten by kvm_xxx_set_mpstate() with this mp_state->mp_state
+			PHMIGRATEPRINTK("[phmigrate] will overwrite mp_state->mp_state to %d "
+							"(expect 0: RUNNABLE 1: UNINITIALIZED 3: HALTED (for FT))\n",
+							 mp_state->mp_state);
+		}
+
+
+		PHMIGRATEPRINTK("\n\n\n\n\n\n\n\n");
+		PHMIGRATEPRINTK("\n ---- 2nd dump_vmcs before overwrite start ----\n");
+		pophype_dump_vmcs(); /* maybe not that important */
+		PHMIGRATEPRINTK("------------ 2nd dump_vmcs end --------------\n\n");
+
+		PHMIGRATEPRINTK("\n ------------ before overwrite start ----------\n");
+		show_cpu_states(dst_vcpu, &req->vcpu);
+		PHMIGRATEPRINTK("\n ----------- before overwrite end -----------\n");
+		PHMIGRATEPRINTK("\n\n\n\n\n\n\n\n");
+
+		PHMIGRATEPRINTK("\n\t============================================\n");
+		PHMIGRATEPRINTK("=========== [OVERWRITE/INSTALL START] ==========\n");
+		PHMIGRATEPRINTK("============================================\n");
+		if (overwrite) { /* check vmcs */
+			int r = 0;
+
+			/* Re-order */
+
+			/* keep overwriting */
+			PHMIGRATEPRINTK(" --- keep updateing current vmcs <%d> ---\n", vcpu->vcpu_id);
+			/* kvm_arch_vcpu_ioctl_set_*() */
+			PHMIGRATEPRINTK("[pophype] get from req - set [kvm_sregs] (=vcpu->arch.?)\n");
+			//PHMIGRATEPRINTK("[pophype] get from req - set kvm_sregs (=vcpu->arch.?) [[[SKIP]]]\n");
+			r = kvm_arch_vcpu_ioctl_set_sregs(vcpu, sregs); // ./virt/kvm/kvm_main.c
+			WARN_ON(r);
+
+			PHMIGRATEPRINTK("[pophype] get from req - set [kvm_regs] (=vcpu->arch.?)\n");
+			kvm_arch_vcpu_ioctl_set_regs(vcpu, regs); // ./virt/kvm/kvm_main.c
+
+			PHMIGRATEPRINTK("[pophype] get from req - set [msr]\n");
+			PHMIGRATEPRINTK("\t\t*msrs check size %d in req %d\n", msrs->nmsrs, req->msrs.nmsrs);
+			r = pophype_msr_io(vcpu, msrs, pophype_do_set_msr, 0); // KVM_SET_MSRS // TODO POPHYPE and argp
+			WARN_ON(r);
+//			struct kvm_msrs _msrs;
+//			r = pophype_msr_io(vcpu, &_msrs, pophype_do_set_msr, 0); // KVM_SET_MSRS // TODO POPHYPE and argp
+//			WARN_ON(r);
+//			memcpy(&req->msrs, &_msrs, sizeof(struct kvm_msrs));
+//			PHMIGRATEPRINTK("_msrs check size %d in req %d\n", _msrs.nmsrs, req->msrs.nmsrs);
+
+			PHMIGRATEPRINTK("[pophype] get from req - set [xcrs]\n");
+			r = pophype_vcpu_ioctl_x86_set_xcrs(vcpu, xcrs); // KVM_SET_XCRS
+			WARN_ON(r);
+
+			PHMIGRATEPRINTK("[pophype] get from req - set kvm_mpstate (=vcpu->arch.?)\n");
+			PHMIGRATEPRINTK("\t [ck] jack bf vcpu->arch.mp_state %u\n", vcpu->arch.mp_state);
+			kvm_arch_vcpu_ioctl_set_mpstate(vcpu, mp_state); // ./virt/kvm/kvm_main.c
+			PHMIGRATEPRINTK("\t [ck] jack af vcpu->arch.mp_state %u\n", vcpu->arch.mp_state);
+			//vcpu->arch.mp_state = KVM_MP_STATE_HALTED;
+			PHMIGRATEPRINTK("\t [ck] skiep seting vcpu->arch.mp_state\n");
+			PHMIGRATEPRINTK("\t [ck] jack af af vcpu->arch.mp_state %u\n", vcpu->arch.mp_state);
+
+			PHMIGRATEPRINTK("[pophype] get from req - set [lapic]\n");
+			r = pophype_vcpu_ioctl_set_lapic(vcpu, lapic); // KVM_SET_LAPIC
+			WARN_ON(r);
+
+			PHMIGRATEPRINTK("[pophype] get from req - set kvm_fpu (=vcpu->arch.?)\n");
+			kvm_arch_vcpu_ioctl_set_fpu(vcpu, fpu); // ./virt/kvm/kvm_main.c
+
+			PHMIGRATEPRINTK("[pophype] get from req - set [xsave]\n");
+			r = pophype_vcpu_ioctl_x86_set_xsave(vcpu, xsave); // KVM_SET_XSAVE
+			WARN_ON(r);
+
+			PHMIGRATEPRINTK("[pophype] get from req - set [vcpu_events]\n");
+			r = pophype_vcpu_ioctl_x86_set_vcpu_events(vcpu, vcpu_events); //KVM_SET_VCPU_EVENTS
+			WARN_ON(r);
+
+			//PHMIGRATEPRINTK("[pophype] get from req - set [kvm_run]\n");
+			//memcpy(vcpu->run, kvm_run, sizeof(struct kvm_run));
+
+			PHMIGRATEPRINTK(" --- end ---\n");
+		}
+		PHMIGRATEPRINTK("\n\t============================================\n");
+		PHMIGRATEPRINTK("=========== [OVERWRITE/INSTALL END] ==========\n");
+		PHMIGRATEPRINTK("============================================\n");
+		PHMIGRATEPRINTK("\n\n\n\n\n\n\n\n");
+
+		PHMIGRATEPRINTK("[reg] rax 0x%lx rbx 0x%lx rcx 0x%lx rdx 0x%lx rsi 0x%lx "
+				"rdi 0x%lx rsp 0x%lx rbp 0x%lx    "
+#ifdef CONFIG_X86_64
+				"r8 0x%lx r9 0x%lx r10 0x%lx"
+#endif
+				"\n",
+				kvm_register_read(vcpu, VCPU_REGS_RAX),
+				kvm_register_read(vcpu, VCPU_REGS_RBX),
+				kvm_register_read(vcpu, VCPU_REGS_RCX),
+				kvm_register_read(vcpu, VCPU_REGS_RDX),
+				kvm_register_read(vcpu, VCPU_REGS_RSI),
+				kvm_register_read(vcpu, VCPU_REGS_RDI),
+				kvm_register_read(vcpu, VCPU_REGS_RSP),
+				kvm_register_read(vcpu, VCPU_REGS_RBP),
+#ifdef CONFIG_X86_64
+				kvm_register_read(vcpu, VCPU_REGS_R8),
+				kvm_register_read(vcpu, VCPU_REGS_R9),
+				kvm_register_read(vcpu, VCPU_REGS_R10)
+#endif
+				);
+	} // end over write
+	/* ========================== */
+	/* ====== overwrite end ===== */
+	/* ========================== */
+
+	PHMIGRATEPRINTK("\n ------------- after overwrite start --------------\n");
+	show_cpu_states(dst_vcpu, &req->vcpu);
+	PHMIGRATEPRINTK("\npophype: [new vmcs]\t[new vmcs]\t[new vmcs]\n");
+	pophype_vcpu_check_vmcs(dst_vcpu);
+	PHMIGRATEPRINTK("\n ------------ after overwrite end -----------------\n");
+
+	PHMIGRATEPRINTK("============== [%d] [ck] end =================\n\n", current->pid);
+
+#if 1
+	if (overwrite) {
+		/* Testing: using wrapper functions of kvm_arch_vcpu_put() */
+
+		// 11111
+		kvm_arch_vcpu_put(dst_vcpu); /* IMPORTANT: match kvm_arch_vcpu_load() */ /* vmx_vcpu_put() */
+
+		// 222222
+		//vcpu_put(dst_vcpu);
+	}
+#else
+#endif
+
+	res->ret = ret;
+    res->from_pid = req->from_pid;
+	res->ws = req->ws;
+	pcn_kmsg_post(PCN_KMSG_TYPE_UPDATE_VCPU_RESPONSE,
+					from_nid, res, sizeof(*res));
+    END_KMSG_WORK(req);
+
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	update_vcpu_handle_end = ktime_get();
+	dt = ktime_sub(update_vcpu_handle_end, update_vcpu_handle_start);
+	atomic64_add(ktime_to_ns(dt), &update_vcpu_handle_ns);
+	atomic64_inc(&update_vcpu_handle_cnt);
+#endif
+
+	popcorn_show_gcpu_table();
+#if HPMIGRATION_DEBUG /* debug */
+	printk("=> %s(): migrating vcpu <%d> %p END END END #%d\n",
+				__func__, dst_vcpu->vcpu_id, dst_vcpu, cnt);
+#endif
+//////////// testing kvm_vcpu_ioctl /// migration not performed yet
+#if 0 //debug
+{
+int j;
+struct kvm_sregs kvm_sregs;
+for (j=0;j<30;j++) {
+printk("\t\t%s(): killme test vcpu <%d> %p start #%d\n",
+				__func__, dst_vcpu->vcpu_id, dst_vcpu, j);}
+
+printk("\t\t%s(): killme test vcpu <%d> %p save vcpu states - 0\n",
+				__func__, dst_vcpu->vcpu_id, dst_vcpu);
+pophype_save_vcpu_states(dst_vcpu);
+printk("\t\t%s(): killme test vcpu <%d> %p test get kvm_sregs - 1\n",
+				__func__, dst_vcpu->vcpu_id, dst_vcpu);
+j = kvm_arch_vcpu_ioctl_get_sregs(dst_vcpu, &kvm_sregs);
+printk("\t\t%s(): killme test vcpu <%d> %p test get kvm_sregs - 2\n",
+				__func__, dst_vcpu->vcpu_id, dst_vcpu);
+
+for (j=0;j<20;j++) {
+printk("\t\t%s(): killme test vcpu <%d> %p end (states loaded, !migrated) #%d\n",
+				__func__, dst_vcpu->vcpu_id, dst_vcpu, j);}
+}
+#endif
+/////
+}
+
+static int handle_update_vcpu_response(struct pcn_kmsg_message *msg)
+{
+	update_vcpu_response_t *res = (update_vcpu_response_t *)msg;
+    struct wait_station *ws = wait_station(res->ws);
+
+    ws->private = res;
+
+	complete(&ws->pendings); /* Release PCN_KMSG_TYPE_UPDATE_VCPU_REQUEST */
+	PHMIGRATEPRINTK("\n\n\n-> %s(): START START START\n\n\n", __func__);
+
+	popcorn_show_gcpu_table();
+	PHMIGRATEPRINTK("-> %s(): END END END\n\n\n\n\n", __func__);
+
+	/* Going to migration */
+    return res->ret;
+}
+
+
+/**************************************************************************
+ * Pophpye net optimization - msghdr
+ */
+/* Gusrt conver to msg-transfferable data struct */
+struct pophype_msghdr *create_pmsghdr_from_msghdr(struct msghdr *msg, int *pmsghdr_size)
+{
+	struct pophype_msghdr *pmsghdr = kmalloc(sizeof(*pmsghdr), GFP_ATOMIC);
+	BUG_ON(!pmsghdr);
+
+	pmsghdr->msg_namelen = msg->msg_namelen;
+	if (msg->msg_name) // && msg->msg_namelen)
+		memcpy(&pmsghdr->msg_name, msg->msg_name, msg->msg_namelen); //
+	else {
+		POP_PK("%s(): debug msg->msg_name %s\n",
+				__func__, msg->msg_name ? "O" : "X");
+		//printk("%s(): debug msg->msg_name %s\n", __func__, msg->msg_name);
+	}
+	pmsghdr->msg_flags = msg->msg_flags;
+
+	BUG_ON(msg->msg_iter.count != msg->msg_iter.iov->iov_len); /* what's this */
+
+	/* struct iov_iter msg_iter; */
+	pmsghdr->type = msg->msg_iter.type;
+	pmsghdr->iov_offset = msg->msg_iter.iov_offset;
+	pmsghdr->count = msg->msg_iter.count;
+	pmsghdr->nr_segs = msg->msg_iter.nr_segs;
+	pmsghdr->iov_len = msg->msg_iter.iov->iov_len;
+	if (msg->msg_iter.iov->iov_len) {
+		/* From user */
+		BUG_ON(msg->msg_iter.iov->iov_len > POPHYPE_MSGHDR_BUF_SIZE); /* We constraint this */
+		BUG_ON(copy_from_user(pmsghdr->iov_base,
+				msg->msg_iter.iov->iov_base, msg->msg_iter.iov->iov_len));
+	} else {
+		printk(KERN_ERR "%s(): !len\n", __func__);
+		goto out;
+	}
+
+	/* return real struct size with real payload */
+	//*pmsghdr_size = sizeof(struct pophype_msghdr) - (int)PAGE_SIZE
+	*pmsghdr_size = sizeof(struct pophype_msghdr) - POPHYPE_MSGHDR_BUF_SIZE
+								+ msg->msg_iter.iov->iov_len;
+	//VHOSTNET_OPTIMIZE_PK("%s(): pmsghdr_size %d "
+	//			"sizeof(struct pophype_msghdr) %lu - (int)PAGE_SIZE (%lu) + "
+	//			"msg->msg_iter.iov->iov_len (%lu)\n",
+	//			__func__, *pmsghdr_size,
+	//			sizeof(struct pophype_msghdr),
+	//			PAGE_SIZE, msg->msg_iter.iov->iov_len);
+
+
+#if 0
+	{ // guest kernel
+		struct kernel_msghdr kmsghdr = {
+			.msg_name = NULL,
+			.msg_namelen = 0,
+			.msg_control = NULL,
+			.msg_controllen = 0,
+			.msg_flags = MSG_DONTWAIT,
+		};
+		int len;
+		struct iov_iter *from;
+		ssize_t n;
+		struct virtio_net_hdr gso = { 0 };
+		// ck local 2
+		printk("====== [remote (local intact data) start] ======\n");
+
+		len = msg->msg_iter.count;
+		printk("[ck] msg->msg_iter.nr_segs %lu\n", msg->msg_iter.nr_segs);
+
+		from = &msg->msg_iter;
+
+		// ONLY-1 can work
+		printk("1. (usr) Do the same (copy from user) type %d\n", msg->msg_iter.type);
+		n = copy_from_iter(&gso, sizeof(gso), from);
+		BUG_ON(n != sizeof(gso));
+		printk("[ck] copy_from_iter -> "
+				"tun16_to_cpu(tun, gso.hdr_len) be %d le %d > len %d (WRONG)\n",
+										//tun16_to_cpu(tun, gso.hdr_len), len);
+										be16_to_cpu((__force __be16)gso.hdr_len),
+										le16_to_cpu((__force __le16)gso.hdr_len),
+										len);
+
+		printk("2. (usr) memcpy type %d\n", msg->msg_iter.type);
+		memcpy(&gso, from, sizeof(gso));
+		printk("[ck] memcpy -> "
+				"tun16_to_cpu(tun, gso.hdr_len) be %d le %d > len %d (WRONG)\n",
+										//tun16_to_cpu(tun, gso.hdr_len), len);
+										be16_to_cpu((__force __be16)gso.hdr_len),
+										le16_to_cpu((__force __le16)gso.hdr_len),
+										len);
+
+
+		/******* BUG dont use this********/
+		msg->msg_iter.type = ITER_KVEC; // im in kern // [Pophype]
+//////		printk("3. (kern) Do the same (copy from user) type %d\n", msg->msg_iter.type);
+//////		n = copy_from_iter(&gso, sizeof(gso), from);
+//////		BUG_ON(n != sizeof(gso));
+//////		printk("[ck] copy_from_iter -> "
+//////				"tun16_to_cpu(tun, gso.hdr_len) be %d le %d > len %d (WRONG)\n",
+//////										//tun16_to_cpu(tun, gso.hdr_len), len);
+//////										be16_to_cpu((__force __be16)gso.hdr_len),
+//////										le16_to_cpu((__force __le16)gso.hdr_len),
+//////										len);
+		printk("4. (kernel) memcpy type %d\n", msg->msg_iter.type);
+		memcpy(&gso, from, sizeof(gso));
+		printk("[ck] memcpy -> "
+				"tun16_to_cpu(tun, gso.hdr_len) be %d le %d > len %d (WRONG)\n",
+										//tun16_to_cpu(tun, gso.hdr_len), len);
+										be16_to_cpu((__force __be16)gso.hdr_len),
+										le16_to_cpu((__force __le16)gso.hdr_len),
+										len);
+		printk("[thought] I think kvaddr may be a problem to copy_from_iter(usr) 3.4.\n");
+		printk("=====================================\n");
+
+
+	}
+#endif
+	return pmsghdr;
+out:
+	if (pmsghdr)
+		kfree(pmsghdr);
+	return NULL;
+}
+
+//struct msghdr {
+//    void        *msg_name;  /* ptr to socket address structure */
+//    int     msg_namelen;    /* size of socket address structure */
+//    struct iov_iter msg_iter;   /* data */
+//    void        *msg_control;   /* ancillary data */
+//    __kernel_size_t msg_controllen; /* ancillary data buffer length */
+//    unsigned int    msg_flags;  /* flags on received message */
+//    struct kiocb    *msg_iocb;  /* ptr to iocb for async requests */
+//};
+//
+//struct pophype_msghdr {
+//    char msg_name[128];
+//    int msg_namelen; //128
+//    struct iov_iter msg_iter;   /* data */
+//    //void        *msg_control;   /* ancillary data */
+//    //__kernel_size_t msg_controllen; /* ancillary data buffer length */
+//    unsigned int    msg_flags;
+//    //struct kiocb    *msg_iocb;
+//};
+
+#include <linux/socket.h>
+void guest_delegate_net_msg_tx_hypercall(struct sock *sk,
+							struct msghdr *msg, size_t size)
+{
+	//struct tcp_sock *tp = tcp_sk(sk); // TODO include // TODO get more info from sk
+	struct pophype_msghdr *pmsghdr;
+	int pmsghdr_size; /* real size to transffer */
+
+	pmsghdr = create_pmsghdr_from_msghdr(msg, &pmsghdr_size);
+	VHOSTNET_OPTIMIZE_PK("%s(): START (guest vanilla) msghdr size %lu "
+						"pmsghdr_size(new my dynamic msg size) %d\n",
+								__func__, size, pmsghdr_size);
+
+	// TODO here I need pmsghdr
+
+	kvm_hypercall2(KVM_HC_POPHYPE_NET_MSG_DELEGATE,
+					(unsigned long)pmsghdr, pmsghdr_size);
+	kfree(pmsghdr);
+}
+
+//debug
+void create_msghdr_from_pmsghdr(struct kernel_msghdr *kmsg, struct pophype_msghdr *pmsghdr);
+//!debug
+void delegate_net_msg_tx(struct pophype_msghdr __user *pmsghdr, int pmsghdr_size)
+//struct sock *sk,
+{
+	delegate_net_msg_tx_request_t *req;
+	delegate_net_msg_tx_response_t *res;
+	struct wait_station *ws;
+	struct remote_context *rc = current->mm->remote;
+	int r, dst_nid = 0; /* delegation to origin */
+
+    int req_size = sizeof(*req);
+
+	unsigned long gpa, gfn, ofs, pmsghdr_hva;
+	struct kvm_translation tr;
+	int my_cpu = my_nid; // TODO HACK but this is puzzlehype
+	int fd = my_cpu + VCPU_FD_BASE;
+
+	unsigned long target_gva = (unsigned long)pmsghdr;
+
+
+	VHOSTNET_OPTIMIZE_PK("%s(): START\n", __func__);
+
+////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////
+	/* Convert skb from guest to host first */
+	/* gva -> gspa */
+	tr.linear_address = (unsigned long)target_gva;
+	kvm_arch_vcpu_ioctl_translate(
+				hype_node_info[my_nid][fd]->vcpu, &tr);
+	gpa = tr.physical_address;
+
+	/* host - gpa -> gfn */
+    gfn = gpa >> PAGE_SHIFT;
+    ofs = gpa % PAGE_SIZE;
+    pmsghdr_hva = kvm_vcpu_gfn_to_hva(
+                hype_node_info[my_nid][fd]->vcpu, gfn);
+	pmsghdr_hva += ofs;
+
+	VHOSTNET_OPTIMIZE_PK("(host requester) %s(): (guest<%d>) START "
+			"msg(target_gva) %p gpa 0x%lx "
+			"pmsghdr_hva 0x%lx (void*)pmsghdr_hva %p "
+			"pmsghdr_size %d (from user->hypercall->)\n",
+			__func__, my_cpu, pmsghdr, gpa, pmsghdr_hva, (void*)pmsghdr_hva,
+			pmsghdr_size);
+
+    req = kmalloc(sizeof(*req), GFP_KERNEL);
+
+	//#################################
+	//#################################
+	/* common msg */
+	//req = kmalloc(sizeof(*req), GFP_KERNEL);
+	ws = get_wait_station(current);
+	BUG_ON(!req || !rc);
+	req->from_pid = current->pid;
+	req->ws = ws->id;
+	//req->->pmsghdr;
+	/* pophype specifi */
+	req->fd = vcpuid_to_fd(my_cpu);
+	//#################################
+	//#################################
+
+	VHOSTNET_OPTIMIZE_PK("%s(): TEST1\n", __func__);
+	BUG_ON(copy_from_user(&req->pmsghdr, (void*)pmsghdr_hva, pmsghdr_size)); // from user buff
+	VHOSTNET_OPTIMIZE_PK("%s(): TEST2\n", __func__);
+
+	req_size = sizeof(*req); /* using all size now. Re-calculate to optimize */
+	// req_size - sizeof(pophype_msghdr) + pmsghdr_size; // optimized version - teset it
+
+
+	VHOSTNET_OPTIMIZE_PK("[ck] %s(): pmsghdr.count %lu .nr_segs %lu .iov_offset %lu\n",
+						__func__,
+						req->pmsghdr.count,
+						req->pmsghdr.nr_segs,
+						req->pmsghdr.iov_offset);
+#if 0
+	{
+		//ssize_t n;
+		//struct virtio_net_hdr gso = { 0 };
+		//struct iov_iter *from = &req->pmsghdr.msg_iter;
+		//printk("[ck] test\n");
+		//printk("1. (usr) Do the same (copy from user) type %d\n", kmsghdr.msg_iter.type);
+		//n = copy_from_iter(&gso, sizeof(gso), from);
+		//BUG_ON(n != sizeof(gso));
+		struct kernel_msghdr kmsghdr = {
+			.msg_name = NULL,
+			.msg_namelen = 0,
+			.msg_control = NULL,
+			.msg_controllen = 0,
+			.msg_flags = MSG_DONTWAIT,
+		};
+		int len;
+		struct iov_iter *from;
+		ssize_t n;
+		struct virtio_net_hdr gso = { 0 };
+		// ck local 1
+		create_msghdr_from_pmsghdr(&kmsghdr, &req->pmsghdr);
+		// ck local 2
+
+		len = kmsghdr.msg_iter.count;
+		printk("[ck] kmsghdr.msg_iter.nr_segs %lu\n", kmsghdr.msg_iter.nr_segs);
+
+		from = &kmsghdr.msg_iter;
+
+		printk("====== [remote (local restore) start] ======\n");
+		printk("1. (usr) Do the same (copy from user) type %d\n", kmsghdr.msg_iter.type);
+		n = copy_from_iter(&gso, sizeof(gso), from);
+		BUG_ON(n != sizeof(gso));
+		printk("[ck] copy_from_iter -> "
+				"tun16_to_cpu(tun, gso.hdr_len) be %d le %d > len %d (WRONG)\n",
+										//tun16_to_cpu(tun, gso.hdr_len), len);
+										be16_to_cpu((__force __be16)gso.hdr_len),
+										le16_to_cpu((__force __le16)gso.hdr_len),
+										len);
+
+		printk("2. (usr) memcpy type %d\n", kmsghdr.msg_iter.type);
+		memcpy(&gso, from, sizeof(gso));
+		printk("[ck] memcpy -> "
+				"tun16_to_cpu(tun, gso.hdr_len) be %d le %d > len %d (WRONG)\n",
+										//tun16_to_cpu(tun, gso.hdr_len), len);
+										be16_to_cpu((__force __be16)gso.hdr_len),
+										le16_to_cpu((__force __le16)gso.hdr_len),
+										len);
+
+		kmsghdr.msg_iter.type = ITER_KVEC; // im in kern // [Pophype]
+		printk("3. (kern) Do the same (copy from user) type %d\n", kmsghdr.msg_iter.type);
+		n = copy_from_iter(&gso, sizeof(gso), from);
+		BUG_ON(n != sizeof(gso));
+		printk("[ck] copy_from_iter -> "
+				"tun16_to_cpu(tun, gso.hdr_len) be %d le %d > len %d (WRONG)\n",
+										//tun16_to_cpu(tun, gso.hdr_len), len);
+										be16_to_cpu((__force __be16)gso.hdr_len),
+										le16_to_cpu((__force __le16)gso.hdr_len),
+										len);
+
+		printk("4. (kernel) memcpy type %d\n", kmsghdr.msg_iter.type);
+		memcpy(&gso, from, sizeof(gso));
+		printk("[ck] memcpy -> "
+				"tun16_to_cpu(tun, gso.hdr_len) be %d le %d > len %d (WRONG)\n",
+										//tun16_to_cpu(tun, gso.hdr_len), len);
+										be16_to_cpu((__force __be16)gso.hdr_len),
+										le16_to_cpu((__force __le16)gso.hdr_len),
+										len);
+		printk("[thought] I think kvaddr may be a problem to copy_from_iter(usr) 3.4.\n");
+		printk("=====================================\n");
+
+
+		kfree(kmsghdr.msg_iter.iov->iov_base);
+		kfree(kmsghdr.msg_iter.iov);
+
+	}
+#endif
+
+	VHOSTNET_OPTIMIZE_PK("%s(): =>\n\n", __func__);
+    /* common */
+    req->remote_pid = rc->remote_tgids[dst_nid];
+	pcn_kmsg_send(PCN_KMSG_TYPE_DELEGATE_NET_MSG_TX_REQUEST,
+									dst_nid, req, req_size);
+    res = wait_at_station(ws);
+    r = res->ret;
+    pcn_kmsg_done(res);
+
+    kfree(req);
+}
+
+
+void create_msghdr_from_pmsghdr(struct kernel_msghdr *kmsg, struct pophype_msghdr *pmsghdr)
+{
+//	VHOSTNET_OPTIMIZE_PK("\t %s(): ck0 \n", __func__);
+	//kmsg->msg_namelen = kmsg->msg_namelen;
+	kmsg->msg_name = kmalloc(128, GFP_KERNEL);
+	BUG_ON(!kmsg->msg_name);
+	//memcpy(kmsg->msg_name, &pmsghdr->msg_name, kmsg->msg_name, 128); //
+	//kfree(kmsg->msg_name);
+	//kmsg->msg_name = NULL;
+	kmsg->msg_flags = pmsghdr->msg_flags; // handle_tx sets MSG_DONTWAIT
+
+	/* struct iov_iter msg_iter; */
+	kmsg->msg_iter.type = pmsghdr->type | ITER_KVEC; // @!!!!!!!!!!!!!!!!! WRITE (guest) | ITER_KVEC 0919/////
+	kmsg->msg_iter.iov_offset = pmsghdr->iov_offset;
+	kmsg->msg_iter.count = pmsghdr->count;
+	kmsg->msg_iter.nr_segs = pmsghdr->nr_segs;
+
+	kmsg->msg_iter.iov = kmalloc(sizeof(*kmsg->msg_iter.iov), GFP_KERNEL);
+	BUG_ON(!kmsg->msg_iter.iov);
+	kmsg->msg_iter.iov->iov_len = pmsghdr->iov_len;
+	kmsg->msg_iter.iov->iov_base =
+			kmalloc(kmsg->msg_iter.iov->iov_len, GFP_KERNEL);
+	BUG_ON(!kmsg->msg_iter.iov->iov_base);
+	memcpy(kmsg->msg_iter.iov->iov_base, pmsghdr->iov_base, pmsghdr->iov_len);
+}
+
+#include <linux/net.h>
+//extern struct socket *pophype_origin_host_tun_sock;
+struct socket *pophype_origin_host_tun_sock;
+static void process_delegate_net_msg_tx_request(struct work_struct *work)
+{
+    START_KMSG_WORK(delegate_net_msg_tx_request_t, req, work);
+    delegate_net_msg_tx_response_t *res = pcn_kmsg_get(sizeof(*res));
+    int from_nid = PCN_KMSG_FROM_NID(req);
+    struct task_struct *tsk = __get_task_struct(req->remote_pid);
+	int ret = 0;
+	struct fd dst_fd;
+	unsigned long v;
+	struct file *filp;
+	//struct kvm_vcpu *dst_vcpu;
+	struct kvm_vcpu *vcpu;
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	//ktime_t dt, delegate_skb_tx_handle_end, delegate_skb_tx_handle_start = ktime_get();
+#endif
+#if HPMIGRATION_DEBUG /* debug */
+	static int cnt = 0;
+#endif
+	struct kernel_msghdr kmsghdr = {
+        .msg_name = NULL,
+        .msg_namelen = 0,
+        .msg_control = NULL,
+        .msg_controllen = 0,
+        //.msg_flags = MSG_DONTWAIT, /* guest kernel uses this */
+        //.msg_flags = 0,
+    };
+
+	BUG_ON(!tsk && "No task exist");
+	VHOSTNET_OPTIMIZE_PK("\n=> [*] %s():\n", __func__);
+
+    v = fget_light_tsk(tsk, req->fd, FMODE_PATH);
+    dst_fd = (struct fd){(struct file *)(v & ~3),v & 3};
+    VHOSTNET_OPTIMIZE_PK("%s(): struct fd & dst_fd %p\n",
+									__func__, (void *)&dst_fd);
+    filp = dst_fd.file;
+    BUG_ON(!filp); /* check run.sh lkvm argv
+                        highly likely you don't have enough CPU online */
+    vcpu = filp->private_data;
+    BUG_ON(!vcpu);
+    fdput(dst_fd);
+
+	VHOSTNET_OPTIMIZE_PK("\t %s(): create msg_hdr and inject it START\n", __func__);
+	//############################################
+	create_msghdr_from_pmsghdr(&kmsghdr, &req->pmsghdr);
+	// = create_skb_from_pskb(&req->pskb);
+	VHOSTNET_OPTIMIZE_PK("\t %s(): create msg_hdr and inject it DONE\n", __func__);
+
+
+	{
+		int err; //, size = 4096; // TODO
+		struct socket *sock = pophype_origin_host_tun_sock; //TODO
+		int len = kmsghdr.msg_iter.count;
+		BUG_ON(!sock);
+		//int ret = tun_sendmsg(sock, kmsghdr, size); // private
+
+		//printk("TODO (major) len %d (should be the same in guest msghdr) "
+		//											"sock %p\n", len, sock);
+		//printk("[*]self testing bf actually doing\n");
+		printk("[*] sk %p [cmp] [msg=kmsghdr] "
+					"msg->msg_namelen %d (blocks) msg->msg_controllen %lu msg->msg_flags 0x%x "
+					"msg.msg_iter.nr_segs %lu msg.msg_iter.count %lu "
+					"msg.msg_iter.iov_offset %lu "
+					"msg.msg_iter.type %d "
+					"msg.msg_iter.iov %p "
+					"msg.msg_iter.iov->iov_base _%p_ "
+					"msg.msg_iter.iov->iov_len [[[%lu]]] "
+					"\n",
+					sock,
+					kmsghdr.msg_namelen, kmsghdr.msg_controllen, kmsghdr.msg_flags,
+					kmsghdr.msg_iter.nr_segs, kmsghdr.msg_iter.count,
+					kmsghdr.msg_iter.iov_offset, kmsghdr.msg_iter.type,
+					kmsghdr.msg_iter.iov,
+					kmsghdr.msg_iter.iov->iov_base,
+					kmsghdr.msg_iter.iov->iov_len);
+
+
+#if 0
+		{
+			ssize_t n;
+			struct iov_iter *from = &kmsghdr.msg_iter;
+			struct virtio_net_hdr gso = { 0 };
+			printk("====== [origin (remote) start] ======\n");
+			printk("1. (usr) Do the same (copy from user) type %d\n", kmsghdr.msg_iter.type);
+			// iov_offset, count, nr_segs, iov fields of the iterator
+			n = copy_from_iter(&gso, sizeof(gso), from);
+			// iov_offset, count, nr_segs, iov fields of the iterator
+			BUG_ON(n != sizeof(gso));
+			printk("[ck] copy_from_iter -> "
+					"tun16_to_cpu(tun, gso.hdr_len) be %d le %d > len %d (WRONG)\n",
+											//tun16_to_cpu(tun, gso.hdr_len), len);
+											be16_to_cpu((__force __be16)gso.hdr_len),
+											le16_to_cpu((__force __le16)gso.hdr_len),
+												len);
+
+			printk("2. (usr) memcpy type %d\n", kmsghdr.msg_iter.type);
+			memcpy(&gso, from, sizeof(gso));
+			printk("[ck] memcpy -> "
+					"tun16_to_cpu(tun, gso.hdr_len) be %d le %d > len %d (WRONG)\n",
+											//tun16_to_cpu(tun, gso.hdr_len), len);
+											be16_to_cpu((__force __be16)gso.hdr_len),
+											le16_to_cpu((__force __le16)gso.hdr_len),
+											len);
+
+			kmsghdr.msg_iter.type = ITER_KVEC; // im in kern // [Pophype]
+			printk("3. (kern) Do the same (copy from user) type %d\n", kmsghdr.msg_iter.type);
+			n = copy_from_iter(&gso, sizeof(gso), from);
+			BUG_ON(n != sizeof(gso));
+			printk("[ck] copy_from_iter -> "
+					"tun16_to_cpu(tun, gso.hdr_len) be %d le %d > len %d (WRONG)\n",
+											//tun16_to_cpu(tun, gso.hdr_len), len);
+											be16_to_cpu((__force __be16)gso.hdr_len),
+											le16_to_cpu((__force __le16)gso.hdr_len),
+											len);
+
+			printk("4. (kernel) memcpy type %d\n", kmsghdr.msg_iter.type);
+			memcpy(&gso, from, sizeof(gso));
+			printk("[ck] memcpy -> "
+					"tun16_to_cpu(tun, gso.hdr_len) be %d le %d > len %d (WRONG)\n",
+											//tun16_to_cpu(tun, gso.hdr_len), len);
+											be16_to_cpu((__force __be16)gso.hdr_len),
+											le16_to_cpu((__force __le16)gso.hdr_len),
+											len);
+			printk("[thought] I think kvaddr may be a problem to copy_from_iter(usr) 3.4.\n");
+			printk("=====================================\n");
+		}
+#endif
+
+		//10/1 check handle_tx() in drivers/vhost/net.c
+		//iov_iter_advance(&msg.msg_iter, hdr_size);
+		//err = sock->ops->sendmsg(sock, (struct msghdr)&kmsghdr, len);
+		err = sock->ops->sendmsg(sock, (struct msghdr*)&kmsghdr, len);
+		if (!err)
+			printk("DONE (JUST G  O      H  O  M  E!!!!)\n");
+		else
+			printk("[dbg] CURRENT PROBLEM - here %d (check err #)\n", err);
+		/* release */
+		kfree(kmsghdr.msg_name);
+//		VHOSTNET_OPTIMIZE_PK("\t %s(): free name\n", __func__);
+		kfree(kmsghdr.msg_iter.iov->iov_base);
+//		VHOSTNET_OPTIMIZE_PK("\t %s(): free iov->iov_base\n", __func__);
+		kfree(kmsghdr.msg_iter.iov);
+//		VHOSTNET_OPTIMIZE_PK("\t %s(): free iov\n", __func__);
+	}
+	// check handle tx or tun_send
+	//skb = create_skb_from_pskb(&req->pskb);
+	//netif_rx_ni(skb); /* Free skb */
+
+
+	VHOSTNET_OPTIMIZE_PK("%s(): remote this handshaking ->\n\n", __func__);
+    res->ret = ret;
+    res->from_pid = req->from_pid;
+    res->ws = req->ws;
+    pcn_kmsg_post(PCN_KMSG_TYPE_DELEGATE_NET_MSG_TX_RESPONSE,
+								from_nid, res, sizeof(*res));
+    END_KMSG_WORK(req);
+
+}
+
+
+static int handle_delegate_net_msg_tx_response(struct pcn_kmsg_message *msg)
+{
+	delegate_net_msg_tx_response_t *res = (delegate_net_msg_tx_response_t *)msg;
+    struct wait_station *ws = wait_station(res->ws);
+
+	VHOSTNET_OPTIMIZE_PK("-> %s(): remote this handshaking\n", __func__);
+	ws->private = res;
+	complete(&ws->pendings);
+
+    //return res->ret;
+	return 0;
+}
+
+
+
+/****
+ * Pophype network optimization
+ * Notes:
+ *		skb->qlen = how many sk_buff for this network package
+ */
+
+struct pophype_skb* guest_skb_to_pophype_skb(struct sk_buff *skb)
+{
+	struct pophype_skb *pskb;
+    int headerlen;
+    int head_data_len;
+    int pskb_size;
+
+	VHOSTNET_OPTIMIZE_PK("%s(): START\n", __func__);
+
+    headerlen = skb_headroom(skb);
+    head_data_len = headerlen + skb->len;
+    pskb_size = head_data_len + sizeof(*pskb);
+
+    pskb = kmalloc(pskb_size, GFP_ATOMIC);
+	BUG_ON(!pskb);
+
+	VHOSTNET_OPTIMIZE_PK("(guest) %s(): create pophype_skb pskb %p pskb_size %d"
+						"[check] skb->len %u ->data_len %u\n",
+						__func__, pskb, pskb_size, skb->len, skb->data_len);
+	VHOSTNET_OPTIMIZE_PK("\t\t(guest) %s(): BUG_ON{"
+			"offset(skb->csum_start %d - (skb->data %lu - skb->head %lu)(%lu))) [[[%d]]]"
+			" >= skb_headlen(skb->len %d - skb->data_len %d) [[[%d]]]} "
+			"csum_offset %u [[csum=%d]] csum %d\n",
+			__func__,
+			skb->csum_start, (unsigned long)skb->data, (unsigned long)skb->head,
+						(unsigned long)skb->data - (unsigned long)skb->head,
+				skb_checksum_start_offset(skb),
+			skb->len, skb->data_len,
+				skb_headlen(skb),
+			skb->csum_offset,
+			skb_checksum(skb, skb_checksum_start_offset(skb), skb->len - skb_checksum_start_offset(skb), 0),
+			skb->csum);
+
+	pskb->headerlen = headerlen;
+    pskb->datalen = skb->len;
+    pskb->taillen = skb_end_pointer(skb) - skb_tail_pointer(skb);
+
+    //this should copy both header and data
+	// skb ofs to len
+	BUG_ON(!skb);
+    BUG_ON(skb_copy_bits(skb, -headerlen, &pskb->data, head_data_len));
+
+    /* Code copied from __copy_skb_header */
+
+    pskb->tstamp         = skb->tstamp;
+#ifdef NET_SKBUFF_DATA_USES_OFFSET
+    pskb->transport_header_off   = skb->transport_header - (skb->data - skb->head);
+	pskb->network_header_off     = skb->network_header - (skb->data - skb->head);
+	pskb->mac_header_off         = skb->mac_header - (skb->data - skb->head);
+#else
+    pskb->transport_header_off   = skb->transport_header - (skb->data);
+	pskb->network_header_off     = skb->network_header - (skb->data);
+	pskb->mac_header_off         = skb->mac_header - (skb->data);
+
+#endif
+
+    memcpy(pskb->cb, skb->cb, sizeof(pskb->cb));
+    pskb->csum               = skb->csum;
+	pskb->pkt_type           = skb->pkt_type;
+	pskb->ip_summed          = skb->ip_summed;
+    pskb->priority          = skb->priority;
+#if defined(CONFIG_IP_VS) || defined(CONFIG_IP_VS_MODULE)
+	pskb->ipvs_property      = skb->ipvs_property;
+#endif
+	pskb->protocol           = skb->protocol;
+	pskb->mark               = skb->mark;
+	pskb->skb_iif            = skb->skb_iif;
+	/*__nf_copy(new, old);*/
+#if defined(CONFIG_NETFILTER_XT_TARGET_TRACE) || \
+    defined(CONFIG_NETFILTER_XT_TARGET_TRACE_MODULE)
+	pskb->nf_trace           = skb->nf_trace;
+#endif
+#ifdef CONFIG_NET_SCHED
+	pskb->tc_index           = skb->tc_index;
+#ifdef CONFIG_NET_CLS_ACT
+	pskb->tc_verd            = skb->tc_verd;
+#endif
+#endif
+	pskb->vlan_tci           = skb->vlan_tci;
+#ifdef CONFIG_NETWORK_SECMARK
+    pskb->secmark = skb->secmark;
+#endif
+
+	return pskb;
+}
+
+
+//#if !POPHYPE_HOST_KERNEL /* TODO: this is for my convinience
+/* hypercall at remote */
+void delegate_skb_tx_hypercall(struct pophype_skb *pskb, int pskb_size)
+{
+	VHOSTNET_OPTIMIZE_PK("[(guest) %s()]: START - pskb %p size %d\n",
+												__func__, pskb, pskb_size);
+	kvm_hypercall2(KVM_HC_POPHYPE_NET_DELEGATE, (unsigned long)pskb, pskb_size);
+	VHOSTNET_OPTIMIZE_PK("[(guest) %s()]: END - pskb %p size %d\n",
+											__func__, pskb, pskb_size);
+	kfree(pskb);
+	VHOSTNET_OPTIMIZE_PK("[(guest) %s()]: size %d freed\n",
+										__func__, pskb_size);
+}
+//#endif
+
+/*
+ * For coping skb check net/core/skbbuff.c (frome ft-popcorn net/core/ft_filter.c)
+ * static int create_rx_skb_copy_msg(struct net_filter_info *filter, long long pckt_id, long long local_tx, struct sk_buff *skb, struct rx_copy_msg **msg, int *msg_size){
+ */
+/* check __copy_skb_header() at net/core/skbuff.c */
+/****
+ * At host.
+ * skb: a guest ptr
+ * pskb_size: from guest (HACK)
+ * caller: ./arch/x86/kvm/x86.c
+ */
+int delegate_skb_tx(struct pophype_skb *pskb_gva, int pskb_size)
+{
+	delegate_skb_tx_request_t *req;
+	delegate_skb_tx_response_t *res;
+	struct wait_station *ws;
+	struct remote_context *rc = current->mm->remote;
+	int r, dst_nid = 0; /* delegation to origin */
+
+	//int headerlen;
+    //int head_data_len;
+    int req_size;
+
+	unsigned long gpa, gfn, ofs, pskb_hva;
+	struct kvm_translation tr;
+	//struct pophype_skb *skb; // the name is wrong as well -> pskb
+	//struct sk_buff *skb;
+	//int my_cpu = 1; // TODO HACK
+	int my_cpu = my_nid; // TODO HACK but this is puzzlehype
+	int fd = my_cpu + VCPU_FD_BASE;
+
+
+
+	VHOSTNET_OPTIMIZE_PK("%s(): START\n", __func__);
+
+
+////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////
+	/* Convert skb from guest to host first */
+	/* gva -> gspa */
+	tr.linear_address = (unsigned long)pskb_gva;
+	kvm_arch_vcpu_ioctl_translate(
+				hype_node_info[my_nid][fd]->vcpu, &tr);
+	gpa = tr.physical_address;
+
+	/* host - gpa -> gfn */
+    gfn = gpa >> PAGE_SHIFT;
+    ofs = gpa % PAGE_SIZE;
+    pskb_hva = kvm_vcpu_gfn_to_hva(
+                hype_node_info[my_nid][fd]->vcpu, gfn);
+	pskb_hva += ofs;
+
+	VHOSTNET_OPTIMIZE_PK("(host requester) %s(): (guest<%d>) START "
+			"pskb_gva %p gpa 0x%lx pskb_hva 0x%lx (void*)pskb_hva %p"
+			"pskb_size %d in_atomic() %d\n",
+			__func__, my_cpu, pskb_gva, gpa, pskb_hva, (void*)pskb_hva,
+			pskb_size, in_atomic());
+
+	BUG_ON(pskb_size > PAGE_SIZE); // implement more
+
+
+
+//	//if (copy_from_user(out, buf, sizeof(*out)))
+//	skb = kmalloc(pskb_size, GFP_KERNEL);
+//	BUG_ON(!skb);
+//	BUG_ON(copy_from_user(skb, (void*)pskb_hva, pskb_size)); // TODO: HACK
+
+
+//	/* Copied skb data from skb_hva */
+//	headerlen = skb_headroom(skb);
+//    head_data_len = headerlen + skb->len;
+//    req_size = head_data_len + sizeof(*req); // skb size varies
+
+
+    req = kmalloc(pskb_size, GFP_KERNEL); // HACK: struct pskb + msg_layer hdr (HACK is outside now)
+	// pskb_size + header
+    //req = kmalloc(req_size, GFP_KERNEL);
+
+	//#################################
+	//#################################
+	/* common msg */
+	//req = kmalloc(sizeof(*req), GFP_KERNEL);
+	ws = get_wait_station(current);
+	BUG_ON(!req || !rc);
+	req->from_pid = current->pid;
+	req->ws = ws->id;
+	//req->pskb->;
+	/* pophype specifi */
+	req->fd = vcpuid_to_fd(my_cpu);
+	//#################################
+	//#################################
+
+	BUG_ON(copy_from_user(&req->pskb, (void*)pskb_hva, pskb_size)); // TODO: HACK
+
+	req_size = pskb_size;
+
+
+	VHOSTNET_OPTIMIZE_PK("%s(): =>\n\n", __func__);
+    /* common */
+    req->remote_pid = rc->remote_tgids[dst_nid];
+    pcn_kmsg_send(PCN_KMSG_TYPE_DELEGATE_SKB_TX_REQUEST,
+                            dst_nid, req, req_size);
+    res = wait_at_station(ws);
+    r = res->ret;
+    pcn_kmsg_done(res);
+
+    kfree(req);
+
+	return r;
+}
+
+#include <linux/ip.h>
+#include <net/ip.h>
+#include <net/tcp.h>
+/* Note: call put_iphdr after using get_iphdr in case
+ * of no errors.
+ */
+static int get_iphdr(struct sk_buff *skb, struct iphdr** ip_header,int *iphdrlen) {
+    int res= -EFAULT;
+    struct iphdr* network_header= NULL;
+    int len;
+
+    skb_reset_network_header(skb);
+    skb_reset_transport_header(skb);
+    skb_reset_mac_len(skb);
+
+    if (skb->pkt_type == PACKET_OTHERHOST)
+        goto out;
+
+    if (!pskb_may_pull(skb, sizeof(struct iphdr)))
+        goto out;
+
+    /*if(skb_shared(skb))
+        printk("%s: WARNING skb shared\n", __func__);*/
+
+    network_header= ip_hdr(skb);
+
+    if (network_header->ihl < 5 || network_header->version != 4)
+        goto out;
+
+    if (!pskb_may_pull(skb, network_header->ihl*4))
+        goto out;
+
+    network_header= ip_hdr(skb);
+
+    if (unlikely(ip_fast_csum((u8 *)network_header, network_header->ihl)))
+        goto out;
+
+    len = ntohs(network_header->tot_len);
+    if (skb->len < len || len < network_header->ihl*4)
+        goto out;
+
+    if (pskb_trim_rcsum(skb, len))
+        goto out;
+
+    /* Remove any debris in the socket control block */
+    memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
+    skb_orphan(skb);
+
+    *iphdrlen= ip_hdrlen(skb);
+    __skb_pull(skb, *iphdrlen);
+    skb_reset_transport_header(skb);
+
+    *ip_header= ip_hdr(skb);
+
+    res= 0;
+
+out:
+    return res;
+}
+
+static void put_iphdr(struct sk_buff *skb, int iphdrlen){
+    __skb_push(skb, iphdrlen);
+}
+
+#if 0
+extern struct net *pophype_tap0_at_origin;
+static void fake_parameters(struct sk_buff *skb)
+{
+    struct inet_sock *inet;
+    //struct inet_request_sock *ireq;
+    int res, iphdrlen, datalen, msg_changed;
+        struct iphdr *network_header;
+    struct tcphdr *tcp_header= NULL;     // tcp header struct
+        struct udphdr *udp_header= NULL;     // udp header struct
+    __be16 sport;
+    __be32 saddr;
+
+	VHOSTNET_OPTIMIZE_PK("\t\t[*] %s(): &init_net %p == "
+						"pophype_tap0_at_origin %p\n",
+						__func__, &init_net, pophype_tap0_at_origin);
+	skb->dev = dev_get_by_name(&init_net, POPHYPE_ORIGIN_TAP_NAME); /* directly mimic ft */
+	VHOSTNET_OPTIMIZE_PK("\t\t[*] %s(): replace with origin host dev \"%s\"\n",
+													__func__, skb->dev->name);
+
+	/* Jack: this is for sync ack? */
+	inet = inet_sk(skb->sk);
+//	printk("!skip ip_hdr - inet %p\n", inet);
+	if (inet) {
+		sport = inet->inet_sport;
+		saddr = inet->inet_saddr;
+	} else {
+//		printk("!skip ip_hdr - SYNC ACK\n");
+		/* I don't have a filet->ft_req (struct request_sock *sk) */
+		//ireq = inet_rsk(filter->ft_req);
+        //if(ireq) {
+        //    sport = ireq->loc_port;
+		//	saddr = ireq->loc_addr;
+        //} else{
+        //    printk("%s, ERROR impossible to retrive inet socket\n",__func__);
+        //    //return;
+        //}
+	}
+
+	res = get_iphdr(skb, &network_header, &iphdrlen);
+    if (res)
+		return;
+
+	//####### Done
+    msg_changed = 0;
+
+    /* saddr is the local IP
+     * watch out, saddr=0 means any address so do not change it
+     * in the packet.
+     */
+    if(saddr && network_header->daddr != saddr) {
+        network_header->daddr = saddr;
+        msg_changed = 1;
+    }
+
+    if (network_header->protocol == IPPROTO_UDP) {
+        udp_header =
+			(struct udphdr *) ((char*)network_header + network_header->ihl * 4);
+        datalen = skb->len - ip_hdrlen(skb);
+
+        if(udp_header->dest != sport ){
+            udp_header->dest= sport;
+            msg_changed = 1;
+        }
+        //inet_iif(skb)
+
+        if(msg_changed) {
+			udp_header->check =
+				csum_tcpudp_magic(
+						network_header->saddr, network_header->daddr,
+					   datalen, network_header->protocol,
+					   csum_partial((char *)udp_header, datalen, 0));
+			ip_send_check(network_header);
+		}
+    } else {
+        if (skb->pkt_type != PACKET_HOST)
+            goto out_put;
+
+        if (!pskb_may_pull(skb, sizeof(struct tcphdr))) /* private skb */
+            goto out_put;
+
+        tcp_header = tcp_hdr(skb);
+
+        if (tcp_header->doff < sizeof(struct tcphdr) / 4)
+            goto out_put;
+
+        if (!pskb_may_pull(skb, tcp_header->doff * 4)) /* private skb */
+            goto out_put;
+
+        if(tcp_header->dest != sport) {
+			tcp_header->dest = sport;
+			msg_changed = 1;
+		}
+
+        if(msg_changed) {
+			POP_PK("pophype: Jack need your ATTENTION skb->sk %p\n", skb->sk);
+			tcp_v4_send_check(skb->sk, skb);
+			ip_send_check(network_header);
+             //tcp_v4_send_check(filter->ft_sock, skb);
+             //            ip_send_check(network_header);
+		 }
+
+        //inet_iif(skb)
+    }
+
+out_put:
+	printk("(bf) skb->data %lx ->len %lx += len %d\n",
+				(unsigned long)skb->data, (unsigned long)skb->len, iphdrlen);
+	put_iphdr(skb, iphdrlen); // skb->data ->len += len
+	printk("(af) skb->data %lx ->len %lx += len %d\n",
+				(unsigned long)skb->data, (unsigned long)skb->len, iphdrlen);
+}
+#endif
+
+static struct sk_buff* create_skb_from_pskb(struct pophype_skb *pskb)
+{
+    struct sk_buff *skb;
+
+	skb = dev_alloc_skb(pskb->datalen + pskb->headerlen + pskb->taillen);
+    BUG_ON(!skb);
+
+//	printk("%s(): Jack skb->csum_start %d ->data %lu ->head %lu (%lu) "
+//			"skb->_skb_refdst %lu\n",
+//					__func__, skb->csum_start,
+//					(unsigned long)skb->data, (unsigned long)skb->head,
+//					(unsigned long)skb->data - (unsigned long)skb->head,
+//					skb->_skb_refdst);
+
+    /* Set the data pointer */
+    skb_reserve(skb, pskb->headerlen);
+    /* Set the tail pointer and length */
+    skb_put(skb, pskb->datalen);
+
+	/* copy data */
+    skb_copy_to_linear_data_offset(skb, -pskb->headerlen,
+					&pskb->data, pskb->headerlen + pskb->datalen);
+
+    /* Code copied from __copy_skb_header */
+	skb->tstamp     = pskb->tstamp;
+	/*new->dev              = old->dev;*/
+    skb_set_transport_header(skb,pskb->transport_header_off);
+    skb_set_network_header(skb,pskb->network_header_off);
+    skb_set_mac_header(skb,pskb->mac_header_off);
+
+	/* skb_dst_copy(new, old); */
+
+	//skb->rxhash             = pskb->rxhash;
+	//skb->ooo_okay           = pskb->ooo_okay;
+	//skb->l4_rxhash          = pskb->l4_rxhash;
+	/*#ifdef CONFIG_XFRM
+	new->sp                 = secpath_get(old->sp);
+	#endif*/
+	memcpy(skb->cb, pskb->cb, sizeof(skb->cb));
+	skb->csum               = pskb->csum;
+	//skb->local_df           = pskb->local_df; // pophype - new doesn't have
+	skb->pkt_type           = pskb->pkt_type;
+	skb->ip_summed          = pskb->ip_summed;
+	/*skb_copy_queue_mapping(new, old);*/
+	skb->priority          = pskb->priority;
+#if defined(CONFIG_IP_VS) || defined(CONFIG_IP_VS_MODULE)
+	skb->ipvs_property      = pskb->ipvs_property;
+#endif
+	skb->protocol           = pskb->protocol;
+	skb->mark               = pskb->mark;
+	skb->skb_iif            = pskb->skb_iif;
+	/*__nf_copy(new, old);*/
+#if defined(CONFIG_NETFILTER_XT_TARGET_TRACE) || \
+    defined(CONFIG_NETFILTER_XT_TARGET_TRACE_MODULE)
+	skb->nf_trace           = pskb->nf_trace;
+#endif
+#ifdef CONFIG_NET_SCHED
+	skb->tc_index           = pskb->tc_index;
+#ifdef CONFIG_NET_CLS_ACT
+	skb->tc_verd            = pskb->tc_verd;
+#endif
+#endif
+	skb->vlan_tci           = pskb->vlan_tci;
+#ifdef CONFIG_NETWORK_SECMARK
+	skb->secmark        = pskb->secmark;
+#endif
+
+//    fake_parameters(skb);
+//	VHOSTNET_OPTIMIZE_PK("\t\t[*] %s(): BUG_ON{"
+//		"offset(skb->csum_start %d - (skb->data %lu - skb->head %lu)(%lu))) [[[%d]]]"
+//		" >= skb_headlen(skb->len %d - skb->data_len %d) [[[%d]]]} "
+//		"csum_offset %u [[csum=%d]] csum %d\n",
+//		__func__,
+//		skb->csum_start, (unsigned long)skb->data, (unsigned long)skb->head,
+//						(unsigned long)skb->data-(unsigned long)skb->head,
+//			skb_checksum_start_offset(skb),
+//		skb->len, skb->data_len,
+//			skb_headlen(skb),
+//		skb->csum_offset,
+//		skb_checksum(skb, skb_checksum_start_offset(skb), skb->len - skb_checksum_start_offset(skb), 0),
+//		skb->csum);
+
+
+    return skb;
+
+};
+
+static void process_delegate_skb_tx_request(struct work_struct *work)
+{
+    START_KMSG_WORK(delegate_skb_tx_request_t, req, work);
+    delegate_skb_tx_response_t *res = pcn_kmsg_get(sizeof(*res));
+    int from_nid = PCN_KMSG_FROM_NID(req);
+    struct task_struct *tsk = __get_task_struct(req->remote_pid);
+	int ret = 0;
+	struct fd dst_fd;
+	unsigned long v;
+	struct file *filp;
+	//struct kvm_vcpu *dst_vcpu;
+	struct kvm_vcpu *vcpu;
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	//ktime_t dt, delegate_skb_tx_handle_end, delegate_skb_tx_handle_start = ktime_get();
+#endif
+#if HPMIGRATION_DEBUG /* debug */
+	static int cnt = 0;
+#endif
+
+	struct sk_buff *skb;
+
+	BUG_ON(!tsk && "No task exist");
+//	VHOSTNET_OPTIMIZE_PK("=> [*] %s():\n", __func__);
+
+    v = fget_light_tsk(tsk, req->fd, FMODE_PATH);
+    dst_fd = (struct fd){(struct file *)(v & ~3),v & 3};
+//    VHOSTNET_OPTIMIZE_PK("%s(): struct fd & dst_fd %p\n", __func__, (void *)&dst_fd);
+    filp = dst_fd.file;
+    BUG_ON(!filp); /* check run.sh lkvm argv
+                        highly likely you don't have enough CPU online */
+    vcpu = filp->private_data;
+    BUG_ON(!vcpu);
+    fdput(dst_fd);
+
+
+//	VHOSTNET_OPTIMIZE_PK("\t %s(): create skb and inject it TODO\n", __func__);
+
+	skb = create_skb_from_pskb(&req->pskb);
+	//pophype_inject_skb(skb); /* Pophype - TODO */
+	netif_rx_ni(skb); /* Free skb */ /* ref: ./drivers/net/tun.c */
+
+
+//	VHOSTNET_OPTIMIZE_PK("%s(): remote this handshaking ->\n", __func__);
+    res->ret = ret;
+    res->from_pid = req->from_pid;
+    res->ws = req->ws;
+    pcn_kmsg_post(PCN_KMSG_TYPE_DELEGATE_SKB_TX_RESPONSE,
+							from_nid, res, sizeof(*res));
+    END_KMSG_WORK(req);
+}
+
+static int handle_delegate_skb_tx_response(struct pcn_kmsg_message *msg)
+{
+	delegate_skb_tx_response_t *res = (delegate_skb_tx_response_t *)msg;
+    struct wait_station *ws = wait_station(res->ws);
+
+	VHOSTNET_OPTIMIZE_PK("-> %s(): remote this handshaking\n", __func__);
+	ws->private = res;
+	complete(&ws->pendings);
+
+    //return res->ret;
+	return 0;
+}
+
+
+
+
+/*******************
+ * States
+ */
+void pophype_stat(struct seq_file *seq, void *v)
+{
+#ifdef CONFIG_POPCORN_STAT
+	if (seq) {
+		seq_printf(seq, "%6s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+					"regw->", (atomic64_read(&apic_reg_write_ns) / 1000) / MICROSECOND,
+							(atomic64_read(&apic_reg_write_ns) / 1000)  % MICROSECOND,
+					"cnt", atomic64_read(&apic_reg_write_cnt),
+					"per", atomic64_read(&apic_reg_write_cnt) ?
+					 atomic64_read(&apic_reg_write_ns) / atomic64_read(&apic_reg_write_cnt) / 1000 : 0);
+		seq_printf(seq, "%6s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+					"rwh<-", (atomic64_read(&apic_reg_write_handle_ns) / 1000) / MICROSECOND,
+							(atomic64_read(&apic_reg_write_handle_ns) / 1000)  % MICROSECOND,
+					"cnt", atomic64_read(&apic_reg_write_handle_cnt),
+					"per", atomic64_read(&apic_reg_write_handle_cnt) ?
+					 atomic64_read(&apic_reg_write_handle_ns) / atomic64_read(&apic_reg_write_handle_cnt) / 1000 : 0);
+
+		seq_printf(seq, "%6s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+					"ipi->", (atomic64_read(&ipi_ns) / 1000) / MICROSECOND,
+							(atomic64_read(&ipi_ns) / 1000)  % MICROSECOND,
+					"cnt", atomic64_read(&ipi_cnt),
+					"per", atomic64_read(&ipi_cnt) ?
+					 atomic64_read(&ipi_ns) / atomic64_read(&ipi_cnt) / 1000 : 0);
+		seq_printf(seq, "%6s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+					"ipih<-", (atomic64_read(&ipi_handle_ns) / 1000) / MICROSECOND,
+							(atomic64_read(&ipi_handle_ns) / 1000)  % MICROSECOND,
+					"cnt", atomic64_read(&ipi_handle_cnt),
+					"per", atomic64_read(&ipi_handle_cnt) ?
+					 atomic64_read(&ipi_handle_ns) / atomic64_read(&ipi_handle_cnt) / 1000 : 0);
+
+		/* Net - event_signal */
+		seq_printf(seq, "%s %lu %s %ld\n",
+		                    "eventfd_delegate_cnt", eventfd_delegate_cnt,
+		                    "eventfd_delegated_cnt", atomic64_read(&eventfd_delegated_cnt));
+	} else { /* clear */
+		atomic64_set(&apic_reg_write_cnt, 0);
+		atomic64_set(&apic_reg_write_ns, 0);
+		atomic64_set(&apic_reg_write_handle_cnt, 0);
+		atomic64_set(&apic_reg_write_handle_ns, 0);
+
+		atomic64_set(&ipi_cnt, 0);
+		atomic64_set(&ipi_ns, 0);
+		atomic64_set(&ipi_handle_cnt, 0);
+		atomic64_set(&ipi_handle_ns, 0);
+
+		eventfd_delegate_cnt = 0;
+		atomic64_set(&eventfd_delegated_cnt, 0);
+	}
+#endif
+}
+
+
+/*******************
+ *
+ */
+DEFINE_KMSG_WQ_HANDLER(remote_kvm_create_request);
+DEFINE_KMSG_WQ_HANDLER(origin_sipi_request);
+DEFINE_KMSG_WQ_HANDLER(origin_broadcast_accept_irq_request);
+DEFINE_KMSG_WQ_HANDLER(origin_broadcast_apic_reg_write_request);
+DEFINE_KMSG_WQ_HANDLER(origin_broadcast_cpu_table_request);
+DEFINE_KMSG_WQ_HANDLER(update_cpu_table_request);
+DEFINE_KMSG_WQ_HANDLER(ipi_request);
+DEFINE_KMSG_WQ_HANDLER(sig_request);
+DEFINE_KMSG_WQ_HANDLER(checkin_vcpu_pid_request);
+DEFINE_KMSG_WQ_HANDLER(origin_checkin_vcpu_pid_request);
+DEFINE_KMSG_WQ_HANDLER(update_vcpu_request);
+DEFINE_KMSG_WQ_HANDLER(delegate_skb_tx_request);
+DEFINE_KMSG_WQ_HANDLER(delegate_net_msg_tx_request);
+DEFINE_KMSG_WQ_HANDLER(eventfd_delegate_request);
+int __init popcorn_hype_kvm_init(void)
+{
+	// reg
+    REGISTER_KMSG_WQ_HANDLER(
+            PCN_KMSG_TYPE_REMOTE_KVM_CREATE_REQUEST, remote_kvm_create_request);
+    REGISTER_KMSG_HANDLER(
+            PCN_KMSG_TYPE_REMOTE_KVM_CREATE_RESPONSE, remote_kvm_create_response);
+
+    REGISTER_KMSG_WQ_HANDLER(
+            PCN_KMSG_TYPE_ORIGIN_SIPI_REQUEST, origin_sipi_request);
+    REGISTER_KMSG_HANDLER(
+            PCN_KMSG_TYPE_ORIGIN_SIPI_RESPONSE, origin_sipi_response);
+    REGISTER_KMSG_WQ_HANDLER(PCN_KMSG_TYPE_ORIGIN_BROADCAST_ACCEPT_IRQ_REQUEST,
+								origin_broadcast_accept_irq_request);
+    REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_ORIGIN_BROADCAST_ACCEPT_IRQ_RESPONSE,
+								origin_broadcast_accept_irq_response);
+    REGISTER_KMSG_WQ_HANDLER(
+					PCN_KMSG_TYPE_ORIGIN_BROADCAST_APIC_REG_WRITE_REQUEST,
+								origin_broadcast_apic_reg_write_request);
+    REGISTER_KMSG_HANDLER(
+					PCN_KMSG_TYPE_ORIGIN_BROADCAST_APIC_REG_WRITE_RESPONSE,
+								origin_broadcast_apic_reg_write_response);
+
+    REGISTER_KMSG_WQ_HANDLER(PCN_KMSG_TYPE_ORIGIN_BROADCAST_CPU_TABLE_REQUEST,
+								origin_broadcast_cpu_table_request);
+    REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_ORIGIN_BROADCAST_CPU_TABLE_RESPONSE,
+								origin_broadcast_cpu_table_response);
+	REGISTER_KMSG_WQ_HANDLER(PCN_KMSG_TYPE_UPDATE_CPU_TABLE_REQUEST_FIELDS,
+								update_cpu_table_request);
+
+	REGISTER_KMSG_WQ_HANDLER(PCN_KMSG_TYPE_IPI_REQUEST, ipi_request); /* For ipi */
+    REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_IPI_RESPONSE, ipi_response);
+	REGISTER_KMSG_WQ_HANDLER(PCN_KMSG_TYPE_SIG_REQUEST, sig_request);
+    REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_SIG_RESPONSE, sig_response);
+	REGISTER_KMSG_WQ_HANDLER(PCN_KMSG_TYPE_REMOTE_CHECKIN_VCPU_PID_REQUEST,
+											checkin_vcpu_pid_request);
+    REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_REMOTE_CHECKIN_VCPU_PID_RESPONSE,
+											checkin_vcpu_pid_response);
+	REGISTER_KMSG_WQ_HANDLER(PCN_KMSG_TYPE_ORIGIN_CHECKIN_VCPU_PID_REQUEST,
+											origin_checkin_vcpu_pid_request);
+    REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_ORIGIN_CHECKIN_VCPU_PID_RESPONSE,
+											origin_checkin_vcpu_pid_response);
+
+	REGISTER_KMSG_WQ_HANDLER(PCN_KMSG_TYPE_DELEGATE_EVENTFD_REQUEST,
+											eventfd_delegate_request);
+    REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_DELEGATE_EVENTFD_RESPONSE,
+										eventfd_delegate_response);
+
+	/* For Pophype migration */
+	REGISTER_KMSG_WQ_HANDLER(PCN_KMSG_TYPE_UPDATE_VCPU_REQUEST,
+												update_vcpu_request);
+    REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_UPDATE_VCPU_RESPONSE,
+												update_vcpu_response);
+
+	/* Network */
+	REGISTER_KMSG_WQ_HANDLER(PCN_KMSG_TYPE_DELEGATE_SKB_TX_REQUEST,
+											delegate_skb_tx_request);
+    REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_DELEGATE_SKB_TX_RESPONSE,
+												delegate_skb_tx_response);
+
+	REGISTER_KMSG_WQ_HANDLER(PCN_KMSG_TYPE_DELEGATE_NET_MSG_TX_REQUEST,
+											delegate_net_msg_tx_request);
+    REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_DELEGATE_NET_MSG_TX_RESPONSE,
+												delegate_net_msg_tx_response);
+
+	/* AP start debugging */
+	//hype_callin[1] = false;
+
+	popcorn_hype_check_remote_cpus();
+
+	/* VM stack walk */
+	kvaddr = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	BUG_ON(!kvaddr);
+	//kfree(kvaddr);
+
+	/* */
+	spin_lock_init(&phmigrate);
+
+	return 0;
+}
diff --git a/kernel/popcorn/hype_migrate.c b/kernel/popcorn/hype_migrate.c
new file mode 100644
index 000000000000..82e1036516b0
--- /dev/null
+++ b/kernel/popcorn/hype_migrate.c
@@ -0,0 +1,88 @@
+/*
+ * hype_migrate.c
+ * Copyright (C) 2020 jackchuang <jackchuang@mir>
+ *
+ * Distributed under terms of the MIT license.
+ *
+ * @author Ho-Ren (Jack) Chuang, SSRG Virginia Tech 2020
+ */
+
+//#include <popcorn/hype_migrate.h> // cannot compile. why?
+#include <linux/kvm_host.h>
+
+#include <linux/kernel.h> /* syscall*/
+#include <linux/syscalls.h> /* syscall */
+#include <linux/delay.h> /* msleep */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+
+#ifdef CONFIG_POPCORN_HYPE
+
+/* search EXIT_REASON_VMCALL & handle_vmcall in ./arch/x86/kvm/vmx.c
+ *		 handle_vmcall -> kvm_emulate_hypercall
+ * ref: https://www.vvzixun.com/index.php/code/2cd8231a84b405b7b5cc5b3df7dad6be
+ *
+ * VM kvm_hypercall*(nr, argv0, argv1, ...);
+ * nr: reason
+ * a0: argv0
+ * a1: argv1
+ * example: kvm_hypercall2(KVM_HC_KICK_CPU, flags, apicid);
+ * 									in ./arch/x86/kernel/kvm.c
+ *	--------------------------------
+ * Host  kvm_emulate_hypercall()
+ * nr: reason
+ * a0: argv0
+ * a1: argv1
+ *		(...)
+ * case KVM_HC_KICK_CPU:
+ */
+
+//#if !POPHYPE_HOST_KERNEL /* TODO: fix it: compiler error "undefined reference to `sys_pophype_migrate'" */
+/* syscall -> hypercall (guest) -> user lkvm calls migrate(0) + init vcpu + migration(1) + migration(87) pophype_do_migrate() to update states and then migrate(0)
+ *
+ */
+//SYSCALL_DEFINE1(pophype_migrate, int __user, a0, int, a1)
+/* Caller: VM kernel space */
+SYSCALL_DEFINE2(pophype_migrate, int, a0, int, a1)
+{
+	PHGMIGRATEPRINTK("[%d] <%d> %s %d %s(): Start\n",
+			current->pid, smp_processor_id(), __FILE__, __LINE__, __func__);
+	kvm_hypercall2(KVM_HC_POPHYPE_MIGRATE, a0, a1);
+	PHGMIGRATEPRINTK("[%d] <%d> %s %d %s(): "
+			"Done for debugging and see this printk (SUCCESS)\n",
+			current->pid, smp_processor_id(), __FILE__, __LINE__, __func__);
+	return 0;
+}
+//#endif
+
+
+//kvm_hypercall2(KVM_HC_POPHYPE_NET_DELEGATE. a0, a1);
+
+/* pophype migration request from host kernel */
+// oeigin: to/back
+//
+int pophype_puase_vm_and_migrate(void)
+{
+	// 1 kick with reason
+	//		kvm_vcpu_kick(vcpu)
+	// 2 check the reason
+	// 3 call the pophype migration
+	return 0;
+}
+
+#if 0
+/* Idea: This has to be in user:
+ * hypercall -> return to user with vm_exit=xxx
+ *	(user) syscall pophype_migration_flag on
+ * 	(user) syscall flush_dsm (when should I do this) (search destroy rc)
+ * 	(user) syscall migration (rely on pophype_migration_flag to know it should do optimized migration)
+ *	(user) syscall pophype_migration_flag off
+ * 	(user)
+ *
+ */
+/* pophype migration request from guest VM */
+#endif
+
+#endif
diff --git a/kernel/popcorn/init.c b/kernel/popcorn/init.c
index b68ab3779ea4..49bb66adb6ca 100644
--- a/kernel/popcorn/init.c
+++ b/kernel/popcorn/init.c
@@ -28,6 +28,10 @@ extern int vma_server_init(void);
 extern int page_server_init(void);
 extern int remote_info_init(void);
 extern int statistics_init(void);
+extern int popcorn_hype_file_init(void);
+extern int popcorn_hype_kvm_init(void);
+extern int vm_dsm_debug_init(void);
+extern int vm_dsm_debug_timer_init(void);
 
 static int __init popcorn_init(void)
 {
@@ -49,6 +53,13 @@ static int __init popcorn_init(void)
 	page_server_init();
 	sched_server_init();
 
+#ifdef CONFIG_POPCORN_HYPE
+	popcorn_hype_file_init();
+	popcorn_hype_kvm_init();
+	vm_dsm_debug_init();
+	vm_dsm_debug_timer_init();
+#endif
+
 	remote_info_init();
 	statistics_init();
 	return 0;
diff --git a/kernel/popcorn/page_server.c b/kernel/popcorn/page_server.c
index ed4ca90efe99..f1b7b08d7b11 100644
--- a/kernel/popcorn/page_server.c
+++ b/kernel/popcorn/page_server.c
@@ -25,9 +25,12 @@
 #include <asm/cacheflush.h>
 #include <asm/mmu_context.h>
 
+#include <asm/vmx.h>
 #include <popcorn/types.h>
 #include <popcorn/bundle.h>
 #include <popcorn/pcn_kmsg.h>
+#include <popcorn/hype_kvm.h>
+#include <popcorn/debug.h>
 
 #include "types.h"
 #include "pgtable.h"
@@ -37,6 +40,233 @@
 
 #include "trace_events.h"
 
+
+#ifdef CONFIG_POPCORN_HYPE
+#include <linux/mmu_notifier.h>
+#define HYPE_RETRY (-78)
+//#define KERNEL_PGS (PAGE_SIZE * 1024 * 1024 / 1024)
+#define KERNEL_PGS (0xd0000 + 0x30000) // 0xd0000 + 0x30000 = 1048576 // works
+//#define KERNEL_PGS (2017020) // try debuging 1117020
+
+/*
+ * Eighter one
+ */
+/* when debuging ap */
+//#define ORIGIN_PGFAULT_SKIP (48000 + KERNEL_PGS)
+////#define REMOTE_PGFAULT_SKIP (0 + KERNEL_PGS) // standard
+//#define REMOTE_PGFAULT_SKIP (0 + KERNEL_PGS + 1000) // faster
+//#define PGFAULT_REQ_AT_ORIGIN_SKIP (0 + KERNEL_PGS)
+//#define PGFAULT_REQ_AT_REMOTE_SKIP (0 + 0)
+
+/* when mount_root() debugging */
+//  >>
+//  1142478
+//- 1048576
+//    70000
+
+//   1099214
+// - 1048576
+//     50000
+//  >>
+//#define ORIGIN_PGFAULT_SKIP (95000 + KERNEL_PGS)
+#define ORIGIN_PGFAULT_SKIP (115000 + KERNEL_PGS)
+//#define REMOTE_PGFAULT_SKIP (0 + KERNEL_PGS + 50000) // faster
+#define REMOTE_PGFAULT_SKIP (0 + KERNEL_PGS + 65000) // faster
+//1130111
+// 1048576
+
+#define PGFAULT_REQ_AT_ORIGIN_SKIP (40000 + KERNEL_PGS)
+//#define PGFAULT_REQ_AT_REMOTE_SKIP (0 + 22000)
+#define PGFAULT_REQ_AT_REMOTE_SKIP (0 + 50000)
+
+// 1117044
+
+// PAGEFAULT_
+//   1076801  1089362
+// - 1048576
+//     28000
+
+// remote
+// 22044
+// PAGEFAULT_
+
+/* mount_root() */
+// origin pg 1114693 1100000
+// remote pg 1079782 1070000
+// origin inv
+// remote inv 51404 50000
+
+// origin
+//		## PAGEFAULT [8730] 700990 R 429eb4 54 8000000000000865 vm_ops ffffffffa04835c0 #1115512
+//[  957.232533] 			>>[8748] 700000 ffff88084f3e5460 #1142478
+//[  957.232534] 			  [8748] ->[2696/1] 700000 r 0 #1076800
+// 			->REMOTE_PAGE_REQUEST [8748] 700000 W(INV) 429f15 from [2696/1] #1076801
+//[  957.264378] 			>>[8748] 700000 ffff88084f3e5460 #1142480
+//[  957.264379] 			  [8748] ->[2696/1] 700000 r 1000 #1076801
+
+
+// remote
+//	## PAGEFAULT [2696] 7ffec1f1b000 W 468797 1 8000000000000866           (null) #1081141
+//[ 1040.983829]  =[2696] 7ffec1f1b000 ffff880859daecd0 INVALIDATE_PAGE
+//[ 1040.983831]   [2696] ->[8748/0] 7ffec1f1b000 instr 468797
+//[ 1040.989298] 			>>[2696] 7ffec1f1b000 ffff880859daecd0 #1099175
+//[ 1041.003993]
+//
+//			->REMOTE_PAGE_REQUEST [2614] 7fffefff3000 R 468797 from [8747/0] ***#22044***
+//[ 1041.444157] 			  [2614] ->[8747/0] 7fffefff3000 r 0 #22044
+//[ 1041.449692]  =[2696] 7fffefff3000 ffff88085252f208 INVALIDATE_PAGE
+//[ 1041.449754]
+//		INVALIDATE_PAGE [2614] 7fffefff3000 [8747/0] #48738
+//		[ 1041.449756]   [2614] inv 7fffefff3000 but local write ongoing, wait
+//		[ 1041.449757]  +[2614] 7fffefff3000 ffff88085252f208 (follower) #48738
+//		[ 1041.476176]   [2696] ->[8748/0] 7fffefff3000 instr 468797
+//		[ 1041.481654] 			>>[2696] 7fffefff3000 ffff88085252f208 #1099214
+//		[ 1041.487534]  =[2614] 7fffefff3000 ffff88085252f208 (inv follower done)
+//		[ 1041.494191]
+
+
+/*** origin revoke remote INVALIDATE_PAGE
+ *  revoke	->
+ *				INV
+ *			<-
+ */
+// smp debug
+//#define COMM_INV_CNT (47500) // 47633 // works right before smp boot process
+// mount_root() debug
+
+// 101000: first bash
+// 51500: last use
+// 47633 // works right before smp boot process
+#define COMM_INV_CNT (123000) // 150000(good for manually dynamic debug) has to run 3t one time to see the logs
+#define ORIGIN_REVOKE (COMM_INV_CNT)
+#define REMOTE_REVOKE (0)
+#define ORIGIN_INVPG (0)
+#define REMOTE_INVPG (COMM_INV_CNT) // + 0xc0000 + 0x30000)
+
+
+
+
+
+/* remotefault at remote RETRY */
+//#define RETRY_REMOTEFAULT 100000000 //good
+//#define RETRY_ORIGINFAULT_AT_ORIGIN 100
+#define RETRY_ORIGINFAULT_AT_ORIGIN 10000000
+//#define RETRY_REMOTEFAULT 1000 // bad
+//#define RETRY_REMOTEFAULT 100
+#define RETRY_REMOTEFAULT 10
+#define RETRY_REMOTEFAULT_GIVEUP 1 /* issue BUG() at origin */
+
+/* DSM traffic debug */
+//#define MAX_VM_STACK_DEBUG 3
+//struct dsm_pgfault {
+//	unsigned long addr; /* faulting addr */
+//	unsigned long inst;
+//	unsigned long rbp;
+//	unsigned long rsp;
+//	unsigned long stack[MAX_VM_STACK_DEBUG];
+//	unsigned long cnt; /* freq */
+//	unsigned long long time; /* total */
+//};
+//typedef struct {
+//	unsigned long addr; /* faulting addr */
+//	unsigned long inst;
+//	unsigned long rbp;
+//	unsigned long rsp;
+//	unsigned long stack[MAX_VM_STACK_DEBUG];
+//	unsigned long cnt; /* freq */
+//	unsigned long long time; /* total */
+//} dsm_traffic_t;
+#define DSM_TRAFFIC_PG_CNT 6500
+#define DSM_TRAFFIC_INST_CNT 1500 // change to dynamic otherwise waste time to tune
+#define DSM_TRAFFIC_RSP_CNT 10 // change to dynamic otherwise waste time to tune
+/* [*][0] indicates the addr; */
+//struct dsm_pgfault **dsm_traffic = NULL;
+dsm_traffic_t ***dsm_traffic = NULL; /* TODO move this to trace... out of mem */
+unsigned long dsm_traffic_pg_cnt = DSM_TRAFFIC_PG_CNT;
+unsigned long dsm_traffic_inst_cnt = DSM_TRAFFIC_INST_CNT;
+unsigned long dsm_traffic_rsp_cnt = DSM_TRAFFIC_RSP_CNT;
+unsigned long max_dsm_traffic_pg_cnt;
+unsigned long max_dsm_traffic_inst_cnt;
+unsigned long max_dsm_traffic_rsp_cnt;
+
+
+static unsigned long all_local_dsm_traffic_cnt = 0;
+static unsigned long dbg_dsm_traffic_cnt = 0; /* vmdsm cnt */
+static unsigned long dbg_dsm_traffic_good_cnt = 0; /* vmdsm cnt */
+
+static unsigned long g_lfal_retry_cnt = 0;
+
+#ifdef CONFIG_POPCORN_HYPE
+extern atomic64_t kvm_eptfault_ns;
+extern atomic64_t kvm_eptfault_cnt;
+//extern atomic64_t kvm_eptfault_new_ns;
+//extern atomic64_t kvm_eptfault_new_cnt;
+#endif
+#endif
+
+/* (##)localfault -> (-/=)follower/leader -> (>>)finish
+ * 											fault_flags pte_flags(pte_val)
+ * ## PAGEFAULT [3249] 7ffec1f1a000 W 468267 d 8000000000000866
+ *  =[3249] 7ffec1f1a000 replicated not mine ffff88084ed3ebe0(fh)
+ * >>[3249] 7ffec1f1a000 ffff88084ed3ebe0(fh)
+ *
+ *
+ * (->)send
+ * REMOTE_PAGE_REQUEST [3251] 7ffec1802000 R 468267 from [2692/1]
+ * >>[3251] 7ffec1802000 ffff88083697ba00
+ *   [3251] ->[2692/1] 0
+ *
+ * (>>)last_fini (>)!last_fini
+ *  >[3251] 7ffec1802000 ffff88083697ba00
+ * >>[3251] 7ffec1802000 ffff88083697ba00
+ *
+ *
+ * INVALIDATION:
+ *  +[] (optional)(found fh existing (foller))
+ *  =[] (done leader/follower)
+ * no >>[]
+ *
+ *
+ * =[] at remote: only inv complet and
+ */
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+#define MICROSECOND 1000000
+atomic64_t mm_cnt = ATOMIC64_INIT(0);
+atomic64_t mm_time_ns = ATOMIC64_INIT(0);
+
+/* local origin & it has to bring from remote (RW)*/
+//atomic64_t ptef_ns = ATOMIC64_INIT(0);
+//atomic64_t ptef_cnt = ATOMIC64_INIT(0);
+/* local_origin & __claim_remote_page(1)(!pg_mine)(RW) */
+atomic64_t clr_ns = ATOMIC64_INIT(0);
+atomic64_t clr_cnt = ATOMIC64_INIT(0);
+atomic64_t clrr_ns = ATOMIC64_INIT(0);
+atomic64_t clrr_cnt = ATOMIC64_INIT(0);
+
+/* local_origin & !pg_mine & !send_revoke_msg & is_page */
+atomic64_t fp_ns = ATOMIC64_INIT(0);
+atomic64_t fp_cnt = ATOMIC64_INIT(0);
+
+/* local_origin & !pg_mine & !send_revoke_msg & is_page */
+atomic64_t fpin_ns = ATOMIC64_INIT(0);
+atomic64_t fpin_cnt = ATOMIC64_INIT(0);
+atomic64_t fpinh_ns = ATOMIC64_INIT(0);
+atomic64_t fpinh_cnt = ATOMIC64_INIT(0);
+
+/* __claim_local_page(pg_mine) & origin */
+atomic64_t inv_ns = ATOMIC64_INIT(0);
+atomic64_t inv_cnt = ATOMIC64_INIT(0);
+
+/* process_page_invalidate_request */
+atomic64_t invh_ns = ATOMIC64_INIT(0);
+atomic64_t invh_cnt = ATOMIC64_INIT(0);
+/* full rr fault time */
+atomic64_t fph_ns = ATOMIC64_INIT(0);
+atomic64_t fph_cnt = ATOMIC64_INIT(0);
+#endif
+
+bool pophype_debug = false; /* pophype DSM force all printks */
+
 inline void page_server_start_mm_fault(unsigned long address)
 {
 #ifdef CONFIG_POPCORN_STAT_PGFAULTS
@@ -66,11 +296,351 @@ inline int page_server_end_mm_fault(int ret)
 				current->fault_address, ret,
 				current->fault_retry, ktime_to_ns(dt));
 		current->fault_address = 0;
+        if (ktime_to_ns(dt) < 1000 * MICROSECOND) { /* noise filter */
+            atomic64_add(ktime_to_ns(dt), &mm_time_ns);
+            atomic64_inc(&mm_cnt);
+        }
 	}
 #endif
 	return ret;
 }
 
+void pf_time_stat(struct seq_file *seq, void *v)
+{
+#ifdef CONFIG_POPCORN_STAT
+	if (seq) {
+		seq_printf(seq, "%4s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+					"mm", (atomic64_read(&mm_time_ns) / 1000) / MICROSECOND,
+							(atomic64_read(&mm_time_ns) / 1000)  % MICROSECOND,
+					"cnt", atomic64_read(&mm_cnt),
+					"per", atomic64_read(&mm_cnt) ?
+					 atomic64_read(&mm_time_ns)/atomic64_read(&mm_cnt)/1000 : 0);
+
+		//seq_printf(seq, "%4s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+		//			"ptef", (atomic64_read(&ptef_ns) / 1000) / MICROSECOND,
+		//					(atomic64_read(&ptef_ns) / 1000)  % MICROSECOND,
+		//			"cnt", atomic64_read(&ptef_cnt),
+		//			"per", atomic64_read(&ptef_cnt) ?
+		//			 atomic64_read(&ptef_ns)/atomic64_read(&ptef_cnt)/1000 : 0);
+
+		/* localfault_at_origin */
+		seq_printf(seq, "%4s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+					"clr", (atomic64_read(&clr_ns) / 1000) / MICROSECOND,
+							(atomic64_read(&clr_ns) / 1000)  % MICROSECOND,
+					"cnt", atomic64_read(&clr_cnt),
+					"per", atomic64_read(&clr_cnt) ?
+					 atomic64_read(&clr_ns)/atomic64_read(&clr_cnt)/1000 : 0);
+		/* clr retry */
+		seq_printf(seq, "%4s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+					"clrr", (atomic64_read(&clrr_ns) / 1000) / MICROSECOND,
+							(atomic64_read(&clrr_ns) / 1000)  % MICROSECOND,
+					"cnt", atomic64_read(&clrr_cnt),
+					"per", atomic64_read(&clrr_cnt) ?
+					 atomic64_read(&clrr_ns)/atomic64_read(&clrr_cnt)/1000 : 0);
+
+		/* R: only page (R+!pg_mine) */
+		seq_printf(seq, "%4s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+			"fp", (atomic64_read(&fp_ns) / 1000) / MICROSECOND,
+					(atomic64_read(&fp_ns) / 1000)  % MICROSECOND,
+			"cnt", atomic64_read(&fp_cnt),
+			"per", atomic64_read(&fp_cnt) ?
+			 atomic64_read(&fp_ns)/atomic64_read(&fp_cnt)/1000 : 0);
+
+		seq_printf(seq, "%4s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+			"fph", (atomic64_read(&fph_ns) / 1000) / MICROSECOND,
+					(atomic64_read(&fph_ns) / 1000)  % MICROSECOND,
+			"cnt", atomic64_read(&fph_cnt),
+			"per", atomic64_read(&fph_cnt) ?
+			 atomic64_read(&fph_ns)/atomic64_read(&fph_cnt)/1000 : 0);
+
+		/* W: only inv */
+		seq_printf(seq, "%4s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+			"inv", (atomic64_read(&inv_ns) / 1000) / MICROSECOND,
+					(atomic64_read(&inv_ns) / 1000)  % MICROSECOND,
+			"cnt", atomic64_read(&inv_cnt),
+			"per", atomic64_read(&inv_cnt) ?
+			 atomic64_read(&inv_ns)/atomic64_read(&inv_cnt)/1000 : 0);
+
+		seq_printf(seq, "%4s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+			"invh", (atomic64_read(&invh_ns) / 1000) / MICROSECOND,
+					(atomic64_read(&invh_ns) / 1000)  % MICROSECOND,
+			"cnt", atomic64_read(&invh_cnt),
+			"per", atomic64_read(&invh_cnt) ?
+			 atomic64_read(&invh_ns)/atomic64_read(&invh_cnt)/1000 : 0);
+
+		/* W: page + inv */
+		seq_printf(seq, "%4s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+			"fpiv", (atomic64_read(&fpin_ns) / 1000) / MICROSECOND,
+					(atomic64_read(&fpin_ns) / 1000)  % MICROSECOND,
+			"cnt", atomic64_read(&fpin_cnt),
+			"per", atomic64_read(&fpin_cnt) ?
+			 atomic64_read(&fpin_ns)/atomic64_read(&fpin_cnt)/1000 : 0);
+		seq_printf(seq, "%5s  %9ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+			"fpivh", (atomic64_read(&fpinh_ns) / 1000) / MICROSECOND,
+					(atomic64_read(&fpinh_ns) / 1000)  % MICROSECOND,
+			"cnt", atomic64_read(&fpinh_cnt),
+			"per", atomic64_read(&fpinh_cnt) ?
+			 atomic64_read(&fpinh_ns)/atomic64_read(&fpinh_cnt)/1000 : 0);
+#ifdef CONFIG_POPCORN_HYPE
+		seq_printf(seq, "%8s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+			"eptfault", (atomic64_read(&kvm_eptfault_ns) / 1000) / MICROSECOND,
+			(atomic64_read(&kvm_eptfault_ns) / 1000)  % MICROSECOND,
+			"cnt", atomic64_read(&kvm_eptfault_cnt),
+			"per", atomic64_read(&kvm_eptfault_cnt) ?
+				atomic64_read(&kvm_eptfault_ns) /
+					atomic64_read(&kvm_eptfault_cnt) / 1000 : 0);
+		seq_printf(seq, "%9s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+			"eptfault2", (pophype_get_kvm_eptfault_new_ns() / 1000) / MICROSECOND,
+			(pophype_get_kvm_eptfault_new_ns() / 1000)  % MICROSECOND,
+			"cnt", pophype_get_kvm_eptfault_new_cnt(),
+			"per", pophype_get_kvm_eptfault_new_cnt() ?
+				pophype_get_kvm_eptfault_new_ns() /
+					pophype_get_kvm_eptfault_new_cnt() / 1000 : 0);
+		seq_printf(seq, "%s %ld   %s %ld   %s %ld   %s %ld\n",
+			"gva_user cnt", pophype_get_user_gva_cnt(),
+			"gva_kernel cnt", pophype_get_kernel_gva_cnt(),
+			"gva_unknow cnt", pophype_get_unknow_gva_cnt(),
+			"gva_wrong cnt", pophype_get_wrong_validity_gva_cnt());
+		seq_printf(seq, "%s %ld   %s %ld\n",
+			"gva_ret_userspace cnt", pophype_get_gva_ret_userspace_cnt(),
+			"gva_ret_kernelspace cnt", pophype_get_gva_ret_kernelspace_cnt());
+#endif
+	} else {
+        atomic64_set(&mm_cnt, 0);
+        atomic64_set(&mm_time_ns, 0);
+
+		//atomic64_set(&ptef_cnt, 0);
+		//atomic64_set(&ptef_ns, 0);
+		atomic64_set(&clr_cnt, 0);
+		atomic64_set(&clr_ns, 0);
+		atomic64_set(&fp_ns, 0);
+		atomic64_set(&fp_cnt, 0);
+		atomic64_set(&fph_ns, 0);
+		atomic64_set(&fph_cnt, 0);
+
+		atomic64_set(&inv_cnt, 0);
+		atomic64_set(&inv_ns, 0);
+		atomic64_set(&invh_cnt, 0);
+		atomic64_set(&invh_ns, 0);
+
+		atomic64_set(&fpin_ns, 0);
+		atomic64_set(&fpin_cnt, 0);
+		atomic64_set(&fpinh_ns, 0);
+		atomic64_set(&fpinh_cnt, 0);
+
+#ifdef CONFIG_POPCORN_HYPE
+		atomic64_set(&kvm_eptfault_ns, 0);
+		atomic64_set(&kvm_eptfault_cnt, 0);
+		pophype_set_kvm_eptfault_new_cnt(0);
+		pophype_set_kvm_eptfault_new_ns(0);
+		pophype_set_user_gva_cnt(0);
+		pophype_set_kernel_gva_cnt(0);
+		pophype_set_unknow_gva_cnt(0);
+		pophype_set_wrong_validity_gva_cnt(0);
+#endif
+	}
+#endif
+}
+
+void write_dsm_traffic (dsm_traffic_t *_dsm_traffic,
+									unsigned long addr,
+									unsigned long rip,
+									unsigned long rbp,
+									unsigned long rsp,
+									unsigned long stack0,
+									unsigned long stack1,
+									unsigned long stack2,
+									unsigned long cnt) {
+	_dsm_traffic->addr = addr;
+	_dsm_traffic->rip = rip;
+	_dsm_traffic->rbp = rbp;
+	_dsm_traffic->rsp = rsp;
+//	_dsm_traffic->stack[0] = stack0;
+//	_dsm_traffic->stack[1] = stack1;
+//	_dsm_traffic->stack[2] = stack2;
+//	_dsm_traffic->cnt = cnt;
+}
+
+/* address: full addr
+ * addr: page algiend addr
+ */
+//#include <kvm/kvm_cache_regs.h>
+#include "../../arch/x86/kvm/kvm_cache_regs.h"
+#define __ex_clear(x, reg) \
+	____kvm_handle_fault_on_reboot(x, "xor " reg " , " reg)
+static __always_inline unsigned long vmcs_readl(unsigned long field)
+{
+	unsigned long value;
+
+	asm volatile (__ex_clear(ASM_VMX_VMREAD_RDX_RAX, "%0")
+		      : "=a"(value) : "d"(field) : "cc");
+	return value;
+}
+void __dsm_traffic_collect(unsigned long address, unsigned long addr, char op, struct kvm_vcpu *vcpu, unsigned long ns, unsigned long real_gva, unsigned long _exit_qualification)
+{
+#if HYPE_PERF_CRITICAL_DSM_TRAFFIC_DEBUG
+	//all_local_dsm_traffic_cnt++;
+
+	/* From handle_ept_violation */
+	unsigned long exit_qualification = vcpu->arch.exit_qualification;
+	unsigned long rip = kvm_rip_read(vcpu);
+	int gla_validity = (exit_qualification >> 7) & 0x3;
+	gpa_t gla = -1;
+
+	if (gla_validity & 0x1)
+		gla = vmcs_readl(GUEST_LINEAR_ADDRESS); // check Table 27-7 Intel manual
+	/* rip, gla, exit_qualification */
+
+
+	/* debug DSM trafic perf slow down */
+	/* Usage:
+	 * within 2 echo > /proc/popcorn_debug, do you want to
+	 *		trace & rank ALL pgafault or only the following tops?
+	 */
+	if (pophype_debug) { /* Controlled by /proc/popcorn_debug */
+		/* all or specific addresses extract by popcorn_trace top 30 */
+		/* For lemp */
+			//unsigned long inst;
+			dsm_traffic_t __dsm_traffic;
+#if HYPE_PERF_CRITICAL_DSM_TRAFFIC_PRINTK
+			//dsm_traffic_t _dsm_traffic;
+			//dbg_dsm_traffic_cnt++;
+			/* show cnt */
+			//POP_PK("pophype: do kvm_reg_dump() 0x%lx #%lu\n",
+			//					address, dbg_dsm_traffic_cnt);
+			//_dsm_traffic = pophype_show_guest_rip_rsp(address, true);
+			//if (_dsm_traffic.rip != 0) {
+			//}
+#endif
+
+#if 1
+			__dsm_traffic = pophype_show_guest_rip_rsp(address, false, vcpu);
+			dbg_dsm_traffic_cnt++;
+
+			/* Trace: todo show it in trace */
+			all_local_dsm_traffic_cnt++;
+			//if (__dsm_traffic.rip != 0)
+			{
+				int kvm_mp_state = KVM_MP_STATE_UNKNOW;
+				if (vcpu) {
+					kvm_mp_state = vcpu->arch.mp_state;
+					//#define KVM_MP_STATE_RUNNABLE          0
+					//#define KVM_MP_STATE_UNINITIALIZED     1
+					//#define KVM_MP_STATE_INIT_RECEIVED     2
+					//#define KVM_MP_STATE_HALTED            3
+					//#define KVM_MP_STATE_SIPI_RECEIVED     4
+					//#define KVM_MP_STATE_STOPPED           5
+					//#define KVM_MP_STATE_CHECK_STOP        6
+					//#define KVM_MP_STATE_OPERATING         7
+					//#define KVM_MP_STATE_LOAD              8
+					//#define KVM_MP_STATE_UNKNOW            9
+				} else {
+					printk(KERN_ERR "%s() %d:\n", __func__, __LINE__);
+				}
+				dbg_dsm_traffic_good_cnt++;
+				//#include "arch/x86/include/asm/kvm_host.h"
+				//printk("%d\n", kvm_x86_ops->get_cpl(vcpu));
+				//printk("%lu\n", kvm_get_linear_rip(vcpu));
+
+				// cpl
+				// arch/x86/kvm/x86.c ->
+				// kvm_x86_ops->get_cpl(vcpu)
+
+				// node
+				//enum {
+				//    OUTSIDE_GUEST_MODE, 			0
+				//    IN_GUEST_MODE,				1
+				//    EXITING_GUEST_MODE,			2
+				//    READING_SHADOW_PAGE_TABLES,	3
+				//};
+				trace_vmdsm_traffic(addr, op, __dsm_traffic.rip,
+						__dsm_traffic.rbp, __dsm_traffic.rsp,
+						__dsm_traffic.stack[0], __dsm_traffic.stack[1],
+						__dsm_traffic.stack[2], __dsm_traffic.stack[3],
+						__dsm_traffic.stack[4], address, kvm_mp_state, ns,
+						kvm_x86_ops->get_cpl(vcpu), vcpu->mode,
+						kvm_get_linear_rip(vcpu),
+						gla, exit_qualification);
+			}
+#endif
+
+		}
+#endif
+}
+
+/* NOT USED */
+void dsm_traffic_collect(unsigned long address, unsigned long addr, char op, unsigned long ns)
+{
+	__dsm_traffic_collect(address, addr, op, NULL, ns, -1, -1);
+}
+
+void dsm_traffic_collect_vcpu(unsigned long address, unsigned long addr, char op, struct kvm_vcpu *vcpu, unsigned long ns, unsigned long real_gva, unsigned long exit_qualification)
+{
+	__dsm_traffic_collect(address, addr, op, vcpu, ns, real_gva, exit_qualification);
+}
+
+void dsm_traffic_stat(struct seq_file *seq, void *v)
+{
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	/*
+	 * Order it:
+	 *		cat /proc/popcorn_debug | sort -nrk 7 (test)
+	 * 		sort -rk 7 out
+	 * TODO: sum time
+	 */
+	//if (seq && dsm_traffic) {
+	if (seq) {
+		seq_printf(seq, "=== pophype vmdsm info (sanity check) ===\n");
+		seq_printf(seq, "g_lfal_retry_cnt %lu\n", g_lfal_retry_cnt); // moved to popcorn_stat clrr
+		seq_printf(seq, "%8s  %10ld.%06ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+						"eptfault", (atomic64_read(&kvm_eptfault_ns) / 1000) / MICROSECOND,
+							(atomic64_read(&kvm_eptfault_ns) / 1000)  % MICROSECOND,
+							"cnt", atomic64_read(&kvm_eptfault_cnt),
+							"per", atomic64_read(&kvm_eptfault_cnt) ?
+							atomic64_read(&kvm_eptfault_ns) /
+								atomic64_read(&kvm_eptfault_cnt) / 1000 : 0);
+		seq_printf(seq, "=========================================\n");
+		seq_printf(seq, "all_local_dsm_traffic_cnt %lu\n", // all_prob
+									all_local_dsm_traffic_cnt);
+		//seq_printf(seq, "dbg_dsm_traffic_cnt all %lu\n", dbg_dsm_traffic_cnt);
+		seq_printf(seq, "dbg_dsm_traffic_good_cnt %lu\n", // trace_cnt
+									dbg_dsm_traffic_good_cnt);
+#if 0
+		int i, j, k;
+		seq_printf(seq, "Usage: cat /proc/popcorn_debug | sort -nrk 11\n");
+		for (i = 0; i < dsm_traffic_pg_cnt; i++) {
+			if (dsm_traffic[i][0][0].addr) {
+				for (j = 0; j < dsm_traffic_inst_cnt; j++) {
+					if (dsm_traffic[i][j][0].rip) {
+						for (k = 0; k < dsm_traffic_rsp_cnt; k++) {
+							if (dsm_traffic[i][j][k].cnt > 1000 ) {
+								seq_printf(seq, "[%d][%d] addr: 0x%-12lx "
+									"rip: 0x%-12lx "
+									"rbp: 0x%-12lx rsp: 0x%-12lx"
+									"cnt: %-12lu\n",
+									i,j, dsm_traffic[i][j][k].addr,
+									dsm_traffic[i][j][k].rip,
+									dsm_traffic[i][j][k].rbp,
+									dsm_traffic[i][j][k].rsp,
+									/* TODO tack[] */
+									dsm_traffic[i][j][k].cnt);
+							}
+						}
+					}
+				}
+			}
+		}
+#endif
+	} else { /* write */
+		all_local_dsm_traffic_cnt = 0;
+		dbg_dsm_traffic_cnt = 0;
+		dbg_dsm_traffic_good_cnt = 0;
+		atomic64_set(&kvm_eptfault_ns, 0);
+		atomic64_set(&kvm_eptfault_cnt, 0);
+	}
+#endif
+}
+
 static inline int __fault_hash_key(unsigned long address)
 {
 	return (address >> PAGE_SHIFT) % FAULTS_HASH;
@@ -232,6 +802,20 @@ out:
 	return ret;
 }
 
+bool page_is_mine_pub(struct mm_struct *mm, unsigned long addr)
+{
+	unsigned long offset;
+	unsigned long *pi = __get_page_info_mapped(mm, addr, &offset);
+	bool ret = true;
+
+	if (!pi) return true;
+	if (!test_bit(PI_FLAG_DISTRIBUTED, pi)) goto out;
+	ret = test_bit(my_nid, pi);
+out:
+	kunmap_atomic(pi - offset);
+	return ret;
+}
+
 static inline bool test_page_owner(int nid, struct mm_struct *mm, unsigned long addr)
 {
 	unsigned long offset;
@@ -319,7 +903,7 @@ static struct fault_handle *__alloc_fault_handle(struct task_struct *tsk, unsign
 	return fh;
 }
 
-
+/* remote fault */
 static struct fault_handle *__start_invalidation(struct task_struct *tsk, unsigned long addr, spinlock_t *ptl)
 {
 	unsigned long flags;
@@ -328,11 +912,16 @@ static struct fault_handle *__start_invalidation(struct task_struct *tsk, unsign
 	bool found = false;
 	DECLARE_COMPLETION_ONSTACK(complete);
 	int fk = __fault_hash_key(addr);
+#ifdef CONFIG_POPCORN_HYPE
+	static unsigned long start_inv_cnt = 0;
+	volatile unsigned long inv_thre;
+#endif
 
 	spin_lock_irqsave(&rc->faults_lock[fk], flags);
 	hlist_for_each_entry(fh, &rc->faults[fk], list) {
 		if (fh->addr == addr) {
-			PGPRINTK("  [%d] %s %s ongoing, wait\n", tsk->pid,
+			PGPRINTK("  [%d] inv %lx but %s %s ongoing, wait\n", tsk->pid,
+				fh->addr,
 				fh->flags & FAULT_HANDLE_REMOTE ? "remote" : "local",
 				fh->flags & FAULT_HANDLE_WRITE ? "write" : "read");
 			BUG_ON(fh->flags & FAULT_HANDLE_INVALIDATE);
@@ -345,15 +934,50 @@ static struct fault_handle *__start_invalidation(struct task_struct *tsk, unsign
 	spin_unlock_irqrestore(&rc->faults_lock[fk], flags);
 	put_task_remote(tsk);
 
+#ifdef CONFIG_POPCORN_HYPE
+	start_inv_cnt++;
+	if (tsk->at_remote) {
+		inv_thre = REMOTE_INVPG;
+	} else {
+		inv_thre = ORIGIN_INVPG;
+	}
+	/* origin revoke remote INVALIDATE_PAGE */
+#endif
 	if (found) {
 		spin_unlock(ptl);
-		PGPRINTK(" +[%d] %lx %p\n", tsk->pid, addr, fh);
+#ifdef CONFIG_POPCORN_HYPE
+		if (pophype_debug || INTERESTED_GVA_2AFTER4(addr) ||
+			((start_inv_cnt > inv_thre || INTERESTED_GVA(addr)) &&
+			NOTINTERESTED_GVA(addr))) {
+			//PGPRINTK(" +[%d] %lx %p (follower) #%lu\n",
+			//			tsk->pid, addr, fh, start_inv_cnt);
+		}
+#endif
 		wait_for_completion(&complete);
-		PGPRINTK(" =[%d] %lx %p\n", tsk->pid, addr, fh);
+#ifdef CONFIG_POPCORN_HYPE
+		if (pophype_debug ||
+		//if (pophype_debug || INTERESTED_GVA_2AFTER4(addr) ||
+			((start_inv_cnt > inv_thre || INTERESTED_GVA(addr)) &&
+			NOTINTERESTED_GVA(addr))) {
+			//PGPRINTK(" =[%d] %lx %p (inv follower done)\n", tsk->pid, addr, fh);
+		}
+#else
+		PGPRINTK(" =[%d] %lx %p (inv follower done)\n", tsk->pid, addr, fh);
+#endif
 		spin_lock(ptl);
 	} else {
 		fh = NULL;
-		PGPRINTK(" =[%d] %lx\n", tsk->pid, addr);
+#ifdef CONFIG_POPCORN_HYPE
+		if (pophype_debug ||
+		//if (pophype_debug || INTERESTED_GVA_2AFTER4(addr) ||
+			((start_inv_cnt > inv_thre || INTERESTED_GVA(addr)) &&
+			NOTINTERESTED_GVA(addr))) {
+			//PGPRINTK(" =[%d] %lx (inv leader) #%lu\n",
+			//			tsk->pid, addr, start_inv_cnt);
+		}
+#else
+		PGPRINTK(" =[%d] %lx (inv leader)\n", tsk->pid, addr);
+#endif
 	}
 	return fh;
 }
@@ -408,6 +1032,12 @@ static struct fault_handle *__start_fault_handling(struct task_struct *tsk, unsi
 #endif
 		if (action & FH_ACTION_RETRY) {
 			if (action & FH_ACTION_WAIT) {
+#ifdef CONFIG_POPCORN_HYPE
+				if (NOTINTERESTED_GVA(addr) || pophype_debug) {
+					PGPRINTK("  [%d] waits %lx fh %p %lx cannot coalesce\n",
+												tsk->pid, addr, fh, fh->addr);
+				}
+#endif
 				goto out_wait_retry;
 			}
 			goto out_retry;
@@ -417,6 +1047,12 @@ static struct fault_handle *__start_fault_handling(struct task_struct *tsk, unsi
 #endif
 
 		if (fh->limit++ > FH_ACTION_MAX_FOLLOWER) {
+#ifdef CONFIG_POPCORN_HYPE
+			if (NOTINTERESTED_GVA(addr) || pophype_debug) {
+				PGPRINTK("  [%d] waits %lx fh %p %lx too many followes\n",
+											tsk->pid, addr, fh, fh->addr);
+			}
+#endif
 			goto out_wait_retry;
 		}
 
@@ -454,7 +1090,11 @@ out_wait_retry:
 	spin_unlock_irqrestore(&rc->faults_lock[fk], flags);
 	put_task_remote(tsk);
 
-	PGPRINTK("  [%d] waits %p\n", tsk->pid, fh);
+#ifdef CONFIG_POPCORN_HYPE
+#else
+	PGPRINTK("  [%d] waits %p too many followes/fh cannot coalesce\n",
+														tsk->pid, fh);
+#endif
 	io_schedule();
 	finish_wait(&fh->waits_retry, &wait);
 	if (atomic_dec_and_test(&fh->pendings_retry)) {
@@ -466,7 +1106,18 @@ out_retry:
 	spin_unlock_irqrestore(&rc->faults_lock[fk], flags);
 	put_task_remote(tsk);
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (pophype_debug || INTERESTED_GVA_2AFTER4(addr) ||
+		((distributed_process(tsk) &&
+		INTERESTED_GVA(addr)) &&
+		NOTINTERESTED_GVA(addr))) {
+		PGPRINTK("\t\t  [%d] locked. retry 0x%lx %p\n", tsk->pid, addr, fh);
+	} else {
+		//PGPRINTK("  [%d] locked. retry %p\n", tsk->pid, fh);
+	}
+#else
 	PGPRINTK("  [%d] locked. retry %p\n", tsk->pid, fh);
+#endif
 	return NULL;
 }
 
@@ -485,7 +1136,26 @@ static bool __finish_fault_handling(struct fault_handle *fh)
 		wake_up(&fh->waits);
 #endif
 	} else {
+#ifdef CONFIG_POPCORN_HYPE
+		static unsigned long origin_pgfault_fini_cnt = 0;
+		unsigned long origin_pgfault_fini_thre;
+		origin_pgfault_fini_cnt++;
+		if (current->at_remote)
+			origin_pgfault_fini_thre = REMOTE_PGFAULT_SKIP;
+		else
+			origin_pgfault_fini_thre = ORIGIN_PGFAULT_SKIP;
+
+		if (pophype_debug ||
+		//if (pophype_debug || INTERESTED_GVA_2AFTER4(fh->addr) ||
+			((origin_pgfault_fini_cnt > origin_pgfault_fini_thre ||
+			INTERESTED_GVA(fh->addr)) &&
+			NOTINTERESTED_GVA(fh->addr))) {
+			//PGPRINTK("\t\t\t>>[%d] %lx %p #%lu\n",
+			//		fh->pid, fh->addr, fh, origin_pgfault_fini_cnt);
+		}
+#else
 		PGPRINTK(">>[%d] %lx %p\n", fh->pid, fh->addr, fh);
+#endif
 		if (fh->complete) {
 			complete(fh->complete);
 		} else {
@@ -811,7 +1481,7 @@ static int handle_remote_page_flush_ack(struct pcn_kmsg_message *msg)
 
 
 /**************************************************************************
- * Page invalidation protocol
+ * Page invalidation protocol (remote fault - got a revoking msg from remote)
  */
 static void __do_invalidate_page(struct task_struct *tsk, page_invalidate_request_t *req)
 {
@@ -831,9 +1501,34 @@ static void __do_invalidate_page(struct task_struct *tsk, page_invalidate_reques
 		goto out;
 	}
 
-	PGPRINTK("\nINVALIDATE_PAGE [%d] %lx [%d/%d]\n", tsk->pid, addr,
-			req->origin_pid, PCN_KMSG_FROM_NID(req));
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef CONFIG_POPCORN_STAT
+	{
+		static unsigned long do_inv_cnt = 0;
+		volatile unsigned long do_inv_thre;
+		do_inv_cnt++;
+		if (tsk->at_remote) {
+			do_inv_thre = REMOTE_INVPG;
+		} else {
+			do_inv_thre = ORIGIN_INVPG;
+		}
 
+		/* origin revoke remote INVALIDATE_PAGE*/
+		//if ((do_inv_cnt > do_inv_thre ||
+		//	INTERESTED_GVA(addr)) &&
+		//	NOTINTERESTED_GVA(addr)) {
+		//if (do_inv_cnt > do_inv_thre || pophype_debug) { /* commented out since im debugging */
+		if (INTERESTED_GVA_2AFTER4(addr)) {
+			PGPRINTK("\n\t\tINVALIDATE_PAGE [%d] %lx [%d/%d] #%lu\n",
+						tsk->pid, addr, req->origin_pid,
+						PCN_KMSG_FROM_NID(req), do_inv_cnt);
+		}
+	}
+#endif
+#else
+	PGPRINTK("\n\t\tINVALIDATE_PAGE [%d] %lx [%d/%d]\n", tsk->pid, addr,
+				req->origin_pid, PCN_KMSG_FROM_NID(req));
+#endif
 	pte = __get_pte_at(mm, addr, &pmd, &ptl);
 	if (!pte) goto out;
 
@@ -845,6 +1540,10 @@ static void __do_invalidate_page(struct task_struct *tsk, page_invalidate_reques
 	BUG_ON(!pte_present(*pte));
 	entry = ptep_clear_flush(vma, addr, pte);
 	entry = pte_make_invalid(entry);
+#ifdef CONFIG_POPCORN_HYPE
+	/* kvm_mmu_notifier_invalidate_page */
+	mmu_notifier_invalidate_page(mm, addr);
+#endif
 
 	set_pte_at_notify(mm, addr, pte, entry);
 	update_mmu_cache(vma, addr, pte);
@@ -859,6 +1558,9 @@ out:
 
 static void process_page_invalidate_request(struct work_struct *work)
 {
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	ktime_t dt, invh_end, invh_start = ktime_get();
+#endif
 	START_KMSG_WORK(page_invalidate_request_t, req, work);
 	page_invalidate_response_t *res;
 	struct task_struct *tsk;
@@ -879,13 +1581,41 @@ static void process_page_invalidate_request(struct work_struct *work)
 
 	__do_invalidate_page(tsk, req);
 
-	PGPRINTK(">>[%d] ->[%d/%d]\n", req->remote_pid, res->origin_pid,
+#ifdef CONFIG_POPCORN_HYPE
+	{
+		static unsigned long process_inv_cnt = 0;
+		unsigned long process_inv_thre;
+		process_inv_cnt++;
+		if (current->at_remote)
+			process_inv_thre = REMOTE_PGFAULT_SKIP;
+		else
+			process_inv_thre = ORIGIN_PGFAULT_SKIP;
+
+		//if (pophype_debug || INTERESTED_GVA_2AFTER4(req->addr) ||
+		if (pophype_debug ||
+			((process_inv_cnt > process_inv_thre ||
+			INTERESTED_GVA(req->addr)) &&
+			NOTINTERESTED_GVA(req->addr))) {
+			//PGPRINTK("\t\t>>[%d] ->[%d/%d] (INV)\n", req->remote_pid, res->origin_pid,
+			//		PCN_KMSG_FROM_NID(req));
+		}
+	}
+#else
+	PGPRINTK("\t\t>>[%d] ->[%d/%d]\n", req->remote_pid, res->origin_pid,
 			PCN_KMSG_FROM_NID(req));
+#endif
 	pcn_kmsg_post(PCN_KMSG_TYPE_PAGE_INVALIDATE_RESPONSE,
 			PCN_KMSG_FROM_NID(req), res, sizeof(*res));
 
 	put_task_struct(tsk);
 
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	invh_end = ktime_get();
+	dt = ktime_sub(invh_end, invh_start);
+	atomic64_add(ktime_to_ns(dt), &invh_ns);
+	atomic64_inc(&invh_cnt);
+#endif
+
 out_free:
 	END_KMSG_WORK(req);
 }
@@ -904,9 +1634,13 @@ static int handle_page_invalidate_response(struct pcn_kmsg_message *msg)
 	return 0;
 }
 
-
+/* Me sending a msg to revoke others ownership */
 static void __revoke_page_ownership(struct task_struct *tsk, int nid, pid_t pid, unsigned long addr, int ws_id)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	static unsigned long revoke_cnt = 0;
+	volatile unsigned long revoke_thre;
+#endif
 	page_invalidate_request_t *req = pcn_kmsg_get(sizeof(*req));
 
 	req->addr = addr;
@@ -914,7 +1648,24 @@ static void __revoke_page_ownership(struct task_struct *tsk, int nid, pid_t pid,
 	req->origin_ws = ws_id;
 	req->remote_pid = pid;
 
+#ifdef CONFIG_POPCORN_HYPE
+	revoke_cnt++;
+	if (current->at_remote) {
+		revoke_thre = REMOTE_REVOKE;
+	} else {
+		revoke_thre = ORIGIN_REVOKE;
+	}
+	/* origin revoke remote INVALIDATE_PAGE*/
+	if (pophype_debug || INTERESTED_GVA_2AFTER4(addr) ||
+		((revoke_cnt > revoke_thre ||
+		INTERESTED_GVA(addr)) &&
+		NOTINTERESTED_GVA(addr))) {
+		PGPRINTK("\t\t  [%d] revoke %lx [%d/%d] #%lu\n",
+				tsk->pid, addr, pid, nid, revoke_cnt);
+	}
+#else
 	PGPRINTK("  [%d] revoke %lx [%d/%d]\n", tsk->pid, addr, pid, nid);
+#endif
 	pcn_kmsg_post(PCN_KMSG_TYPE_PAGE_INVALIDATE_REQUEST, nid, req, sizeof(*req));
 }
 
@@ -968,6 +1719,10 @@ int page_server_release_page_ownership(struct vm_area_struct *vma, unsigned long
 	clear_page_owner(my_nid, mm, addr);
 	pte_val = ptep_clear_flush(vma, addr, pte);
 	pte_val = pte_make_invalid(pte_val);
+#ifdef CONFIG_POPCORN_HYPE
+	/* kvm_mmu_notifier_invalidate_page */
+	mmu_notifier_invalidate_page(mm, addr);
+#endif
 
 	set_pte_at_notify(mm, addr, pte, pte_val);
 	update_mmu_cache(vma, addr, pte);
@@ -984,9 +1739,27 @@ static int handle_remote_page_response(struct pcn_kmsg_message *msg)
 	remote_page_response_t *res = (remote_page_response_t *)msg;
 	struct wait_station *ws = wait_station(res->origin_ws);
 
+#ifdef CONFIG_POPCORN_HYPE
+	static unsigned long pg_response_cnt = 0;
+	unsigned long pg_response_thre;
+	//struct task_struct *tsk = __get_task_struct(res->remote_pid);
+	pg_response_cnt++;
+	if (current->at_remote)
+		pg_response_thre = REMOTE_PGFAULT_SKIP;
+	else
+		pg_response_thre = ORIGIN_PGFAULT_SKIP;
+
+	if ((pg_response_cnt > pg_response_thre) &&
+		NOTINTERESTED_GVA(res->addr)) {
+		PGPRINTK("  [%d] <-[%d/%d] %lx %x\n", // TODO make sure I can see it
+				ws->pid, res->remote_pid, PCN_KMSG_FROM_NID(res),
+				res->addr, res->result);
+	}
+#else
 	PGPRINTK("  [%d] <-[%d/%d] %lx %x\n",
 			ws->pid, res->remote_pid, PCN_KMSG_FROM_NID(res),
 			res->addr, res->result);
+#endif
 	ws->private = res;
 
 	if (atomic_dec_and_test(&ws->pendings_count))
@@ -1028,9 +1801,42 @@ static int __request_remote_page(struct task_struct *tsk, int from_nid, pid_t fr
 		req->rdma_key = 0;
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	if (!req) {
+		DDPRINTK("PROBLEMATIC ADDR [[[%lx]]]\n", addr);
+		dump_stack();
+		msleep(60*1000);
+	}
+	if (from_pid < 0 || from_nid < 0) {
+		printk(KERN_ERR "  BAD [%d] ->[%d/%d] addr %lx instr %lx\n", tsk->pid,
+							from_pid, from_nid, addr, req->instr_addr);
+		dump_stack();
+		msleep(60*1000);
+	}
+#endif
+
+	{
+		static unsigned long pg_req_cnt = 0;
+		unsigned long pg_req_thre;
+		pg_req_cnt++;
+		if (current->at_remote)
+			pg_req_thre = REMOTE_PGFAULT_SKIP;
+		else
+			pg_req_thre = ORIGIN_PGFAULT_SKIP;
+
+		if (pophype_debug || INTERESTED_GVA_2AFTER4(addr) ||
+			((pg_req_cnt > pg_req_thre ||
+			INTERESTED_GVA(addr)) &&
+			NOTINTERESTED_GVA(addr))) {
+			PGPRINTK("  [%d] ->[%d/%d] %lx instr %lx\n", tsk->pid,
+					from_pid, from_nid, addr, req->instr_addr);
+		}
+	}
+#else
 	PGPRINTK("  [%d] ->[%d/%d] %lx %lx\n", tsk->pid,
 			from_pid, from_nid, addr, req->instr_addr);
-
+#endif
 	pcn_kmsg_post(PCN_KMSG_TYPE_REMOTE_PAGE_REQUEST,
 			from_nid, req, sizeof(*req));
 	return 0;
@@ -1042,6 +1848,18 @@ static remote_page_response_t *__fetch_page_from_origin(struct task_struct *tsk,
 	struct wait_station *ws = get_wait_station(tsk);
 	struct pcn_kmsg_rdma_handle *rh;
 
+#if 0
+#ifdef CONFIG_POPCORN_HYPE
+	BUG_ON(!tsk);
+	if (tsk->origin_nid < 0 || tsk->origin_pid < 0) {
+		printk("  BAD [%d] ->[%d/%d] addr %lx instr %lx\n", tsk->pid,
+						tsk->origin_nid, tsk->origin_pid,
+						instruction_pointer(current_pt_regs()));
+		dump_stack();
+	}
+#endif
+#endif
+
 	__request_remote_page(tsk, tsk->origin_nid, tsk->origin_pid,
 			addr, fault_flags, ws->id, &rh);
 
@@ -1063,7 +1881,7 @@ static remote_page_response_t *__fetch_page_from_origin(struct task_struct *tsk,
 	return rp;
 }
 
-static int __claim_remote_page(struct task_struct *tsk, struct mm_struct *mm, struct vm_area_struct *vma, unsigned long addr, unsigned long fault_flags, struct page *page)
+static int __claim_remote_page(struct task_struct *tsk, struct mm_struct *mm, struct vm_area_struct *vma, unsigned long addr, unsigned long fault_flags, struct page *page, int local_origin)
 {
 	int peers;
 	unsigned int random = prandom_u32();
@@ -1077,16 +1895,48 @@ static int __claim_remote_page(struct task_struct *tsk, struct mm_struct *mm, st
 	unsigned long offset;
 	struct page *pip = __get_page_info_page(mm, addr, &offset);
 	unsigned long *pi = (unsigned long *)kmap(pip) + offset;
+#ifdef CONFIG_POPCORN_HYPE
+	int origin_retry = 0;
+	int ret = 0; /* hyper fail = HYPE_RETRY */
+	bool is_clean_bit = false;
+#endif
+	int page_trans = 0;
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	//int revoke = 0;
+	ktime_t fp_start;
+	if (local_origin) /* aka !pg_mine */
+		fp_start = ktime_get();
+#endif
+#ifdef CONFIG_POPCORN_HYPE
+//reclaimrpg: /* not used now return to outside and retry outside to release fh & ptl*/
+#endif
 	BUG_ON(!pip);
 
 	peers = bitmap_weight(pi, MAX_POPCORN_NODES);
 
 	if (test_bit(my_nid, pi)) {
-		peers--;
+		peers--; /* page is mine */
 	}
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	/* no longer need this since I put retry outside this function */
+	if (!origin_retry) {
+		page_server_panic(peers == 0, mm, addr, NULL, __pte(0));
+	} // else { DON'T LET RETY CHECK PANIC }
+	else {
+		printk(" [%d] %lx peers==0 (%s) pte_flags(__pte(0)) %lx "
+				"from_nid %d RETRY#%d\n",
+				tsk->pid, addr,
+				peers == 0 ? "*****true(BUG - NOT DISTRIBUTED)*****" :
+														"false(GOOD)",
+				pte_flags(__pte(0)), from_nid, origin_retry);
+	}
+#endif
+#else
 #ifdef CONFIG_POPCORN_CHECK_SANITY
 	page_server_panic(peers == 0, mm, addr, NULL, __pte(0));
 #endif
+#endif
 	from = random % peers;
 
 	// PGPRINTK("  [%d] fetch %lx from %d peers\n", tsk->pid, addr, peers);
@@ -1104,8 +1954,16 @@ static int __claim_remote_page(struct task_struct *tsk, struct mm_struct *mm, st
 			__request_remote_page(tsk, nid, pid, addr, fault_flags, ws->id, &rh);
 		} else {
 			if (fault_for_write(fault_flags)) {
+#ifdef CONFIG_POPCORN_HYPE
+				BUG_ON("Two nodes shouldn't send stand along inv");
+#endif
 				clear_bit(nid, pi);
 				__revoke_page_ownership(tsk, nid, pid, addr, ws->id);
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+				//revoke = 1;
+				//BUG_ON(revoke && "Two nodes shouldn't send stand along inv");
+				BUG_ON("Two nodes shouldn't send stand along inv");
+#endif
 			}
 		}
 		if (--peers == 0) break;
@@ -1113,8 +1971,12 @@ static int __claim_remote_page(struct task_struct *tsk, struct mm_struct *mm, st
 
 	rp = wait_at_station(ws);
 
+	/* Popcorn assume this is 100% succ */
 	if (fault_for_write(fault_flags)) {
-		clear_bit(from_nid, pi);
+		clear_bit(from_nid, pi); /* got page ownership from from_nid */
+#ifdef CONFIG_POPCORN_HYPE
+		is_clean_bit = true;
+#endif
 	}
 
 	if (rp->result == 0) {
@@ -1127,13 +1989,73 @@ static int __claim_remote_page(struct task_struct *tsk, struct mm_struct *mm, st
 		kunmap(page);
 		flush_dcache_page(page);
 		__SetPageUptodate(page);
+		page_trans = 1;
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+		//page_trans = 1; // TODO have a look
+#endif
 	}
-	pcn_kmsg_done(rp);
+	//pcn_kmsg_done(rp);
+	//if (rh) pcn_kmsg_unpin_rdma_buffer(rh);
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (!my_nid && /* origin */
+		local_origin && /* !pg_mine */
+		!page_trans)
+	{
+		if (rp->result != 0 && is_clean_bit) {
+			printk("Jack - %d %x wrong\n", rp->result, rp->result); /* retry = 78 */
+		}
+		//BUG_ON("!pg_mine must transfer page");
+		if (NOTINTERESTED_GVA(addr)) {
+			printk(" [%d] %lx !pg_mine but must succ RETRY (Wierd - "
+								"my patch applied)\n", tsk->pid, addr);
+		}
+		/* pophype: restore states */
+		if (is_clean_bit) {
+			set_bit(from_nid, pi);
+		}
+
+		//schedule(); // testing
+		//udelay(100); // good
+		//BUG_ON(++origin_retry > RETRY_ORIGINFAULT_AT_ORIGIN);
+		//goto reclaimrpg;
+		ret = HYPE_RETRY;
+	}
+#endif
+	pcn_kmsg_done(rp);
 	if (rh) pcn_kmsg_unpin_rdma_buffer(rh);
+
 	__put_task_remote(rc);
 	kunmap(pip);
+
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	//if (!my_nid && local_origin && !revoke && page_trans) {
+	//if (!my_nid && local_origin && page_trans) {
+	if (!my_nid && local_origin) {
+		if (fault_for_write(fault_flags)) { /* page + inv */
+			ktime_t dt, fp_end = ktime_get();
+			dt = ktime_sub(fp_end, fp_start);
+			atomic64_add(ktime_to_ns(dt), &fpin_ns);
+			atomic64_inc(&fpin_cnt);
+		} else { /* page + !inv  */
+		//if (page_trans) {
+			ktime_t dt, fp_end = ktime_get();
+			dt = ktime_sub(fp_end, fp_start);
+			atomic64_add(ktime_to_ns(dt), &fp_ns);
+			atomic64_inc(&fp_cnt);
+		//}
+		}
+
+		///* Jack: DON'T CATCH FOR HYPE_RETRY release all locks outside */
+		//if (!page_trans)
+		//	BUG_ON("!pg_mine must transfer page");
+	}
+#endif
+#ifdef CONFIG_POPCORN_HYPE
+	return ret;
+#else
 	return 0;
+#endif
 }
 
 
@@ -1144,6 +2066,10 @@ static void __claim_local_page(struct task_struct *tsk, unsigned long addr, int
 	struct page *pip = __get_page_info_page(mm, addr, &offset);
 	unsigned long *pi;
 	int peers;
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	int is_inv = 0;
+	ktime_t dt, inv_end, inv_start;
+#endif
 
 	if (!pip) return; /* skip claiming non-distributed page */
 	pi = (unsigned long *)kmap(pip) + offset;
@@ -1158,6 +2084,10 @@ static void __claim_local_page(struct task_struct *tsk, unsigned long addr, int
 
 	if (test_bit(my_nid, pi) && except_nid != my_nid) peers--;
 
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	inv_start = ktime_get();
+#endif
+
 	if (peers > 0) {
 		int nid;
 		struct remote_context *rc = get_task_remote(tsk);
@@ -1169,11 +2099,24 @@ static void __claim_local_page(struct task_struct *tsk, unsigned long addr, int
 
 			clear_bit(nid, pi);
 			__revoke_page_ownership(tsk, nid, pid, addr, ws->id);
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+			is_inv = 1;
+#endif
 		}
 		put_task_remote(tsk);
 
 		wait_at_station(ws);
 	}
+
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	if (is_inv) {
+		inv_end = ktime_get();
+		dt = ktime_sub(inv_end, inv_start);
+		atomic64_add(ktime_to_ns(dt), &inv_ns);
+		atomic64_inc(&inv_cnt);
+	}
+#endif
+
 	kunmap(pip);
 }
 
@@ -1236,7 +2179,21 @@ static int __handle_remotefault_at_remote(struct task_struct *tsk, struct mm_str
 
 	struct fault_handle *fh;
 	bool leader;
-
+#if 0
+#ifdef CONFIG_POPCORN_HYPE
+	/* debug */
+	static unsigned long process_rr_cnt = 0;
+	unsigned long process_rr_thre;
+	process_rr_cnt++;
+	process_rr_thre = PGFAULT_REQ_AT_REMOTE_SKIP;
+	if (process_rr_cnt > process_rr_thre) {
+		PGPRINTK("  rr1[%d] %lx %c %lx from [%d/%d]\n",
+				req->remote_pid, req->addr,
+				fault_for_write(req->fault_flags) ? 'W' : 'R',
+				req->instr_addr, req->origin_pid, PCN_KMSG_FROM_NID(req));
+	}
+#endif
+#endif
 	pte = __get_pte_at(mm, addr, &pmd, &ptl);
 	if (!pte) {
 		PGPRINTK("  [%d] No PTE!!\n", tsk->pid);
@@ -1244,6 +2201,16 @@ static int __handle_remotefault_at_remote(struct task_struct *tsk, struct mm_str
 	}
 
 	spin_lock(ptl);
+#if 0
+#ifdef CONFIG_POPCORN_HYPE
+	if (process_rr_cnt > process_rr_thre) {
+		PGPRINTK("  rr2[%d] %lx %c %lx from [%d/%d]\n",
+				req->remote_pid, req->addr,
+				fault_for_write(req->fault_flags) ? 'W' : 'R',
+				req->instr_addr, req->origin_pid, PCN_KMSG_FROM_NID(req));
+	}
+#endif
+#endif
 	fh = __start_fault_handling(tsk, addr, fault_flags, ptl, &leader);
 	if (!fh) {
 		pte_unmap(pte);
@@ -1258,15 +2225,40 @@ static int __handle_remotefault_at_remote(struct task_struct *tsk, struct mm_str
 #ifdef CONFIG_POPCORN_CHECK_SANITY
 	BUG_ON(!page_is_mine(mm, addr));
 #endif
+#if 0
+#ifdef CONFIG_POPCORN_HYPE
+	if (process_rr_cnt > process_rr_thre) {
+		PGPRINTK("  rr3[%d] %lx %c %lx from [%d/%d]\n",
+				req->remote_pid, req->addr,
+				fault_for_write(req->fault_flags) ? 'W' : 'R',
+				req->instr_addr, req->origin_pid, PCN_KMSG_FROM_NID(req));
+	}
+#endif
+#endif
 
 	spin_lock(ptl);
+#if 0
+#ifdef CONFIG_POPCORN_HYPE
+	if (process_rr_cnt > process_rr_thre) {
+		PGPRINTK("  rr4[%d] %lx %c %lx from [%d/%d]\n",
+				req->remote_pid, req->addr,
+				fault_for_write(req->fault_flags) ? 'W' : 'R',
+				req->instr_addr, req->origin_pid, PCN_KMSG_FROM_NID(req));
+	}
+#endif
+#endif
 	SetPageDistributed(mm, addr);
 	entry = ptep_clear_flush(vma, addr, pte);
 
 	if (fault_for_write(fault_flags)) {
 		clear_page_owner(my_nid, mm, addr);
 		entry = pte_make_invalid(entry);
+#ifdef CONFIG_POPCORN_HYPE
+		/* kvm_mmu_notifier_invalidate_page */
+		mmu_notifier_invalidate_page(mm, addr);
+#endif
 	} else {
+		/* shared-read page - write protect */
 		entry = pte_wrprotect(entry);
 	}
 
@@ -1288,6 +2280,16 @@ static int __handle_remotefault_at_remote(struct task_struct *tsk, struct mm_str
 		kunmap_atomic(paddr);
 	}
 
+#if 0
+#ifdef CONFIG_POPCORN_HYPE
+	if (process_rr_cnt > process_rr_thre) {
+		PGPRINTK("  rr5[%d] %lx %c %lx from [%d/%d]\n",
+				req->remote_pid, req->addr,
+				fault_for_write(req->fault_flags) ? 'W' : 'R',
+				req->instr_addr, req->origin_pid, PCN_KMSG_FROM_NID(req));
+	}
+#endif
+#endif
 	__finish_fault_handling(fh);
 	return 0;
 }
@@ -1324,7 +2326,12 @@ again:
 	if (pte_none(*pte)) {
 		int ret;
 		spin_unlock(ptl);
+#ifdef CONFIG_POPCORN_HYPE
+		/* Too many so commented out */
+		//PGPRINTK("  [%d] handle local fault at origin\n", tsk->pid);
+#else
 		PGPRINTK("  [%d] handle local fault at origin\n", tsk->pid);
+#endif
 		ret = handle_pte_fault_origin(mm, vma, addr, pte, pmd, fault_flags);
 		/* returned with pte unmapped */
 		if (ret & VM_FAULT_RETRY) {
@@ -1353,23 +2360,49 @@ again:
 	BUG_ON(!page);
 
 	if (leader) {
+		/* Prepare the page if it is not mine. This should be leader */
 		pte_t entry;
 
-		/* Prepare the page if it is not mine. This should be leader */
-		PGPRINTK(" =[%d] %s%s %p\n",
+#ifdef CONFIG_POPCORN_HYPE
+	{
+		static unsigned long remote_at_origin_cnt = 0;
+		unsigned long remote_at_origin_thre;
+		remote_at_origin_cnt++;
+		if (current->at_remote)
+			remote_at_origin_thre = REMOTE_PGFAULT_SKIP;
+		else
+			remote_at_origin_thre = ORIGIN_PGFAULT_SKIP;
+
+		//if (pophype_debug || INTERESTED_GVA_2AFTER4(addr) ||
+		if (pophype_debug ||
+			((remote_at_origin_cnt > remote_at_origin_thre ||
+			INTERESTED_GVA(addr)) &&
+			NOTINTERESTED_GVA(addr))) {
+			//PGPRINTK("\t\t\t =[%d] %s%s %p %s\n",
+			//	tsk->pid, page_is_mine(mm, addr) ? "origin " : "",
+			//	test_page_owner(from_nid, mm, addr) ? "remote": "", fh,
+			//	fault_for_write(fault_flags) ? "INV" : "");
+		}
+	}
+#else
+		PGPRINTK("\t\t =[%d] %s%s %p\n",
 				tsk->pid, page_is_mine(mm, addr) ? "origin " : "",
 				test_page_owner(from_nid, mm, addr) ? "remote": "", fh);
-
+#endif
 		if (test_page_owner(from_nid, mm, addr)) {
 			BUG_ON(fault_for_read(fault_flags) && "Read fault from owner??");
 			__claim_local_page(tsk, addr, from_nid);
 			grant = true;
 		} else {
 			if (!page_is_mine(mm, addr)) {
-				__claim_remote_page(tsk, mm, vma, addr, fault_flags, page);
+				//BUG_ON("rr: 2-node case will never happen");
+				int r = __claim_remote_page(tsk, mm, vma, addr, fault_flags, page, 0);
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_CHECK_SANITY)
+				BUG_ON(r == HYPE_RETRY);
+#endif
 			} else {
 				if (fault_for_write(fault_flags))
-					__claim_local_page(tsk, addr, my_nid);
+					__claim_local_page(tsk, addr, my_nid); /* 2-node: bypass it */
 			}
 		}
 		spin_lock(ptl);
@@ -1381,6 +2414,10 @@ again:
 		if (fault_for_write(fault_flags)) {
 			clear_page_owner(my_nid, mm, addr);
 			entry = pte_make_invalid(entry);
+#ifdef CONFIG_POPCORN_HYPE
+			/* kvm_mmu_notifier_invalidate_page */
+			mmu_notifier_invalidate_page(mm, addr);
+#endif
 		} else {
 			entry = pte_make_valid(entry); /* For remote-claimed case */
 			entry = pte_wrprotect(entry);
@@ -1430,6 +2467,15 @@ static void process_remote_page_request(struct work_struct *work)
 	int res_size;
 	enum pcn_kmsg_type res_type;
 	int down_read_retry = 0;
+#ifdef CONFIG_POPCORN_HYPE
+	/* debug */
+	static unsigned long process_remote_cnt = 0;
+	unsigned long process_remote_thre;
+#endif
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	int rr = 0;
+	ktime_t fph_start = ktime_get();
+#endif
 
 	if (TRANSFER_PAGE_WITH_RDMA) {
 		res = pcn_kmsg_get(sizeof(remote_page_response_short_t));
@@ -1446,17 +2492,100 @@ again:
 	}
 	mm = get_task_mm(tsk);
 
-	PGPRINTK("\nREMOTE_PAGE_REQUEST [%d] %lx %c %lx from [%d/%d]\n",
+#ifdef CONFIG_POPCORN_HYPE
+	/* debug */
+	process_remote_cnt++;
+	if (tsk->at_remote)
+		process_remote_thre = PGFAULT_REQ_AT_REMOTE_SKIP;
+	else
+		process_remote_thre = PGFAULT_REQ_AT_ORIGIN_SKIP;
+
+	if (pophype_debug || INTERESTED_GVA_2AFTER4(req->addr) ||
+		((process_remote_cnt > process_remote_thre ||
+		INTERESTED_GVA(req->addr)) &&
+		NOTINTERESTED_GVA(req->addr))) {
+		PGPRINTK("\n\t=>REMOTE_PAGE_REQUEST [%d] %lx %s %lx from [%d/%d] "
+				"#%ld\n",
+				req->remote_pid, req->addr,
+				fault_for_write(req->fault_flags) ? "W(INV)" : "R",
+				req->instr_addr, req->origin_pid, from_nid,
+				process_remote_cnt);
+	}
+#else
+	PGPRINTK("\n\t=>REMOTE_PAGE_REQUEST [%d] %lx %c %lx from [%d/%d]\n",
 			req->remote_pid, req->addr,
 			fault_for_write(req->fault_flags) ? 'W' : 'R',
 			req->instr_addr, req->origin_pid, from_nid);
+#endif
 
 	while (!down_read_trylock(&mm->mmap_sem)) {
+#ifdef CONFIG_POPCORN_HYPE
+		//BUG_ON(down_read_retry > 20);
+#endif
+//#ifdef CONFIG_POPCORN_HYPE
+//		if (down_read_retry++ > 4) { /* who hold it at remote? */
+//#else
 		if (!tsk->at_remote && down_read_retry++ > 4) {
+//#endif
 			res->result = VM_FAULT_RETRY;
 			goto out_up;
 		}
-		schedule();
+#ifdef CONFIG_POPCORN_HYPE
+		if (tsk->at_remote) {
+			/* ORIGIN IS SURE THAT THIS REMOTE HAS THE PAGE and MUST FIX IT.
+			   That's the current request from this remote at remote should
+				return a retry to this remote so that this remote
+				can handle origin's works first*/
+			down_read_retry++;
+		}
+		//BUG() // 0x7ffec1a0c000
+		// from origin __claim_remote_page -> __request_remote_page
+		// from remote  __fetch_page_from_origin -> __request_remote_page
+		//Jack for the speed
+		if (!(down_read_retry % (RETRY_REMOTEFAULT / 10))) {
+			if (NOTINTERESTED_GVA(req->addr)) {
+				PGPRINTK("\t\t [%d] mmlk %lx by[%d/%ld] retry#%d "
+						"MINE %s letbugatorigin %s\n",
+						//"in_atomic() %s\n",
+						req->remote_pid, req->addr,
+						mm->mmap_sem.owner ? mm->mmap_sem.owner->pid : -78,
+						mm->mmap_sem.count,
+						down_read_retry,
+						page_is_mine(mm, req->addr) ? "O" : "X",
+						RETRY_REMOTEFAULT_GIVEUP ? "O" : "X");
+						//in_atomic() ? "O" : "X");
+			}
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+			BUG_ON(in_atomic());
+#endif
+		}
+
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+#if HYPE_PERF_CRITICAL_DEBUG
+		if (!page_is_mine(mm, req->addr)) { /* DSM corrupted */
+			printk(KERN_ERR "\n\n\n\n"
+				"  BAD [%d] ->[%d/%d] addr %lx %c instr %lx."
+				"pophype lets it pass for testing "
+				"since this is just a rr case isn't it?\n\n\n",
+				tsk->pid, req->remote_pid, from_nid, req->addr,
+				fault_for_write(req->fault_flags) ? 'W' : 'R', req->instr_addr);
+			//dump_stack();
+			//BUG();
+		}
+#endif
+#endif
+
+		if (tsk->at_remote && down_read_retry > RETRY_REMOTEFAULT) {
+			if (RETRY_REMOTEFAULT_GIVEUP) {
+			/* Remote should not return RETRY but.....let's BUG() at origin */
+				res->result = VM_FAULT_RETRY;
+				goto out_up; /* correct */
+			}
+		}
+#endif
+		/* retrying */
+		//udelay(100);
+		io_schedule();
 	}
 	vma = find_vma(mm, req->addr);
 	if (!vma || vma->vm_start > req->addr) {
@@ -1470,12 +2599,17 @@ again:
 
 	if (tsk->at_remote) {
 		res->result = __handle_remotefault_at_remote(tsk, mm, vma, req, res);
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+		if (res->result == 0)
+			rr = 1;
+#endif
 	} else {
 		res->result = __handle_remotefault_at_origin(tsk, mm, vma, req, res);
 	}
 
 out_up:
 	if (res->result != VM_FAULT_RETRY) {
+		/* replying VM_FAULT_RETRY means didn't get the mmap_sem */
 		up_read(&mm->mmap_sem);
 	}
 	mmput(mm);
@@ -1499,8 +2633,19 @@ out:
 	res->origin_pid = req->origin_pid;
 	res->origin_ws = req->origin_ws;
 
-	PGPRINTK("  [%d] ->[%d/%d] %x\n", req->remote_pid,
-			res->origin_pid, from_nid, res->result);
+#ifdef CONFIG_POPCORN_HYPE
+	if (pophype_debug || INTERESTED_GVA_2AFTER4(req->addr) ||
+		((process_remote_cnt > process_remote_thre ||
+		INTERESTED_GVA(req->addr)) &&
+		NOTINTERESTED_GVA(req->addr))) {
+		PGPRINTK("\t\t\t  [%d] ->[%d/%d] %lx r %x #%ld\n", req->remote_pid,
+					res->origin_pid, from_nid, res->addr,
+					res->result, process_remote_cnt);
+	}
+#else
+	PGPRINTK("  [%d] ->[%d/%d] %lx %x\n", req->remote_pid,
+			res->origin_pid, from_nid, res->addr, res->result);
+#endif
 
 	trace_pgfault(from_nid, req->remote_pid,
 			fault_for_write(req->fault_flags) ? 'W' : 'R',
@@ -1509,6 +2654,14 @@ out:
 	pcn_kmsg_post(res_type, from_nid, res, res_size);
 
 	END_KMSG_WORK(req);
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	if (rr) {
+		ktime_t dt, fph_end = ktime_get();
+		dt = ktime_sub(fph_end, fph_start);
+		atomic64_add(ktime_to_ns(dt), &fph_ns);
+		atomic64_inc(&fph_cnt);
+	}
+#endif
 }
 
 
@@ -1565,8 +2718,12 @@ retry:
 
 	if (leader && !page_is_mine(mm, addr)) {
 		struct page *page = get_normal_page(vma, addr, pte);
-		__claim_remote_page(current, mm, vma, addr, fault_flags, page);
-
+#ifdef CONFIG_POPCORN_HYPE
+		int ret = __claim_remote_page(current, mm, vma, addr, fault_flags, page, 0);
+		BUG_ON(ret == HYPE_RETRY);
+#else
+		 __claim_remote_page(current, mm, vma, addr, fault_flags, page, 0);
+#endif
 		spin_lock(ptl);
 		__make_pte_valid(mm, vma, addr, fault_flags, pte);
 		spin_unlock(ptl);
@@ -1594,7 +2751,8 @@ void page_server_put_userpage(struct fault_handle *fh, char *mode)
  */
 static int __handle_localfault_at_remote(struct mm_struct *mm,
 		struct vm_area_struct *vma, unsigned long addr,
-		pmd_t *pmd, pte_t *pte, pte_t pte_val, unsigned int fault_flags)
+		pmd_t *pmd, pte_t *pte, pte_t pte_val,
+		unsigned int fault_flags, unsigned long address)
 {
 	spinlock_t *ptl;
 	struct page *page;
@@ -1605,6 +2763,22 @@ static int __handle_localfault_at_remote(struct mm_struct *mm,
 	struct fault_handle *fh;
 	bool leader;
 	remote_page_response_t *rp;
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	ktime_t fp_start, fpin_start;
+	ktime_t dt, inv_end, inv_start;
+	fp_start = fpin_start = inv_start = ktime_get();
+#endif
+
+#if 0
+#ifdef CONFIG_POPCORN_HYPE
+	if (addr == 0x7ffff4fdd000) {
+		printk("%s(): jack %p %p "
+				"(I think we didn't have DSM working for this resion "
+				"so this is the problem)\n",
+				__func__, vma->vm_ops, vma->vm_ops->fault);
+	}
+#endif
+#endif
 
 	if (anon_vma_prepare(vma)) {
 		BUG_ON("Cannot prepare vma for anonymous page");
@@ -1624,14 +2798,56 @@ static int __handle_localfault_at_remote(struct mm_struct *mm,
 	if (!fh) {
 		pte_unmap(pte);
 		up_read(&mm->mmap_sem);
+#ifdef CONFIG_POPCORN_HYPE
+#if HYPE_PERF_CRITICAL_DSM_TRAFFIC_PRINTK
+		/* Handled outside */
+		if (pophype_debug || INTERESTED_GVA_2AFTER4(addr) ||
+			(INTERESTED_GVA(addr) && NOTINTERESTED_GVA(addr)))
+#else
+		if (INTERESTED_GVA_2AFTER4(addr) ||
+			(INTERESTED_GVA(addr) && NOTINTERESTED_GVA(addr)))
+#endif
+		{
+			printk("\t\t(remote) !![%d] %lx !fh ->RETRY\n",
+					current->pid, addr); /* 1c0* happens a lot */
+		}
+#endif
 		return VM_FAULT_RETRY;
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+	{
+		static unsigned long local_at_remote_cnt = 0;
+		unsigned long local_at_remote_thre;
+		local_at_remote_cnt++;
+		if (current->at_remote)
+			local_at_remote_thre = REMOTE_PGFAULT_SKIP;
+		else
+			local_at_remote_thre = ORIGIN_PGFAULT_SKIP;
+
+		if (pophype_debug || INTERESTED_GVA_2AFTER4(addr) ||
+			((local_at_remote_cnt > local_at_remote_thre ||
+			INTERESTED_GVA(addr)) &&
+			NOTINTERESTED_GVA(addr))) {
+			PGPRINTK(" %c[%d] %lx %p %s\n",
+				leader ? '=' : '-', current->pid, addr, fh,
+				fault_for_write(fault_flags) ? "INVALIDATE_PAGE" : "");
+		}
+	}
+#else
 	PGPRINTK(" %c[%d] %lx %p\n", leader ? '=' : '-', current->pid, addr, fh);
+#endif
 	if (!leader) {
 		pte_unmap(pte);
 		ret = fh->ret;
-		if (ret) up_read(&mm->mmap_sem);
+		if (ret) {
+#ifdef CONFIG_POPCORN_HYPE
+			// many even idle in bash
+			PGPRINTK("  $$[%d] 0x%lx not leader ret 0x%x\n",
+									current->pid, addr, ret);
+#endif
+			up_read(&mm->mmap_sem);
+		}
 		goto out_follower;
 	}
 
@@ -1646,14 +2862,103 @@ static int __handle_localfault_at_remote(struct mm_struct *mm,
 	}
 	get_page(page);
 
+#if 0
+#ifdef CONFIG_POPCORN_HYPE
+	BUG_ON(!current);
+	if (current->origin_nid < 0 || current->origin_pid < 0) {
+		printk("  BAD [%d] ->[%d/%d] addr %lx instr %llx\n", current->pid,
+				current->origin_nid, current->origin_pid,
+				instruction_pointer(current_pt_regs()));
+		dump_stack();
+	}
+#endif
+#endif
 	rp = __fetch_page_from_origin(current, vma, addr, fault_flags, page);
 
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	if (page_is_mine(mm, addr)) {
+		if (fault_for_write(fault_flags)) {
+			if (rp->result == VM_FAULT_CONTINUE) { /* W: inv lat */
+				inv_end = ktime_get();
+				dt = ktime_sub(inv_end, inv_start);
+				atomic64_add(ktime_to_ns(dt), &inv_ns);
+				atomic64_inc(&inv_cnt);
+			} else if (!rp->result) { /* W: inv + page transferred */
+				// X -> W
+				ktime_t dt, fpin_end = ktime_get();
+				dt = ktime_sub(fpin_end, fpin_start);
+				atomic64_add(ktime_to_ns(dt), &fpin_ns);
+				atomic64_inc(&fpin_cnt);
+			}
+		}
+	} else { /* fp only page */
+		if (fault_for_read(fault_flags)) {
+			ktime_t dt, fp_end = ktime_get();
+			dt = ktime_sub(fp_end, fp_start);
+			atomic64_add(ktime_to_ns(dt), &fp_ns);
+			atomic64_inc(&fp_cnt);
+		}
+		if (fault_for_write(fault_flags)) { /* w: inv + page transferred */
+				ktime_t dt, fpin_end = ktime_get();
+				dt = ktime_sub(fpin_end, fpin_start);
+				atomic64_add(ktime_to_ns(dt), &fpin_ns);
+				atomic64_inc(&fpin_cnt);
+		}
+	}
+#endif
+
 	if (rp->result && rp->result != VM_FAULT_CONTINUE) {
-		if (rp->result != VM_FAULT_RETRY)
+		if (rp->result != VM_FAULT_RETRY) {
+#ifdef CONFIG_POPCORN_HYPE
+			printk("  $$[%d] 0x%lx failed ret 0x%x TODO\n",
+							current->pid, addr, rp->result);
+			printk("  $$[%d] 0x%lx failed ret 0x%x TODO\n",
+							current->pid, addr, rp->result);
+			printk("  $$[%d] 0x%lx failed ret 0x%x TODO\n",
+							current->pid, addr, rp->result);
+			//printk("  $$[%d] failed 0x%x\n", current->pid, rp->result);
+			if (pophype_debug || INTERESTED_GVA_2AFTER4(addr) ||
+				(INTERESTED_GVA(addr) && NOTINTERESTED_GVA(addr))) {
+				printk("  $$[%d] 0x%lx failed ret 0x%x TODO\n",
+								current->pid, addr, rp->result);
+			}
+#else
 			PGPRINTK("  [%d] failed 0x%x\n", current->pid, rp->result);
+#endif
+		}
+#ifdef CONFIG_POPCORN_HYPE
+		else {
+			DSMRETRYPRINTK("  !![%d] fpfo->lfr 0x%lx ret 0x%x "
+							"[[[ RETRY UNLOCKED ]]]\n",
+							current->pid, addr, rp->result);
+			// remote
+		}
+		/* eighter RETRY or FAIL - UNLOCK */
+#endif
+
 		ret = rp->result;
 		pte_unmap(pte);
 		up_read(&mm->mmap_sem);
+#ifdef CONFIG_POPCORN_HYPE
+		/* Handled outside */
+		/* TODO  HYPE - BUG: bad unlock balance detected! 0521
+			VM_FAULT_KILLED
+				//VM_FAULT_RETRY
+					err VM_FAULT_FALLBACK
+
+			VM_FAULT_LOCKED
+			VM_FAULT_NOPAGE
+					err VM_FAULT_SIGSEGV
+					err VM_FAULT_HWPOISON_LARGE
+					err VM_FAULT_HWPOISON
+
+			ERR
+			(VM_FAULT_OOM | VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV | \
+			 VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE | \
+						  VM_FAULT_FALLBACK)
+		*/
+		/* do I handle this RETRY WELL? */
+#endif
 		goto out_free;
 	}
 
@@ -1693,6 +2998,8 @@ static int __handle_localfault_at_remote(struct mm_struct *mm,
 	set_page_owner(my_nid, mm, addr);
 	pte_unmap_unlock(pte, ptl);
 	ret = 0;	/* The leader squashes both 0 and VM_FAULT_CONTINUE to 0 */
+//	dsm_traffic_collect(address, addr,
+//			fault_for_write(fault_flags) ? 'W' : 'R'); /* pophype */
 
 out_free:
 	put_page(page);
@@ -1711,7 +3018,18 @@ static bool __handle_copy_on_write(struct mm_struct *mm,
 		pte_t *pte, pte_t *pte_val, unsigned int fault_flags)
 {
 	if (vma_is_anonymous(vma) || fault_for_read(fault_flags)) return false;
+#ifdef CONFIG_POPCORN_HYPE
+	if(vma->vm_flags & VM_SHARED) {
+		printk("fault addr %lx %lx - %lx\n"
+				"since we touch all *vcpu3pg at remote in the end\n",
+			addr, vma->vm_start, vma->vm_end);
+		dump_stack();
+		return false; /* hacking: dealing with rw-s files
+				anon_inode:kvm-vcpu:0, /[aio] (deleted), /dev/zero (deleted) */
+	}
+#else
 	BUG_ON(vma->vm_flags & VM_SHARED);
+#endif
 
 	/**
 	 * We need to determine whether the page is already cowed or not to
@@ -1742,12 +3060,25 @@ static bool __handle_copy_on_write(struct mm_struct *mm,
  */
 static int __handle_localfault_at_origin(struct mm_struct *mm,
 		struct vm_area_struct *vma, unsigned long addr,
-		pmd_t *pmd, pte_t *pte, pte_t pte_val, unsigned int fault_flags)
+		pmd_t *pmd, pte_t *pte, pte_t pte_val, unsigned int fault_flags,
+		unsigned long address)
 {
 	spinlock_t *ptl;
 
 	struct fault_handle *fh;
 	bool leader;
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	//ktime_t ptef_start = ktime_get();
+	ktime_t dt, clr_end, clr_start = ktime_get();
+#endif
+#ifdef CONFIG_POPCORN_HYPE
+	unsigned long lfal_retry_cnt = 0;
+	int ret;
+	static unsigned long origin_pgfault_fresh_cnt = 0;
+	origin_pgfault_fresh_cnt++;
+lfal_retry:
+	ret = 0;
+#endif
 
 	ptl = pte_lockptr(mm, pmd);
 	spin_lock(ptl);
@@ -1762,7 +3093,13 @@ static int __handle_localfault_at_origin(struct mm_struct *mm,
 	if (pte_none(pte_val)) {
 		BUG_ON(pte_present(pte_val));
 		spin_unlock(ptl);
+#ifdef CONFIG_POPCORN_HYPE
+		if (origin_pgfault_fresh_cnt > ORIGIN_PGFAULT_SKIP) {
+			PGPRINTK("  [%d] fresh at origin. continue\n", current->pid);
+		}
+#else
 		PGPRINTK("  [%d] fresh at origin. continue\n", current->pid);
+#endif
 		return VM_FAULT_CONTINUE;
 	}
 
@@ -1777,14 +3114,39 @@ static int __handle_localfault_at_origin(struct mm_struct *mm,
 	if (!fh) {
 		pte_unmap(pte);
 		up_read(&mm->mmap_sem);
+#ifdef CONFIG_POPCORN_HYPE
+#if HYPE_PERF_CRITICAL_DSM_TRAFFIC_PRINTK
+		if (pophype_debug || INTERESTED_GVA_2AFTER4(addr) ||
+			(INTERESTED_GVA(addr) && NOTINTERESTED_GVA(addr)))
+#else
+		if (INTERESTED_GVA_2AFTER4(addr) ||
+			(INTERESTED_GVA(addr) && NOTINTERESTED_GVA(addr)))
+#endif
+		{
+			printk("\t\t(origin) !![%d] %lx !fh ->RETRY\n",
+					current->pid, addr); /* 1c0* happens a lot */
+		}
+#endif
 		return VM_FAULT_RETRY;
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (pophype_debug ||  INTERESTED_GVA_2AFTER4(addr) ||
+		((origin_pgfault_fresh_cnt > ORIGIN_PGFAULT_SKIP ||
+		INTERESTED_GVA(addr)) &&
+		NOTINTERESTED_GVA(addr))) {
+		PGPRINTK(" %c[%d] %lx replicated %sMINE %p %s #%lu\n",
+			leader ? '=' : ' ', current->pid, addr,
+			page_is_mine(mm, addr) ? "" : "*NOT* ", fh,
+			page_is_mine(mm, addr) ? "" : "=>", lfal_retry_cnt);
+	}
+#else
 	/* Handle replicated page via the memory consistency protocol */
-	PGPRINTK(" %c[%d] %lx replicated %smine %p\n",
+	PGPRINTK(" %c[%d] %lx replicated %sMINE %p %s\n",
 			leader ? '=' : ' ', current->pid, addr,
-			page_is_mine(mm, addr) ? "" : "not ", fh);
-
+			page_is_mine(mm, addr) ? "" : "*NOT* ", fh,
+			page_is_mine(mm, addr) ? "" : "=>");
+#endif
 	if (!leader) {
 		pte_unmap(pte);
 		goto out_wakeup;
@@ -1813,7 +3175,23 @@ static int __handle_localfault_at_origin(struct mm_struct *mm,
 		struct page *page = vm_normal_page(vma, addr, pte_val);
 		BUG_ON(!page);
 
-		__claim_remote_page(current, mm, vma, addr, fault_flags, page);
+#ifdef CONFIG_POPCORN_HYPE
+		ret = __claim_remote_page(current, mm, vma, addr, fault_flags, page, 1);
+		/* !page_mine must transffer */
+		if (ret == HYPE_RETRY) {
+			pte_unmap(pte);
+			goto out_wakeup; // aka origin_retry_out // don't change pte
+		}
+#else
+		__claim_remote_page(current, mm, vma, addr, fault_flags, page, 1);
+#endif
+
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+		clr_end = ktime_get();
+		dt = ktime_sub(clr_end, clr_start);
+		atomic64_add(ktime_to_ns(dt), &clr_ns);
+		atomic64_inc(&clr_cnt);
+#endif
 
 		spin_lock(ptl);
 		__make_pte_valid(mm, vma, addr, fault_flags, pte);
@@ -1822,10 +3200,35 @@ static int __handle_localfault_at_origin(struct mm_struct *mm,
 	BUG_ON(!test_page_owner(my_nid, mm, addr));
 #endif
 	pte_unmap_unlock(pte, ptl);
+//	dsm_traffic_collect(address, addr, /* pophype */
+//			fault_for_write(fault_flags) ? 'W' : 'R');
 
 out_wakeup:
 	__finish_fault_handling(fh);
 
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+	//if (!remote_fault) {
+		//ktime_t dt, ptef_end = ktime_get();
+		//dt = ktime_sub(ptef_end, ptef_start);
+		//atomic64_add(ktime_to_ns(dt), &ptef_ns);
+		//atomic64_inc(&ptef_cnt);
+	//}
+#endif
+
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef CONFIG_POPCORN_STAT
+	if (ret == HYPE_RETRY) {
+		ktime_t clrr_end = ktime_get();
+		dt = ktime_sub(clrr_end, clr_start);
+		atomic64_add(ktime_to_ns(dt), &clrr_ns);
+		atomic64_inc(&clrr_cnt);
+		//udelay(100);
+		lfal_retry_cnt++;
+		g_lfal_retry_cnt++;
+		goto lfal_retry;
+	}
+#endif
+#endif
 	return 0;
 }
 
@@ -1857,18 +3260,69 @@ int page_server_handle_pte_fault(
 
 	might_sleep();
 
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef HYPE_PERF_DSM_TRAFFIC_PK
+	if (current->at_remote) {
+		static unsigned long remote_pgfault_cnt = 0;
+		remote_pgfault_cnt++;
+		if (pophype_debug || INTERESTED_GVA_2AFTER4(addr) ||
+			((remote_pgfault_cnt > REMOTE_PGFAULT_SKIP
+			|| INTERESTED_GVA(addr)) &&
+			NOTINTERESTED_GVA(addr))) {
+
+// 11/05/19 uncommented
+//			if (pophype_debug || INTERESTED_GVA_2AFTER4(addr) ||
+//				INTERESTED_GVA(addr))
+//				goto force_pk;
+
+			if (((((addr >> PAGE_SHIFT) >> 16) >> 8) & 0xfff) == 0x7ff) {
+				if ((((addr >> PAGE_SHIFT) >> 16) & 0xff) != 0xec) {
+					goto skip_printk; /* lose info but fast */
+				}
+			}
+//force_pk:
+			PGPRINTK("\n\t## PAGEFAULT [%d] %lx %c %lx %x %lx %s%p #%lu\n",
+					current->pid, address,
+					fault_for_write(fault_flags) ? 'W' : 'R',
+					instruction_pointer(current_pt_regs()),
+					fault_flags, pte_flags(pte_val),
+					vma->vm_ops ? "vm_ops " : "", vma->vm_ops,
+					remote_pgfault_cnt);
+		}
+	} else {
+		static unsigned long origin_pgfault_cnt = 0;
+		origin_pgfault_cnt++;
+		if (pophype_debug || INTERESTED_GVA_2AFTER4(addr) ||
+			((origin_pgfault_cnt > ORIGIN_PGFAULT_SKIP ||
+			INTERESTED_GVA(addr)) &&
+			NOTINTERESTED_GVA(addr))) {
+			PGPRINTK("\n\t## PAGEFAULT [%d] %lx %c %lx %x %lx %s%p #%lu\n",
+					current->pid, address,
+					fault_for_write(fault_flags) ? 'W' : 'R',
+					instruction_pointer(current_pt_regs()),
+					fault_flags, pte_flags(pte_val),
+					vma->vm_ops ? "vm_ops " : "", vma->vm_ops,
+					origin_pgfault_cnt);
+		}
+	}
+
+
+skip_printk:
+#endif
+#else
 	PGPRINTK("\n## PAGEFAULT [%d] %lx %c %lx %x %lx\n",
-			current->pid, address,
-			fault_for_write(fault_flags) ? 'W' : 'R',
-			instruction_pointer(current_pt_regs()),
-			fault_flags, pte_flags(pte_val));
+				current->pid, address,
+				fault_for_write(fault_flags) ? 'W' : 'R',
+				instruction_pointer(current_pt_regs()),
+				fault_flags, pte_flags(pte_val));
+#endif
 
 	/**
 	 * Thread at the origin
 	 */
 	if (!current->at_remote) {
 		ret = __handle_localfault_at_origin(
-				mm, vma, addr, pmd, pte, pte_val, fault_flags);
+				mm, vma, addr, pmd, pte, pte_val, fault_flags, address);
 		goto out;
 	}
 
@@ -1888,17 +3342,37 @@ int page_server_handle_pte_fault(
 		}
 		if (!vma_is_anonymous(vma) &&
 				((vma->vm_flags & (VM_WRITE | VM_SHARED)) == 0)) {
+#ifdef CONFIG_POPCORN_HYPE
+			printk("\n\n\n*****************************\n"
+					"THIS ASSUMPTION MAY KILL ME\n"
+					"*****************************\n\n\n\n");
+			WARN_ON(1);
+#endif
 			PGPRINTK("  [%d] locally file-mapped read-only. continue\n",
 					current->pid);
 			ret = VM_FAULT_CONTINUE;
 			goto out;
 		}
+#ifdef CONFIG_POPCORN_HYPE
+		if (!vma_is_anonymous(vma) &&
+				vma->vm_flags & VM_SHARED) {
+			PGPRINTK("  [%d] VM_VCPU. locally file-mmapped shared. continue "
+					"vma->vm_ops %p popcorn_vcpu_op %p\n",
+					current->pid, vma->vm_ops, popcorn_vcpu_op);
+			/* debug */
+			if (!popcorn_vcpu_op || (vma->vm_ops != popcorn_vcpu_op))  {
+				POP_PK("\t\tThis I'm NOT interested!!!\n");
+			}
+			ret = VM_FAULT_CONTINUE;
+			goto out;
+		}
+#endif
 	}
 
 	if (!pte_present(pte_val)) {
 		/* Remote page fault */
 		ret = __handle_localfault_at_remote(
-				mm, vma, addr, pmd, pte, pte_val, fault_flags);
+				mm, vma, addr, pmd, pte, pte_val, fault_flags, address);
 		goto out;
 	}
 
@@ -1906,7 +3380,7 @@ int page_server_handle_pte_fault(
 			fault_for_write(fault_flags) && !pte_write(pte_val)) {
 		/* wr-protected for keeping page consistency */
 		ret = __handle_localfault_at_remote(
-				mm, vma, addr, pmd, pte, pte_val, fault_flags);
+				mm, vma, addr, pmd, pte, pte_val, fault_flags, address);
 		goto out;
 	}
 
@@ -1915,6 +3389,10 @@ int page_server_handle_pte_fault(
 	ret = 0;
 
 out:
+////	if (!current->at_remote)
+////		dsm_traffic_collect(address, addr,
+////				fault_for_write(fault_flags) ? 'W' : 'R');
+
 	trace_pgfault(my_nid, current->pid,
 			fault_for_write(fault_flags) ? 'W' : 'R',
 			instruction_pointer(current_pt_regs()), addr, ret);
@@ -1932,6 +3410,7 @@ DEFINE_KMSG_ORDERED_WQ_HANDLER(remote_page_flush);
 
 int __init page_server_init(void)
 {
+	//int i, j;
 	REGISTER_KMSG_WQ_HANDLER(
 			PCN_KMSG_TYPE_REMOTE_PAGE_REQUEST, remote_page_request);
 	REGISTER_KMSG_HANDLER(
@@ -1952,5 +3431,49 @@ int __init page_server_init(void)
 	__fault_handle_cache = kmem_cache_create("fault_handle",
 			sizeof(struct fault_handle), 0, 0, NULL);
 
+#if POPHYPE_HOST_KERNEL /* guest mem is on host, so don't waste */
+#if 0
+//	for (i = 0; i < dsm_traffic_pg_cnt; i++) {
+//		for (j = 0; j < dsm_traffic_inst_cnt; j++) {
+//			dsm_traffic[i][j].addr = 0;
+//			dsm_traffic[i][j].inst = 0;
+//			dsm_traffic[i][j].cnt = 0;
+//		}
+//	}
+	/*
+	 * dsm_traffic[ptr list]		-> [ptr list]		-> [real content]
+	 * [dsm_traffic_pg_cnt]	* [dsm_traffic_inst_cnt]
+	 *									* [dsm_traffic_inst_cnt * dsm_traffic_t]
+	 */
+	printk("Pophype: debug dsm_traffic init %lu MB init (takes a while...)\n",
+				(sizeof(dsm_traffic_t) * dsm_traffic_rsp_cnt *
+				dsm_traffic_inst_cnt * dsm_traffic_pg_cnt) / 1024 / 1024);
+	printk("Pophype: dsm_traffic %lu * %lu * %lu * %lu B\n",
+				sizeof(dsm_traffic_t), dsm_traffic_rsp_cnt,
+				dsm_traffic_inst_cnt, dsm_traffic_pg_cnt);
+	//dsm_traffic = kzalloc(dsm_traffic_pg_cnt * sizeof(void*), GFP_KERNEL);
+	//dsm_traffic = kzalloc(sizeof(dsm_traffic_t) *
+	//				dsm_traffic_inst_cnt * dsm_traffic_rsp_cnt, GFP_KERNEL);
+	dsm_traffic = kzalloc(sizeof(void *) *
+						dsm_traffic_pg_cnt, GFP_KERNEL);
+	BUG_ON(!dsm_traffic);
+	for (i = 0; i < dsm_traffic_pg_cnt; i++) {
+		//dsm_traffic[i] = (struct dsm_pgfault *)
+		//	kzalloc(sizeof(struct dsm_pgfault) *
+		//								dsm_traffic_inst_cnt, GFP_KERNEL);
+		dsm_traffic[i] = (dsm_traffic_t **)
+				kzalloc(sizeof(void *) * dsm_traffic_inst_cnt, GFP_KERNEL);
+			//kzalloc(sizeof(dsm_traffic_t) *
+			//							dsm_traffic_inst_cnt, GFP_KERNEL);
+		BUG_ON(!dsm_traffic[i]);
+		for (j = 0; j < dsm_traffic_inst_cnt; j++) {
+			dsm_traffic[i][j] = (dsm_traffic_t *)
+				kzalloc(sizeof(dsm_traffic_t) *
+											dsm_traffic_rsp_cnt, GFP_KERNEL);
+			BUG_ON(!dsm_traffic[i][j]);
+		}
+	}
+#endif
+#endif
 	return 0;
 }
diff --git a/kernel/popcorn/pcn_kmsg.c b/kernel/popcorn/pcn_kmsg.c
index 56fba5383890..100f381f6cb5 100644
--- a/kernel/popcorn/pcn_kmsg.c
+++ b/kernel/popcorn/pcn_kmsg.c
@@ -46,29 +46,77 @@ EXPORT_SYMBOL(pcn_kmsg_unregister_callback);
 static atomic_t __nr_outstanding_requests[PCN_KMSG_TYPE_MAX] = { ATOMIC_INIT(0) };
 #endif
 
+#define ITERS 1000002
+#define ITER 1000000
 void pcn_kmsg_process(struct pcn_kmsg_message *msg)
 {
 	pcn_kmsg_cbftn ftn;
-
+//	static int cnt = 0;
+#ifdef CONFIG_POPCORN_STAT
+	//ktime_t dt1, t1e, t1s;
+	ktime_t t2e, t2s;
+	ktime_t t3e, t3s;
+	ktime_t t4e, t4s;
+	static long long t2 = 0, t3 = 0, t4 = 0;
+
+	t2s = ktime_get();
+#endif
 #ifdef CONFIG_POPCORN_CHECK_SANITY
 	BUG_ON(msg->header.type < 0 || msg->header.type >= PCN_KMSG_TYPE_MAX);
 	BUG_ON(msg->header.size < 0 || msg->header.size > PCN_KMSG_MAX_SIZE);
-	if (atomic_inc_return(__nr_outstanding_requests + msg->header.type) > 64) {
+	if (atomic_inc_return(__nr_outstanding_requests + msg->header.type) > 96) {
 		if (WARN_ON_ONCE("leaking received messages, ")) {
-			printk("type %d\n", msg->header.type);
+			//printk("type %d\n", msg->header.type);
 		}
 	}
 #endif
 	account_pcn_message_recv(msg);
+#ifdef CONFIG_POPCORN_STAT
+	t2e = ktime_get();
+	t2 += ktime_to_ns(ktime_sub(t2e, t2s));
 
+	t3s = ktime_get();
+#endif
 	ftn = pcn_kmsg_cbftns[msg->header.type];
+#ifdef CONFIG_POPCORN_STAT
+	t3e = ktime_get();
+	t3 += ktime_to_ns(ktime_sub(t3e, t3s));
 
+	t4s = ktime_get();
+#endif
 	if (ftn != NULL) {
 		ftn(msg);
 	} else {
 		printk(KERN_ERR"No callback registered for %d\n", msg->header.type);
 		pcn_kmsg_done(msg);
 	}
+#ifdef CONFIG_POPCORN_STAT
+	t4e = ktime_get();
+	t4 += ktime_to_ns(ktime_sub(t4e, t4s));
+#if 0
+	if (cnt <= 2 ) {
+		t2 = 0; t3 = 0; t4 = 0;
+	}
+
+	if (cnt >= ITERS) {
+		//printk("%s(): %d\n", __func__, cnt);
+		printk("%s(): t2 %lld ns %lld us!!!\n",
+						__func__,
+						t2 / ITER,
+						t2 / ITER / 1000);
+		printk("%s(): t3 %lld ns %lld us!!!\n",
+						__func__,
+						t3 / ITER,
+						t3 / ITER / 1000);
+		printk("%s(): t4 %lld ns %lld us!!!\n",
+						__func__,
+						t4 / ITER,
+						t4 / ITER / 1000);
+		// TODO jack
+	}
+#endif
+#endif
+
 }
 EXPORT_SYMBOL(pcn_kmsg_process);
 
@@ -76,12 +124,28 @@ EXPORT_SYMBOL(pcn_kmsg_process);
 static inline int __build_and_check_msg(enum pcn_kmsg_type type, int to, struct pcn_kmsg_message *msg, size_t size)
 {
 #ifdef CONFIG_POPCORN_CHECK_SANITY
+	if (type < 0 || type >= PCN_KMSG_TYPE_MAX || size > PCN_KMSG_MAX_SIZE ||
+		to < 0 || to >= MAX_POPCORN_NODES || to == my_nid)
+			dump_stack();
 	BUG_ON(type < 0 || type >= PCN_KMSG_TYPE_MAX);
 	BUG_ON(size > PCN_KMSG_MAX_SIZE);
 	BUG_ON(to < 0 || to >= MAX_POPCORN_NODES);
 	BUG_ON(to == my_nid);
 #endif
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* Currently, no user send > PCN_KMSG_TYPE_MAX. Even true for pophype migration */
+	if (to >= get_popcorn_nodes() &&
+		to < MAX_POPCORN_NODES) {
+		/* TODO get_highest_popcorn_node_number(); */
+
+		//printk("skip -> [%d] / %d\n", to, get_popcorn_nodes()); /* debug */
+
+		/* But user usually don't handle (release) this when using pcn_kmsg_post().
+			If users handle it, this is a good protection mechanism. */
+		return -1;
+	}
+#endif
 	msg->header.type = type;
 	msg->header.prio = PCN_KMSG_PRIO_NORMAL;
 	msg->header.size = size;
diff --git a/kernel/popcorn/pf_interface.c b/kernel/popcorn/pf_interface.c
new file mode 100644
index 000000000000..7caa3b48889e
--- /dev/null
+++ b/kernel/popcorn/pf_interface.c
@@ -0,0 +1,83 @@
+#include <linux/kernel.h>
+#include <linux/ktime.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/percpu.h>
+
+#include <popcorn/stat.h>
+#include "types.h"
+
+extern int max_ongoing_pf_req_per_thread;
+#define MAX_STR_LEN 20
+#define BUFSIZE 4*4096
+
+static int __show_stats(struct seq_file *seq, void *v)
+{
+	return 0;
+}
+
+static ssize_t __write_stats(struct file *file, const char __user *buffer, size_t size, loff_t *offset)
+{
+	char tmp[MAX_STR_LEN];
+
+	memset(tmp, 0, MAX_STR_LEN);
+	if (copy_from_user(tmp, buffer, MAX_STR_LEN))
+		return -EFAULT;
+
+	// don't call it durring runtime no lock protecting this
+	max_ongoing_pf_req_per_thread =
+			simple_strtol(tmp, NULL, 10); //dec
+	//printk("size(len) %lu, num %d\n",
+	//		size, max_ongoing_pf_req_per_thread);
+	return size;
+}
+
+static ssize_t __seq_read(struct file *filp, char *buf,
+							size_t count, loff_t *offset)
+{
+	int len = 0;
+	char *tmp = kzalloc(BUFSIZE, GFP_KERNEL);
+
+	if (*offset > 0)
+		return 0;
+
+	len += snprintf(tmp + strlen(tmp), BUFSIZE, "%d", max_ongoing_pf_req_per_thread);
+
+	if(len > BUFSIZE)
+        len = BUFSIZE;
+
+    if (copy_to_user(buf, tmp, len))
+		return -EFAULT;
+	*offset += len;
+
+    //printk("count %lu len %d *offset %llu\n", count, len, *offset);
+    kfree(tmp);
+	return len;
+}
+
+static int __open_stats(struct inode *inode, struct file *file)
+{
+	return single_open(file, __show_stats, inode->i_private);
+}
+
+static struct file_operations stats_ops = {
+	.owner = THIS_MODULE,
+	.open = __open_stats,
+	.read = __seq_read,
+	.llseek  = seq_lseek,
+	.release = single_release,
+	.write = __write_stats,
+};
+
+int prefetch_usr_interface_init(void)
+{
+	struct proc_dir_entry *proc_entry = NULL;
+	proc_entry = proc_create("popcorn_pf_interface", S_IRUGO | S_IWUGO, NULL, &stats_ops);
+	if (proc_entry == NULL) {
+		printk(KERN_ERR"cannot create proc_fs entry for popcorn prefetch interface\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
diff --git a/kernel/popcorn/process_server.c b/kernel/popcorn/process_server.c
index 679cc3530b05..325ce51b0a5f 100644
--- a/kernel/popcorn/process_server.c
+++ b/kernel/popcorn/process_server.c
@@ -2,7 +2,7 @@
  * @file process_server.c
  *
  * Popcorn Linux thread migration implementation
- * This work was an extension of David Katz MS Thesis, but totally rewritten 
+ * This work was an extension of David Katz MS Thesis, but totally rewritten
  * by Sang-Hoon to support multithread environment.
  *
  * @author Sang-Hoon Kim, SSRG Virginia Tech 2017
@@ -27,6 +27,10 @@
 #include <popcorn/types.h>
 #include <popcorn/bundle.h>
 #include <popcorn/cpuinfo.h>
+#include <popcorn/debug.h>
+
+//#include <popcorn/hype_file.h>
+#include <linux/file.h>
 
 #include "types.h"
 #include "process_server.h"
@@ -35,9 +39,14 @@
 #include "wait_station.h"
 #include "util.h"
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/hype_kvm.h>
+#endif
 static struct list_head remote_contexts[2];
 static spinlock_t remote_contexts_lock[2];
 
+static void popcorn_ask_remote_tgid(int nid, struct remote_context *rc);
+
 enum {
 	INDEX_OUTBOUND = 0,
 	INDEX_INBOUND = 1,
@@ -167,6 +176,11 @@ static void __build_task_comm(char *buffer, char *path)
 ///////////////////////////////////////////////////////////////////////////////
 // Distributed mutex
 ///////////////////////////////////////////////////////////////////////////////
+//#define KERNEL_PGS (0xd0000 + 0x30000) // 0xd0000 + 0x30000 = 1048576
+//#define ORIGIN_FUTEX_SKIP (48000 + KERNEL_PGS)
+//#define REMOTE_FUTEX_SKIP (0 + KERNEL_PGS)
+#define ORIGIN_FUTEX_SKIP (0)
+#define REMOTE_FUTEX_SKIP (0)
 long process_server_do_futex_at_remote(u32 __user *uaddr, int op, u32 val,
 		bool valid_ts, struct timespec *ts,
 		u32 __user *uaddr2,u32 val2, u32 val3)
@@ -187,25 +201,66 @@ long process_server_do_futex_at_remote(u32 __user *uaddr, int op, u32 val,
 	};
 	remote_futex_response *res;
 	long ret;
+#ifdef CONFIG_POPCORN_HYPE
+	static unsigned long futex_at_remote_cnt = 0;
+	unsigned long futex_at_remote_thre;
+	unsigned long addr;
+	//BUG_ON(!uaddr || !uaddr2);
+	if (uaddr) {
+		BUG_ON(copy_from_user(&addr, uaddr, sizeof(unsigned long)));
+	}
+#endif
 
 	if (valid_ts) {
 		req.ts = *ts;
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+	BUG_ON(!current->at_remote);
+	futex_at_remote_thre = REMOTE_FUTEX_SKIP;
+	futex_at_remote_cnt++;
+	if (uaddr &&
+		(futex_at_remote_cnt > futex_at_remote_thre ||
+		INTERESTED_GVA(addr))) {
+		FUTEXPRINTK(" f[%d] =>[%d/%d] 0x%x %p 0x%x #%lu\n", current->pid,
+				current->origin_pid, current->origin_nid,
+				op, uaddr, val, futex_at_remote_cnt);
+	}
+#else
 	/*
 	printk(" f[%d] ->[%d/%d] 0x%x %p 0x%x\n", current->pid,
 			current->origin_pid, current->origin_nid,
 			op, uaddr, val);
 	*/
+#endif
 	pcn_kmsg_send(PCN_KMSG_TYPE_FUTEX_REQUEST,
 			current->origin_nid, &req, sizeof(req));
 	res = wait_at_station(ws);
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	BUG_ON(!res);
+#ifdef CONFIG_POPCORN_HYPE
+	if (res == ERR_PTR(-ETIMEDOUT)) {
+		PCNPRINTK_ERR("Not !res but time out\n");
+		WARN_ON(res == ERR_PTR(-ETIMEDOUT));
+	}
+#endif
+#endif
 	ret = res->ret;
+#ifdef CONFIG_POPCORN_HYPE
+	if (uaddr &&
+		(futex_at_remote_cnt > futex_at_remote_thre ||
+		INTERESTED_GVA(addr))) {
+		FUTEXPRINTK(" >>f[%d] <=[%d/%d] 0x%x %p 0x%x #%lu\n", current->pid,
+				current->origin_pid, current->origin_nid,
+				op, uaddr, val, futex_at_remote_cnt);
+	}
+#else
 	/*
 	printk(" f[%d] <-[%d/%d] 0x%x %p %ld\n", current->pid,
 			current->origin_pid, current->origin_nid,
 			op, uaddr, ret);
 	*/
+#endif
 
 	pcn_kmsg_done(res);
 	return ret;
@@ -226,6 +281,15 @@ static void process_remote_futex_request(remote_futex_request *req)
 	int ret;
 	remote_futex_response *res;
 	ktime_t t, *tp = NULL;
+#ifdef CONFIG_POPCORN_HYPE
+	static unsigned long process_futex_at_origin_cnt = 0;
+	unsigned long process_futex_at_origin_thre;
+	unsigned long addr;
+	//BUG_ON(!req->uaddr || !req->uaddr2);
+	if (req->uaddr) {
+		BUG_ON(copy_from_user(&addr, req->uaddr, sizeof(unsigned long)));
+	}
+#endif
 
 	if (timespec_valid(&req->ts)) {
 		t = timespec_to_ktime(req->ts);
@@ -233,18 +297,43 @@ static void process_remote_futex_request(remote_futex_request *req)
 		tp = &t;
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+	BUG_ON(current->at_remote);
+	process_futex_at_origin_thre = ORIGIN_FUTEX_SKIP;
+	process_futex_at_origin_cnt++;
+
+//	if (req->uaddr &&
+//		(process_futex_at_origin_cnt > process_futex_at_origin_thre ||
+//		INTERESTED_GVA(addr))) {
+		FUTEXPRINTK(" f[%d] <-[%d/%d] 0x%x %p 0x%x #%lu\n", current->pid,
+				current->remote_pid, current->remote_nid,
+				req->op, req->uaddr, req->val, process_futex_at_origin_cnt);
+//	}
+#else
 	/*
 	printk(" f[%d] <-[%d/%d] 0x%x %p 0x%x\n", current->pid,
 			current->remote_pid, current->remote_nid,
 			req->op, req->uaddr, req->val);
 	*/
+#endif
 	ret = do_futex(req->uaddr, req->op, req->val,
 			tp, req->uaddr2, req->val2, req->val3);
+
+#ifdef CONFIG_POPCORN_HYPE
+//	if (req->uaddr &&
+//		(process_futex_at_origin_cnt > process_futex_at_origin_thre ||
+//		INTERESTED_GVA(addr))) {
+		FUTEXPRINTK(" f[%d] ->[%d/%d] 0x%x %p %d #%lu\n", current->pid,
+				current->remote_pid, current->remote_nid,
+				req->op, req->uaddr, ret, process_futex_at_origin_cnt);
+//	}
+#else
 	/*
-	printk(" f[%d] ->[%d/%d] 0x%x %p %ld\n", current->pid,
+	printk(" f[%d] ->[%d/%d] 0x%x %p %d\n", current->pid,
 			current->remote_pid, current->remote_nid,
-			req->op, req->uaddr, res.ret);
+			req->op, req->uaddr, ret);
 	*/
+#endif
 	res = pcn_kmsg_get(sizeof(*res));
 	res->remote_ws = req->remote_ws;
 	res->ret = ret;
@@ -433,6 +522,9 @@ static int __do_back_migration(struct task_struct *tsk, int dst_nid, void __user
 {
 	back_migration_request_t *req;
 	int ret;
+//#if defined(CONFIG_POPCORN_HYPE)
+//	int arch;
+//#endif
 
 	might_sleep();
 
@@ -456,6 +548,15 @@ static int __do_back_migration(struct task_struct *tsk, int dst_nid, void __user
 	memcpy(req->action, tsk->sighand->action, sizeof(req->action));
 	*/
 
+#if defined(CONFIG_POPCORN_HYPE)
+	/* Handled outside */
+//	if (dst_nid >= MAX_POPCORN_VCPU ) {
+//				// && dst_nid < 2 * MAX_POPCORN_VCPU) { // no need
+//		dst_nid = 0; // no need
+//    }
+////	if (dst_nid == POPHYPE_MIGRATE_BACK)
+////		dst_nid = 0;
+#endif
 	ret = copy_from_user(&req->arch.regsets, uregs,
 			regset_size(get_popcorn_node_arch(dst_nid)));
 	BUG_ON(ret != 0);
@@ -484,12 +585,22 @@ static int handle_remote_task_pairing(struct pcn_kmsg_message *msg)
 		ret = -ESRCH;
 		goto out;
 	}
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_CHECK_SANITY)
+	if (tsk->at_remote) {
+		printk(KERN_ERR "from a remote remote_thread_main() => "
+				"from_nid [%d/%d]\n", from_nid, req->my_pid);
+	}
+#endif
 	BUG_ON(tsk->at_remote);
 	BUG_ON(!tsk->remote);
 
 	tsk->remote_nid = from_nid;
 	tsk->remote_pid = req->my_pid;
 	tsk->remote->remote_tgids[from_nid] = req->my_tgid;
+#ifdef CONFIG_POPCORN_HYPE
+	//printk("pair: %s() at origin every migration [%d/%d]\n",
+	//		__func__, from_nid, req->my_tgid);
+#endif
 
 	put_task_struct(tsk);
 out:
@@ -545,6 +656,12 @@ static int remote_thread_main(void *_args)
 	memcpy(current->sighand->action, req->action, sizeof(req->action));
 	*/
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* No need to restore fds */
+	FDPRINTK("[%d] current->files [[%p]] skip fd establishing\n",
+									current->pid, current->files);
+#endif
+
 	__pair_remote_task();
 
 	PSPRINTK("\n####### MIGRATED - [%d/%d] from [%d/%d]\n",
@@ -565,7 +682,7 @@ static int __fork_remote_thread(clone_request_t *req)
 
 	/* The loop deals with signals between concurrent migration */
 	while (kernel_thread(remote_thread_main, params,
-					CLONE_THREAD | CLONE_SIGHAND | SIGCHLD) < 0) {
+					CLONE_FILES | CLONE_THREAD | CLONE_SIGHAND | SIGCHLD) < 0) {
 		schedule();
 	}
 	return 0;
@@ -679,11 +796,18 @@ struct remote_worker_params {
 	char comm[TASK_COMM_LEN];
 };
 
+#include <linux/fdtable.h>
+extern int sys_close(unsigned int fd);
 static int remote_worker_main(void *data)
 {
 	struct remote_worker_params *params = (struct remote_worker_params *)data;
 	struct remote_context *rc = params->rc;
 	clone_request_t *req = params->req;
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef CONFIG_POPCORN_TERMINAL_MIGRATION
+	int fd1, fd2, fd3;
+#endif
+#endif
 
 	might_sleep();
 	kfree(params);
@@ -718,10 +842,100 @@ static int remote_worker_main(void *data)
 
 	get_task_remote(current);
 	rc->tgid = current->tgid;
-	
+
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef CONFIG_POPCORN_TERMINAL_MIGRATION
+	/* fd migration support */
+	/* There is a permission BUG - e.g. pts/6 can open others' pts */
+	{
+		int flags = O_CREAT | O_RDWR;
+
+		fd1 = do_sys_open(AT_FDCWD , "/dev/pts/0", flags, 0);
+		fd2 = do_sys_open(AT_FDCWD , "/dev/pts/0", flags, 0);
+		fd3 = do_sys_open(AT_FDCWD , "/dev/pts/0", flags, 0);
+
+		//int fd1 = do_sys_open(AT_FDCWD , "/dev/null", flags, 0);
+		POP_PK("/dev/pts/ %d %d %d\n", fd1, fd2, fd3);
+		if (fd1 >= 0 && fd2 >= 0 && fd3 >= 0) { /* All good */
+			PSPRINTK("fd Recreated /dev/pts/ %d %d %d\n", fd1, fd2, fd3);
+		} else {
+			fd1 = do_sys_open(AT_FDCWD , "/dev/pts/1", flags, 0);
+			fd2 = do_sys_open(AT_FDCWD , "/dev/pts/1", flags, 0);
+			fd3 = do_sys_open(AT_FDCWD , "/dev/pts/1", flags, 0);
+			POP_PK("%d %d %d\n", fd1, fd2, fd3);
+			if (fd1 == 0 && fd2 == 1 && fd3 == 2) {
+				PSPRINTK("fd Recreated %d %d %d (ALL GOOD)\n", fd1, fd2, fd3);
+			} else {
+				BUG();
+				// if (f1 < 0 || f2 < 0 || f3 < 0) { }
+				//int __a = get_unused_fd_flags(flags);
+				//int __b = get_unused_fd_flags(flags);
+				//int __c = get_unused_fd_flags(flags);
+				// note: if (fd123 < 0) { put_unused_fd() } is requred
+				// or /dev/null
+				//PCNPRINTK_ERR("Since cannot open dummy file, plan C start\n");
+				//HPPRINTK("[%d] Opening fd %d done\n", current->pid, __a);
+				//HPPRINTK("[%d] Opening fd %d done\n", current->pid, __b);
+				//HPPRINTK("[%d] Opening fd %d done\n", current->pid, __c);
+			}
+		}
+		//PSPRINTK("Opening fd 0, 1, 2 done next available %d\n",
+		//								current->files->next_fd);
+	}
+#else /* kill me */
+#endif
+#endif
+
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("%s(): at remote first worker thread migration [%d/%d]\n",
+		__func__, POPCORN_HOST_NID, rc->remote_tgids[POPCORN_HOST_NID]);
+	{
+		int nid;
+		for (nid = 1; nid < get_popcorn_nodes() && nid < my_nid; nid++) {
+			/* how can I be sure remote has created the worker thread. */
+			POP_PK("%s() JACK ASK [%d(/%d)] for tgid\n",
+				__func__, nid, get_popcorn_nodes() - 1);
+			popcorn_ask_remote_tgid(nid, rc);
+		}
+	}
+	POP_PK("\n");
+#endif
+
 	__run_remote_worker(rc);
 
 	__terminate_remote_threads(rc);
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef CONFIG_POPCORN_TERMINAL_MIGRATION
+	PSPRINTK("remote main worker frees dummy files/fds\n");
+	if (fd1 == 0 && fd2 == 1 && fd3 == 2) { /* All good */
+		PSPRINTK("Close fd %d %d %d\n", fd1, fd2, fd3);
+		sys_close(fd1);
+		sys_close(fd2);
+		sys_close(fd3);
+		//filp_close(f1, NULL);
+	} else {
+		/*
+		if (f1 < 0 || f2 < 0 || f3 <0) {
+			put_unused_fd(0);
+			put_unused_fd(1);
+			put_unused_fd(2);
+
+			// Somehow other fds are left - exit not properly at remote //
+			put_unused_fd(3);
+			put_unused_fd(4);
+			put_unused_fd(5);
+			put_unused_fd(6);
+			put_unused_fd(7);
+			put_unused_fd(8);
+			put_unused_fd(9);
+		}
+		*/
+		BUG();
+	}
+#else /* kill me */
+	;
+#endif
+#endif
 
 	put_task_remote(current);
 	return current->exit_code;
@@ -807,9 +1021,22 @@ int request_remote_work(pid_t pid, struct pcn_kmsg_message *req)
 	struct task_struct *tsk = __get_task_struct(pid);
 	int ret = -ESRCH;
 	if (!tsk) {
-		printk(KERN_INFO"%s: invalid origin task %d for remote work %d\n",
+		int i = 0;
+		POP_PK(KERN_INFO"%s: invalid origin task %d for remote work %d\n",
 				__func__, pid, req->header.type);
-		goto out_err;
+		WARN_ON("trying to fix");
+		while (!tsk) {
+			if (++i > 1000000) {
+				POP_PK(KERN_INFO"%s: invalid origin task %d for remote work %d\n",
+						__func__, pid, req->header.type);
+				BUG();
+			}
+			io_schedule();
+			tsk = __get_task_struct(pid);
+		}
+		POP_PK(KERN_INFO"%s: fixed origin task %d for remote work %d\n",
+										__func__, pid, req->header.type);
+		//goto out_err;
 	}
 
 	/**
@@ -829,7 +1056,9 @@ int request_remote_work(pid_t pid, struct pcn_kmsg_message *req)
 
 		__put_task_remote(rc);
 	} else {
-		BUG_ON(tsk->remote_work);
+		WARN_ON(tsk->remote_work);
+		while (tsk->remote_work) // Jack DEX BUG FIX
+			; // Jack DEX BUG FIX
 		tsk->remote_work = req;
 		complete(&tsk->remote_work_pended); /* implicit memory barrier */
 	}
@@ -837,7 +1066,7 @@ int request_remote_work(pid_t pid, struct pcn_kmsg_message *req)
 	put_task_struct(tsk);
 	return 0;
 
-out_err:
+//out_err:
 	pcn_kmsg_done(req);
 	return ret;
 }
@@ -845,6 +1074,9 @@ out_err:
 static void __process_remote_works(void)
 {
 	bool run = true;
+	if (current->at_remote) {
+		dump_stack();
+	}
 	BUG_ON(current->at_remote);
 
 	while (run) {
@@ -864,26 +1096,26 @@ static void __process_remote_works(void)
 		case PCN_KMSG_TYPE_REMOTE_PAGE_REQUEST:
 			WARN_ON_ONCE("Not implemented yet!");
 			break;
-		case PCN_KMSG_TYPE_VMA_OP_REQUEST:
+		case PCN_KMSG_TYPE_VMA_OP_REQUEST: // DEFINE_KMSG_RW_HANDLER in vma_server.c
 			process_vma_op_request((vma_op_request_t *)req);
 			break;
-		case PCN_KMSG_TYPE_VMA_INFO_REQUEST:
+		case PCN_KMSG_TYPE_VMA_INFO_REQUEST: // DEFINE_KMSG_RW_HANDLER in vma_server.c
 			process_vma_info_request((vma_info_request_t *)req);
 			break;
-		case PCN_KMSG_TYPE_FUTEX_REQUEST:
+		case PCN_KMSG_TYPE_FUTEX_REQUEST: // DEFINE_KMSG_RW_HANDLER
 			process_remote_futex_request((remote_futex_request *)req);
 			break;
-		case PCN_KMSG_TYPE_TASK_EXIT_REMOTE:
+		case PCN_KMSG_TYPE_TASK_EXIT_REMOTE: // DEFINE_KMSG_RW_HANDLER
 			process_remote_task_exit((remote_task_exit_t *)req);
 			run = false;
 			break;
-		case PCN_KMSG_TYPE_TASK_MIGRATE_BACK:
+		case PCN_KMSG_TYPE_TASK_MIGRATE_BACK: // DEFINE_KMSG_RW_HANDLER
 			process_back_migration((back_migration_request_t *)req);
 			run = false;
 			break;
 		default:
 			if (WARN_ON("Received unsupported remote work")) {
-				printk("  type: %d\n", req->header.type);
+				POP_PK("  type: %d\n", req->header.type);
 			}
 		}
 	}
@@ -978,10 +1210,27 @@ static int __do_migration(struct task_struct *tsk, int dst_nid, void __user *ure
 		 */
 		rc->mm = tsk->mm;
 		rc->remote_tgids[my_nid] = tsk->tgid;
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("%s() myself [%d/%d]\n",
+				__func__, my_nid, tsk->tgid);
+#endif
 
 		__lock_remote_contexts_out(dst_nid);
 		list_add(&rc->list, &__remote_contexts_out());
 		__unlock_remote_contexts_out(dst_nid);
+
+		/* First migration from origin */
+		//PSPRINTK("First migration\n");
+		//get_unused_fd_flags(O_CREAT);
+		//get_unused_fd_flags(O_CREAT);
+		//get_unused_fd_flags(O_CREAT);
+		//PSPRINTK("Opening fd 0, 1, 2 done\n");
+		{
+			int cur_total_files_cnt = jack_traverse_thread_files(current, 1, 1);
+			cur_total_files_cnt += 0; // fixing compilterwarning
+			PSPRINTK("do_migrate: cur total file cnt %d\n", cur_total_files_cnt);
+		}
+		jack_do_file_migration(current); // TODO: name
 	}
 	/*
 	 * tsk->remote != NULL implies this thread is distributed (migrated away).
@@ -996,6 +1245,40 @@ static int __do_migration(struct task_struct *tsk, int dst_nid, void __user *ure
 }
 
 
+
+#ifdef CONFIG_POPCORN_HYPE
+/***********
+ * Hype
+ */
+
+/* TODO: This has to be in user:
+ * hypercall -> return to user with vm_exit=xxx
+ *  (user) syscall pophype_migration_flag on
+ *  (user) syscall flush_dsm (when should I do this) (search destroy rc)
+ *  (user) syscall migration (rely on pophype_migration_flag to know it should do optimized migration)
+ *  (user) syscall pophype_migration_flag off
+ *  (user)
+ *
+ */
+//extern int gcpus[];
+/* pophype migration request from guest VM */
+/* only sync kernel data. user needs to perform migration */
+/* TODO rename and this function is redundant */
+static int __pophype_do_migrate(int dst_nid, int dst_vcpu)
+{
+    int ret = 0; /* good */
+
+    PHMIGRATEPRINTK("[%d] <%d> %s(%d, %d): at \"%s\"\n",
+            current->pid, smp_processor_id(), __func__,
+			dst_nid, dst_vcpu,
+            distributed_remote_process(current) ? "REMOTE" : "ORIGIN");
+
+	popcorn_update_remote_vcpu(dst_nid, dst_vcpu); // TODO: to origin 0
+
+    return ret; // let userspace to do back_migration()
+}
+#endif
+
 /**
  * Migrate the specified task <task> to node <dst_nid>
  * Currently, this function will put the specified task to sleep,
@@ -1009,6 +1292,30 @@ int process_server_do_migration(struct task_struct *tsk, unsigned int dst_nid, v
 
 	if (tsk->origin_nid == dst_nid) {
 		ret = __do_back_migration(tsk, dst_nid, uregs);
+#ifdef CONFIG_POPCORN_HYPE
+	} else if (dst_nid >= MAX_POPCORN_VCPU
+				&& dst_nid < 2 * MAX_POPCORN_VCPU) {
+		PHMIGRATEPRINTK("syscall input dst_nid %d\n", dst_nid);
+		BUG_ON(!my_nid);
+		dst_nid -= MAX_POPCORN_VCPU; /* assumption: 1 vcpu on 1 node - restore */
+		/* Node N -> Node 0 */
+		__pophype_do_migrate(0, dst_nid);
+
+		BUG_ON(dst_nid >= MAX_POPCORN_VCPU);
+		ret = __do_back_migration(tsk, 0, uregs);
+	} else if (dst_nid >= 2 * MAX_POPCORN_VCPU
+				&& dst_nid < 3 * MAX_POPCORN_VCPU) {
+		PHMIGRATEPRINTK("syscall input dst_nid %d\n", dst_nid);
+		BUG_ON(my_nid);
+		dst_nid -= MAX_POPCORN_VCPU * 2; /* assumption: 1 vcpu on 1 node - restore */
+		__pophype_do_migrate(dst_nid, dst_nid);
+
+		BUG_ON(dst_nid >= MAX_POPCORN_VCPU);
+		ret = __do_migration(tsk, dst_nid, uregs);
+		BUG_ON(ret);
+	} else if (dst_nid >= 3 * MAX_POPCORN_VCPU) {
+		BUG();
+#endif
 	} else {
 		ret = __do_migration(tsk, dst_nid, uregs);
 		if (ret) {
@@ -1022,11 +1329,155 @@ int process_server_do_migration(struct task_struct *tsk, unsigned int dst_nid, v
 }
 
 
+
+/* Ask origin for tgid table
+ * //Remote registers vcpu to original's list.
+ * [remote] -> origin -fwd> remote
+ */
+static void popcorn_ask_remote_tgid(int nid, struct remote_context *rc)
+{
+	remote_ask_origin_tgid_request_t *req = kmalloc(sizeof(*req), GFP_KERNEL);
+	struct wait_station *ws = get_wait_station(current);
+	remote_ask_origin_tgid_response_t *res;
+	//struct remote_context *rc = current->mm->remote;
+
+	BUG_ON(!current->at_remote);
+	BUG_ON(!rc || !req);
+	req->from_pid = current->pid;
+	req->ws = ws->id;
+
+	BUG_ON(!rc->remote_tgids[0]); // if works kill me
+	req->origin_pid = rc->remote_tgids[0];
+
+	req->src_tgid = current->tgid;
+	req->dst_nid = nid;
+
+	POP_PK("pair: [%d/%d] src_pid %d => [%d/%d]\n",
+			my_nid, current->pid, current->tgid, my_nid, req->origin_pid);
+	pcn_kmsg_send(PCN_KMSG_TYPE_REMOTE_ASK_ORIGIN_TGID_REQUEST,
+							POPCORN_HOST_NID, req, sizeof(*req));
+	res = wait_at_station(ws);
+
+	POP_PK("\t\tpair: [%d] install [%d/%d]\n", current->pid, nid, res->dst_tgid);
+	rc->remote_tgids[nid] = res->dst_tgid;
+	BUG_ON(res->dst_tgid < 0);
+
+	kfree(req);
+	pcn_kmsg_done(res);
+}
+
+#define FOWARD_PID 123456
+/* remote -> origin [-fwd>] remote */
+void send_tgid_to_remote_at_origin(int src_nid, int dst_nid, int remote_pid, int forward_src_tgid)
+{
+	origin_ask_remote_tgid_request_t *req =
+			kmalloc(sizeof(*req), GFP_KERNEL);
+	req->src_tgid = forward_src_tgid;
+	req->remote_pid = remote_pid;
+	req->src_nid= src_nid;
+	req->from_pid = FOWARD_PID;
+	pcn_kmsg_send(PCN_KMSG_TYPE_ORIGIN_ASK_REMOTE_TGID_REQUEST,
+									dst_nid, req, sizeof(*req));
+	kfree(req);
+}
+
+/* remote -> [origin] -fwd> remote */
+static void process_remote_ask_origin_tgid_request(struct work_struct *work)
+{
+    START_KMSG_WORK(remote_ask_origin_tgid_request_t, req, work);
+    remote_ask_origin_tgid_response_t *res = pcn_kmsg_get(sizeof(*res));
+    int from_nid = PCN_KMSG_FROM_NID(req), dst_tgid = -1;
+    struct task_struct *tsk = __get_task_struct(req->origin_pid);
+	struct remote_context *rc;
+
+    POP_PK("pair: [from%d/%d] => [origin%d] [[rr pair]] at origin\n",
+						from_nid, req->from_pid, req->origin_pid);
+    BUG_ON(!tsk && "No task exist");
+    BUG_ON(tsk->at_remote);
+
+	/* Get from original + forward to remote /
+		redirect to another remote (NOT IMPLEMENTED) */
+	/* Cache */
+	rc = tsk->mm->remote;
+	BUG_ON(!rc->remote_tgids[req->dst_nid]);
+	BUG_ON(rc->remote_tgids[req->dst_nid] < 0);
+	dst_tgid = rc->remote_tgids[req->dst_nid];
+
+	/* Forward */
+	{
+		int forward_src_tgid = req->src_tgid;
+		int dst_nid = req->dst_nid;
+		int remote_pid = rc->remote_tgids[dst_nid];
+		//int remote_pid = req->remote_pid;
+		POP_PK("\t\t pair: fwd [from%d/%d] => [origin%d] [[rr pair]]\n",
+							from_nid, req->from_pid, req->remote_pid);
+		send_tgid_to_remote_at_origin(from_nid, dst_nid, remote_pid, forward_src_tgid);
+	}
+	// (int forward_src_tgid)
+//	{
+//		//struct wait_station *ws = get_wait_station(current);
+//		origin_ask_remote_tgid_request_t *req =
+//				kmalloc(sizeof(*req), GFP_KERNEL);
+//		//req->ws = ws->id;
+//		req->src_tgid = forward_src_tgid;
+//		req->remote_pid = rc->remote_tgids[dst_nid];
+//		pcn_kmsg_send(PCN_KMSG_TYPE_ORIGIN_ASK_REMOTE_TGID_REQUEST,
+//										dst_nid, req, sizeof(*req));
+//		kfree(req);
+//	}
+	/* Redirect (all) done */
+
+	res->dst_tgid = dst_tgid;
+    res->from_pid = req->from_pid;
+    res->ws = req->ws;
+
+    POP_PK("pair: [from%d/%d] => [origin%d] [[rr pair]] ret %d\n",
+			from_nid, req->from_pid, req->origin_pid, dst_tgid);
+    pcn_kmsg_post(PCN_KMSG_TYPE_REMOTE_ASK_ORIGIN_TGID_RESPONSE,
+									from_nid, res, sizeof(*res));
+    END_KMSG_WORK(req);
+}
+
+/* remote -> origin -fwd> [remote] */
+static void process_origin_ask_remote_tgid_request(struct work_struct *work)
+{
+    START_KMSG_WORK(origin_ask_remote_tgid_request_t, req, work);
+    struct task_struct *tsk = __get_task_struct(req->remote_pid);
+	struct remote_context *rc;
+
+    POP_PK("pair: [from(?->%d)/%d] => [remote%d] "
+			"[[rr notice (not ask) pair]]\n",
+			PCN_KMSG_FROM_NID(req), req->from_pid, req->remote_pid);
+    BUG_ON(!tsk && "No task exist");
+    BUG_ON(!tsk->at_remote);
+
+	/* rr installs */
+	rc = tsk->mm->remote;
+	rc->remote_tgids[req->src_nid] = req->src_tgid;
+    POP_PK("\t\tpair: [%d] install [%d/%d]\n",
+				tsk->pid, req->src_nid, req->src_tgid);
+
+	END_KMSG_WORK(req);
+}
+
+static int handle_remote_ask_origin_tgid_response(struct pcn_kmsg_message *msg)
+{
+	remote_ask_origin_tgid_response_t *res =
+		(remote_ask_origin_tgid_response_t *)msg;
+    struct wait_station *ws = wait_station(res->ws);
+
+    ws->private = res;
+
+    complete(&ws->pendings);
+    return 0;
+}
+
 DEFINE_KMSG_RW_HANDLER(origin_task_exit, origin_task_exit_t, remote_pid);
 DEFINE_KMSG_RW_HANDLER(remote_task_exit, remote_task_exit_t, origin_pid);
 DEFINE_KMSG_RW_HANDLER(back_migration, back_migration_request_t, origin_pid);
 DEFINE_KMSG_RW_HANDLER(remote_futex_request, remote_futex_request, origin_pid);
-
+DEFINE_KMSG_WQ_HANDLER(remote_ask_origin_tgid_request);
+DEFINE_KMSG_WQ_HANDLER(origin_ask_remote_tgid_request);
 /**
  * Initialize the process server.
  */
@@ -1049,5 +1500,15 @@ int __init process_server_init(void)
 	REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_FUTEX_REQUEST, remote_futex_request);
 	REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_FUTEX_RESPONSE, remote_futex_response);
 
+	REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_REMOTE_ASK_ORIGIN_TGID_REQUEST,
+										remote_ask_origin_tgid_request);
+	REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_ORIGIN_ASK_REMOTE_TGID_REQUEST,
+										origin_ask_remote_tgid_request);
+	//REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_ORIGIN_ASK_REMOTE_TGID_RESPONSE,
+	//									origin_ask_remote_tgid_response);
+	REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_REMOTE_ASK_ORIGIN_TGID_RESPONSE,
+										remote_ask_origin_tgid_response);
+
+
 	return 0;
 }
diff --git a/kernel/popcorn/stat.c b/kernel/popcorn/stat.c
index fc7e62f3c644..788bee4bb9ad 100644
--- a/kernel/popcorn/stat.c
+++ b/kernel/popcorn/stat.c
@@ -28,6 +28,8 @@ const char *pcn_kmsg_type_name[PCN_KMSG_TYPE_MAX] = {
 	[PCN_KMSG_TYPE_VMA_INFO_REQUEST] = "VMA info",
 	[PCN_KMSG_TYPE_VMA_OP_REQUEST] = "VMA op",
 	[PCN_KMSG_TYPE_REMOTE_PAGE_REQUEST] = "remote page",
+	[PCN_KMSG_TYPE_REMOTE_PAGE_RESPONSE] = "w/ page",
+	[PCN_KMSG_TYPE_REMOTE_PAGE_RESPONSE_SHORT] = "w/o page",
 	[PCN_KMSG_TYPE_PAGE_INVALIDATE_REQUEST] = "invalidate",
 	[PCN_KMSG_TYPE_FUTEX_REQUEST] = "futex",
 };
@@ -61,6 +63,10 @@ void account_pcn_rdma_read(size_t size)
 }
 
 void fh_action_stat(struct seq_file *seq, void *);
+extern void pf_time_stat(struct seq_file *seq, void *v);
+extern void pophype_stat(struct seq_file *seq, void *v);
+extern void dsm_traffic_stat(struct seq_file *seq, void *v);
+extern void pophype_net_gup(struct seq_file *seq, void *v);
 
 static int __show_stats(struct seq_file *seq, void *v)
 {
@@ -113,13 +119,15 @@ static int __show_stats(struct seq_file *seq, void *v)
 
 #ifdef CONFIG_POPCORN_STAT
 	seq_printf(seq, "-----------------------------------------------\n");
-	for (i = PCN_KMSG_TYPE_STAT_START + 1; i < PCN_KMSG_TYPE_STAT_END; i++) {
+	//for (i = PCN_KMSG_TYPE_STAT_START + 1; i < PCN_KMSG_TYPE_STAT_END; i++) {
+	for (i = PCN_KMSG_TYPE_REMOTE_PAGE_REQUEST; i < PCN_KMSG_TYPE_REMOTE_PAGE_FLUSH; i++) {
 		seq_printf(seq, POPCORN_STAT_FMT,
 				sent_stats[i], recv_stats[i], pcn_kmsg_type_name[i] ? : "");
 	}
 	seq_printf(seq, "---------------------------------------------------------------------------\n");
 
-	fh_action_stat(seq, v);
+	//fh_action_stat(seq, v);
+	pf_time_stat(seq, v);
 #endif
 	return 0;
 }
@@ -141,6 +149,10 @@ static ssize_t __write_stats(struct file *file, const char __user *buffer, size_
 	}
 	fh_action_stat(NULL, NULL);
 
+#ifdef CONFIG_POPCORN_STAT
+	pf_time_stat(NULL, NULL);
+#endif
+
 	return size;
 }
 
@@ -158,14 +170,229 @@ static struct file_operations stats_ops = {
 	.write = __write_stats,
 };
 
-static struct proc_dir_entry *proc_entry = NULL;
+static int __show_pophype_stats(struct seq_file *seq, void *v)
+{
+#if 0
+	int i;
+	unsigned long long sent = 0;
+	unsigned long long recv = 0;
+	unsigned long long rate_sent, rate_recv;
+	unsigned long elapsed;
+	struct timeval now;
+
+	/* Between two cat */
+	do_gettimeofday(&now);
+	elapsed = (now.tv_sec * 1000000 + now.tv_usec) -
+			(last_stat.tv_sec * 1000000 + last_stat.tv_usec);
+	last_stat = now;
+
+	/* Per cpu msg */
+	for_each_present_cpu(i) {
+		sent += per_cpu(bytes_sent, i);
+		recv += per_cpu(bytes_recv, i);
+	}
+	seq_printf(seq, POPCORN_STAT_FMT, sent, recv, "Total network I/O");
+
+	rate_sent = (sent - last_bytes_sent);
+	rate_recv = (recv - last_bytes_recv);
+	seq_printf(seq, POPCORN_STAT_FMT2,
+			rate_sent / elapsed, (rate_sent % elapsed) * 1000 / elapsed,
+			rate_recv / elapsed, (rate_recv % elapsed) * 1000 / elapsed,
+			"MB/s");
+	last_bytes_sent = sent;
+	last_bytes_recv = recv;
+
+	if (pcn_kmsg_has_features(PCN_KMSG_FEATURE_RDMA) && elapsed) {
+		recv = sent = 0;
+		for_each_present_cpu(i) {
+			sent += per_cpu(bytes_rdma_written, i);
+			recv += per_cpu(bytes_rdma_read, i);
+		}
+		seq_printf(seq, POPCORN_STAT_FMT, sent, recv, "RDMA");
+
+		rate_sent = (sent - last_bytes_rdma_written);
+		rate_recv = (recv - last_bytes_rdma_read);
+		seq_printf(seq, POPCORN_STAT_FMT2,
+				rate_sent / elapsed, (rate_sent % elapsed) * 1000 / elapsed,
+				rate_recv / elapsed, (rate_recv % elapsed) * 1000 / elapsed,
+				"MB/s");
+		last_bytes_rdma_written = sent;
+		last_bytes_rdma_read = recv;
+	}
+
+	pcn_kmsg_stat(seq, NULL);
+#endif
+
+#ifdef CONFIG_POPCORN_STAT
+#if 0
+	seq_printf(seq, "-----------------------------------------------\n");
+	//for (i = PCN_KMSG_TYPE_STAT_START + 1; i < PCN_KMSG_TYPE_STAT_END; i++) {
+	for (i = PCN_KMSG_TYPE_REMOTE_PAGE_REQUEST; i < PCN_KMSG_TYPE_REMOTE_PAGE_FLUSH; i++) {
+		seq_printf(seq, POPCORN_STAT_FMT,
+				sent_stats[i], recv_stats[i], pcn_kmsg_type_name[i] ? : "");
+	}
+	seq_printf(seq, "---------------------------------------------------------------------------\n");
+#endif
+#endif
+
+	//fh_action_stat(seq, v);
+	//pf_time_stat(seq, v);
+	pophype_stat(seq, v); /* kernel/popcorn/hype_kvm.c */
+	//file_stat(seq, v); /* kernel/popcorn/hype_file.c */
+	seq_printf(seq, "\n");
+	pophype_net_gup(seq, v); /* arch/x86/mm/gup.c (no time for me to move) */
+
+	return 0;
+}
+
+static ssize_t __write_pophype_stats(struct file *file, const char __user *buffer, size_t size, loff_t *offset)
+{
+#if 0
+	int i;
+
+	/* Msg */
+	for_each_present_cpu(i) {
+		per_cpu(bytes_sent, i) = 0;
+		per_cpu(bytes_recv, i) = 0;
+		per_cpu(bytes_rdma_written, i) = 0;
+		per_cpu(bytes_rdma_read, i) = 0;
+	}
+
+	pcn_kmsg_stat(NULL, NULL);
+
+	for (i = 0 ; i < PCN_KMSG_TYPE_MAX; i++) {
+		sent_stats[i] = 0;
+		recv_stats[i] = 0;
+	}
+
+	fh_action_stat(NULL, NULL);
+#endif
+
+	//pf_time_stat(NULL, NULL);
+	pophype_stat(NULL, NULL); /* kernel/popcorn/hype_kvm.c */
+	//file_stat(NULL, NULL); /* kernel/popcorn/hype_file.c */
+	pophype_net_gup(NULL, NULL); /* arch/x86/mm/gup.c (no time for me to move) */
+
+	return size;
+}
+
+static int __open_pophype_stats(struct inode *inode, struct file *file)
+{
+	return single_open(file, __show_pophype_stats, inode->i_private);
+}
+
+static struct file_operations pophype_stats_ops = {
+	.owner = THIS_MODULE,
+	.open = __open_pophype_stats,
+	.read = seq_read,
+	.llseek  = seq_lseek,
+	.release = single_release,
+	.write = __write_pophype_stats,
+};
+
+extern bool pophype_debug;
+
+static int __show_pophype_debug(struct seq_file *seq, void *v)
+{
+	if (seq) { /* show */
+		seq_printf(seq, "Pophype debug %s (current)\n",
+							pophype_debug ? "ON" : "OFF");
+		printk("Pophype debug %s (current)\n", pophype_debug ? "ON" : "OFF");
+		dsm_traffic_stat(seq, v);
+	} else { /* change */
+		printk("never happen\n");
+	}
+	return 0;
+}
+
+static ssize_t __write_pophype_debug(struct file *file, const char __user *buffer, size_t size, loff_t *offset)
+{
+	/* toggle */
+	if (pophype_debug)
+		pophype_debug = false;
+	else
+		pophype_debug = true;
+	//pophype_debug = ~pophype_debug;
+
+	/* show */
+	//seq_printf(seq, "Pophype debug %s (current)\n",
+	//					pophype_debug ? "ON" : "OFF");
+	printk("Pophype debug %s (current)\n", pophype_debug ? "ON" : "OFF");
+	printk("Clean all the info\n");
+	dsm_traffic_stat(NULL, NULL);
+	return size;
+}
+
+static int __open_pophype_debug(struct inode *inode, struct file *file)
+{
+	return single_open(file, __show_pophype_debug, inode->i_private);
+}
+
+static struct file_operations pophype_debug_ops = {
+	.owner = THIS_MODULE,
+	.open = __open_pophype_debug,
+	.read = seq_read,
+	.llseek  = seq_lseek,
+	.release = single_release,
+	.write = __write_pophype_debug,
+};
+
+#if POPCORN_STAT_MQ_INFO
+extern void pophype_mq_tx_stat(struct seq_file *seq, void *v); /* net/core/dev.c */
+extern void pophype_mq_rx_stat(struct seq_file *seq, void *v); /* net/core/dev.c */
+static int __show_pophype_mq(struct seq_file *seq, void *v)
+{
+	pophype_mq_tx_stat(seq, v);
+	pophype_mq_rx_stat(seq, v);
+	return 0;
+}
+
+static ssize_t __write_pophype_mq(struct file *file, const char __user *buffer, size_t size, loff_t *offset)
+{
+	pophype_mq_tx_stat(NULL, NULL);
+	pophype_mq_rx_stat(NULL, NULL);
+	return 0;
+}
+
+static int __open_pophype_mq(struct inode *inode, struct file *file)
+{
+	return single_open(file, __show_pophype_mq, inode->i_private);
+}
+
+static struct file_operations pophype_mq_ops = {
+	.owner = THIS_MODULE,
+	.open = __open_pophype_mq,
+	.read = seq_read,
+	.llseek  = seq_lseek,
+	.release = single_release,
+	.write = __write_pophype_mq,
+};
+#endif
 
 int statistics_init(void)
 {
+	struct proc_dir_entry *proc_entry = NULL;
 	proc_entry = proc_create("popcorn_stat", S_IRUGO | S_IWUGO, NULL, &stats_ops);
 	if (proc_entry == NULL) {
 		printk(KERN_ERR"cannot create proc_fs entry for popcorn stats\n");
 		return -ENOMEM;
 	}
+	proc_entry = proc_create("popcorn_hype", S_IRUGO | S_IWUGO, NULL, &pophype_stats_ops);
+	if (proc_entry == NULL) {
+		printk(KERN_ERR"cannot create proc_fs entry for popcorn_hype stats\n");
+		return -ENOMEM;
+	}
+	proc_entry = proc_create("popcorn_debug", S_IRUGO | S_IWUGO, NULL, &pophype_debug_ops);
+	if (proc_entry == NULL) {
+		printk(KERN_ERR"cannot create proc_fs entry for popcorn_hype stats\n");
+		return -ENOMEM;
+	}
+#if POPCORN_STAT_MQ_INFO
+	proc_entry = proc_create("popcorn_mq", S_IRUGO | S_IWUGO, NULL, &pophype_mq_ops);
+	if (proc_entry == NULL) {
+		printk(KERN_ERR"cannot create proc_fs entry for popcorn_mq stats\n");
+		return -ENOMEM;
+	}
+#endif
 	return 0;
 }
diff --git a/kernel/popcorn/sync.h b/kernel/popcorn/sync.h
new file mode 100644
index 000000000000..8f95fd80fa3b
--- /dev/null
+++ b/kernel/popcorn/sync.h
@@ -0,0 +1,14 @@
+/*
+ * sync.h
+ * Copyright (C) 2018 jackchuang <jackchuang@mir7>
+ *
+ * Distributed under terms of the MIT license.
+ */
+
+#ifndef _SYNC_H
+#define _SYNC_H
+#include <popcorn/sync.h>
+
+void tso_wr_inc(struct vm_area_struct *vma, unsigned long addr, struct page *page, spinlock_t *ptl);
+
+#endif /* !_SYNC_H */
diff --git a/kernel/popcorn/timer.c b/kernel/popcorn/timer.c
new file mode 100644
index 000000000000..bcaa36b32b4d
--- /dev/null
+++ b/kernel/popcorn/timer.c
@@ -0,0 +1,188 @@
+/**
+ * @file timer.c
+ *
+ *
+ * @author Ho-Ren (Jack) Chuang, SSRG Virginia Tech 2019
+ *
+ * Distributed under terms of the MIT license.
+ */
+#include <linux/kernel.h>
+#include <linux/timer.h>
+
+#include <asm/pgtable.h>
+#include <popcorn/hype_kvm.h>
+
+#include <linux/highmem.h>
+
+extern bool pophype_debug;
+#if defined(CONFIG_POPCORN_STAT) && POPHYPE_HOST_KERNEL
+static struct timer_list my_timer;
+#endif
+
+static unsigned char *paddr;
+static unsigned char _paddr[PAGE_SIZE];
+//static char kvaddr[PAGE_SIZE];
+static char kvmaddr_hex_str[PAGE_SIZE * 10];
+
+//static int cnt = 0;
+
+void my_timer_callback(unsigned long data)
+{
+#if defined(CONFIG_POPCORN_STAT) && POPHYPE_HOST_KERNEL
+	/* do your timer stuff here */
+	//if (++cnt < 10 || !(cnt % 10))
+	//	printk("%s(): timer 10s pophype_debug %d #%d\n",
+	//						__func__, pophype_debug, cnt);
+	if (pophype_debug) {
+
+
+		/* TODO bh.......... otherwise __get_user_pages_unlocked() cannot work */
+
+
+		int i, found = 0;
+		for (i = 0; i < MAX_POPCORN_VCPU; i++) {
+			if (my_nid == popcorn_vcpuid_to_nid(i)) {
+				int fd = i + VCPU_FD_BASE;
+				if (hype_node_info[my_nid][fd]->vcpu) { /* found vcpu */
+					struct kvm_vcpu *vcpu = hype_node_info[my_nid][fd]->vcpu;
+					unsigned long gpa = __pa(level3_kernel_pgt);
+					unsigned long gfn, hva;
+					int j, ofs = 0;
+
+					struct task_struct *tsk = hype_node_info[my_nid][fd]->tsk;
+					struct page *page[1];
+					int write_fault = 0;
+					int npages;
+
+					struct vm_area_struct *vma;
+
+					found = 1;
+					// level3_kernel_pgt
+					// 		gva = ffffffff81e0d000
+					//		gpa = 		   1e0d000
+					//		hva =
+
+					// show page contain
+
+					///* guest pgt walk */
+					//tr.linear_address = next_rbp_gva;
+					//kvm_arch_vcpu_ioctl_translate(
+					//            hype_node_info[my_nid][fd]->vcpu, &tr);
+					//gpa = tr.physical_address;
+
+					//if (gpa == 0UL - 1)
+					//    goto __err;
+
+					//int cnt = 0, i;
+					//int err_cnt = 0;
+					//struct kvm_translation tr;
+					//unsigned long *frame;
+					//unsigned long next_rbp_gva = kvm_regs->rbp;
+
+					/* host - gpa -> gfn */
+					gfn = gpa >> PAGE_SHIFT;
+					hva = kvm_vcpu_gfn_to_hva(vcpu, gfn);
+
+					// BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG
+					// BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG
+					//// how to get the right address space???
+					//// how to feed to copy_from_user.....
+					//if (copy_from_user(kvaddr,
+					//			(const void __user *)hva, PAGE_SIZE)) {
+					//	printk(KERN_ERR "%s(): BUG() "
+					//			"kvaddr %p gpa %lx gfn %lx hva %p\n",
+					//				__func__, kvaddr, gpa, gfn, hva);
+					//	BUG();
+					//}
+					// BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG
+					// BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG
+
+					// case 2
+					// get mm vma
+
+		goto out; // remote out origin stay
+		goto out; // remote out origin stay
+		goto out; // remote out origin stay
+		goto out; // remote out origin stay
+		goto out; // remote out origin stay
+		goto out; // remote out origin stay
+		goto out; // remote out origin stay
+		goto out; // remote out origin stay
+		goto out; // remote out origin stay
+
+					if (my_nid) goto out; // remote out origin stay
+					printk("show level3_kernel_pgt %p %lx page data "
+							"(dbg - fd %d) hva %lx "
+							"tsk %p [pid %d's address space]\n",
+							level3_kernel_pgt, __pa(level3_kernel_pgt),
+							fd, hva, tsk, tsk ? tsk->pid : -78);
+					/* remote tsk already released so pid is -XXXXXXXXXXX */
+					if (!tsk->mm) goto out; // remote out origin stay
+
+					// get_user_pages
+					//		like virt/kvm/kvm_main.c
+					//		ref get_user_page_nowait()
+					//struct task_struct *tsk, struct mm_struct *mm,
+					//		unsigned long start, int write, struct page **page
+					//int read_flags = FOLL_TOUCH | FOLL_HWPOISON | FOLL_GET;
+					//int a = __get_user_pages(tsk, mm, start,
+					//						1, read_flags, page, NULL, NULL);
+					//long get_user_pages_unlocked(
+					//		struct task_struct *tsk, struct mm_struct *mm,
+					//		unsigned long start, unsigned long nr_pages,
+					//		int write, int force, struct page **pages) {
+					//	__get_user_pages_unlocked(tsk, mm, start, nr_pages,
+					//						write, force, pages, FOLL_TOUCH);
+					//}
+					npages = __get_user_pages_unlocked(tsk, tsk->mm,
+										hva, 1, write_fault, 0, page,
+											FOLL_TOUCH|FOLL_HWPOISON);
+					BUG_ON(npages != 1);
+
+					//paddr = kmap(page);
+					vma = find_vma(tsk->mm, hva);
+					BUG_ON (!vma || vma->vm_start > hva);
+
+					paddr = kmap_atomic(*page);
+					copy_from_user_page(vma, *page, hva, _paddr, paddr, PAGE_SIZE); // !!!! retry
+					kunmap_atomic(paddr);
+					// TODO hex to string and then print
+					//for (j = 0; j < PAGE_SIZE; j += sizeof(long)) {
+					for (j = 0; j < PAGE_SIZE; j += sizeof(char)) { // 0xff (*4096)
+						ofs += sprintf(kvmaddr_hex_str + ofs,
+										"%02hhx ", *(_paddr + j));
+					}
+
+					kvmaddr_hex_str[ofs] = '\0';
+					printk("ofs %d: %s\n",
+								ofs, kvmaddr_hex_str);
+				}
+			}
+		}
+		BUG_ON(!found);
+	}
+out:
+	mod_timer(&my_timer, jiffies + msecs_to_jiffies(1000));
+#endif
+}
+
+int __init vm_dsm_debug_timer_init(void)
+{
+#if defined(CONFIG_POPCORN_STAT) && POPHYPE_HOST_KERNEL
+	/* setup your timer to call my_timer_callback */
+	setup_timer(&my_timer, my_timer_callback, 0);
+	/* setup timer interval to 1000 msecs */
+	mod_timer(&my_timer, jiffies + msecs_to_jiffies(1000));
+	printk("%s(): __init\n", __func__);
+#endif
+	return 0;
+}
+
+void __exit cleanup_vm_dsm_debug_timer(void)
+{
+#if defined(CONFIG_POPCORN_STAT) && POPHYPE_HOST_KERNEL
+	del_timer(&my_timer);
+	printk("%s(): __exit\n", __func__);
+#endif
+	return;
+}
diff --git a/kernel/popcorn/trace_events.h b/kernel/popcorn/trace_events.h
index 31bb57cbcc7c..e4c30fa6e3e9 100644
--- a/kernel/popcorn/trace_events.h
+++ b/kernel/popcorn/trace_events.h
@@ -40,16 +40,16 @@ TRACE_EVENT(pgfault,
 
 TRACE_EVENT(pgfault_stat,
 	TP_PROTO(const unsigned long instr_addr, const unsigned long addr,
-		const int result, const int retries, const unsigned long time_us),
+		const int result, const int retries, const unsigned long time_ns),
 
-	TP_ARGS(instr_addr, addr, result, retries, time_us),
+	TP_ARGS(instr_addr, addr, result, retries, time_ns),
 
 	TP_STRUCT__entry(
 		__field(unsigned long, instr_addr)
 		__field(unsigned long, addr)
 		__field(int, result)
 		__field(int, retries)
-		__field(unsigned long, time_us)
+		__field(unsigned long, time_ns)
 	),
 
 	TP_fast_assign(
@@ -57,14 +57,135 @@ TRACE_EVENT(pgfault_stat,
 		__entry->addr = addr;
 		__entry->result = result;
 		__entry->retries = retries;
-		__entry->time_us = time_us;
+		__entry->time_ns = time_ns;
 	),
 
 	TP_printk("%lx %lx %d %d %lu",
 		__entry->instr_addr, __entry->addr, __entry->result,
-		__entry->retries, __entry->time_us)
+		__entry->retries, __entry->time_ns)
 );
 
+/*
+typedef struct {
+    unsigned long addr;
+    unsigned long rip;
+    unsigned long rbp;
+    unsigned long rsp;
+    unsigned long stack[MAX_VM_STACK_DEBUG];
+    unsigned long cnt;
+    unsigned long long time;
+} dsm_traffic_t;
+*/
+/*
+ *	address: full
+ *	addr: page addr
+ */
+TRACE_EVENT(vmdsm_traffic,
+	TP_PROTO(const unsigned long addr, const char rw,
+		const unsigned long rip, const unsigned long rbp,
+		const unsigned long rsp, const unsigned long stack0,
+		const unsigned long stack1, const unsigned long stack2,
+		const unsigned long stack3, const unsigned long stack4,
+		const unsigned long address, const int kvm_mp_state,
+		const unsigned long ns, const int vcpu_cpl,
+		const int vcpu_mode, const unsigned long api_rip,
+		unsigned long real_gva, unsigned long exit_qualification),
+
+	TP_ARGS(addr, rw, rip, rbp, rsp,
+			stack0, stack1, stack2, stack3, stack4,
+				address, kvm_mp_state, ns,
+				vcpu_cpl, vcpu_mode, api_rip,
+				real_gva, exit_qualification),
+
+	TP_STRUCT__entry(
+		__field(unsigned long, addr)
+		__field(char, rw)
+		__field(unsigned long, rip)
+		__field(unsigned long, rbp)
+		__field(unsigned long, rsp)
+		__field(unsigned long, stack0)
+		__field(unsigned long, stack1)
+		__field(unsigned long, stack2)
+		__field(unsigned long, stack3)
+		__field(unsigned long, stack4)
+		__field(unsigned long, address)
+		__field(int, kvm_mp_state)
+		__field(unsigned long, ns)
+		__field(int, vcpu_cpl)
+		__field(int, vcpu_mode)
+		__field(unsigned long, api_rip)
+		__field(unsigned long, real_gva)
+		__field(unsigned long, exit_qualification)
+	),
+
+	TP_fast_assign(
+		__entry->addr = addr; /* cr2 >> PAGE_SHIFT */
+		__entry->rw = rw;
+		__entry->rip = rip;
+		__entry->rbp = rbp;
+		__entry->rsp = rsp;
+		__entry->stack0 = stack0;
+		__entry->stack1 = stack1;
+		__entry->stack2 = stack2;
+		__entry->stack3 = stack3;
+		__entry->stack4 = stack4;
+		__entry->address = address; /* cr2 */
+		__entry->kvm_mp_state = kvm_mp_state;
+		__entry->ns = ns;
+		__entry->vcpu_cpl = vcpu_cpl;
+		__entry->vcpu_mode = vcpu_mode;
+		__entry->api_rip = api_rip;
+		__entry->real_gva = real_gva;
+		__entry->exit_qualification = exit_qualification;
+		),
+
+	TP_printk("%lx %c %lx %lx %lx %lx %lx %lx %lx %lx %lx %d %lu - %d %d %lx - %lx %lx (%c%c%c %c%c%c%c %c%c %s%s)",
+		__entry->addr, __entry->rw, __entry->rip, __entry->rbp,
+		__entry->rsp, __entry->stack0, __entry->stack1,
+		__entry->stack2, __entry->stack3, __entry->stack4,
+		__entry->address, __entry->kvm_mp_state, __entry->ns,
+		__entry->vcpu_mode, __entry->vcpu_mode, __entry->api_rip,
+		__entry->real_gva,
+		__entry->exit_qualification,
+		((__entry->exit_qualification & 0x1) ? 'r' : '-'),
+		((__entry->exit_qualification & 0x2) ? 'w' : '-'),
+		((__entry->exit_qualification & 0x4) ? 'f' : '-'),
+		((__entry->exit_qualification & 0x8) ? 'R' : '-'),
+		((__entry->exit_qualification & 0x10) ? 'W' : '-'),
+		((__entry->exit_qualification & 0x20) ? 'X' : '-'),
+		((__entry->exit_qualification & 0x40) ? 'x' : '-'),
+		((__entry->exit_qualification & 0x80) ? ((__entry->exit_qualification & 0x100) ? 'p' : 't') : '-'), // last or walks
+		((__entry->exit_qualification & 0x80) && (__entry->exit_qualification & 0x100) ? ((__entry->exit_qualification & 0x200) ? 'u' : 'k') : '-'),
+		((__entry->exit_qualification & 0x80) && (__entry->exit_qualification & 0x100) ? ((__entry->exit_qualification & 0x400) ? "ro" : "rw") : "-"),
+		((__entry->exit_qualification & 0x80) && (__entry->exit_qualification & 0x100) ? ((__entry->exit_qualification & 0x800) ? "Ex" : "Nx") : "-")
+		)
+);
+
+
+/*
+ * Retry before __direct_map() in ./arch/x86/kvm/mmu.c.
+ */
+TRACE_EVENT(kvm_ept_retry,
+    TP_PROTO(unsigned long fast_retry_gpa, unsigned long retry_gpa, unsigned long inv_gpa),
+    TP_ARGS(fast_retry_gpa, retry_gpa, inv_gpa),
+
+    TP_STRUCT__entry(
+        __field(    unsigned long,  fast_retry_gpa   )
+        __field(    unsigned long,  retry_gpa   )
+        __field(    unsigned long,  inv_gpa )
+    ),
+
+    TP_fast_assign(
+        __entry->fast_retry_gpa  = fast_retry_gpa;
+        __entry->retry_gpa  = retry_gpa;
+        __entry->inv_gpa    = inv_gpa;
+    ),
+
+    TP_printk("fast_retry_gpa %lx retry_gpa %lx inv_gpa %lx",
+          __entry->fast_retry_gpa,
+          __entry->retry_gpa,
+          __entry->inv_gpa)
+);
 #endif
 
 #undef TRACE_INCLUDE_PATH
diff --git a/kernel/popcorn/types.h b/kernel/popcorn/types.h
index 08d26735c7b3..29c041f1e4d9 100644
--- a/kernel/popcorn/types.h
+++ b/kernel/popcorn/types.h
@@ -12,8 +12,19 @@
 #include <popcorn/pcn_kmsg.h>
 #include <popcorn/regset.h>
 
-#define FAULTS_HASH 31
+#include <popcorn/hype_file.h>
+#include <popcorn/hype_kvm.h>
+#include <popcorn/hype.h>
+
+#include <asm/kvm_host.h>
+#include <linux/kvm_host.h>
+
+#include <linux/skbuff.h> // vhost-net optimication
+
+#define MAX_POPCORN_VCPU 32 /* HACK: not sure why including popcorn/hype_kvm.h doesn't work */
 
+#define FAULTS_HASH 31
+#define MAX_PCN_NAME_LEN 255
 /**
  * Remote execution context
  */
@@ -178,6 +189,7 @@ DEFINE_PCN_KMSG(vma_info_response_t, VMA_INFO_RESPONSE_FIELDS);
 		unsigned long pgoff;	/* mmap */ \
 		unsigned long new_addr;	/* mremap */ \
 	}; \
+	int fd; \
 	char path[512];
 DEFINE_PCN_KMSG(vma_op_request_t, VMA_OP_REQUEST_FIELDS);
 
@@ -303,6 +315,329 @@ DEFINE_PCN_KMSG(node_info_t, NODE_INFO_FIELDS);
 	int power_3;
 DEFINE_PCN_KMSG(sched_periodic_req, SCHED_PERIODIC_FIELDS);
 
+/**
+ * Hype
+ */
+#define REMOTE_HYPE_COMMON_FIELDS \
+	pid_t from_pid; \
+	pid_t origin_pid; \
+	int ws; \
+
+// open
+#define REMOTE_OPEN_COMMON_FIELDS \
+	pid_t from_pid; \
+	pid_t origin_pid; \
+	int ws; \
+	int fd;
+//	int ret;
+
+/* using */
+#define ORIGIN_HYPE_COMMON_FIELDS \
+	pid_t from_pid; \
+	pid_t remote_pid; \
+	int ws; \
+	int fd; \
+	int ret;
+
+#define REMOTE_OPEN_REQUEST_FIELDS \
+	REMOTE_OPEN_COMMON_FIELDS \
+	int flags; \
+	int mode; \
+	char filename[MAX_PCN_NAME_LEN];
+DEFINE_PCN_KMSG(remote_open_request_t, REMOTE_OPEN_REQUEST_FIELDS);
+
+#define REMOTE_OPEN_RESPONSE_FIELDS \
+	REMOTE_OPEN_COMMON_FIELDS
+DEFINE_PCN_KMSG(remote_open_response_t, REMOTE_OPEN_RESPONSE_FIELDS);
+
+// delegate rw
+//	int pos; // not need to exchange pos. Always use origin's pos // so recycle definition of  REMOTE_OPEN
+#define MAX_POPCONR_FILE_RW_SIZE 255
+
+#define DELEGATE_RW_REQUEST_FIELDS \
+	REMOTE_OPEN_COMMON_FIELDS \
+	size_t count; \
+	bool is_read; \
+	char buf[MAX_POPCONR_FILE_RW_SIZE];
+DEFINE_PCN_KMSG(delegate_rw_request_t, DELEGATE_RW_REQUEST_FIELDS);
+
+#define DELEGATE_RW_RESPONSE_FIELDS \
+	REMOTE_OPEN_COMMON_FIELDS \
+	int ret; \
+	char buf[MAX_POPCONR_FILE_RW_SIZE];
+DEFINE_PCN_KMSG(delegate_rw_response_t, DELEGATE_RW_RESPONSE_FIELDS);
+
+
+// kvm
+#define REMOTE_KVM_CREATE_REQUEST_FIELDS \
+	REMOTE_HYPE_COMMON_FIELDS \
+	unsigned long type;
+DEFINE_PCN_KMSG(remote_kvm_create_request_t, REMOTE_KVM_CREATE_REQUEST_FIELDS);
+
+#define REMOTE_KVM_CREATE_RESPONSE_FIELDS \
+	REMOTE_HYPE_COMMON_FIELDS \
+	int fd;
+DEFINE_PCN_KMSG(remote_kvm_create_response_t, REMOTE_KVM_CREATE_RESPONSE_FIELDS);
+
+DEFINE_PCN_KMSG(pophype_request_t, ORIGIN_HYPE_COMMON_FIELDS);
+#define REMOTE_CHECKIN_VCPU_PID_RESPONSE_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	int origin_pid; \
+	int from_nid;
+DEFINE_PCN_KMSG(pophype_response_t, REMOTE_CHECKIN_VCPU_PID_RESPONSE_FIELDS);
+
+// not used
+#define ORIGIN_CHECKIN_VCPU_PID_REQEUST_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	int from_nid;
+DEFINE_PCN_KMSG(pophype_origin_checkin_vcpu_request_t, ORIGIN_CHECKIN_VCPU_PID_REQEUST_FIELDS);
+
+#define ORIGIN_SIPI_REQUEST_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	int vcpu_id; \
+	int vector;
+DEFINE_PCN_KMSG(origin_sipi_request_t, ORIGIN_SIPI_REQUEST_FIELDS);
+
+#define ORIGIN_SIPI_RESPONSE_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS
+DEFINE_PCN_KMSG(origin_sipi_response_t, ORIGIN_SIPI_RESPONSE_FIELDS);
+
+#define IPI_REQUEST_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	struct kvm_lapic_irq irq;
+DEFINE_PCN_KMSG(ipi_request_t, IPI_REQUEST_FIELDS);
+//	int vcpu_id;
+//int vector;
+
+#define IPI_RESPONSE_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	struct kvm_lapic_irq irq;
+DEFINE_PCN_KMSG(ipi_response_t, IPI_RESPONSE_FIELDS);
+
+#define SIG_REQUEST_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	int target_tgid; \
+	int target_pid; \
+	int usr_sig; \
+	struct siginfo siginfo;
+DEFINE_PCN_KMSG(sig_request_t, SIG_REQUEST_FIELDS);
+
+#define SIG_RESPONSE_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	int target_pid;
+DEFINE_PCN_KMSG(sig_response_t, SIG_RESPONSE_FIELDS);
+
+#define ORIGIN_HYPE_COMMON_FIELDS \
+	pid_t from_pid; \
+	pid_t remote_pid; \
+	int ws; \
+	int fd; \
+	int ret;
+
+#define ORIGIN_BROADCAST_ACCEPT_IRQ_REQUEST_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	int delivery_mode; \
+	int vcpu_id; \
+	int vector; \
+	int level; \
+	int trig_mode; \
+	int dest_map;
+DEFINE_PCN_KMSG(origin_broadcast_accept_irq_request_t, ORIGIN_BROADCAST_ACCEPT_IRQ_REQUEST_FIELDS);
+
+#define ORIGIN_BROADCAST_ACCEPT_IRQ_RESPONSE_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS
+DEFINE_PCN_KMSG(origin_broadcast_accept_irq_response_t, ORIGIN_BROADCAST_ACCEPT_IRQ_RESPONSE_FIELDS);
+
+#define ORIGIN_BROADCAST_APIC_REG_WRITE_REQUEST_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	int vcpu_id; \
+	u32 reg; \
+	u32 val;
+DEFINE_PCN_KMSG(origin_broadcast_apic_reg_write_request_t, ORIGIN_BROADCAST_APIC_REG_WRITE_REQUEST_FIELDS);
+
+#define ORIGIN_BROADCAST_APIC_REG_WRITE_RESPONSE_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS
+DEFINE_PCN_KMSG(origin_broadcast_apic_reg_write_response_t, ORIGIN_BROADCAST_APIC_REG_WRITE_RESPONSE_FIELDS);
+
+
+#define ORIGIN_BROADCAST_CPU_TABLE_REQUEST_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	int vcpu_to_nid[MAX_POPCORN_VCPU];
+DEFINE_PCN_KMSG(origin_broadcast_cpu_table_request_t, ORIGIN_BROADCAST_CPU_TABLE_REQUEST_FIELDS);
+
+#define ORIGIN_BROADCAST_CPU_TABLE_RESPONSE_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS
+DEFINE_PCN_KMSG(origin_broadcast_cpu_table_response_t, ORIGIN_BROADCAST_CPU_TABLE_RESPONSE_FIELDS);
+
+#define UPDATE_CPU_TABLE_REQUEST_FIELDS \
+	int migrated_vcpu; \
+	int migrate_to_nid;
+DEFINE_PCN_KMSG(update_cpu_table_request_t, UPDATE_CPU_TABLE_REQUEST_FIELDS);
+
+
+/* remote asks remote_tgid = remote->origin origin->remote remote->origin origin->remote */
+// ORIGIN_HYPE_COMMON_FIELDS is a bad name // because not origin but remote
+#define REMOTE_ASK_ORIGIN_TGID_REQUEST_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	int src_tgid; \
+	int dst_nid; \
+	int origin_pid
+DEFINE_PCN_KMSG(remote_ask_origin_tgid_request_t, REMOTE_ASK_ORIGIN_TGID_REQUEST_FIELDS);
+
+#define REMOTE_ASK_ORIGIN_TGID_RESPONSE_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	int dst_tgid;
+DEFINE_PCN_KMSG(remote_ask_origin_tgid_response_t, REMOTE_ASK_ORIGIN_TGID_RESPONSE_FIELDS);
+//int dst_tgid;
+//int src_tgid;
+//int origin_pid
+#define ORIGIN_ASK_REMOTE_TGID_REQUEST_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	int src_nid; \
+	int src_tgid;
+DEFINE_PCN_KMSG(origin_ask_remote_tgid_request_t, ORIGIN_ASK_REMOTE_TGID_REQUEST_FIELDS);
+
+/***
+ * Pophype migration
+ */
+#define MAX_MSR_ENTRIES 25
+struct pophype_kvm_msrs {
+    __u32 nmsrs; /* number of msrs in entries */
+    __u32 pad;
+    struct kvm_msr_entry entries[MAX_MSR_ENTRIES];
+};
+#define UPDATE_VCPU_REQUEST_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	struct kvm_vcpu vcpu; \
+	struct kvm_regs regs; \
+	struct kvm_mp_state mp_state; \
+	struct kvm_sregs sregs; \
+	struct kvm_fpu fpu; \
+	struct kvm_xcrs xcrs; \
+	struct kvm_lapic_state lapic; \
+	struct kvm_xsave xsave; \
+	struct kvm_vcpu_events vcpu_events; \
+	struct pophype_kvm_msrs msrs; \
+	u64 pae_root[4]; \
+	u64 pdptrs[4]; /*pae*/ \
+	u64 guest_sysenter_rsp; \
+	u32 guest_sysenter_cs; \
+	u64 guest_sysenter_rip;
+DEFINE_PCN_KMSG(update_vcpu_request_t, UPDATE_VCPU_REQUEST_FIELDS);
+
+#define UPDATE_VCPU_RESPONSE_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS
+DEFINE_PCN_KMSG(update_vcpu_response_t, UPDATE_VCPU_RESPONSE_FIELDS);
+
+
+/***
+ * vhost-net eventfd
+ */
+#define DELEGATE_EVENTFD_REQUEST_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	int eventfd_fd; \
+	__u64 n;
+DEFINE_PCN_KMSG(delegate_eventfd_request_t, DELEGATE_EVENTFD_REQUEST_FIELDS);
+
+#define DELEGATE_EVENTFD_RESPONSE_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	int eventfd_fd; \
+	__u64 n;
+DEFINE_PCN_KMSG(delegate_eventfd_response_t, DELEGATE_EVENTFD_RESPONSE_FIELDS);
+
+/***
+ * vhost-net optimization
+ */
+//struct rx_copy_msg {
+struct pophype_skb {
+	//struct pcn_kmsg_hdr header;
+	//struct ft_pid creator;
+	//int filter_id;
+	//int is_child;
+    //__be16 dport;
+    //__be32 daddr;
+	//long long pckt_id;
+    //long long local_tx;
+
+    ktime_t tstamp;
+	char cb[48];
+    union {
+			__wsum          csum;
+			struct {
+				__u16   csum_start;
+				__u16   csum_offset;
+			};
+	}; // pophype - old
+	__u32 priority; // pophype - old
+	kmemcheck_bitfield_begin(flags1); // pophype - old
+	//__u8 		local_df:1, // pophype - new doesn't have
+	__u8		cloned:1,
+			ip_summed:2,
+			nohdr:1,
+			nfctinfo:3;
+	__u8		pkt_type:3,
+			fclone:2,
+			ipvs_property:1,
+			peeked:1,
+			nf_trace:1;
+	kmemcheck_bitfield_end(flags1);
+	__be16 protocol;
+	int skb_iif;
+#ifdef CONFIG_NET_SCHED
+        __u16 tc_index;       /* traffic control index */
+#ifdef CONFIG_NET_CLS_ACT
+        __u16 tc_verd;        /* traffic control verdict */
+#endif
+#endif
+    //__u32 rxhash;	// pophype - new doesn't have
+    kmemcheck_bitfield_begin(flags2);
+#ifdef CONFIG_IPV6_NDISC_NODETYPE
+	__u8 ndisc_nodetype:2;
+#endif
+	//__u8 ooo_okay:1; // pophype - new doesn't have
+	//__u8 l4_rxhash:1; // pophype - new doesn't have
+	kmemcheck_bitfield_end(flags2);
+#ifdef CONFIG_NETWORK_SECMARK
+        __u32 secmark;
+#endif
+    union {
+                __u32           mark;
+                __u32           dropcount;
+        };
+    __u16 vlan_tci;
+    int transport_header_off;
+        int network_header_off;
+        int mac_header_off;
+
+    int headerlen;
+        int datalen;
+        int taillen;
+    //NOTE: data must be the last field;
+    char data;
+};
+
+
+#define DELEGATE_SKB_TX_REQUEST_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	struct pophype_skb pskb;
+DEFINE_PCN_KMSG(delegate_skb_tx_request_t, DELEGATE_SKB_TX_REQUEST_FIELDS);
+
+#define DELEGATE_SKB_TX_RESPONSE_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS
+DEFINE_PCN_KMSG(delegate_skb_tx_response_t, DELEGATE_SKB_TX_RESPONSE_FIELDS);
+
+#include <linux/socket.h>
+#define DELEGATE_NET_MSG_TX_REQUEST_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS \
+	struct pophype_msghdr pmsghdr;
+DEFINE_PCN_KMSG(delegate_net_msg_tx_request_t, DELEGATE_NET_MSG_TX_REQUEST_FIELDS);
+
+#define DELEGATE_NET_MSG_TX_RESPONSE_FIELDS \
+	ORIGIN_HYPE_COMMON_FIELDS
+DEFINE_PCN_KMSG(delegate_net_msg_tx_response_t, DELEGATE_NET_MSG_TX_RESPONSE_FIELDS);
+
+
+
 
 /**
  * Message routing using work queues
diff --git a/kernel/popcorn/util.c b/kernel/popcorn/util.c
index 86df0b5b6660..ee28c17263e6 100644
--- a/kernel/popcorn/util.c
+++ b/kernel/popcorn/util.c
@@ -1,8 +1,22 @@
+/**
+ * @file util.c
+ *
+ *
+ * @author Ho-Ren (Jack) Chuang, SSRG Virginia Tech 2019
+ *
+ * Distributed under terms of the MIT license.
+ */
 #include <linux/mm.h>
 #include <linux/slab.h>
 
 #include <popcorn/bundle.h>
 
+/* vm dsm debug */
+volatile long false_share[PAGE_SIZE];
+volatile long true_share[PAGE_SIZE];
+volatile long no_share_first[PAGE_SIZE];
+volatile long no_share_second[PAGE_SIZE];
+
 void print_page_data(unsigned char *addr)
 {
 	int i;
@@ -107,3 +121,103 @@ void trace_task_status(void)
 		}
 	}
 }
+
+/********
+ *
+ */
+#include <linux/syscalls.h>
+#define OP_FALSE_SHARE_FIRST 0
+#define OP_FALSE_SHARE_SECOND 1
+#define OP_TRUE_SHARE 2
+#define OP_NO_SHARE_FIRST 3
+#define OP_NO_SHARE_SECOND 4
+
+long noinline level4_stack(int op)
+{
+	int i, j, k;
+	ktime_t dt, invh_end, invh_start = ktime_get();
+	for (i = 0; i < 100; i++) {
+		for (j = 0; j < 100000000; j++) {
+	//for (i = 0; i < 10000000; i++) {
+	//	for (j = 0; j < 1000; j++) {
+			for (k = 0; k < 1; k++) {
+				if (op == OP_FALSE_SHARE_FIRST) {
+					*(false_share + 0) += 1;
+				} else if (op == OP_FALSE_SHARE_SECOND) {
+					*(false_share + 10) += 1;
+				} else if (op == OP_TRUE_SHARE) {
+					*(true_share + 0) += 1;
+				} else if (op == OP_NO_SHARE_FIRST) {
+					*(no_share_first + 0) += 1;
+				} else if (op == OP_NO_SHARE_SECOND) {
+					*(no_share_second + 0) += 1;
+				} else {
+					BUG();
+				}
+			}
+		}
+		schedule();
+	}
+	invh_end = ktime_get();
+	dt = ktime_sub(invh_end, invh_start);
+	printk("Took %lld s\n", ktime_to_ns(dt) / 1000 / 1000 / 1000);
+	return 0;
+}
+
+long noinline level3_stack(int op) { return level4_stack(op); }
+long noinline level2_stack(int op) { return level3_stack(op); }
+long noinline level1_stack(int op) { return level2_stack(op); }
+
+SYSCALL_DEFINE1(popcorn_false_share, int __user, notused)
+{
+	printk("[%d] %s(): %d [START]\n", current->pid, __func__, notused);
+	if (notused == 1) {
+		return level1_stack(OP_FALSE_SHARE_FIRST);
+	} else if (notused == 2) {
+		return level1_stack(OP_FALSE_SHARE_SECOND);
+	} else {
+		printk("[%d] %s() not support\n", current->pid, __func__);
+	}
+	printk("[%d] %s(): %d [DONE]\n\n", current->pid, __func__, notused);
+	return 0;
+}
+
+/* notused: NULL since always the same */
+SYSCALL_DEFINE1(popcorn_true_share, int __user *, notused)
+{
+	printk("%s(): [START]\n", __func__);
+	level1_stack(OP_TRUE_SHARE);
+	printk("%s(): [DONE]\n\n", __func__);
+	return 0;
+}
+
+SYSCALL_DEFINE1(popcorn_no_share, int __user, notused)
+{
+	printk("%s(): %d [START]\n", __func__, notused);
+	if (notused == 1) {
+		return level1_stack(OP_NO_SHARE_FIRST);
+	} else if (notused == 2) {
+		return level1_stack(OP_NO_SHARE_SECOND);
+	} else {
+		printk("%s() not support\n", __func__);
+	}
+	printk("%s(): %d [DONE]\n\n", __func__, notused);
+	return 0;
+}
+
+int __init vm_dsm_debug_init(void)
+{
+	/* todo - move to global to see it in objdumped file */
+	//volatile long *false_share;
+	//volatile long *true_share;
+	//volatile long *no_share_first;
+	//volatile long *no_share_second;
+	//false_share = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	//true_share = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	//no_share_first = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	//no_share_second = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	POP_PK("false_share: %p true_share: %p "
+			"no_share_first: %p no_share_second: %p\n",
+			false_share, true_share, no_share_first, no_share_second);
+	return 0;
+}
diff --git a/kernel/popcorn/vma_server.c b/kernel/popcorn/vma_server.c
index 354fe98d59ea..57f00c3d096b 100644
--- a/kernel/popcorn/vma_server.c
+++ b/kernel/popcorn/vma_server.c
@@ -2,7 +2,7 @@
  * @file vma_server.c
  *
  * Popcorn Linux VMA handler implementation
- * This work was an extension of David Katz MS Thesis, but totally rewritten 
+ * This work was an extension of David Katz MS Thesis, but totally rewritten
  * by Sang-Hoon to support multithread environment.
  *
  * @author Sang-Hoon Kim, SSRG Virginia Tech 2016-2017
@@ -25,6 +25,8 @@
 
 #include <popcorn/types.h>
 #include <popcorn/bundle.h>
+#include <popcorn/hype_kvm.h>
+#include <popcorn/debug.h>
 
 #include "types.h"
 #include "util.h"
@@ -47,7 +49,7 @@ const char *vma_op_code_sz[] = {
 	"mmap", "munmap", "mprotect", "mremap", "madvise", "brk"
 };
 
-
+/* remap */
 static unsigned long map_difference(struct mm_struct *mm, struct file *file,
 		unsigned long start, unsigned long end,
 		unsigned long prot, unsigned long flags, unsigned long pgoff)
@@ -73,6 +75,9 @@ static unsigned long map_difference(struct mm_struct *mm, struct file *file,
 			 */
 			VSPRINTK("  [%d] map0 %lx -- %lx @ %lx, %lx\n", current->pid,
 					start, end, pgoff, prot);
+#ifndef CONFIG_POPCORN_HYPE
+			flags |= MAP_FIXED; /* pophype - WE MUST REPLAY THE SAME ADDR */
+#endif
 			error = do_mmap_pgoff(file, start, end - start,
 					prot, flags, pgoff, &populate);
 			if (error != start) {
@@ -124,7 +129,7 @@ static unsigned long map_difference(struct mm_struct *mm, struct file *file,
 			start = vma->vm_end;
 		}
 	}
-	BUG_ON(populate);
+	BUG_ON(populate); /* we dont handle it */
 	return ret;
 }
 
@@ -230,6 +235,8 @@ static int handle_vma_op_response(struct pcn_kmsg_message *msg)
 	return 0;
 }
 
+#include <linux/fdtable.h>
+extern unsigned long vm_mmap_pgoff(struct file *, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long);
 unsigned long vma_server_mmap_remote(struct file *file,
 		unsigned long addr, unsigned long len,
 		unsigned long prot, unsigned long flags, unsigned long pgoff)
@@ -243,21 +250,86 @@ unsigned long vma_server_mmap_remote(struct file *file,
 	req->prot = prot;
 	req->flags = flags;
 	req->pgoff = pgoff;
+	req->fd = -1;
 	get_file_path(file, req->path, sizeof(req->path));
 
 	VSPRINTK("\n## VMA mmap [%d] %lx - %lx, %lx %lx\n", current->pid,
 			addr, addr + len, prot, flags);
 	if (req->path[0] != '\0') {
+#ifdef CONFIG_POPCORN_HYPE
+		/* pophype handle files (mmaped vcpu region)*/
+		int i;
+		struct fdtable *fdt;
+		spin_lock(&current->files->file_lock);
+		fdt = files_fdtable(current->files);
+		spin_unlock(&current->files->file_lock);
+		/* *file to fd for vcpu requestes */
+		for (i = 3; i < fdt->max_fds; i++) { /* any MACRO to leverage? */
+			if (fdt->fd[i] == file) {
+				POP_PK("\t*file %p to fd %d\n\n", file, i);
+				req->fd = i;
+				break;
+			} //else { printk("\tnot found %p\n", i, file); }
+		}
+#endif
 		VSPRINTK("  [%d] %s\n", current->pid, req->path);
 	}
 
 	ret = __delegate_vma_op(req, &res);
 
+#ifdef CONFIG_POPCORN_HYPE
+    if (file) {
+		/* pophype handle files (mmaped vcpu region) */
+        //char path[512];
+        //get_file_path(file, path, sizeof(path)); /* file to path */
+		/* check path */
+        //if (!strncmp("anon_inode:kvm-vcpu:", path,
+        if (!strncmp("anon_inode:kvm-vcpu:", req->path,
+                sizeof("anon_inode:kvm-vcpu:") - 1 )) {
+			/* save to pophype table */
+			hype_node_info[my_nid][req->fd]->vcpu =
+						(struct kvm_vcpu *)file->private_data;
+			hype_node_info[my_nid][req->fd]->run =
+						((struct kvm_vcpu *)file->private_data)->run;
+			hype_node_info[my_nid][req->fd]->vcpu_id =
+						((struct kvm_vcpu *)file->private_data)->vcpu_id;
+			hype_node_info[my_nid][req->fd]->uaddr = res->addr; // done by delegation
+			//hype_node_info[my_nid][req->fd]->tsk = current; // ./drivers/vhost/vhost.c
+			POP_PK("--------------------------------------------\n");
+            POP_PK("%s(): ATTENTION this is a mmap(\"%s\") "
+					"req->addr %lx [deleg] res->addr 0x%lx len %lx "
+					"prot %lx flags %lx pgoff %lx\n", __func__,
+					req->path, req->addr, addr, len, prot, flags, pgoff);
+			POP_PK("[%d] rem (INSTALL VCPU) [%d][fd %d] vcpu_id %d vcpu %p "
+					"(kern)*vcpu->run [[[%p]]] "
+					"uaddr [[[0x%lx]]] *tsk [[%p]] (2nd usr cpu->kvm_run)\n",
+						current->pid, my_nid, req->fd,
+						hype_node_info[my_nid][req->fd]->vcpu_id,
+						hype_node_info[my_nid][req->fd]->vcpu,
+						hype_node_info[my_nid][req->fd]->run,
+						hype_node_info[my_nid][req->fd]->uaddr,
+						hype_node_info[my_nid][req->fd]->tsk);
+			POP_PK("--------------------------------------------\n\n");
+        }
+    }
+#endif
+
 	VSPRINTK("  [%d] %ld %lx -- %lx\n", current->pid,
 			ret, res->addr, res->addr + res->len);
 
-	if (ret) goto out_free;
+	if (ret) {
+		/* origin cannot handle, do it at remote */
+		unsigned long __addr;
+		__addr  = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);
+		VSPRINTK("  [%d] rollback 0x%lx\n", current->pid, __addr);
+		goto out_free;
+	}
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	if (INTERESTED_GVA(addr)) {
+		POP_PK("%s(): [%d] %lx $$$\n", __func__, current->pid, addr);
+	}
+#endif
 	while (!down_write_trylock(&current->mm->mmap_sem)) {
 		schedule();
 	}
@@ -265,10 +337,25 @@ unsigned long vma_server_mmap_remote(struct file *file,
 			prot, flags, pgoff);
 	up_write(&current->mm->mmap_sem);
 
+#if 0
+	/* TODO bebug  addr to vma vma->file */
+#endif
 out_free:
 	kfree(req);
 	pcn_kmsg_done(res);
 
+#ifdef CONFIG_POPCORN_HYPE
+#if HYPE_PERF_CRITICAL_DEBUG
+    if (file) { /* dbg */
+        char path[512];
+        get_file_path(file, path, sizeof(path));
+        if (!strncmp("anon_inode:kvm-vcpu:", path,
+                sizeof("anon_inode:kvm-vcpu:") - 1 )) {
+			VCPUPRINTK("map_difference(): [[[%lx]]] (usr cpu->kvm_run)\n\n\n\n", ret);
+		}
+	}
+#endif
+#endif
 	return ret;
 }
 
@@ -387,6 +474,7 @@ int vma_server_munmap_origin(unsigned long start, size_t len, int nid_except)
 
 	req->start = start;
 	req->len = len;
+	req->fd = -1;
 
 	for (nid = 0; nid < MAX_POPCORN_NODES; nid++) {
 		struct wait_station *ws;
@@ -400,8 +488,9 @@ int vma_server_munmap_origin(unsigned long start, size_t len, int nid_except)
 		req->remote_ws = ws->id;
 		req->origin_pid = rc->remote_tgids[nid];
 
-		VSPRINTK("  [%d] ->munmap [%d/%d] %lx+%lx\n", current->pid,
-				req->origin_pid, nid, start, len);
+		VSPRINTK("  [%d] ->munmap [%d/%d] %lx+%lx (%lx)\n", current->pid,
+				req->origin_pid, nid, start, len,
+				instruction_pointer(current_pt_regs()));
 		pcn_kmsg_send(PCN_KMSG_TYPE_VMA_OP_REQUEST, nid, req, sizeof(*req));
 		res = wait_at_station(ws);
 		pcn_kmsg_done(res);
@@ -413,6 +502,45 @@ int vma_server_munmap_origin(unsigned long start, size_t len, int nid_except)
 	return 0;
 }
 
+/* Not used */
+unsigned long pophype_vm_mmap_anon(unsigned long size, unsigned long prot, unsigned long flags)
+{
+	unsigned long hva = 0;
+	// 1. check nodes
+	//int __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)
+
+	struct remote_context *rc = get_task_remote(current);
+	/*======================= TODO =======================*/
+	BUG();
+	/*======================= TODO =======================*/
+	if (!rc) { // !migrated at all
+		BUG_ON(my_nid);
+		hva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,
+				  MAP_SHARED | MAP_ANONYMOUS, 0);
+	} else {
+		if (!my_nid) { // origin
+			int nid;
+			// 2. origin: ->
+				//check nodes
+			for (nid = 1; nid < MAX_POPCORN_NODES; nid++) {
+				if (!get_popcorn_node_online(nid) || !rc->remote_tgids[nid])
+					continue; /* !msg || !migrated to the node */
+
+				// TODO(): send hva -> rc->hva ()
+			}
+		} else { // remote
+			// 3. remote: wait origin to reach (3 objs in rc)
+
+
+			// TODO: spin on ec->hva
+			// TODO: mimic  vma_server_mmap_remot's map_difference()
+		}
+	}
+//done:
+	HPPRINTK("%s: kvm alloates user-cannot-see hva address 0x%lx\n",
+														__func__, hva);
+	return hva;
+}
 
 /**
  * VMA worker
@@ -464,15 +592,25 @@ static long __process_vma_op_at_remote(vma_op_request_t *req)
 	return ret;
 }
 
+#ifdef CONFIG_POPCORN_HYPE
+extern struct file_operations kvm_vm_fops;
+//extern struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op);
+extern int anon_inode_getfd(const char *name, const struct file_operations *fops, void *priv, int flags);
+extern struct filename *getname_kernel(const char * filename);
+#endif
+#include <linux/file.h>
 static long __process_vma_op_at_origin(vma_op_request_t *req)
 {
 	long ret = -EPERM;
 	int from_nid = PCN_KMSG_FROM_NID(req);
+#ifdef CONFIG_POPCORN_HYPE
+	int hype_filp = 0;
+#endif
 
 	switch (req->operation) {
 	case VMA_OP_MMAP: {
 		unsigned long populate = 0;
-		unsigned long raddr;
+		unsigned long raddr, req_addr;
 		struct file *f = NULL;
 		struct mm_struct *mm = get_task_mm(current);
 
@@ -480,23 +618,120 @@ static long __process_vma_op_at_origin(vma_op_request_t *req)
 			f = filp_open(req->path, O_RDONLY | O_LARGEFILE, 0);
 
 		if (IS_ERR(f)) {
+#ifdef CONFIG_POPCORN_HYPE
+			/* POPCORN cannot open vcpu (no sysfs) - if vcpu, retry */
+			char *path = req->path;
+			if (!strncmp("anon_inode:kvm-vcpu:", path,
+					sizeof("anon_inode:kvm-vcpu:") - 1 )) {
+				int i, fd = req->fd;
+				struct fd __fd = fdget(fd);
+				/* Let origin go first and remote overwrite vaddr */
+				/* vcpu fd -> kernel *vcpu (f->private_data) */
+				VCPUPRINTK(" [%d]: => remapping/overwriting \"%s\" use fd %d "
+							"to get struct &__fd %p __fd.file %p (matched???)\n\n",
+								from_nid, path, req->fd, (void *)&__fd, __fd.file);
+				BUG_ON(!__fd.file);
+				f = __fd.file;
+				BUG_ON(!f);
+				fdput(__fd);
+				hype_filp = 1; /* skip close since we never opened */
+
+				POP_PK("\n======================\n"
+						"\t\tPOPHYPE LOOKUP VCPU\n"
+						"=======================\n");
+				//for (i = 0; i < 8; i++) {
+				for (i = 0; i < MAX_POPCORN_NODES; i++) {
+					POP_PK("hype_node_info[%d][%d]->uaddr %lx\n",
+							i, req->fd, hype_node_info[i][req->fd]->uaddr);
+					POP_PK("hype_node_info[%d][%d]->uaddr %lx\n",
+							i, req->fd + 1, hype_node_info[i][req->fd + 1]->uaddr);
+					POP_PK("hype_node_info[%d][%d]->uaddr %lx\n",
+							i, req->fd + 2, hype_node_info[i][req->fd + 2]->uaddr);
+					if (hype_node_info[i][req->fd]->uaddr) {
+						req_addr = req->addr;
+						req->addr = raddr = hype_node_info[i][req->fd]->uaddr;
+						ret = IS_ERR_VALUE(req->addr) ? req->addr : 0;
+						VSPRINTK("  [%d] %lx req %lx ack [[[%lx]]] "
+									"-- %lx %lx %lx\n",
+									current->pid, ret, req_addr, raddr,
+									raddr + req->len, req->prot, req->flags);
+						POP_PK("\n");
+						goto pophype_got_addr;
+					} else {
+						POP_PK(KERN_ERR "\n\n"
+								"mynid %d=%d req->fd %d uaddr 0x%lx\n\n\n",
+										my_nid, i, req->fd,
+										hype_node_info[i][req->fd]->uaddr);
+						BUG();
+					}
+				}
+				POP_PK("\n");
+
+				goto pophype_resume;
+#if 0
+				/* 2. Cannot get the path from sysfs */
+				get_file_path(file, path, sizeof(path)); /* user space */
+				printk("%s(): \"%s\" selected got *file %p "
+								"at origin (O)\n", __func__, path, file);
+				/* 3. Treat vcpu op as a normal region at origin */
+				printk("  [%d] (using) treat as /dev/zero\n", current->pid);
+				f = NULL;
+#endif
+			}
+#endif
 			ret = PTR_ERR(f);
-			printk("  [%d] Cannot open %s %ld\n", current->pid, req->path, ret);
+			POP_PK("  [%d] Cannot open %s %ld\n", current->pid, req->path, ret);
 			mmput(mm);
 			break;
 		}
+pophype_resume:
 		down_write(&mm->mmap_sem);
 		raddr = do_mmap_pgoff(f, req->addr, req->len, req->prot,
 				req->flags, req->pgoff, &populate);
-		up_write(&mm->mmap_sem);
 		if (populate) mm_populate(raddr, populate);
 
 		ret = IS_ERR_VALUE(raddr) ? raddr : 0;
-		req->addr = raddr;
-		VSPRINTK("  [%d] %lx %lx -- %lx %lx %lx\n", current->pid,
-				ret, req->addr, req->addr + req->len, req->prot, req->flags);
+		up_write(&mm->mmap_sem);
+		req_addr = req->addr;
+		req->addr = raddr; /* will copy to res */
+		VSPRINTK("  [%d] %lx req %lx ack [[[%lx]]] -- %lx %lx %lx\n", current->pid,
+				ret, req_addr, raddr, raddr + req->len, req->prot, req->flags);
+#ifndef CONFIG_POPCORN_HYPE
+		if (f)
+			filp_close(f, NULL);
+#else
+		if (hype_filp && f) { /* more info - dbg - origin save debug info */
+			/* Not used - check "(INSTALL VCPU)" at ./virt/kvm/kvm_main.c */
+			hype_node_info[my_nid][req->fd]->vcpu =
+							(struct kvm_vcpu *)f->private_data;
+			hype_node_info[my_nid][req->fd]->run =
+							((struct kvm_vcpu *)f->private_data)->run;
+			hype_node_info[my_nid][req->fd]->vcpu_id =
+							((struct kvm_vcpu *)f->private_data)->vcpu_id;
+			hype_node_info[my_nid][req->fd]->uaddr = raddr;
+			//hype_node_info[my_nid][req->fd]->tsk = current; ./drivers/vhost/vhost.c
+			VCPUPRINTK("--------------------------------------------\n");
+            VCPUPRINTK("%s(): ATTENTION this is a mmap(\"%s\") "
+					"delegated at origin\n", __func__, req->path);
+			//VCPUPRINTK("[%d] ori (INSTALL VCPU) [%d] fd %d vcpu_id %d "
+			POP_PK("[%d] ori (INSTALL VCPU) [%d][fd %d] vcpu_id %d "
+					"(kern)*vcpu->run [[[%p]]] uaddr [[[0x%lx]]] "
+						"*tsk [[%p]] (2nd usr cpu->kvm_run)\n",
+						current->pid, my_nid, req->fd,
+						hype_node_info[my_nid][req->fd]->vcpu_id,
+						hype_node_info[my_nid][req->fd]->run,
+						hype_node_info[my_nid][req->fd]->uaddr,
+						hype_node_info[my_nid][req->fd]->tsk);
+			VCPUPRINTK("--------------------------------------------\n\n");
+#if 0
+			/* TODO bebug  addr to vma vma->file */
+#endif
+		} else if (f && !hype_filp) {
+			filp_close(f, NULL);
+		}
+#endif
 
-		if (f) filp_close(f, NULL);
+pophype_got_addr: /* Don't reinstall hype_node_info[][] */
 		mmput(mm);
 		break;
 	}
@@ -534,8 +769,9 @@ static long __process_vma_op_at_origin(vma_op_request_t *req)
 void process_vma_op_request(vma_op_request_t *req)
 {
 	long ret = 0;
-	VSPRINTK("\nVMA_OP_REQUEST [%d] %s %lx %lx\n", current->pid,
-			vma_op_code_sz[req->operation], req->addr, req->len);
+	VSPRINTK("\nVMA_OP_REQUEST [%d] %s %lx %lx %lx\n", current->pid,
+			vma_op_code_sz[req->operation], req->addr, req->len,
+			instruction_pointer(current_pt_regs()));
 
 	if (current->at_remote) {
 		ret = __process_vma_op_at_remote(req);
@@ -627,12 +863,24 @@ void process_vma_info_request(vma_info_request_t *req)
 	}
 	res->addr = addr;
 
+retry:
 	mm = get_task_mm(current);
 	down_read(&mm->mmap_sem);
 
 	vma = find_vma(mm, addr);
+
+#ifdef CONFIG_POPCORN_HYPE
+	/* pophype debug */
+	POP_PK("vma_info: %lx, %lx - %lx\n",
+			addr, vma->vm_start, vma->vm_end);
+#endif
 	if (unlikely(!vma)) {
-		printk("vma_info: vma does not exist at %lx\n", addr);
+		up_read(&mm->mmap_sem);
+		mmput(mm);
+		printk(KERN_WARNING "vma_info: vma not exist at %lx "
+							"(retrying)\n", addr);
+		msleep(1000);
+		goto retry;
 		res->result = -ENOENT;
 		goto out_up;
 	}
@@ -640,7 +888,13 @@ void process_vma_info_request(vma_info_request_t *req)
 		goto good;
 	}
 	if (unlikely(!(vma->vm_flags & VM_GROWSDOWN))) {
-		printk("vma_info: vma does not really exist at %lx\n", addr);
+		up_read(&mm->mmap_sem);
+		mmput(mm);
+		printk(KERN_WARNING "vma_info: vma not really exist "
+					"(GROWSDOWN) at %lx > vm_start %lx (retrying)\n",
+												addr, vma->vm_start);
+		msleep(1000);
+		goto retry;
 		res->result = -ENOENT;
 		goto out_up;
 	}
@@ -729,16 +983,39 @@ static int __update_vma(struct task_struct *tsk, vma_info_response_t *res)
 		goto out;
 	}
 
+	/* Pophype VMFAULT has solved by origin. Now unstall */
 	if (vma_info_anon(res)) {
 		flags |= MAP_ANONYMOUS;
 	} else {
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("%s: fetched from ORIGIN now replay on my node \"%s\" "
+				"res-> vm_addr 0x%lx - 0x%lx, vm_pgoff 0x%lx\n",
+				__func__, res->vm_file_path,
+				res->vm_start, res->vm_end, res->vm_pgoff);
+		/***********************************************/
+		/*** popcorn open file succ (e.g. lkvm file) ***/
+		/***********************************************/
+#endif
 		f = filp_open(res->vm_file_path, O_RDONLY | O_LARGEFILE, 0);
 		if (IS_ERR(f)) {
-			printk(KERN_ERR"%s: cannot find backing file %s\n",__func__,
-				res->vm_file_path);
+			printk(KERN_ERR"%s: cannot find backing file %s\n",
+					__func__, res->vm_file_path);
 			ret = -EIO;
+#ifdef CONFIG_POPCORN_HYPE
+            /****************************************/
+            /*** popcorn open file fail -
+				 pophype kick in (e.g. vcpu file) ***/
+            /****************************************/
+			dump_stack();
+			printk(KERN_ERR"%s: POPHYPE FALLTHROUGH %s (popcorn cannot open)\n",
+					__func__, res->vm_file_path);
+			goto pophype_fall_through;
+#endif
 			goto out;
 		}
+#ifdef CONFIG_POPCORN_HYPE
+pophype_fall_through:
+#endif
 		/*
 		unsigned long orig_pgoff = res->vm_pgoff;
 		res->vm_pgoff = __get_file_offset(f, res->vm_start);
@@ -757,6 +1034,7 @@ static int __update_vma(struct task_struct *tsk, vma_info_response_t *res)
 			| ((res->vm_flags & VM_SHARED) ? MAP_SHARED : MAP_PRIVATE)
 			| ((res->vm_flags & VM_GROWSDOWN) ? MAP_GROWSDOWN : 0);
 
+	/* remap */
 	err = map_difference(mm, f, res->vm_start, res->vm_end,
 				prot, flags, res->vm_pgoff);
 
@@ -818,6 +1096,12 @@ int vma_server_fetch_vma(struct task_struct *tsk, unsigned long address)
 
 		VSPRINTK("  [%d] %lx ->[%d/%d]\n", current->pid,
 				addr, tsk->origin_pid, tsk->origin_nid);
+#ifdef CONFIG_POPCORN_HYPE
+		/* pophype (dex) limitation -
+		 * if address < 0x7ffff0000000 && address > heap,
+		 * mir cannot malloc at remote - found caused by mpx.
+		 * Current solution: disable intel mpx */
+#endif
 		pcn_kmsg_send(PCN_KMSG_TYPE_VMA_INFO_REQUEST,
 				tsk->origin_nid, req, sizeof(*req));
 		wait_for_completion(&vi->complete);
@@ -858,8 +1142,10 @@ int vma_server_fetch_vma(struct task_struct *tsk, unsigned long address)
 DEFINE_KMSG_RW_HANDLER(vma_info_request, vma_info_request_t, origin_pid);
 DEFINE_KMSG_RW_HANDLER(vma_op_request, vma_op_request_t, origin_pid);
 
+extern int first[]; // from arch/x86/kvm/x86.c
 int vma_server_init(void)
 {
+	int i, j;
 	REGISTER_KMSG_HANDLER(
 			PCN_KMSG_TYPE_VMA_INFO_REQUEST, vma_info_request);
 	REGISTER_KMSG_HANDLER(
@@ -868,5 +1154,21 @@ int vma_server_init(void)
 	REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_VMA_OP_REQUEST, vma_op_request);
 	REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_VMA_OP_RESPONSE, vma_op_response);
 
+#ifdef CONFIG_POPCORN_HYPE
+//	hype_node_info = kmalloc(sizeof(struct hype_node_info_t) *
+//							MAX_POPCORN_NODES * MAX_POPCORN_FD, GFP_KERNEL);
+	SIGVPRINTK("%s(): init vma_server_init[][]\n", __func__);
+	for (i = 0; i < MAX_POPCORN_NODES; i++)
+		for (j = 0; j < MAX_POPCORN_VCPU; j++) {
+			hype_node_info[i][j] =
+					kmalloc(sizeof(struct hype_node_info_t), GFP_KERNEL);
+			BUG_ON(!hype_node_info[i][j]);
+			memset(hype_node_info[i][j], 0, sizeof(struct hype_node_info_t));
+		}
+
+	for (i = 0; i < MAX_POPCORN_NODES; i++) {
+		first[i] = 1;
+	}
+#endif
 	return 0;
 }
diff --git a/kernel/popcorn/wait_station.c b/kernel/popcorn/wait_station.c
index 1c170de4a38e..05e6c907b1b0 100644
--- a/kernel/popcorn/wait_station.c
+++ b/kernel/popcorn/wait_station.c
@@ -60,14 +60,27 @@ void *wait_at_station(struct wait_station *ws)
 {
 	void *ret;
 	if (!try_wait_for_completion(&ws->pendings)) {
+#ifdef CONFIG_POPCORN_HYPE
+		/* hype latency is higher */
+		while (wait_for_completion_io_timeout(&ws->pendings, 300 * HZ) == 0) {
+			schedule();
+		}
+#else
 		if (wait_for_completion_io_timeout(&ws->pendings, 300 * HZ) == 0) {
+			/* time out */
+			WARN_ON(-1);
 			ret = ERR_PTR(-ETIMEDOUT);
 			goto out;
 		}
+#endif
 	}
 	smp_rmb();
 	ret = (void *)ws->private;
+
+#ifndef CONFIG_POPCORN_HYPE
 out:
+#endif
+
 	put_wait_station(ws);
 	return ret;
 }
diff --git a/kernel/sched/clock.c b/kernel/sched/clock.c
index caf4041f5b0a..a5d2501bd5a8 100644
--- a/kernel/sched/clock.c
+++ b/kernel/sched/clock.c
@@ -128,7 +128,8 @@ struct sched_clock_data {
 	u64			tick_raw;
 	u64			tick_gtod;
 	u64			clock;
-};
+//};
+} __attribute__((aligned(PAGE_SIZE))); /* pophype */
 
 static DEFINE_PER_CPU_SHARED_ALIGNED(struct sched_clock_data, sched_clock_data);
 
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index ce57243192c1..5276077162b1 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -90,6 +90,10 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/sched.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/hype_kvm.h>
+#endif
+
 DEFINE_MUTEX(sched_domains_mutex);
 DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues);
 
@@ -1758,6 +1762,9 @@ ttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags)
 		rq->nr_uninterruptible--;
 #endif
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* insert to the queue and wake up */
+#endif
 	ttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING);
 	ttwu_do_wakeup(rq, p, wake_flags);
 }
@@ -4713,23 +4720,44 @@ SYSCALL_DEFINE2(popcorn_migrate, int, nid, void __user *, uregs)
 	if (nid == -1) {
 		nid = current->migration_target_nid;
 	}
-	if (nid < 0 || nid >= MAX_POPCORN_NODES) {
-		PSPRINTK("  [%d] invalid migration destination %d\n",
-				current->pid, nid);
+	if (nid < 0 || ((nid >= MAX_POPCORN_NODES)
+#ifdef CONFIG_POPCORN_HYPE
+			&& (nid >= 3 * MAX_POPCORN_VCPU))
+			// && (nid != POPHYPE_MIGRATE_BACK) // -78
+#else
+	)
+#endif
+	) {
+		printk("\n[WARNING] [%d] popcorn: invalid migration destination %d "
+				"> (%d * 3)\n\n",
+				current->pid, nid, MAX_POPCORN_VCPU);
+		//BUG();
 		return -EINVAL;
 	}
 	if (nid == my_nid) {
-		PSPRINTK("  [%d] already running at the destination %d\n",
+		PSPRINTK("  [%d] popcorn: already running at the destination %d\n",
 				current->pid, nid);
 		return -EBUSY;
 	}
 
 	if (!get_popcorn_node_online(nid)) {
-		PSPRINTK("  [%d] destination node %d is offline\n",
+#ifdef CONFIG_POPCORN_HYPE
+		/* my lkvm is relying on !get_popcorn_node_online(nid) */
+		if (nid >= 1 * MAX_POPCORN_VCPU &&
+				nid < 3 * MAX_POPCORN_VCPU) {
+			// popcorn migrate back(+1*MAX)/to(+2*MAX)
+			// && (nid != POPHYPE_MIGRATE_BACK) // -78 // (old)
+			PHMIGRATEPRINTK("pophype migration nid %d\n", nid);
+			goto pophype_migrate;
+		}
+#endif
+		PSPRINTK("  [%d] popcorn: destination node %d is offline\n",
 				current->pid, nid);
 		return -EAGAIN;
 	}
 
+pophype_migrate:
+
 	ret = process_server_do_migration(current, nid, uregs);
 	if (ret) return ret;
 
@@ -7308,6 +7336,9 @@ void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)
 static int init_sched_domains(const struct cpumask *cpu_map)
 {
 	int err;
+#ifdef CONFIG_POPCORN_HYPE
+	SMPBSPPRINTK("<BSP> %s():\n", __func__);
+#endif
 
 	arch_update_cpu_topology();
 	ndoms_cur = 1;
@@ -7522,6 +7553,9 @@ void __init sched_init_smp(void)
 {
 	cpumask_var_t non_isolated_cpus;
 
+#ifdef CONFIG_POPCORN_HYPE
+	SMPBSPPRINTK("<BSP> %s():\n", __func__);
+#endif
 	alloc_cpumask_var(&non_isolated_cpus, GFP_KERNEL);
 	alloc_cpumask_var(&fallback_doms, GFP_KERNEL);
 
@@ -7584,6 +7618,12 @@ void __init sched_init(void)
 	int i, j;
 	unsigned long alloc_size = 0, ptr;
 
+#ifdef CONFIG_POPCORN_HYPE
+//#if !POPHYPE_HOST_KERNEL
+	POP_PK("bsp<*>: __init %s()\n", __func__);
+//#endif
+#endif
+
 #ifdef CONFIG_FAIR_GROUP_SCHED
 	alloc_size += 2 * nr_cpu_ids * sizeof(void **);
 #endif
diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index 3b136fb4422c..4d3c97dc2166 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -7483,6 +7483,7 @@ static struct {
 	atomic_t nr_cpus;
 	unsigned long next_balance;     /* in jiffy units */
 } nohz ____cacheline_aligned;
+/* pophype - dsm traffic */
 
 static inline int find_new_ilb(void)
 {
diff --git a/kernel/sched/idle.c b/kernel/sched/idle.c
index 4a2ef5a02fd3..aecb42d0e486 100644
--- a/kernel/sched/idle.c
+++ b/kernel/sched/idle.c
@@ -15,6 +15,14 @@
 
 #include "sched.h"
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/bundle.h>
+#include <popcorn/debug.h>
+
+extern bool **hype_callin;
+extern bool **hype_callin_dynamic_alloc;
+#endif
+
 /**
  * sched_idle_set_state - Record idle state for the current CPU.
  * @idle_state: State to record.
@@ -280,6 +288,9 @@ static void cpu_idle_loop(void)
 
 void cpu_startup_entry(enum cpuhp_state state)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	int cpu = smp_processor_id();
+#endif
 	/*
 	 * This #ifdef needs to die, but it's too late in the cycle to
 	 * make this generic (arm and sh have never invoked the canary
@@ -296,5 +307,23 @@ void cpu_startup_entry(enum cpuhp_state state)
 	boot_init_stack_canary();
 #endif
 	arch_cpu_idle_prepare();
+
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK(KERN_INFO "\t\t#smpboot [%d/%d] %s(): AP %d%s END go idle!!!\n",
+						my_nid, current->pid, __func__, cpu,
+						!cpu ? " (NOT INTERESTED)" : "");
+
+	if (!cpu) {
+		POP_PK("HYPE_DEBUG_POINT NOT INIT YET FOR  <%d>\n", cpu);
+	} else { // TODO BUG BUG BUG SOMEHOW 10 IS BUGGY if no !cpu
+		if (&hype_callin_dynamic_alloc[HYPE_DEBUG_POINT10][cpu]) /* CRASH!!!!!!! if no if(cpu) */
+			hype_callin_dynamic_alloc[HYPE_DEBUG_POINT10][cpu] = true;
+		else {
+			POP_PK("\n\n\n");
+			POP_PK("HYPE_DEBUG_POINT10 DIE DIE DIE <%d>\n", cpu);
+			POP_PK("\n\n\n");
+		}
+	}
+#endif
 	cpu_idle_loop();
 }
diff --git a/kernel/sched/wait.c b/kernel/sched/wait.c
index f15d6b6a538a..5914f6c3c11b 100644
--- a/kernel/sched/wait.c
+++ b/kernel/sched/wait.c
@@ -11,6 +11,11 @@
 #include <linux/hash.h>
 #include <linux/kthread.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+//#include <popcorn/bundle.h>
+#include <popcorn/debug.h>
+#endif
+
 void __init_waitqueue_head(wait_queue_head_t *q, const char *name, struct lock_class_key *key)
 {
 	spin_lock_init(&q->lock);
@@ -175,10 +180,26 @@ prepare_to_wait(wait_queue_head_t *q, wait_queue_t *wait, int state)
 
 	wait->flags &= ~WQ_FLAG_EXCLUSIVE;
 	spin_lock_irqsave(&q->lock, flags);
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	GSMPBSPPRINTK("\t\t<%d> %s(): - 1 list_empty (%s)\n",
+		smp_processor_id(), __func__, list_empty(&wait->task_list) ? "O":"X");
+#endif
+#endif
 	if (list_empty(&wait->task_list))
 		__add_wait_queue(q, wait);
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	GSMPBSPPRINTK("\t\t<%d> %s(): - 2\n", smp_processor_id(), __func__);
+#endif
+#endif
 	set_current_state(state);
 	spin_unlock_irqrestore(&q->lock, flags);
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	GSMPBSPPRINTK("\t\t<%d> %s(): - 3\n", smp_processor_id(), __func__);
+#endif
+#endif
 }
 EXPORT_SYMBOL(prepare_to_wait);
 
@@ -390,10 +411,63 @@ __wait_on_bit(wait_queue_head_t *wq, struct wait_bit_queue *q,
 	int ret = 0;
 
 	do {
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+		static int cnt = 0;
+		cnt++;
+		if (cnt > 0)
+			GSMPBSPPRINTK("\t<%d> %s(): - 1 #%d\n",
+					smp_processor_id(), __func__, cnt);
+#endif
+#endif
 		prepare_to_wait(wq, &q->wait, mode);
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+		GSMPBSPPRINTK("\t<%d> %s(): - 2 nr %d addr %p #%d\n",
+			smp_processor_id(), __func__, q->key.bit_nr, q->key.flags, cnt);
+#endif
+#endif
+
+//#ifdef CONFIG_POPCORN_HYPE
+//#if !POPHYPE_HOST_KERNEL
+//		u32 *p = q->key.flags;
+//		if (((1UL << (q->key.bit_nr & 31)) & (p[q->key.bit_nr >> 5])) != 0)
+//			ret = (*action)(&q->key, mode);
+//#else
+//		if (test_bit(q->key.bit_nr, q->key.flags))
+//			ret = (*action)(&q->key, mode);
+//#endif
+//#else
 		if (test_bit(q->key.bit_nr, q->key.flags))
 			ret = (*action)(&q->key, mode);
+//#endif
+
+////#ifdef CONFIG_POPCORN_HYPE
+////#if !POPHYPE_HOST_KERNEL
+////		u32 *p = q->key.flags;
+////		if (((1UL << (q->key.bit_nr & 31)) & (p[q->key.bit_nr >> 5])) != 0)
+////			ret = (*action)(&q->key, mode);
+////#else
+////		if (test_bit(q->key.bit_nr, q->key.flags))
+////			ret = (*action)(&q->key, mode);
+////#endif
+////#else
+//		if (test_bit(q->key.bit_nr, q->key.flags))
+//			ret = (*action)(&q->key, mode);
+////#endif
+
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+		GSMPBSPPRINTK("\t<%d> %s(): - 3 #%d\n",
+				smp_processor_id(), __func__, cnt);
+#endif
+#endif
 	} while (test_bit(q->key.bit_nr, q->key.flags) && !ret);
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	GSMPBSPPRINTK("\t<%d> %s(): finish\n", smp_processor_id(), __func__);
+#endif
+#endif
 	finish_wait(wq, &q->wait);
 	return ret;
 }
diff --git a/kernel/signal.c b/kernel/signal.c
index 8bfbc47f0a23..1f2cbc947756 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -45,6 +45,12 @@
 #include <asm/cacheflush.h>
 #include "audit.h"	/* audit_signal_info() */
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/types.h>
+#include <popcorn/bundle.h>
+#include <popcorn/hype_kvm.h>
+#endif
+
 /*
  * SLAB caches for signal bits.
  */
@@ -2328,7 +2334,7 @@ relock:
 }
 
 /**
- * signal_delivered - 
+ * signal_delivered -
  * @ksig:		kernel signal struct
  * @stepping:		nonzero if debugger single-step or block-step in use
  *
@@ -2878,16 +2884,129 @@ SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)
 	return kill_something_info(sig, &info, pid);
 }
 
+#if defined(CONFIG_POPCORN_HYPE)
+/* kern_sig: kernel's sig # not userspace's sig #
+	usr_sig: userspace's sig # not kernel's sig # */
+volatile bool is_pophype_signal(int usr_sig)
+{
+	/* kernel: arch/x86/include/uapi/asm/signal.h */
+	/* pophype userspace definition in include/kvm/kvm.h
+		where SIGRTMIN=34, SIGKVMPAUSE=35, SIGKVMCPUMIGRATE_BACK_W_STATE=37...
+		#define SIGKVMEXIT		(SIGRTMIN + 0)
+		#define SIGKVMPAUSE		(SIGRTMIN + 1)
+		#define SIGKVMTASK		(SIGRTMIN + 2)
+		#define SIGKVMCPUMIGRATE_BACK_W_STATE		(SIGRTMIN + 3)
+		#define SIGKVMPAUSEVANILLA		(SIGRTMIN + 4)
+		...
+
+		However kernel's SIGRTMIN is 32 defined in
+		arch/x86/include/uapi/asm/signal.h (O)
+		include/uapi/asm-generic/signal.h (X).
+		SIGRTMIN=32, SIGKVMPAUSE=33, SIGKVMCPUMIGRATE_BACK_W_STATE=35....
+	*/
+	//if (sig == 33 || sig == 35 || sig == 37)
+#define POPHYPE_HACK 2
+	usr_sig -= POPHYPE_HACK;
+//if (sig - POPHYPE_HACK == SIGKVMPAUSE) {
+	if (usr_sig == SIGKVMPAUSE ||
+		usr_sig == SIGKVMCPUMIGRATE ||
+		usr_sig == SIGKVMCPUMIGRATE_BACK ||
+		usr_sig == SIGKVMCPUMIGRATE_W_STATE ||
+		usr_sig == SIGKVMFTCKPT ||
+		usr_sig == SIGKVMCPUMIGRATE_BACK_W_STATE ||
+		usr_sig == SIGKVMFTRESTART) {
+		return true;
+	}
+	return false;
+}
+#endif
+
 static int
 do_send_specific(pid_t tgid, pid_t pid, int sig, struct siginfo *info)
 {
 	struct task_struct *p;
 	int error = -ESRCH;
 
+#if defined(CONFIG_POPCORN_HYPE)
+	int old_pid = -1;
+	if (distributed_process(current) && sig >= SIGKVMEXIT) {
+		SIGVPRINTK("native %s(): [%d] sig %d \"%s\" %d\n",
+						__func__, current->pid, sig,
+						is_pophype_signal(sig) ? "TRUE" : "FALSE",
+						distributed_remote_process(current));
+	}
+	if (is_pophype_signal(sig)) {
+		if (distributed_remote_process(current)) {
+			/* Pophype: only remote need to convert it */
+			bool succ = false;
+			int j, origin = 0;
+			SIGVPRINTK("pophype: %s(): [%d] sig %d "
+						"converting target pid %d start\n",
+						__func__, current->pid, sig, pid);
+			for (j = VCPU_FD_BASE; j < MAX_POPCORN_VCPU; j++) {
+				SIGVPRINTK("\t\t%d: hype_node_info[origin][%d]: "
+							"origin_pid %d ->remote_pid %d\n",
+							j, j, hype_node_info[origin][j]->origin_pid,
+							hype_node_info[origin][j]->remote_pid);
+				if (hype_node_info[origin][j]->origin_pid == pid) {
+				// hype_node_info[from_nid][VCPU_FD_BASE + from_nid]->origin_pid; // this only saved in origin.....
+					old_pid = pid;
+					SIGVPRINTK("pophype: [convert] %s(): pid %d -> %d\n",
+						__func__, pid, hype_node_info[my_nid][j]->remote_pid);
+					pid = hype_node_info[my_nid][j]->remote_pid;
+					SIGVPRINTK("[convert] new pid = "
+						"hype_node_info[my_nid %d][%d]->remote_pid %d\n",
+						my_nid, j, hype_node_info[my_nid][j]->remote_pid);
+					succ = true;
+					break;
+				}
+			}
+			SIGVPRINTK("pophype: %s(): [%d] converting "
+						"[old pid %d ] to [[[new pid %d]]] done\n",
+								__func__, current->pid, old_pid, pid);
+			BUG_ON(!succ);
+		}
+	}
+#endif
 	rcu_read_lock();
 	p = find_task_by_vpid(pid);
+#if defined(CONFIG_POPCORN_HYPE)
+	if (is_pophype_signal(sig)) {
+		if (distributed_remote_process(current)) { /* Same */
+			SIGVPRINTK("native? %s(): [%d] "
+						"converting tgid for pid %d p %p\n",
+						__func__, current->pid, pid, p);
+			/* Pophype doesn't update the table after
+						(pophyp/popcorn) migration.
+				Check the first KVM_RUN at remote vCPU.
+				Check hype_node_info[][] */
+			BUG_ON(!p);
+			/* We don't record tgid */
+			tgid = task_tgid_vnr(p);
+		}
+	}
+
+	if (is_pophype_signal(sig)) { // native
+		if (p) {
+			SIGVPRINTK("[native] %s(): p->pid %d\n", __func__, p->pid);
+		} else {
+			SIGVPRINTK("[native] %s(): p %p (NULL)\n", __func__, p);
+		}
+		SIGVPRINTK("[native] %s(): [%d] sig %d si_pid %d si_uid %d\n",
+			__func__, current->pid, sig, info->si_pid, info->si_uid);
+		SIGVPRINTK("[native] %s(): p %p && (pid %d <= 0 && "
+				" task_tgid_vnr(p) %d == tgid %d) for sig %d\n",
+					__func__, p, pid, task_tgid_vnr(p), tgid, sig);
+	}
+#endif
 	if (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {
 		error = check_kill_permission(sig, info, p);
+#if defined(CONFIG_POPCORN_HYPE) && POPCORN_DEBUG_FT
+		if (is_pophype_signal(sig)) {
+			SIGVPRINTK("[native] %s(): pid %d permission "
+					"ret error %d\n\n", __func__, pid, error);
+		}
+#endif
 		/*
 		 * The null signal is a permissions and process existence
 		 * probe.  No signal is actually delivered.
@@ -2908,10 +3027,147 @@ do_send_specific(pid_t tgid, pid_t pid, int sig, struct siginfo *info)
 	return error;
 }
 
+#ifdef CONFIG_POPCORN_HYPE
+// called by pophype_kvm.c
+int pophype_do_send_specific_at_remote(pid_t tgid, pid_t pid, int sig, struct siginfo *info)
+{
+	struct task_struct *p;
+	int error = -ESRCH;
+
+	rcu_read_lock();
+	p = find_task_by_vpid(pid);
+	if (p) {
+		SIGVPRINTK("%s(): p->pid %d\n", __func__, p->pid);
+	}
+	SIGVPRINTK("%s(): [%d] p %p && (pid %d <= 0 || "
+			" task_tgid_vnr(p) %d == tgid %d) for sig %d\n",
+				__func__, current->pid, p, pid, task_tgid_vnr(p), tgid, sig);
+	/* hack */ tgid = -1;
+	/* hack force it */ tgid = task_tgid_vnr(p);
+	SIGVPRINTK("%s(): force tgid = %d\n", __func__, tgid);
+	if (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {
+		error = check_kill_permission(sig, info, p);
+		SIGVPRINTK("%s(): pid %d permission ret error %d (expect 0)\n",
+						__func__, pid, error);
+		/*
+		 * The null signal is a permissions and process existence
+		 * probe.  No signal is actually delivered.
+		 */
+		if (!error && sig) {
+			error = do_send_sig_info(sig, info, p, false);
+			/*
+			 * If lock_task_sighand() failed we pretend the task
+			 * dies after receiving the signal. The window is tiny,
+			 * and the signal is private anyway.
+			 */
+			if (unlikely(error == -ESRCH))
+				error = 0;
+		}
+	}
+	rcu_read_unlock();
+
+	return error;
+}
+
+
+/* Userspace lkvm defined signals -
+	moved to arch/x86/include/uapi/asm/signal.h */
+//#define SIGKVMEXIT      (SIGRTMIN + 0)
+//#define SIGKVMPAUSE     (SIGRTMIN + 1)
+//#define SIGKVMTASK      (SIGRTMIN + 2)
+//#define SIGKVMCPUMIGRATE     (SIGRTMIN + 3)
+
+enum {
+	KVM_VMSTATE_RUNNING,
+	KVM_VMSTATE_PAUSED,
+};
+
+//enum {
+//    KVM_IPC_BALLOON = 1,
+//    KVM_IPC_DEBUG   = 2,
+//    KVM_IPC_STAT    = 3,
+//    KVM_IPC_PAUSE   = 4,
+//    KVM_IPC_RESUME  = 5,
+//    KVM_IPC_STOP    = 6,
+//    KVM_IPC_PID = 7,
+//    KVM_IPC_VMSTATE = 8,
+//    KVM_IPC_FT_CKPT = 9,    //popcorn
+//    KVM_IPC_FT_RESTART  = 10, //popcorn
+//};
+#endif
 static int do_tkill(pid_t tgid, pid_t pid, int sig)
 {
 	struct siginfo info = {};
 
+#if 0
+#if defined(CONFIG_POPCORN_HYPE)
+	//if (distributed_process(current)) {
+	/* pophype: ckpt signal is not redirectred in kernel but in userspace!!! */
+	if (0) {
+		//if (!my_nid) {
+			static int cnt = 0;
+			cnt++;
+			printk("[%d/%d] %s(): %d %d %d #%d "
+				"(SIGKVMPAUSE %d SIGKVMCPUMIGRATE %d "
+				"dbg: SIGRTMIN %d)\n",
+				my_nid, current->pid, __func__,
+				tgid, pid, sig, cnt,
+				SIGKVMPAUSE, SIGKVMCPUMIGRATE, SIGRTMIN);
+
+// may need to convert 33387 to remote thread pid
+// user passes 33 but kernel thinks it's 35
+//[  966.566143] [0] do_tkill(): 33322 33386 35 #1
+//[  966.570649] [0] do_tkill(): 33322 33387 35 #2
+// Conclusion: SIGRTMIN usr 32 ker 34
+#define POPHYPE_HACK 2
+			if (sig - POPHYPE_HACK == SIGKVMPAUSE) {
+				int i, j;
+				bool found_atremote = false;;
+				printk("[%d/%d] %s(): POPHYPE TODO 12/16 - "
+					"(target host to targer remote) "
+					"'SIGKVMPAUSE %d' (dbg: SIGRTMIN %d) "
+					"redirect to remotes\n",
+					 my_nid, current->pid,
+					__func__, SIGKVMPAUSE, SIGRTMIN);
+				//// 0 usr space ipc_thread at remote to receive sig
+				//(try&err)// 0-1 check if sig is for threads or process
+					// thread migration's remote pid keeps chainging
+				// 1 find right tif
+				// 2
+				printk("origin - si_uid %d pid %d\n",
+					from_kuid_munged(current_user_ns(),
+										current_uid()), pid);
+				BUG_ON(!pid);
+				for (i = 0; i < MAX_POPCORN_NODES; i++) {
+					for (j = 0; j < MAX_POPCORN_VCPU; j++) {
+						if (hype_node_info[i][j]->origin_pid == pid) {
+							found_atremote = true;
+							break;
+						}
+					}
+				}
+
+				//if (!found_atremote) // == islocal_sig
+				//	goto resume;
+
+				/************ debugging ****************/
+				static int cnt = 0;
+				cnt++;
+				printk("%s(): HACK NOW - TODO "
+						"implement checkin_at_origin #%d\n", __func__, cnt);
+				if ((cnt % 2))
+					goto resume;
+
+				printk("%s(): [[[[[pophype - redirect it]]]]] =>\n",
+											__func__);
+				return popcorn_broadcast_sig(sig); /* usr_sig */
+				/* Directly set up the follwing in the func() */
+			}
+		//}
+	}
+resume:
+#endif
+#endif
 	info.si_signo = sig;
 	info.si_errno = 0;
 	info.si_code = SI_TKILL;
@@ -3252,7 +3508,7 @@ int __compat_save_altstack(compat_stack_t __user *uss, unsigned long sp)
  */
 SYSCALL_DEFINE1(sigpending, old_sigset_t __user *, set)
 {
-	return sys_rt_sigpending((sigset_t __user *)set, sizeof(old_sigset_t)); 
+	return sys_rt_sigpending((sigset_t __user *)set, sizeof(old_sigset_t));
 }
 
 #endif
@@ -3377,7 +3633,7 @@ COMPAT_SYSCALL_DEFINE4(rt_sigaction, int, sig,
 	ret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);
 	if (!ret && oact) {
 		sigset_to_compat(&mask, &old_ka.sa.sa_mask);
-		ret = put_user(ptr_to_compat(old_ka.sa.sa_handler), 
+		ret = put_user(ptr_to_compat(old_ka.sa.sa_handler),
 			       &oact->sa_handler);
 		ret |= copy_to_user(&oact->sa_mask, &mask, sizeof(mask));
 		ret |= put_user(old_ka.sa.sa_flags, &oact->sa_flags);
@@ -3500,7 +3756,11 @@ SYSCALL_DEFINE2(signal, int, sig, __sighandler_t, handler)
 {
 	struct k_sigaction new_sa, old_sa;
 	int ret;
-
+#ifdef CONFIG_POPCORN_HYPE
+	SIGVPRINTK("pophype: %s(): "
+				"[%d] registers signal handler for sig %d %p\n",
+				__func__, current->pid, sig, handler);
+#endif
 	new_sa.sa.sa_handler = handler;
 	new_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK;
 	sigemptyset(&new_sa.sa.sa_mask);
@@ -3553,7 +3813,7 @@ SYSCALL_DEFINE2(rt_sigsuspend, sigset_t __user *, unewset, size_t, sigsetsize)
 		return -EFAULT;
 	return sigsuspend(&newset);
 }
- 
+
 #ifdef CONFIG_COMPAT
 COMPAT_SYSCALL_DEFINE2(rt_sigsuspend, compat_sigset_t __user *, unewset, compat_size_t, sigsetsize)
 {
diff --git a/kernel/smp.c b/kernel/smp.c
index d903c02223af..21a2ba5287db 100644
--- a/kernel/smp.c
+++ b/kernel/smp.c
@@ -17,6 +17,16 @@
 
 #include "smpboot.h"
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#include <popcorn/bundle.h>
+#include <popcorn/hype_kvm.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+extern pgd_t early_level4_pgt[PTRS_PER_PGD];
+#define POPHYPE_SSLEEP 1 /* x2 */
+#endif
+
 enum {
 	CSD_FLAG_LOCK		= 0x01,
 	CSD_FLAG_SYNCHRONOUS	= 0x02,
@@ -90,9 +100,34 @@ void __init call_function_init(void)
 {
 	void *cpu = (void *)(long)smp_processor_id();
 	int i;
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	POP_PK("bsp<*>: __init %s() <%d> "
+			"list_init(&per_cpu(call_single_queue, all_cpu)\n",
+							__func__, cpu ? *(int *)cpu : -99);
+#endif
+
+//	for_each_possible_cpu(i)
+//		init_llist_head(&per_cpu(call_single_queue, i));
 
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	for_each_possible_cpu(i) {
+		struct llist_head *head = &per_cpu(call_single_queue, i);
+		POP_PK("bsp<*> %s(): init <%d> bf head %p head->first %p\n",
+									__func__, i, head, head->first);
+		init_llist_head(&per_cpu(call_single_queue, i));
+		POP_PK("bsp<*> %s(): init <%d> af head %p head->first %p\n",
+									__func__, i, head, head->first);
+	}
+#else
+	for_each_possible_cpu(i)
+		init_llist_head(&per_cpu(call_single_queue, i));
+#endif
+#else
 	for_each_possible_cpu(i)
 		init_llist_head(&per_cpu(call_single_queue, i));
+#endif
+
 
 	hotplug_cfd(&hotplug_cfd_notifier, CPU_UP_PREPARE, cpu);
 	register_cpu_notifier(&hotplug_cfd_notifier);
@@ -128,6 +163,10 @@ static void csd_unlock(struct call_single_data *csd)
 {
 	WARN_ON(!(csd->flags & CSD_FLAG_LOCK));
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	GSMPPRINTK("<%d> %s(): csd %p\n", smp_processor_id(), __func__, csd);
+#endif
+
 	/*
 	 * ensure we're all done before releasing data:
 	 */
@@ -144,6 +183,10 @@ static DEFINE_PER_CPU_SHARED_ALIGNED(struct call_single_data, csd_data);
 static int generic_exec_single(int cpu, struct call_single_data *csd,
 			       smp_call_func_t func, void *info)
 {
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	GBSPIPIPRINTK("<BSP> %s(): check my_cpu %d =? <%d>\n",
+						__func__, smp_processor_id(), cpu);
+#endif
 	if (cpu == smp_processor_id()) {
 		unsigned long flags;
 
@@ -159,6 +202,9 @@ static int generic_exec_single(int cpu, struct call_single_data *csd,
 	}
 
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	GBSPIPIPRINTK("<BSP> %s(): not the same - 1\n", __func__);
+#endif
 	if ((unsigned)cpu >= nr_cpu_ids || !cpu_online(cpu)) {
 		csd_unlock(csd);
 		return -ENXIO;
@@ -167,6 +213,11 @@ static int generic_exec_single(int cpu, struct call_single_data *csd,
 	csd->func = func;
 	csd->info = info;
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	GBSPIPIPRINTK("<BSP> %s(): not the same &csd->llist %lx "
+			"&per_cpu(call_single_queue, cpu) %lx\n",
+			__func__, (unsigned long)&csd->llist, (unsigned long)&per_cpu(call_single_queue, cpu));
+#endif
 	/*
 	 * The list addition should be visible before sending the IPI
 	 * handler locks the list to pull the entry off it because of
@@ -178,8 +229,16 @@ static int generic_exec_single(int cpu, struct call_single_data *csd,
 	 * locking and barrier primitives. Generic code isn't really
 	 * equipped to do the right thing...
 	 */
-	if (llist_add(&csd->llist, &per_cpu(call_single_queue, cpu)))
+	if (llist_add(&csd->llist, &per_cpu(call_single_queue, cpu))) {
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+		/* According to the theory,
+			this is for preventing double ipi (check code) */
+		GBSPIPIPRINTK("<BSP> %s(): not the same my_cpu %d "
+					"*****=ipi>***** <%d>\n",
+					__func__, smp_processor_id(), cpu);
+#endif
 		arch_send_call_function_single_ipi(cpu);
+	}
 
 	return 0;
 }
@@ -297,8 +356,29 @@ int smp_call_function_single(int cpu, smp_call_func_t func, void *info,
 		csd_lock(csd);
 	}
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	GBSPIPIPRINTK("%s(): my_cpu <%d> cpu <%d> > generic_exec_single() %p\n",
+					__func__, smp_processor_id(), cpu, csd);
+	{
+		int i;
+		for_each_possible_cpu(i) {
+			struct llist_head *_head = &per_cpu(call_single_queue, i);
+			GBSPIPIPRINTK("\t\t\tmy_cpu <%d> cpu <%d> %s(): iter <%d> "
+							"_head->first %p\n",
+					smp_processor_id(), cpu, __func__, i, _head->first);
+		}
+	}
+#endif
 	err = generic_exec_single(cpu, csd, func, info);
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	GBSPIPIPRINTK("%s(): my_cpu <%d> run on cpu <%d> wait=%d\n",
+					__func__, smp_processor_id(), cpu, wait);
+#if !PERF_EXP
+	if (!wait) // ONLY SMP INIT DOES THIS
+		dump_stack();
+#endif
+#endif
 	if (wait)
 		csd_lock_wait(csd);
 
@@ -432,6 +512,10 @@ void smp_call_function_many(const struct cpumask *mask,
 
 	/* Fastpath: do that cpu by itself. */
 	if (next_cpu >= nr_cpu_ids) {
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+		GBSPIPIPRINTK("%s(): my_cpu <%d> cpu <%d> > smp_call_function_single()\n",
+						__func__, smp_processor_id(), cpu);
+#endif
 		smp_call_function_single(cpu, func, info, wait);
 		return;
 	}
@@ -456,6 +540,11 @@ void smp_call_function_many(const struct cpumask *mask,
 		llist_add(&csd->llist, &per_cpu(call_single_queue, cpu));
 	}
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	GSMPPRINTK("%s(): my_cpu <%d> cpu <%d> > "
+				"arch_send_call_function_ipi_mask()\n",
+				__func__, smp_processor_id(), cpu);
+#endif
 	/* Send a message to all CPUs in the map */
 	arch_send_call_function_ipi_mask(cfd->cpumask);
 
@@ -564,12 +653,145 @@ void __weak smp_announce(void)
 }
 
 /* Called by boot processor to activate the rest. */
+#ifdef CONFIG_POPCORN_HYPE
+void ssleep_at_ap(int seconds)
+{
+	int i, j,k, loop1 = 100, loop2 = 100000000 / 60;
+//	POP_PK(KERN_INFO "\t\t[%d] (sleep %ds...)\n",
+//					current ? current->pid : -1, seconds);
+	for (k=0; k< seconds; k++)
+		for (i = 0; i < loop1; i++)
+			for (j = 0; j < loop2; j++)
+				cpu_relax();
+
+}
+
+extern bool **hype_callin_dynamic_alloc;
+extern bool hype_callin[HYPE_DEBUG_POINT_MAX + 1][MAX_POPCORN_VCPU];
+//extern bool **hype_callin;
+#if 0
+void cpu_sleep_almost_forever(int cpu)
+{
+    //hype_callin[HYPE_DEBUG_POINT1][1] = true; /* remote guest kernel cannot printk() */
+    //wmb(); // DSM has handled it
+//    if (cpu == 1) {
+        //int ssleep = 999999;
+        //ssleep_at_ap(ssleep); /* dont sleep forever */
+//    }
+}
+#endif
+
+void popcorn_hype_faultaddr_test(bool is_bsp)
+{
+#if 0
+	int tmp;
+	printk("__START_KERNEL_map %lx (cannot read)\n", __START_KERNEL_map);
+
+	printk("__START_KERNEL %lx\n", __START_KERNEL);
+	printk("__START_KERNEL %lx read (%d)\n", __START_KERNEL, *(int*)__START_KERNEL);
+	tmp = *(int*)__START_KERNEL;
+
+	printk("__START_KERNEL %lx write back (%d)\n", __START_KERNEL, tmp);
+	memset((void*)__START_KERNEL, tmp, sizeof(tmp));
+	if (is_bsp) {
+		msleep(2000);
+	} else {
+		ssleep_at_ap(2);
+	}
+
+	printk("__PAGE_OFFSET %lx\n", __PAGE_OFFSET);
+	printk("__PAGE_OFFSET %lx read (%d)\n", __PAGE_OFFSET, *(int*)__PAGE_OFFSET);
+	tmp = *(int*)__PAGE_OFFSET;
+	printk("__PAGE_OFFSET %lx write back (%d)\n", __PAGE_OFFSET, *(int*)__PAGE_OFFSET);
+	memset((void*)__PAGE_OFFSET, tmp, sizeof(tmp));
+
+	if (is_bsp) {
+		msleep(2000);
+	} else {
+		ssleep_at_ap(2);
+	}
+
+	//printk("init_level4_pgt %lx\n", init_level4_pgt);
+	printk("early_level4_pgt %p\n", early_level4_pgt);
+	printk("&early_level4_pgt[510] %p\n", &early_level4_pgt[510]);
+	printk("&early_level4_pgt[511] %p\n", &early_level4_pgt[511]);
+	printk("early_level4_pgt[510].pgd %lx\n", early_level4_pgt[510].pgd);
+	printk("early_level4_pgt[511].pgd %lx\n", early_level4_pgt[511].pgd);
+#endif
+}
+//ffffffff81000042:   48 01 2d af 1f c1 00    add    %rbp,0xc11faf(%rip)        # ffffffff81c11ff8 <level3_kernel_pgt+0xff8>
+#endif
 void __init smp_init(void)
 {
 	unsigned int cpu;
-
+#ifdef CONFIG_POPCORN_HYPE
+	int i; //, j;
+	//unsigned long cnt = 0; /* 4054000 */
+	//struct mm_struct *mm = current->mm;
+#endif
 	idle_threads_init();
+#ifdef CONFIG_POPCORN_HYPE
+    HYPEBOOTDBGPRINTK("\n\t\t===== <*> BSP TESTING ZONE ======\n\n");
+	HYPEBOOTDBGPRINTK("Move others to here\n");
+
+    HYPEBOOTDBGPRINTK("Popcorn Hype argvs:\n");
+    HYPEBOOTDBGPRINTK("DISABLE_WRITABLE_EPT %c\n",
+					DISABLE_WRITABLE_EPT ? 'O' : 'X');
+    HYPEBOOTDBGPRINTK("HYPE_PERF_CRITICAL_DEBUG %c\n",
+					  HYPE_PERF_CRITICAL_DEBUG ? 'O' : 'X');
+    HYPEBOOTDBGPRINTK("DISABLE_VANILLA_DIRECT_PTE_PREFETCH %c\n",
+					  DISABLE_VANILLA_DIRECT_PTE_PREFETCH ? 'O' : 'X');
+	HYPEBOOTDBGPRINTK("RETRY_FIRST_EPT (I don't think this should happen) %c\n",
+											RETRY_FIRST_EPT ? 'O' : 'X');
+	HYPEBOOTDBGPRINTK("HYPE_DEBUG_POINT_MAX %d\n", HYPE_DEBUG_POINT_MAX);
+
+    HYPEBOOTDBGPRINTK("cpu_initialized_mask passed %p 0x%lx\n",
+				cpu_initialized_mask, __pa(cpu_initialized_mask));
+	HYPEBOOTDBGPRINTK("***cpu_callout_mask*** %p 0x%lx\n",
+				cpu_callout_mask, __pa(cpu_callout_mask));
+	HYPEBOOTDBGPRINTK("cpu_online_mask kva %p kpa 0x%lx\n",
+				cpu_online_mask, __pa(cpu_online_mask));
+
+#if POPHYPE_HOST_KERNEL
+    HYPEBOOTDBGPRINTK("\n\n\t\tI'm a HOST OS BSP !!!!!\n\n");
+#else
+	HYPEBOOTDBGPRINTK("\n\n\t\tI'm a GUEST OS BSP !atomic sleepable!!!!\n");
+    //HYPEBOOTDBGPRINTK("Prepare to start (sleep %ds first...)\n\n",
+	//												POPHYPE_SSLEEP);
+	//msleep(POPHYPE_SSLEEP * 1000);
+#endif
+
+#if 0
+	popcorn_hype_faultaddr_test(true);
+#endif
+
+#ifdef CONFIG_POPCORN_HYPE
+	hype_callin_dynamic_alloc =
+			kmalloc((HYPE_DEBUG_POINT_MAX + 1) * sizeof(bool *), GFP_KERNEL);
+	BUG_ON(!hype_callin_dynamic_alloc);
+	for (i = 0; i < HYPE_DEBUG_POINT_MAX + 1; i++) {
+		BUG_ON(!&hype_callin_dynamic_alloc[i]);
+		BUG_ON(!(bool *)((hype_callin_dynamic_alloc) + i));
+		hype_callin_dynamic_alloc[i] =
+				kmalloc(MAX_POPCORN_VCPU * sizeof(bool), GFP_KERNEL);
+		BUG_ON(!hype_callin_dynamic_alloc[i]);
+	}
+	POP_PK("pophype: GOOD ALLOC !!!!!!\n");
+    HYPEBOOTDBGPRINTK("Only check <1>\n");
+    for (i = HYPE_DEBUG_POINT0; i < HYPE_DEBUG_POINT_MAX; i++) {
+		HYPEBOOTDBGPRINTK(KERN_INFO "addr of "
+					"&hype_callin_dynamic_alloc[HYPE_DEBUG_POINT%d][1] %p\n",
+										i, &hype_callin_dynamic_alloc[i][1]);
+    }
+#endif
 
+#if !POPHYPE_HOST_KERNEL
+    //HYPEBOOTDBGPRINTK("Done!! (sleeping %ds...)\n", POPHYPE_SSLEEP);
+	//msleep(POPHYPE_SSLEEP * 1000);
+#endif
+
+    HYPEBOOTDBGPRINTK("\n\t\t======= <*> BSP TESTING ZONE DONE ==========\n\n");
+#endif
 	/* FIXME: This should be done in userspace --RR */
 	for_each_present_cpu(cpu) {
 		if (num_online_cpus() >= setup_max_cpus)
@@ -578,6 +800,19 @@ void __init smp_init(void)
 			cpu_up(cpu);
 	}
 
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+	for_each_possible_cpu(i) {
+		struct llist_head *head = &per_cpu(call_single_queue, i);
+		POP_PK("bsp<*> %s(): <%d> late smp_init check "
+				"head %p head->first %p\n",
+				__func__, i, head, head->first);
+		//init_llist_head(&per_cpu(call_single_queue, i));
+		//POP_PK("bsp<*> %s(): laste smp_init <%d> af head %p head->first %p\n",
+		//							__func__, i, head, head->first);
+	}
+#endif
+
+
 	/* Any cleanup work */
 	smp_announce();
 	smp_cpus_done(setup_max_cpus);
@@ -698,6 +933,9 @@ EXPORT_SYMBOL(on_each_cpu_cond);
 
 static void do_nothing(void *unused)
 {
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+    GBSPIPIPRINTK("<%d> %s():\n", smp_processor_id(), __func__);
+#endif
 }
 
 /**
@@ -713,6 +951,19 @@ static void do_nothing(void *unused)
  */
 void kick_all_cpus_sync(void)
 {
+#if defined(CONFIG_POPCORN_HYPE) && !POPHYPE_HOST_KERNEL
+#if HYPE_PERF_CRITICAL_DEBUG
+	static u64 cnt = 0;
+	cnt++;
+	if (my_nid > 0) {
+		POP_PK("%s(): debug for remote1 boot die "
+				"(potential problematic spot (only remote)) "
+				"#%llu\n", __func__, cnt);
+	}
+
+#endif
+    GBSPIPIPRINTK("<BSP> %s():\n", __func__);
+#endif
 	/* Make sure the change is visible before we kick the cpus */
 	smp_mb();
 	smp_call_function(do_nothing, NULL, 1);
diff --git a/kernel/smpboot.c b/kernel/smpboot.c
index d264f59bff56..281def37460e 100644
--- a/kernel/smpboot.c
+++ b/kernel/smpboot.c
@@ -133,7 +133,15 @@ static int smpboot_thread_fn(void *data)
 			continue;
 		}
 
+#ifdef CONFIG_POPCORN_HYPE
+		if(td->cpu != smp_processor_id()) {
+			printk(KERN_ERR "td->cpu %d smp_processor_id() %d\n",
+									td->cpu, smp_processor_id());
+			BUG();
+		}
+#else
 		BUG_ON(td->cpu != smp_processor_id());
+#endif
 
 		/* Check for state change setup */
 		switch (td->status) {
diff --git a/kernel/sys.c b/kernel/sys.c
index 6624919ef0e7..1e99dd74286e 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -63,6 +63,8 @@
 #include <asm/io.h>
 #include <asm/unistd.h>
 
+#include <popcorn/types.h>
+
 #ifndef SET_UNALIGN_CTL
 # define SET_UNALIGN_CTL(a, b)	(-EINVAL)
 #endif
@@ -2141,6 +2143,12 @@ SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,
 			return -EFAULT;
 		set_task_comm(me, comm);
 		proc_comm_connector(me);
+#ifdef CONFIG_POPCORN_HYPE
+		if (distributed_process(current)) {
+			POP_PK("[%d] %s: thread set name PR_SET_NAME %s\n",
+									current->pid, __func__, comm);
+		}
+#endif
 		break;
 	case PR_GET_NAME:
 		get_task_comm(comm, me);
@@ -2273,6 +2281,11 @@ SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,
 		error = -EINVAL;
 		break;
 	}
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		POP_PK("[%d] %s: return %ld\n", current->pid, __func__, error);
+	}
+#endif
 	return error;
 }
 
diff --git a/kernel/time/clocksource.c b/kernel/time/clocksource.c
index b98810d2f3b4..08fb1d148598 100644
--- a/kernel/time/clocksource.c
+++ b/kernel/time/clocksource.c
@@ -36,6 +36,9 @@
 #include "tick-internal.h"
 #include "timekeeping_internal.h"
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#endif
 /**
  * clocks_calc_mult_shift - calculate mult/shift factors for scaled math of clocks
  * @mult:	pointer to mult variable
@@ -586,9 +589,19 @@ static void __clocksource_select(bool skipcur)
 	best = clocksource_find_best(oneshot, skipcur);
 	if (!best)
 		return;
+#ifdef CONFIG_POPCORN_HYPE
+	KVMCLOCKPK("<%d> %s %s(): pophype: clocksource: "
+						"[best] clocksource = \"%s\"\n",
+			smp_processor_id(), __FILE__, __func__, best->name);
+#endif
 
 	/* Check for the override clocksource. */
 	list_for_each_entry(cs, &clocksource_list, list) {
+#ifdef CONFIG_POPCORN_HYPE
+		KVMCLOCKPK("<%d> %s %s(): pophype: clocksource: "
+							"possible clock source \"%s\"\n",
+				smp_processor_id(), __FILE__, __func__, cs->name);
+#endif
 		if (skipcur && cs == curr_clocksource)
 			continue;
 		if (strcmp(cs->name, override_name) != 0)
@@ -603,9 +616,22 @@ static void __clocksource_select(bool skipcur)
 			pr_warn("Override clocksource %s is not HRT compatible - cannot switch while in HRT/NOHZ mode\n",
 				cs->name);
 			override_name[0] = 0;
-		} else
+		} else {
 			/* Override clocksource can be used. */
 			best = cs;
+#ifdef CONFIG_POPCORN_HYPE
+			KVMCLOCKPK("<%d> %s %s(): pophype: clocksource: "
+								"\"%s\" switch to \"%s\"\n",
+				smp_processor_id(), __FILE__, __func__, best->name, cs->name);
+#endif
+		}
+#ifdef CONFIG_POPCORN_HYPE
+		if (best && cs) {
+			KVMCLOCKPK("<%d> %s %s(): pophype: clocksource: "
+								"best \"%s\" cs \"%s\"\n",
+				smp_processor_id(), __FILE__, __func__, best->name, cs->name);
+		}
+#endif
 		break;
 	}
 
diff --git a/kernel/time/hrtimer.c b/kernel/time/hrtimer.c
index 8c4e27cbfe7f..49bcde3012a7 100644
--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -56,6 +56,8 @@
 
 #include "tick-internal.h"
 
+#include <popcorn/debug.h>
+
 /*
  * The timer bases:
  *
@@ -64,7 +66,13 @@
  * to reach a base using a clockid, hrtimer_clockid_to_base()
  * is used to convert from clockid to the proper hrtimer_base_type.
  */
+#if !GUEST_KERNEL_OPTIMIZE
 DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =
+#else
+DEFINE_PER_CPU_PAGE_ALIGNED(struct hrtimer_cpu_base, hrtimer_bases) = /* pophype - dsm traffic */
+#endif
+////DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =
+//DEFINE_PER_CPU_PAGE_ALIGNED(struct hrtimer_cpu_base, hrtimer_bases) = /* pophype - dsm traffic */
 {
 	.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),
 	.seq = SEQCNT_ZERO(hrtimer_bases.seq),
@@ -1727,6 +1735,11 @@ void __init hrtimers_init(void)
 	hrtimer_cpu_notify(&hrtimers_nb, (unsigned long)CPU_UP_PREPARE,
 			  (void *)(long)smp_processor_id());
 	register_cpu_notifier(&hrtimers_nb);
+#ifdef CONFIG_POPCORN_HYPE
+    KVMCLOCKPK("pophype: false-sharing: was DEFINE_PER_CPU "
+			"this_cpu_ptr(&hrtimer_bases) %p\n",
+					this_cpu_ptr(&hrtimer_bases));
+#endif
 }
 
 /**
diff --git a/kernel/time/tick-common.c b/kernel/time/tick-common.c
index 4fcd99e12aa0..a1c2bd6dbc58 100644
--- a/kernel/time/tick-common.c
+++ b/kernel/time/tick-common.c
@@ -25,6 +25,20 @@
 
 #include "tick-internal.h"
 
+#include <popcorn/debug.h>
+///*
+// * Tick devices
+// */
+////DEFINE_PER_CPU(struct tick_device, tick_cpu_device);
+//DEFINE_PER_CPU_PAGE_ALIGNED(struct tick_device, tick_cpu_device); /* pophype - dsm traffic */
+///*
+// * Tick next event: keeps track of the tick time
+// */
+////ktime_t tick_next_period; /* pophype - dsm traffic */
+////ktime_t tick_period; /* pophype - dsm traffic */
+//ktime_t tick_next_period __attribute__((aligned(PAGE_SIZE))); /* pophype - dsm traffic */
+//ktime_t tick_period __attribute__((aligned(PAGE_SIZE))); /* pophype - dsm traffic */
+#if !GUEST_KERNEL_OPTIMIZE
 /*
  * Tick devices
  */
@@ -32,8 +46,13 @@ DEFINE_PER_CPU(struct tick_device, tick_cpu_device);
 /*
  * Tick next event: keeps track of the tick time
  */
-ktime_t tick_next_period;
-ktime_t tick_period;
+ktime_t tick_next_period; /* pophype - dsm traffic */
+ktime_t tick_period; /* pophype - dsm traffic */
+#else
+DEFINE_PER_CPU_PAGE_ALIGNED(struct tick_device, tick_cpu_device); /* pophype - dsm traffic */
+ktime_t tick_next_period __attribute__((aligned(PAGE_SIZE))); /* pophype - dsm traffic */
+ktime_t tick_period __attribute__((aligned(PAGE_SIZE))); /* pophype - dsm traffic */
+#endif
 
 /*
  * tick_do_timer_cpu is a timer core internal variable which holds the CPU NR
@@ -532,4 +551,21 @@ void __init tick_init(void)
 {
 	tick_broadcast_init();
 	tick_nohz_init();
+#ifdef CONFIG_POPCORN_HYPE
+//#if !POPHYPE_HOST_KERNEL
+	KVMCLOCKPK("pophype: false-sharing: was DEFINE_PER_CPU "
+			"&tick_cputick_next_period_device %p\n",
+				&tick_cpu_device);
+	KVMCLOCKPK("pophype: false-sharing: was DEFINE_PER_CPU "
+			"&per_cpu(*,0) %p\n",
+				&per_cpu(tick_cpu_device, 0));
+	KVMCLOCKPK("pophype: false-sharing: was DEFINE_PER_CPU "
+			"this_cpu_ptr(&tick_cpu_device) %p\n",
+					this_cpu_ptr(&tick_cpu_device));
+	KVMCLOCKPK("pophype: false-sharing: GLOBAL &tick_next_period %p\n",
+											&tick_next_period);
+	KVMCLOCKPK("pophype: false-sharing: GLOBAL &tick_period %p\n",
+											&tick_period);
+//#endif
+#endif
 }
diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.c
index e5d228f7224c..aa5ad1310c64 100644
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@ -31,6 +31,8 @@
 
 #include <trace/events/timer.h>
 
+#include <popcorn/debug.h>
+
 /*
  * Per cpu nohz control structure
  */
@@ -39,7 +41,13 @@ static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);
 /*
  * The time, when the last jiffy update happened. Protected by jiffies_lock.
  */
-static ktime_t last_jiffies_update;
+////static ktime_t last_jiffies_update; /* pophype - dsm traffic - global */
+//static ktime_t last_jiffies_update __attribute__((aligned(PAGE_SIZE))); /* pophype - dsm traffic - global */
+#if !GUEST_KERNEL_OPTIMIZE
+static ktime_t last_jiffies_update; /* pophype - dsm traffic - global */
+#else
+static ktime_t last_jiffies_update __attribute__((aligned(PAGE_SIZE))); /* pophype - dsm traffic - global */
+#endif
 
 struct tick_sched *tick_get_tick_sched(int cpu)
 {
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index d8a2084b88db..56e7417d98fb 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -51,6 +51,8 @@
 
 #include "workqueue_internal.h"
 
+#include <popcorn/debug.h>
+
 enum {
 	/*
 	 * worker_pool flags
@@ -5352,8 +5354,12 @@ static int __init init_workqueues(void)
 	system_wq = alloc_workqueue("events", 0, 0);
 	system_highpri_wq = alloc_workqueue("events_highpri", WQ_HIGHPRI, 0);
 	system_long_wq = alloc_workqueue("events_long", 0, 0);
+#if POPHYPE_HOST_KERNEL
 	system_unbound_wq = alloc_workqueue("events_unbound", WQ_UNBOUND,
 					    WQ_UNBOUND_MAX_ACTIVE);
+#else
+	system_unbound_wq = alloc_workqueue("events_unbound", 0, 0);
+#endif
 	system_freezable_wq = alloc_workqueue("events_freezable",
 					      WQ_FREEZABLE, 0);
 	system_power_efficient_wq = alloc_workqueue("events_power_efficient",
diff --git a/lib/iov_iter.c b/lib/iov_iter.c
index daca582a8ed0..0377f2afd694 100644
--- a/lib/iov_iter.c
+++ b/lib/iov_iter.c
@@ -5,6 +5,8 @@
 #include <linux/vmalloc.h>
 #include <net/checksum.h>
 
+#include <popcorn/types.h>
+
 #define iterate_iovec(i, n, __v, __p, skip, STEP) {	\
 	size_t left;					\
 	size_t wanted = n;				\
@@ -569,7 +571,28 @@ ssize_t iov_iter_get_pages(struct iov_iter *i,
 			len = maxpages * PAGE_SIZE;
 		addr &= ~(PAGE_SIZE - 1);
 		n = DIV_ROUND_UP(len, PAGE_SIZE);
+#ifdef CONFIG_POPCORN_HYPE
+		/* pophype ept/dsm bug - we support only 1 pg at a time */
+		if (distributed_process(current)) {
+			//if (n > 1)
+				DSMPATCHPK("pophype %s %s(): %d: n %d "
+							"omg I need to deal with it "
+							"(NOWAY NOT THE GUP THAT I KNOW OF ) %p\n",
+						__FILE__, __func__, __LINE__, n, get_user_pages_fast);
+				/* There are cases where n = 2 but no new_nr_pages info
+												in get_user_pages_fast() */
+				// arch/x86/mm/gup.c (O)
+				// mm/gup.c (dsm path)
+				// mm/util.c
+		}
+		/* arch/x86/mm/gup.c */
+		res = get_user_pages_fast(addr, n, (i->type & WRITE) != WRITE, pages);
+		/* move my implementation in get_user_pages_fast() to here */
+
+#else
+		/* arch/x86/mm/gup.c */
 		res = get_user_pages_fast(addr, n, (i->type & WRITE) != WRITE, pages);
+#endif
 		if (unlikely(res < 0))
 			return res;
 		return (res == n ? len : res * PAGE_SIZE) - *start;
@@ -617,6 +640,12 @@ ssize_t iov_iter_get_pages_alloc(struct iov_iter *i,
 		p = get_pages_array(n);
 		if (!p)
 			return -ENOMEM;
+#ifdef CONFIG_POPCORN_HYPE
+		if (distributed_process(current)) {
+			printk("pophype %s %s(): %d: omg I need to deal with it\n",
+											__FILE__, __func__, __LINE__);
+		}
+#endif
 		res = get_user_pages_fast(addr, n, (i->type & WRITE) != WRITE, p);
 		if (unlikely(res < 0)) {
 			kvfree(p);
@@ -655,7 +684,7 @@ size_t csum_and_copy_from_iter(void *addr, size_t bytes, __wsum *csum,
 	sum = *csum;
 	iterate_and_advance(i, bytes, v, ({
 		int err = 0;
-		next = csum_and_copy_from_user(v.iov_base, 
+		next = csum_and_copy_from_user(v.iov_base,
 					       (to += v.iov_len) - v.iov_len,
 					       v.iov_len, 0, &err);
 		if (!err) {
@@ -700,7 +729,7 @@ size_t csum_and_copy_to_iter(void *addr, size_t bytes, __wsum *csum,
 	iterate_and_advance(i, bytes, v, ({
 		int err = 0;
 		next = csum_and_copy_to_user((from += v.iov_len) - v.iov_len,
-					     v.iov_base, 
+					     v.iov_base,
 					     v.iov_len, 0, &err);
 		if (!err) {
 			sum = csum_block_add(sum, next, off);
diff --git a/lib/llist.c b/lib/llist.c
index ae5872b1df0c..fcb029dadae9 100644
--- a/lib/llist.c
+++ b/lib/llist.c
@@ -26,6 +26,12 @@
 #include <linux/export.h>
 #include <linux/llist.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#if !POPHYPE_HOST_KERNEL
+//#include <linux/delay.h>
+#endif
+#endif
 
 /**
  * llist_add_batch - add several linked entries in batch
@@ -40,10 +46,54 @@ bool llist_add_batch(struct llist_node *new_first, struct llist_node *new_last,
 {
 	struct llist_node *first;
 
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	if ((long int)new_first == 0xffff88012a417cc0) {
+		//identical then swap
+		printk("\t\t%s(): new_first %p "
+				"head(from &per_cpu(call_single_queue, cpu)) %p "
+				"first(ret) %p\n",
+				__func__, new_first, head, first);
+	}
+#endif
+#endif
+
 	do {
 		new_last->next = first = ACCESS_ONCE(head->first);
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+		if ((long int)new_first == 0xffff88012a417cc0) {
+			printk("\t\t\t: inside head->first %p\n", head->first);
+			if (head->first)
+				printk("\t\t\t: inside *head->first %lx\n", *(long int*)head->first);
+
+			printk("\t\t\t: inside first %p\n", first);
+			if (first)
+				printk("\t\t\t: inside *first %lx\n", *(long int*)first);
+
+			printk("\t\t\t: inside new_first %p *new_first %x\n",
+								new_first, *(unsigned int*)new_first);
+		}
+		//identical then swap
+#endif
+#endif
 	} while (cmpxchg(&head->first, first, new_first) != first);
 
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+	if ((long int)new_first == 0xffff88012a417cc0) {
+		//identical then swap
+		printk("\t\t%s(): new_first %p head %p first(ret) %p\n",
+							__func__, new_first, head, first);
+		if (first)
+			printk("\t\t\t*fist %lx\n",  *(long int*)first);
+		else
+			printk("\t\t\tCANNOT * SO fist %p\n", new_first);
+
+		printk("\t\t\tREAL return !first %x\n", (unsigned int)!first);
+	}
+#endif
+#endif
 	return !first;
 }
 EXPORT_SYMBOL_GPL(llist_add_batch);
diff --git a/mm/gup.c b/mm/gup.c
index ebc9627f8461..dbdb1fb41975 100644
--- a/mm/gup.c
+++ b/mm/gup.c
@@ -17,8 +17,12 @@
 #include <asm/tlbflush.h>
 
 #ifdef CONFIG_POPCORN
+#define HYPE_GUP_RETRY 1 // BUG......
 #include <popcorn/process_server.h>
 #include <popcorn/vma_server.h>
+#include <popcorn/page_server.h>
+#include <popcorn/debug.h>
+#include <linux/delay.h>
 #endif
 
 #include "internal.h"
@@ -314,22 +318,72 @@ static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,
 	unsigned int fault_flags = 0;
 	int ret;
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* lkvm interested cases
+		1st __gfn_to_pfn_memslot/ hva_to_pfn path:
+			vmas: NULL, nonblocking(locked): NULL
+				gup_flags: FOLL_TOUCH | FOLL_NOWAIT |
+							FOLL_HWPOISON | FOLL_GET | (FOLL_WRITE)
+
+		2nd __gfn_to_pfn_memslot/ hva_to_pfn path:
+					vmas: NULL, *nonblocking(*locked): 1
+					gup_flags = FOLL_TOUCH | FOLL_HWPOISON (from the topest)
+								FOLL_GET | (FOLL_WRITE)
+
+		Diff: 1st is FOLL_NOWAIT, 2nd is !FOLL_NOWAIT
+			1st nonblocking(locked): NULL 2nd *nonblocking(*locked): 1
+	*/
+#endif
+
 	/* mlock all present pages, but do not fault in new pages */
 	if ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)
 		return -ENOENT;
 	if (*flags & FOLL_WRITE)
 		fault_flags |= FAULT_FLAG_WRITE;
-	if (nonblocking)
+	if (nonblocking) {
+#ifdef CONFIG_POPCORN_HYPE
+		/* 1st NULL 2nd *nonblocking 1 2nd-2 NULL*/
+#endif
 		fault_flags |= FAULT_FLAG_ALLOW_RETRY;
+	}
 	if (*flags & FOLL_NOWAIT)
 		fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;
 	if (*flags & FOLL_TRIED) {
+#ifdef CONFIG_POPCORN_HYPE
+		/* 2nd-2 case meaning 2nd failed....and now retrying */
+#endif
 		VM_WARN_ON_ONCE(fault_flags & FAULT_FLAG_ALLOW_RETRY);
 		fault_flags |= FAULT_FLAG_TRIED;
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* aka handle_pte_fault(dsm) return directly */
+	/* HOOK WITH DSM */
+	// __get_user_pages -> (faultin_page) -> __handle_mm_fault ->
+	//		handle_pte_fault -> page_server_handle_pte_fault
+#endif
 	ret = handle_mm_fault(mm, vma, address, fault_flags);
+#ifdef CONFIG_POPCORN_HYPE
+	if (tsk) {
+		if (distributed_process(tsk)) {
+			//if ((address & 0xffff000) == 0x1c75 ||
+			//	(address & 0xffff000) == 0x1f1b) {
+			if (INTERESTED_GVA(address)) {
+				//printk("\t\t\t%s(): pophype %lx ret %lx\n",
+				//				__func__, address, (long)ret);
+			}
+		}
+	}
+#endif
 	if (ret & VM_FAULT_ERROR) {
+#ifdef CONFIG_POPCORN_HYPE
+		if (tsk) {
+			if (distributed_process(tsk)) {
+				printk("%s(): !![%d] %lx VM_FAULT_ERROR ret %x (THINK ABOUT IT)\n",
+								__func__, tsk->pid, address, ret);
+			}
+		}
+#endif
 		if (ret & VM_FAULT_OOM)
 			return -ENOMEM;
 		if (ret & (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))
@@ -347,10 +401,104 @@ static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,
 	}
 
 	if (ret & VM_FAULT_RETRY) {
-		if (nonblocking)
+#ifdef CONFIG_POPCORN_HYPE
+		/* Can be local RETRY=(DSM CONTINU + local RETRY) or DSM RETRY */
+#endif
+		if (nonblocking) {
+#ifdef CONFIG_POPCORN_HYPE
+			/* 1st NULL 2nd *nonblocking 1 2nd-2 NULL*/
+			BUG_ON(distributed_process(tsk));
+			/* =*locked */
+			/* TODO 0526 not sure but testing */
+			*nonblocking = 0;
+#else
 			*nonblocking = 0;
+#endif
+		}
+#ifdef CONFIG_POPCORN_HYPE
+		if (tsk) {
+			if (distributed_process(tsk)) {
+				EPTVVPRINTK("%s(): @@ [%d] %lx HYPE_RETRY (for debug)\n",
+											__func__, tsk->pid, address);
+				/* POPCRON DSM RETRY ALSO SHARE THIS (*locked|*nonblocking=0) */
+
+				/* if from caller, defaultly *nonblocking(locked)=1 or
+														!nonblocking */
+
+				/* debuggin fore reasons */
+				if (!(ret & VM_FAULT_HYPE_RETRY) && (ret & VM_FAULT_RETRY)) {
+					printk("%s(): @@ $$[%d] %lx $$VM_FAULT_RETRY$$ locally$$$$$ "
+										"r 0x%x (for debug)\n",
+										__func__, tsk->pid, address, ret);
+				}
+//				else if ((ret & VM_FAULT_HYPE_RETRY) &&
+//							(ret & VM_FAULT_RETRY)) {
+//					printk("%s(): @@ [%d] %lx "
+//							//"VM_FAULT_HYPE_RETRY a super set of VM_FAULT_RETRY "
+//							"r 0x%x from DSM RETRY\n",
+//							__func__, tsk->pid, address, ret);
+//				}
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+				/* impossible */
+				BUG_ON((ret & VM_FAULT_HYPE_RETRY) && !(ret & VM_FAULT_RETRY));
+#endif
+
+				// DEBUG
+				if (ret & VM_FAULT_LOCKED) {
+					printk("%s(): @@ !![%d] %lx $$VM_FAULT_LOCKED$$ "
+										"r 0x%x (for debug)\n",
+										__func__, tsk->pid, address, ret);
+				}
+				if (ret & VM_FAULT_NOPAGE) {
+					printk("%s(): @@ !![%d] %lx $$VM_FAULT_NOPAGE$$ "
+											"r 0x%x (for debug)\n",
+											__func__, tsk->pid, address, ret);
+				}
+				if (ret & VM_FAULT_KILLED) {
+					printk("%s(): @@ !![%d] %lx $$VM_FAULT_KILLED$$ "
+											"r 0x%x (for debug)\n",
+											__func__, tsk->pid, address, ret);
+				}
+
+				/*****************************************
+				 *	Pophype - obey PTE fault/DSM sematics to retry -
+				 *											throw to upper
+				 *	check the discription of handle_mm_fault()
+				 *									in __do_page_fault().
+				 *	"if we get VM_FAULT_RETRY back,
+				 *		the mmap_sem has been unlocked."
+				 *
+				 *	So, we unlock here now.
+				 *****************************************/
+				//goto retry; // throw to upper level don't retry here
+				if (ret & VM_FAULT_HYPE_RETRY) {
+					//printk("%s(): @@ [%d] %lx HYPE RETRY #%lu\n"
+					//	__func__, tsk->pid, address, pophype_dsm_retry++);
+					down_read(&tsk->mm->mmap_sem);
+				}
+
+			}
+		} else { BUG(); }
+#endif
+
 		return -EBUSY;
 	}
+#ifdef CONFIG_POPCORN_HYPE
+	else {
+		if (tsk->backoff_weight &&
+			NOTINTERESTED_GVA(address)
+			) {
+			EPTPRINTK("@@ %s(): [%d] %lx HYPE_RETRYed/backoffed #%d(+0/1)\n",
+					__func__, tsk->pid, address, tsk->backoff_weight * 2);
+		}
+	}
+
+	if (ret & VM_FAULT_CONTINUE) {
+		printk("@@ %s(): !![%d] %lx TODO VM_FAULT_CONTINUE "
+								"r 0x%x (for debug)\n",
+								__func__, tsk->pid, address, ret);
+	}
+#endif
 
 	/*
 	 * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when
@@ -361,8 +509,17 @@ static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,
 	 * which a read fault here might prevent (a readonly page might get
 	 * reCOWed by userspace write).
 	 */
-	if ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))
-	        *flags |= FOLL_COW;
+	if ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE)) {
+		*flags |= FOLL_COW;
+#ifdef CONFIG_POPCORN_HYPE
+		/* seems dirtycow patvh */
+		if (distributed_remote_process(tsk)) {
+			printk(KERN_ERR "[%d] %lx XXX COW AT REMOTE XXX\n",
+											tsk->pid, address);
+			BUG(); /* IF, HANDLE IT */
+		}
+#endif
+	}
 	return 0;
 }
 
@@ -469,11 +626,45 @@ long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 	unsigned int page_mask;
 	struct vm_area_struct *vma = NULL;
 
+#ifdef CONFIG_POPCORN_HYPE
+	int iter = 0;
+	unsigned long gup_retry = 0;
+	unsigned long retry_itself = 0;
+//	unsigned long pophype_dsm_retry = 0;
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	unsigned long old_start = start;
+#endif
+	/* lkvm interested cases
+		1st __gfn_to_pfn_memslot/ hva_to_pfn path:
+			vmas: NULL, nonblocking(locked): NULL
+				gup_flags: FOLL_TOUCH | FOLL_NOWAIT |
+							FOLL_HWPOISON | FOLL_GET | (FOLL_WRITE)
+
+		2nd __gfn_to_pfn_memslot/ hva_to_pfn path:
+					vmas: NULL, *nonblocking(*locked): 1
+					gup_flags = FOLL_TOUCH | FOLL_HWPOISON (from the topest)
+								FOLL_GET | (FOLL_WRITE)
+
+		Diff 1st FOLL_NOWAIT 2nd !FOLL_NOWAIT
+			1st nonblocking(locked): NULL 2nd *nonblocking(*locked): 1
+
+		!!!!!2nd-2 (similar to 1 but flag)
+				vmas: NULL nonblocking: NULL *gup_flags | FOLL_TRIED*
+	*/
+#endif
+
 	if (!nr_pages)
 		return 0;
 
 	VM_BUG_ON(!!pages != !!(gup_flags & FOLL_GET));
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (tsk)
+		if (distributed_process(tsk)) {
+			//BUG_ON(nr_pages > 1);
+			WARN_ON(nr_pages > 1); /* happens when memcached - concurrent large -reqs */
+		}
+#endif
 	/*
 	 * If FOLL_FORCE is set then do not force a full fault as the hinting
 	 * fault information is unrelated to the reference behaviour of a task
@@ -489,21 +680,71 @@ long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 
 		/* first iteration or cross vma bound */
 		if (!vma || start >= vma->vm_end) {
+			/* find rbtree - property = priv/share */
 			vma = find_extend_vma(mm, start);
-			if (!vma && in_gate_area(mm, start)) {
+#ifdef CONFIG_POPCORN
+#ifdef CONFIG_POPCORN_HYPE
+			if(tsk) {
+				//if (distributed_remote_process(tsk)) {
+				if (distributed_process(tsk)) {
+					///* vma worker should not fault */
+					BUG_ON(tsk->is_worker);
+					if (!vma || start < vma->vm_start) {
+					//if (!vma || vma->vm_start > address)  //
+#ifdef CONFIG_POPCORN_STAT
+						printk(" $$[%d] %lx TODO - remote never touch vma - "
+								"no chance to test yet\n", tsk->pid, start);
+						WARN_ON("Maybe BAD");
+#endif
+						/* If origin doesn't populate mem (enforce touch),
+							this will happen at remote.
+									(My sol for this is not tested yet) */
+						if (vma_server_fetch_vma(tsk, start) == 0) {
+							/* Replace with updated VMA */
+#ifdef CONFIG_POPCORN_STAT
+							printk(" $$[%d] %lx TODO - "
+									"origin doesn't have it as well, "
+									"alloc by myself - "
+									"no chance to test yet\n", tsk->pid, start);
+#endif
+							vma = find_extend_vma(mm, start);
+							//vma = find_vma(mm, address); //
+						}
+						/* Check again */
+						if (!vma || start < vma->vm_start)
+							BUG();
+							//return -EFAULT;
+					}
+				}
+			}
+#endif
+#endif
+
+			if (!vma && in_gate_area(mm, start)) { // whether this addr is in page
 				int ret;
 				ret = get_gate_page(mm, start & PAGE_MASK,
 						gup_flags, &vma,
 						pages ? &pages[i] : NULL);
+#ifdef CONFIG_POPCORN_HYPE
+				printk(" $$[%d] %lx TODO - not in page\n", tsk->pid, start);
+#endif
 				if (ret)
 					return i ? : ret;
 				page_mask = 0;
 				goto next_page;
 			}
 
-			if (!vma || check_vma_flags(vma, gup_flags))
+			if (!vma || check_vma_flags(vma, gup_flags)) {
+#ifdef CONFIG_POPCORN_HYPE
+				BUG_ON(distributed_process(tsk));
+#endif
 				return i ? : -EFAULT;
+			}
 			if (is_vm_hugetlb_page(vma)) {
+#ifdef CONFIG_POPCORN_HYPE
+				/* pophype - our dsm doesn't support hugepg */
+				BUG_ON(distributed_process(tsk));
+#endif
 				i = follow_hugetlb_page(mm, vma, pages, vmas,
 						&start, &nr_pages, i,
 						gup_flags);
@@ -511,26 +752,207 @@ long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 			}
 		}
 retry:
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+		if (tsk) {
+			if (distributed_process(tsk)) {
+				BUG_ON(i != 0); // we don't handle more than 1 fault
+				//BUG_ON(i != 0 || i != 1); // i will
+				BUG_ON(old_start != start);
+			}
+		}
+#endif
+#endif
 		/*
 		 * If we have a pending SIGKILL, don't keep faulting pages and
 		 * potentially allocating memory.
 		 */
-		if (unlikely(fatal_signal_pending(current)))
+		if (unlikely(fatal_signal_pending(current))) {
+#ifdef CONFIG_POPCORN_HYPE
+			/* ATTENTION current vs tsk */
+			if (tsk) {
+				if (distributed_process(tsk))
+					printk(" !![%d] %lx TODO - is_signal ret/i %ld\n",
+													tsk->pid, start, i);
+			} else {
+				printk(" !![%s] %lx pending signal while faulting ret/i %ld\n",
+														"no task", start, i);
+			}
+#endif
 			return i ? i : -ERESTARTSYS;
+		}
 		cond_resched();
+		/* get pte */
 		page = follow_page_mask(vma, start, foll_flags, &page_mask);
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef CONFIG_POPCORN_STAT
+		if (tsk) {
+			if (distributed_process(tsk) && gup_retry) {
+				if (page) {
+					/* 0603 is_page - doesn't mean is_permission */
+					DSMRETRYPRINTK(" !![%d] %lx ***WATCHOUT*** "
+								"solved !page #%lu MINE %s\n",
+								tsk->pid, start, gup_retry,
+								page_is_mine_pub(tsk->mm, start) ? "O" : "X");
+					if (!page_is_mine_pub(tsk->mm, start)) {
+						DSMRETRYPRINTK(" !![%d] %lx **WATCHOUT** "
+										"will triger EPT_RETRY\n",
+										tsk->pid, start);
+					}
+					BUG_ON(i);
+					/* origin */
+				} else {
+					if (retry_itself > 0) {
+						/* see this when mm_fault returns !RETRY but page is not mine.... */
+						DSMRETRYPRINTK(" !![%d] %lx **MINE %s** !page imm "
+								"autofix localgood#%lu gupdsmretry #%lu\n",
+								tsk->pid, start,
+								page_is_mine_pub(tsk->mm, start) ? "O" : "X",
+								retry_itself, gup_retry);
+					} /* remote */
+				}
+			}
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+			if (distributed_process(tsk)) {
+				if (tsk != current) {
+					printk(KERN_ERR " !![%d] %lx WATCHOUT current != tsk\n",
+															tsk->pid, start);
+					BUG();
+				}
+			}
+#endif
+		}
+#endif
+#endif
+
 		if (!page) {
 			int ret;
+#ifdef CONFIG_POPCORN_HYPE
+//dsm_path:
+//#ifdef CONFIG_POPCORN_CHECK_SANITY
+//			if (tsk) {
+//				if (distributed_process(tsk)) {
+//					if (tsk != current) {
+//						printk(KERN_ERR " !![%d] %lx WATCHOUT current != tsk\n",
+//																tsk->pid, start);
+//						BUG();
+//					}
+//				}
+//			}
+//#endif
+			/* VM_FAULT_HYPE_RETRY debug info point */
+			if (tsk) {
+				if ((distributed_process(tsk) &&
+					//(INTERESTED_GVA(start) || tsk->at_remote)) &&
+					(INTERESTED_GVA(start))) &&
+					NOTINTERESTED_GVA(start)) {
+					/* 1 memslot 2 memslot both call it
+						asyn is not delivered to here so
+						use nonblocking to determin */
+					EPTVPRINTK("\t\t=slow: (lked) __gups() %s [%d] %lx "
+							"faultin_pg nrpg(remain) %lu mine %s\n",
+							!nonblocking ?
+								(!(gup_flags & FOLL_TRIED) ? "=1st" : "=2nd-2")
+															: "=2nd",
+							tsk->pid, start, nr_pages,
+							page_is_mine_pub(tsk->mm, start) ? "O" : "X");
+				}
+			}
+
+			// (__get_user_pages) -> faultin_page -> __handle_mm_fault ->
+			//				handle_pte_fault -> page_server_handle_pte_fault
+#endif
 			ret = faultin_page(tsk, vma, start, &foll_flags,
 					nonblocking);
+#ifdef CONFIG_POPCORN_HYPE
+			if (tsk) {
+				if (distributed_process(tsk)) {
+					//if ((start & 0xffff000) == 0x1c75 ||
+					//	(start & 0xffff000) == 0x1f1b) {
+					if (INTERESTED_GVA(start)) {
+						//printk("\t\t\t%s(): pophype %lx ret %lx\n",
+						//				__func__, start, (long)ret);
+					}
+				}
+			}
+#endif
 			switch (ret) {
 			case 0:
+#ifdef CONFIG_POPCORN_HYPE
+				/* 0: good */
+				if (tsk) {
+					if (distributed_process(tsk)) {
+						if (retry_itself > 0) {
+							if (INTERESTED_GVA(start) &&
+								NOTINTERESTED_GVA(start)) {
+									DSMRETRYPRINTK(" $$[%d] %lx local good #%lu"
+										"\n", tsk->pid, start, retry_itself);
+							}
+						}
+						retry_itself++;
+					}
+				}
+#endif
 				goto retry;
 			case -EFAULT:
 			case -ENOMEM:
 			case -EHWPOISON:
+#ifdef CONFIG_POPCORN_HYPE
+				if (tsk)
+					if (distributed_process(tsk))
+						printk("!![%d] %lx TODO -EHWPOISON\n", tsk->pid, start);
+#endif
 				return i ? i : ret;
 			case -EBUSY:
+#ifdef CONFIG_POPCORN_HYPE
+				/* 1st: immediately return
+					2nd: *nonblocking = 0; (set by VM_FAULT_RETRY) */
+				//if ((tsk && INTERESTED_GVA(start)) &&
+				if (tsk) {
+					if (distributed_process(tsk)) {
+						if (
+							INTERESTED_GVA(start)
+							//(INTERESTED_GVA(start) && NOTINTERESTED_GVA(start)) ||
+							//(start & 0xffff0000) == 0x1c75 ||
+							//(start & 0xffff0000) == 0x1f1b
+							) {
+							EPTVPRINTK("\t=__gups() [%d] %s %lx ret RETRY "
+								"i(succpgs) %ld HYPE_GUP_RETRY(%s) #%lu\n",
+									tsk->pid,
+									!nonblocking ?
+										(!(gup_flags & FOLL_TRIED) ?
+											"=1st(imme return)" :
+											"=2nd-2 (TODO!)") :
+												"=2nd(by DSM RETRY "
+												"*nonblocking = 0)",
+									start, i,
+									HYPE_GUP_RETRY ? "O" : "X",
+									gup_retry); /* i=0 */
+						}
+					}
+				}
+
+				/* hype retry - faultin_page has unlocked
+						and VM_FAULT_HYPE_RETRY -> -EBUSY */
+				if (HYPE_GUP_RETRY) {
+					//if (distributed_remote_process(tsk) && // BUG
+					if (distributed_process(tsk) &&
+						/* retry for 1st - don't only retry for 2nd-1 */
+						!nonblocking &&  (!(gup_flags & FOLL_TRIED))) {
+						// =1st
+						io_schedule();
+						gup_retry++;
+						goto retry;
+						//goto dsm_path;
+					} else if (distributed_process(tsk)) {
+						printk(KERN_ERR "nonblocking %p gup_flags %x\n",
+												nonblocking, gup_flags);
+						BUG();
+					}
+				} else {
+					printk(" !![%d] %lx need attention!\n", tsk->pid, start);
+				}
+#endif
 				return i;
 			case -ENOENT:
 				goto next_page;
@@ -541,18 +963,35 @@ retry:
 			 * Proper page table entry exists, but no corresponding
 			 * struct page.
 			 */
+#ifdef CONFIG_POPCORN_HYPE
+			if (tsk)
+				if (distributed_process(tsk))
+					printk(" !![%d] %lx TODO - pte but !page\n", tsk->pid, start);
+#endif
 			goto next_page;
 		} else if (IS_ERR(page)) {
+#ifdef CONFIG_POPCORN_HYPE
+			if (tsk)
+				if (distributed_process(tsk))
+					printk(" !![%d] %lx TODO - IS_ERR(page)\n", tsk->pid, start);
+#endif
 			return i ? i : PTR_ERR(page);
 		}
-		if (pages) {
+
+		if (pages) { /* flush cache coressponded to the page */
 			pages[i] = page;
 			flush_anon_page(vma, page, start);
 			flush_dcache_page(page);
 			page_mask = 0;
 		}
+
 next_page:
 		if (vmas) {
+#ifdef CONFIG_POPCORN_HYPE
+			if (tsk) {
+				BUG_ON(distributed_process(tsk)); /* not seen yet */
+			}
+#endif
 			vmas[i] = vma;
 			page_mask = 0;
 		}
@@ -562,7 +1001,32 @@ next_page:
 		i += page_increm;
 		start += page_increm * PAGE_SIZE;
 		nr_pages -= page_increm;
+#ifdef CONFIG_POPCORN_HYPE
+		iter++;
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+		if (tsk)
+			if (distributed_process(tsk))
+				BUG_ON(page_increm > 1);
+#endif
+#endif
 	} while (nr_pages);
+
+#ifdef CONFIG_POPCORN_HYPE
+	/* If !i, start has been shifted */
+	if (tsk) {
+		if (distributed_process(tsk)) {
+			if (i != 1 || gup_retry > 0)
+				DSMRETRYPRINTK(" !![%d] %lx CHECK ret/i %ld(%s) dsm_retry #%lu "
+								"MINE %s\n",
+						tsk->pid, start - (iter * PAGE_SIZE),
+						i, i == 1 ? "GOOD" : "BAD", gup_retry,
+						page_is_mine_pub(tsk->mm, start - (iter * PAGE_SIZE)) ?
+																	"O" : "X");
+				// origin
+		}
+	}
+#endif
+
 	return i;
 }
 EXPORT_SYMBOL(__get_user_pages);
@@ -651,6 +1115,15 @@ static __always_inline long __get_user_pages_locked(struct task_struct *tsk,
 	long ret, pages_done;
 	bool lock_dropped;
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* lkvm interested cases = vmas: NULL notify_drop: NULL forece: 0
+				2nd __gfn_to_pfn_memslot/ hva_to_pfn path:
+					vmas: NULL, *nonblocking(*locked): 1
+					gup_flags = FOLL_TOUCH | FOLL_HWPOISON (from the topest)
+								FOLL_GET | (FOLL_WRITE)
+	*/
+#endif
+
 	if (locked) {
 		/* if VM_FAULT_RETRY can be returned, vmas become invalid */
 		BUG_ON(vmas);
@@ -670,25 +1143,61 @@ static __always_inline long __get_user_pages_locked(struct task_struct *tsk,
 	for (;;) {
 		ret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,
 				       vmas, locked);
-		if (!locked)
+#ifdef CONFIG_POPCORN_HYPE
+		/* faultin_page may have change locked */
+#endif
+		if (!locked) {
+#ifdef CONFIG_POPCORN_HYPE
+			if (tsk) {
+				BUG_ON(distributed_process(tsk));
+			}
+#endif
 			/* VM_FAULT_RETRY couldn't trigger, bypass */
 			return ret;
+		}
 
 		/* VM_FAULT_RETRY cannot return errors */
 		if (!*locked) {
+#ifdef CONFIG_POPCORN_HYPE
+			/* nice check for us */
+#endif
 			BUG_ON(ret < 0);
 			BUG_ON(ret >= nr_pages);
 		}
 
-		if (!pages)
+		if (!pages) {
+#ifdef CONFIG_POPCORN_HYPE
+			if (tsk) {
+				if (distributed_process(tsk)) {
+					EPTVPRINTK("\t=__gups() $$[%d] =2nd -1 %lx "
+								" mine %s nr_pages %ld pages_done %ld\n",
+								tsk->pid, start,
+								page_is_mine_pub(tsk->mm, start) ? "O" : "X",
+								nr_pages, pages_done);
+				}
+			}
+#endif
 			/* If it's a prefault don't insist harder */
 			return ret;
+		}
 
 		if (ret > 0) {
 			nr_pages -= ret;
 			pages_done += ret;
-			if (!nr_pages)
+			if (!nr_pages) {
+#ifdef CONFIG_POPCORN_HYPE
+				if (tsk) {
+					if (distributed_process(tsk)) {
+						EPTVPRINTK("\t=__gups() $$[%d] =2nd -2 %lx "
+									" mine %s nr_pages %ld pages_done %ld\n",
+									tsk->pid, start,
+									page_is_mine_pub(tsk->mm, start) ? "O" : "X",
+									nr_pages, pages_done);
+					}
+				}
+#endif
 				break;
+			}
 		}
 		if (*locked) {
 			/* VM_FAULT_RETRY didn't trigger */
@@ -696,6 +1205,18 @@ static __always_inline long __get_user_pages_locked(struct task_struct *tsk,
 				pages_done = ret;
 			break;
 		}
+#ifdef CONFIG_POPCORN_HYPE
+		/* POPCRON DSM RETRY ALSO SHARE THIS (*locked|*nonblocking=0)
+		 * VM_FAULT_RETRY will set *locked = 0 and then come to here
+		 * here we lock again (*locked=1 + down_read())
+		 * (notice: 2nd is not properly handled (todo hype retry))
+		 */
+		/* (notice: 2nd is not properly handled (todo hype retry)) */
+		if (tsk) {
+			BUG_ON(distributed_process(tsk));
+			//BUG_ON(distributed_remote_process(tsk));
+		}
+#endif
 		/* VM_FAULT_RETRY triggered, so seek to the faulting offset */
 		pages += ret;
 		start += ret << PAGE_SHIFT;
@@ -708,10 +1229,35 @@ static __always_inline long __get_user_pages_locked(struct task_struct *tsk,
 		*locked = 1;
 		lock_dropped = true;
 		down_read(&mm->mmap_sem);
+#ifdef CONFIG_POPCORN_HYPE
+		if (tsk) {
+			if (distributed_process(tsk)) {
+				BUG_ON(ret); /* we only support 1 page */
+				//if ((tsk &&
+					//INTERESTED_GVA(start)) &&
+					//NOTINTERESTED_GVA(start) {
+				EPTVPRINTK("\t=__gups() $$[%d] =2nd-2 [[LOCKED]] %lx faultin_pg "
+						"nrpg(remain) %lu mine %s (TODO) pages_done %ld\n",
+						tsk->pid, start, nr_pages,
+						page_is_mine_pub(tsk->mm, start) ? "O" : "X",
+						pages_done);
+				//}
+			}
+		}
+#endif
 		ret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,
 				       pages, NULL, NULL);
 		if (ret != 1) {
 			BUG_ON(ret > 1);
+#ifdef CONFIG_POPCORN_HYPE
+			/* Jack have a look */
+			/* ret = 0 because of RETRY */
+			/* I guess pages_done is 0 ret is 0 so return 0 */
+			if (distributed_process(tsk)) {
+				EPTVPRINTK("\t=__gups() $$[%d] =2nd-2 %lx why dsm fail?\n",
+														tsk->pid, start);
+			}
+#endif
 			if (!pages_done)
 				pages_done = ret;
 			break;
@@ -723,6 +1269,12 @@ static __always_inline long __get_user_pages_locked(struct task_struct *tsk,
 		pages++;
 		start += PAGE_SIZE;
 	}
+#ifdef CONFIG_POPCORN_HYPE
+	/* I guess pages_done is 0 ret is 0 so return 0 now back to 2nd argvs
+			notify_drop: false,
+			lock_dropped: true (sinde 2nd-2), *locked: 1 (sinde 2nd-2)
+								so this lock will be unlocked outside */
+#endif
 	if (notify_drop && lock_dropped && *locked) {
 		/*
 		 * We must let the caller know we temporarily dropped the lock
@@ -730,6 +1282,19 @@ static __always_inline long __get_user_pages_locked(struct task_struct *tsk,
 		 */
 		up_read(&mm->mmap_sem);
 		*locked = 0;
+#ifdef CONFIG_POPCORN_HYPE
+		if (distributed_process(tsk)) {
+			//if ((tsk && (INTERESTED_GVA(start) || tsk->at_remote)) &&
+			if ((tsk && (INTERESTED_GVA(start))) &&
+				NOTINTERESTED_GVA(start)) {
+				EPTVPRINTK("\t=__gups() $$[%d] =2nd [[UNLOCKED]] %lx faultin_pg "
+							"nrpg(remain) %lu mine %s "
+							"(BUG: should not reach)\n",
+							tsk->pid, start, nr_pages,
+							page_is_mine_pub(tsk->mm, start) ? "O" : "X");
+			}
+		}
+#endif
 	}
 	return pages_done;
 }
@@ -781,15 +1346,58 @@ __always_inline long __get_user_pages_unlocked(struct task_struct *tsk, struct m
 					       unsigned int gup_flags)
 {
 	long ret;
-	int locked = 1;
+	int locked = 1; /* lkvm interested */
 	down_read(&mm->mmap_sem);
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(tsk)) {
+		//if ((tsk && (INTERESTED_GVA(start) || tsk->at_remote)) &&
+		//	NOTINTERESTED_GVA(start)) {
+			EPTVPRINTK("\t=__gups() [%d] =2nd async(NULL) [[[LOCKed]]] "
+												"addr %lx locked 1\n",
+													tsk->pid, start);
+		//}
+	}
+#endif
 	ret = __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,
 				      pages, NULL, &locked, false, gup_flags);
-	if (locked)
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(tsk) && ret != 1) {
+		/* if so, handle it (double up_read probkem (1 loc above and below) */
+		printk("[%d] DIE DIE DIE locked [[[[[[%d]]]]]] ret %ld\n",
+											tsk->pid, locked, ret);
+		WARN_ON(1); /* happens when memcachedlarg regs & more conn */
+	}
+#endif
+	if (locked) {
 		up_read(&mm->mmap_sem);
+#ifdef CONFIG_POPCORN_HYPE
+		if (distributed_process(tsk)) {
+			//if ((tsk && (INTERESTED_GVA(start) || tsk->at_remote)) &&
+			//	NOTINTERESTED_GVA(start)) {
+//				EPTVPRINTK("\t=__gups() [%d] =2nd UNLOCKED %lx faultin_pg "
+//							"nrpg(remain) %lu mine %s\n",
+//							tsk->pid, start, nr_pages,
+//							page_is_mine_pub(tsk->mm, start) ? "O" : "X");
+				/* 0519 someone up_read again */
+				/* right after got sipi 7ffff4fe400 from kvm_vcpu_reload_apic_access_page() */
+				EPTVPRINTK("\t=__gups() $$[%d] =2nd async(NULL) "
+						"locked %d %s [[[UNLOCKed]]] addr %lx ret %ld\n",
+						tsk->pid, locked, locked ? "=>" : "!=>", start, ret);
+				//dump_stack();
+			//}
+			BUG_ON(ret != 1 && "if so, handle it"); /* This is another general
+										place to solve pophype dsm shortage */
+		}
+#endif
+	}
+//#ifdef CONFIG_POPCORN_HYPE
+//	if (tsk->at_remote) {
+//		EPTVPRINTK("%s(): [%d] no async [[[UNLOCKed]]] mmap_sem addr %lx locked %d\n",
+//							__func__, tsk->pid, start, locked);
+//	}
+//#endif
 	return ret;
 }
-EXPORT_SYMBOL(__get_user_pages_unlocked);
 
 /*
  * get_user_pages_unlocked() is suitable to replace the form:
@@ -1360,6 +1968,12 @@ int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
 					start, len)))
 		return 0;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current) && INTERESTED_GVA(start)) {
+		printk(" fast[%d] %lx mm/gup.c\n", current->pid, start);
+	}
+#endif
+
 	/*
 	 * Disable interrupts.  We use the nested form as we can already have
 	 * interrupts disabled by get_futex_key.
@@ -1371,6 +1985,8 @@ int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
 	 * We do not adopt an rcu_read_lock(.) here as we also want to
 	 * block IPIs that come from THPs splitting.
 	 */
+	/* If !!pte, gup_pud_rang() going to next level (pmd)
+								and next next level (pte) */
 
 	local_irq_save(flags);
 	pgdp = pgd_offset(mm, addr);
@@ -1379,7 +1995,7 @@ int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
 
 		next = pgd_addr_end(addr, end);
 		if (pgd_none(pgd))
-			break;
+			break;	/* !pte goto slow path */
 		if (unlikely(pgd_huge(pgd))) {
 			if (!gup_huge_pgd(pgd, pgdp, addr, next, write,
 					  pages, &nr))
@@ -1427,8 +2043,33 @@ int get_user_pages_fast(unsigned long start, int nr_pages, int write,
 		start += nr << PAGE_SHIFT;
 		pages += nr;
 
+#ifdef CONFIG_POPCORN_HYPE
+		/* pophype: currently, memcached tx problem happens in another
+						get_user_pages_fast() located arch/x86/mm/gup.c.
+			If this happens, we need to solve
+					solving dsm shortage/problem here */
+		WARN_ON("should never happen");
+		POP_PK("pophype: dsm shortage - nr (done) %d < nr_pages (req) %d\n",
+																nr, nr_pages);
+		if (nr_pages - nr) { /* multi-page but pophype doesn't support so */
+			/*break it down to be individual */
+			int cnt = nr_pages - nr;
+			while (cnt) {
+				POP_PK("pophype: my sol %d/%d\n", cnt, nr_pages - nr);
+				ret = get_user_pages_unlocked(current, mm, start,
+												  1, write, 0, pages);
+				/* TODO: what should I do for ret and nr_pages & nr !!!! TODO */
+				cnt--;
+			}
+
+		} else { /* normal single page */
+			ret = get_user_pages_unlocked(current, mm, start,
+							  nr_pages - nr, write, 0, pages);
+		}
+#else
 		ret = get_user_pages_unlocked(current, mm, start,
 					      nr_pages - nr, write, 0, pages);
+#endif
 
 		/* Have to be a bit careful with return values */
 		if (nr > 0) {
diff --git a/mm/huge_memory.c b/mm/huge_memory.c
index 0127b788272f..f04d146ebf0e 100644
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@ -2215,6 +2215,9 @@ void __khugepaged_exit(struct mm_struct *mm)
 		 * khugepaged has finished working on the pagetables
 		 * under the mmap_sem.
 		 */
+ #ifdef CONFIG_POPCORN
+		BUG();
+ #endif
 		down_write(&mm->mmap_sem);
 		up_write(&mm->mmap_sem);
 	}
@@ -2582,6 +2585,9 @@ static void collapse_huge_page(struct mm_struct *mm,
 	 * gup_fast later hanlded by the ptep_clear_flush and the VM
 	 * handled by the anon_vma lock + PG_lock.
 	 */
+#ifdef CONFIG_POPCORN_HYPE
+	BUG();
+#endif
 	down_write(&mm->mmap_sem);
 	if (unlikely(khugepaged_test_exit(mm)))
 		goto out;
diff --git a/mm/ksm.c b/mm/ksm.c
index 0b496edc704b..8514eaec71b2 100644
--- a/mm/ksm.c
+++ b/mm/ksm.c
@@ -1902,6 +1902,9 @@ void __ksm_exit(struct mm_struct *mm)
 		clear_bit(MMF_VM_MERGEABLE, &mm->flags);
 		mmdrop(mm);
 	} else if (mm_slot) {
+#ifdef CONFIG_POPCORN
+		 BUG();
+#endif
 		down_write(&mm->mmap_sem);
 		up_write(&mm->mmap_sem);
 	}
diff --git a/mm/madvise.c b/mm/madvise.c
index 4278bb8268a4..d95245bc160f 100644
--- a/mm/madvise.c
+++ b/mm/madvise.c
@@ -527,9 +527,18 @@ SYSCALL_DEFINE3(madvise, unsigned long, start, size_t, len_in, int, behavior)
 		return error;
 
 	write = madvise_need_mmap_write(behavior);
-	if (write)
+	if (write) {
+#ifdef CONFIG_POPCORN
+	if (distributed_process(current)) {
+#ifdef CONFIG_POPCORN_HYPE
+	    if (INTERESTED_GVA(start)) {
+			printk("%s(): [%d] %lx $$$\n", __func__, current->pid, start);
+		}
+#endif
+	}
+#endif
 		down_write(&current->mm->mmap_sem);
-	else
+	} else
 		down_read(&current->mm->mmap_sem);
 
 	/*
diff --git a/mm/memblock.c b/mm/memblock.c
index f8fab45bfdb7..e1f6b8349f9c 100644
--- a/mm/memblock.c
+++ b/mm/memblock.c
@@ -225,12 +225,43 @@ phys_addr_t __init_memblock memblock_find_in_range_node(phys_addr_t size,
 		/* make sure we will allocate above the kernel */
 		bottom_up_start = max(start, kernel_end);
 
+#ifdef CONFIG_POPCORN_HYPE
+//TODO hv_clock addr here to make sure
+		{
+			int i;
+			unsigned long target_paddr[] = { 0x12b105000,
+											0x12b106000,
+											0x12b10c000,
+											0x12a413000,
+											0x12b016000,
+											0x12ffff000,
+											0x12fc14000 };
+
+			ret = __memblock_find_range_bottom_up(bottom_up_start, end,
+									  size, align, nid, flags);
+			for (i = 0; i < ARRAY_SIZE(target_paddr); i++) {
+				if (target_paddr[i] >= ret &&
+					target_paddr[i] < ret + size) {
+					static unsigned int cnt = 0;
+					cnt++;
+					POP_PK("\n\npophype: got you #%u: dynamic: "
+							"target_paddr[] = 0x%lx 0x%llx ~ 0x%llx\n\n",
+							cnt, target_paddr[i], ret, ret + size);
+					dump_stack();
+					printk("\n\n\n");
+				}
+			}
+
+			if (ret)
+				return ret;
+		}
+#else
 		/* ok, try bottom-up allocation first */
 		ret = __memblock_find_range_bottom_up(bottom_up_start, end,
 						      size, align, nid, flags);
 		if (ret)
 			return ret;
-
+#endif
 		/*
 		 * we always limit bottom-up allocation above the kernel,
 		 * but top-down allocation doesn't have the limit, so
@@ -245,8 +276,38 @@ phys_addr_t __init_memblock memblock_find_in_range_node(phys_addr_t size,
 			     "memory hotunplug may be affected\n");
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+//TODO hv_clock addr here to make sure
+	{
+		int i;
+		unsigned long target_paddr[] = { 0x12b105000,
+										0x12b106000,
+										0x12b10c000,
+										0x12a413000,
+										0x12b016000,
+										0x12ffff000,
+										0x12fc14000 };
+
+		ret = __memblock_find_range_top_down(
+					start, end, size, align, nid, flags);
+		for (i = 0; i < ARRAY_SIZE(target_paddr); i++) {
+			if (target_paddr[i] >= ret &&
+				target_paddr[i] < ret + size) {
+				static unsigned int cnt = 0;
+				cnt++;
+				POP_PK("\n\npophype: got you #%u: dynamic: "
+						"target_paddr[] = 0x%lx 0x%llx ~ 0x%llx\n\n",
+						cnt, target_paddr[i], ret, ret + size);
+				dump_stack();
+				printk("\n\n\n");
+			}
+		}
+	}
+	return ret;
+#else
 	return __memblock_find_range_top_down(start, end, size, align, nid,
 					      flags);
+#endif
 }
 
 /**
diff --git a/mm/memory.c b/mm/memory.c
index 3c02373997f3..0b3d7e6cf5b2 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -76,6 +76,7 @@
 #include <linux/delay.h>
 #include <popcorn/page_server.h>
 #include <popcorn/process_server.h>
+#include <popcorn/hype_kvm.h>
 #endif
 
 #if defined(LAST_CPUPID_NOT_IN_PAGE_FLAGS) && !defined(CONFIG_COMPILE_TEST)
@@ -1755,6 +1756,15 @@ int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,
 	struct mm_struct *mm = vma->vm_mm;
 	int err;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (size == 0x3000 || addr == 0x99000) {
+		DDPRINTK("================================\n");
+		DDPRINTK("%s(): vma %p addr %lx pfn %lx size %lx prot %lu\n",
+						__func__, vma, addr, pfn, size, prot.pgprot);
+		DDPRINTK("================================\n");
+	}
+#endif
+
 	/*
 	 * Physically remapped pages are special. Tell the
 	 * rest of the world about it:
@@ -2802,6 +2812,18 @@ static int __do_fault(struct vm_area_struct *vma, unsigned long address,
 	vmf.gfp_mask = __get_fault_gfp_mask(vma);
 	vmf.cow_page = cow_page;
 
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef CONFIG_POPCORN_STAT
+    if (distributed_process(current) &&
+		(address == 0x7ffff4fdd000 || INTERESTED_GVA(address))) {
+        EPTPRINTK("%s(): jack %p %p local file fault "
+                "(I think we didn't have DSM working for this resion "
+                "so this is the problem)\n",
+                __func__, vma->vm_ops, vma->vm_ops->fault);
+    }
+#endif
+#endif
+
 	ret = vma->vm_ops->fault(vma, &vmf);
 	if (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))
 		return ret;
@@ -3152,6 +3174,16 @@ static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,
 	pgoff_t pgoff = (((address & PAGE_MASK)
 			- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current) &&
+		(address == 0x7ffff4fdd000 || INTERESTED_GVA(address))) {
+		POP_PK("%s(): localfault jack %p %p "
+				"(I think we didn't have DSM working for this resion "
+				"so this is the problem)\n",
+				__func__, vma->vm_ops, vma->vm_ops->fault);
+    }
+#endif
+
 	pte_unmap(page_table);
 	/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */
 	if (!vma->vm_ops->fault)
@@ -3303,10 +3335,13 @@ static int wp_huge_pmd(struct mm_struct *mm, struct vm_area_struct *vma,
  * The mmap_sem may have been released depending on flags and our
  * return value.  See filemap_fault() and __lock_page_or_retry().
  */
+//volatile int current->is_backoff = 0;
 static int handle_pte_fault(struct mm_struct *mm,
 		     struct vm_area_struct *vma, unsigned long address,
 		     pte_t *pte, pmd_t *pmd, unsigned int flags)
 {
+#ifdef CONFIG_POPCORN_HYPE
+#endif
 	pte_t entry;
 	spinlock_t *ptl;
 
@@ -3322,30 +3357,258 @@ static int handle_pte_fault(struct mm_struct *mm,
 	barrier();
 #ifdef CONFIG_POPCORN
 	if (distributed_process(current)) {
+#ifdef CONFIG_POPCORN_HYPE /* kill me */
+//	if (distributed_process(current) &&
+//		!(vma->vm_ops == popcorn_vcpu_op &&
+//			vma->vm_ops)) {
+#endif
 		int ret = page_server_handle_pte_fault(
 				mm, vma, address, pmd, pte, entry, flags);
 		if (ret == VM_FAULT_RETRY) {
 			int backoff = ++current->backoff_weight;
-			PGPRINTK("  [%d] backoff %d\n", current->pid, backoff);
+			/* let the last succ printk */
+			//PGPRINTK("  [%d] %lx *******backoff******* #%d\n",
+#ifdef CONFIG_POPCORN_HYPE
+			//if (NOTINTERESTED_GVA(address))
+#endif
+			{
+				EPTVPRINTK("  [%d] %lx *******backoff******* weight#%d tried#%d\n",
+								current->pid, address, backoff, current->is_backoff);
+			}
+			current->is_backoff++;
+#ifdef CONFIG_POPCORN_HYPE
+			ret |= VM_FAULT_HYPE_RETRY;
+#endif
+
 			if (backoff <= 10) {
+				/* Perf Critical - usually retry = 0 and then 1 */
+#ifdef CONFIG_POPCORN_HYPE
+				/* TODO 0527 If this is the problem seperate fault from EPT or local PTE */
+				/* TODO 0527 If this is the problem seperate fault from EPT or local PTE */
+				/* TODO 0527 If this is the problem seperate fault from EPT or local PTE */
+				if (current->at_remote) {
+					//udelay(backoff * 5000); /* Jack good */
+					//udelay(backoff * 1000); /* Jack works */
+					//udelay(backoff * 100); // AP X 20s O 30s takes forever to boot
+					//msleep(backoff * 10); //
+					//udelay(backoff * 1000); // testing
+
+					// good
+					//msleep(backoff * 10); // AP O 20s
+					//msleep(backoff * 1); // ok remote eptfault > origin
+
+					// case 5 try succ
+					//udelay(backoff * 10000); AP X !! udelay is busy-wait loop
+					//msleep(backoff * 10); // AP O 20s
+
+					// case 6
+					//msleep(backoff * 5); // AP OK
+
+					// case 7
+					msleep(backoff * 1); // AP OK
+
+					// case 8
+					//usleep_range(100, 100); // since pophype shortage...
+
+					// case 9 for trying better kernel false share perform
+					//usleep_range(200, 200); // since pophype shortage...
+
+					// case 10 for trying better kernel false share perform
+					//usleep_range(500, 500); // since pophype shortage...
+
+					// case 11
+					//msleep(backoff * 5);
+
+					// case 12
+					//msleep(backoff * 5);
+
+					// case 13
+					//msleep(backoff * 5);
+				} else {
+					//udelay(backoff * 100); // AP X 20s O 30s tales forever to boot
+					//udelay(backoff * 100); // testing
+
+					/* testing what show I do when remote eptfault_t > origin */
+					//udelay(backoff * 100); // testing ori 1 rem 5 X AP
+					//msleep(backoff * 5); // testing ori 1 rem 5
+
+					// good
+					//msleep(backoff * 10); // AP O 20s
+					//msleep(backoff * 1); // ok remote eptfault > origin
+
+					// case 5 try succ
+					//udelay(backoff * 10000); // AP X !!
+					//msleep(backoff * 10); // AP O 20s
+
+					// case 6
+					//msleep(backoff * 5); // AP OK
+
+					// case 7
+					msleep(backoff * 1); // AP OK
+
+					// case 8
+					//usleep_range(100, 100); // since pophype shortage...
+					//pgfault_stat: 46ca57 7ffc41e0d000 0 1 127375
+					//pgfault_stat: 46ca57 7fff95669000 0 0 20492
+
+					// case 9 for trying better kernel false share perform
+					//usleep_range(200, 200); // since pophype shortage...
+
+					// case 10 for trying better kernel false share perform
+					//usleep_range(500, 500); // since pophype shortage...
+
+					// case 11
+					//msleep(backoff * 5);
+
+					// case 12
+					//msleep(backoff * 1);
+
+					// case 13
+					//msleep(backoff * 3);
+				}
+#else
 				udelay(backoff * 100);
+#endif
+
+#ifdef CONFIG_POPCORN_HYPE
+#if 0
+				if (INTERESTED_GVA(address) && current->at_remote) {
+					printk("\t\t[%d] DOWN %lx %d %s\n", current->pid,
+							address, in_atomic(), a ? "" : " ");
+				}
+#endif
+//				down_read(&mm->mmap_sem); // BUG canno renter
+//				if (INTERESTED_GVA(address) && current->at_remote)
+//					printk("\t\t[%d] DOWN %lx %d LOCKED\n", current->pid, address, in_atomic());
+#endif
 			} else {
+				/* Perf Critical */
+#ifdef CONFIG_POPCORN_HYPE
+				//msleep((backoff - 10) * 100); // AP O
+				//msleep((backoff - 10) * 10); // AP O (remote eptfault > origin?)
+				//msleep((backoff - 10) * 1); // AP X 20s O 30s takes forever to boot
+				//if (current->at_remote) {
+				//	msleep((backoff - 10) * 10);
+				//} else {
+				//	msleep((backoff - 10) * 1);
+				//}
+
+				// case 1 delay 10 times at remote
+				//if (current->at_remote) {
+				//	msleep((backoff - 10) * 10);
+				//} else {
+				//	msleep((backoff - 10) * 1);
+				//}
+
+				// case 2 try > 10
+				//if (current->at_remote) {
+				//	msleep((backoff - 10) * 10);
+				//} else {
+				//	msleep((backoff - 10) * 10);
+				//}
+
+				// case 3 try more
+				//if (current->at_remote) {
+				//if 	msleep((backoff - 10) * 50);
+				//if } else {
+				//if 	msleep((backoff - 10) * 5);
+				//if }
+
+				// case 4 try succ
+				//if (current->at_remote) {
+				//	msleep((backoff - 10) * 50);
+				//} else {
+				//	msleep((backoff - 10) * 50);
+				//}
+
+				// case 5 try succ
+				//if (current->at_remote) {
+				//	msleep((backoff - 10) * 100);
+				//} else {
+				//	msleep((backoff - 10) * 100);
+				//}
+
+				// case 6 // AP O
+				//if (current->at_remote) {
+				//	msleep((backoff - 10) * 50);
+				//} else {
+				//	msleep((backoff - 10) * 50);
+				//}
+
+				// case 7 // AP O
+				if (current->at_remote) {
+					msleep((backoff - 10) * 10);
+				} else {
+					msleep((backoff - 10) * 10);
+				}
+
+				// case 8 // AP O
+				//if (current->at_remote) {
+				//	msleep((backoff - 10) * 1);
+				//} else {
+				//	msleep((backoff - 10) * 1);
+				//}
+
+				// case 9
+				//if (current->at_remote) {
+				//if 	msleep((backoff - 10) * 50);
+				//if } else {
+				//if 	msleep((backoff - 10) * 50);
+				//if }
+
+				// case 10
+				//if (current->at_remote) {
+				//	msleep((backoff - 10) * 50);
+				//} else {
+				//	msleep((backoff - 10) * 10);
+				//}
+#else
 				msleep(backoff - 10);
+#endif
 			}
 		} else {
+#ifdef CONFIG_POPCORN_HYPE
+			//if ((current->is_backoff == 1 &&
+			//	(current->at_remote || INTERESTED_GVA(address))) &&
+			//	NOTINTERESTED_GVA(address))
+			if (current->is_backoff > 0)
+			{
+				EPTMPRINTK("\t==[%d] %lx **GOOD ret 0x%lx** **backoffed** "
+						"weight#%d tried#%d MINE %s==\n",
+						current->pid, address, (long)ret, current->backoff_weight,
+						current->is_backoff,
+						page_is_mine_pub(current->mm, address) ? "O" : "X");
+				//printk("\t\t[%d] %01ld DOWN %lx %d\n", current->pid, a, address, in_atomic());
+				current->is_backoff = 0;
+			}
+#endif
 			current->backoff_weight /= 2;
 		}
 		if (ret != VM_FAULT_CONTINUE) return ret;
 	}
+	/* DSM fault rollback to local fault (VM_FAULT_CONTINUE) */
 #endif
 	if (!pte_present(entry)) {
 		if (pte_none(entry)) {
-			if (vma_is_anonymous(vma))
+			if (vma_is_anonymous(vma)) {
+#ifdef CONFIG_POPCORN_HYPE
+				if (current->backoff_weight > 0 && current->at_remote) {
+					printk("  [%d] %lx [[[backoff]]] %d - 1 do_anonymous_page\n",
+						current->pid, address, current->backoff_weight);
+				}
+#endif
 				return do_anonymous_page(mm, vma, address,
 							 pte, pmd, flags);
-			else
-				return do_fault(mm, vma, address, pte, pmd,
+			} else {
+#ifdef CONFIG_POPCORN_HYPE
+				if (current->backoff_weight > 0 && current->at_remote) {
+					printk("  [%d] %lx [[[backoff]]] %d - 2 do_fault\n",
+						current->pid, address, current->backoff_weight);
+				}
+#endif
+				return do_fault(mm, vma, address, pte, pmd, // Jack looking at
 						flags, entry);
+			}
 		}
 #ifdef CONFIG_POPCORN
 		page_server_panic(true, mm, address, pte, entry);
@@ -3354,6 +3617,13 @@ static int handle_pte_fault(struct mm_struct *mm,
 					pte, pmd, flags, entry);
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (current->backoff_weight > 0 && current->at_remote) {
+		printk("  [%d] %lx [[[backoff]]] %d - 3\n",
+			current->pid, address, current->backoff_weight);
+	}
+#endif
+
 	if (pte_protnone(entry))
 		return do_numa_page(mm, vma, address, entry, pte, pmd);
 
@@ -3380,6 +3650,13 @@ static int handle_pte_fault(struct mm_struct *mm,
 		if (flags & FAULT_FLAG_WRITE)
 			flush_tlb_fix_spurious_fault(vma, address);
 	}
+
+#ifdef CONFIG_POPCORN_HYPE
+	if (current->backoff_weight && current->at_remote) {
+		printk("  [%d] %lx backoff %d - 5\n",
+			current->pid, address, current->backoff_weight);
+	}
+#endif
 unlock:
 	pte_unmap_unlock(pte, ptl);
 	return 0;
diff --git a/mm/mempolicy.c b/mm/mempolicy.c
index b777590c3e13..454ac081671f 100644
--- a/mm/mempolicy.c
+++ b/mm/mempolicy.c
@@ -101,6 +101,10 @@
 
 #include "internal.h"
 
+#ifdef CONFIG_POPCORN
+#include <popcorn/types.h>
+#endif
+
 /* Internal flags */
 #define MPOL_MF_DISCONTIG_OK (MPOL_MF_INTERNAL << 0)	/* Skip checks for continuous vmas */
 #define MPOL_MF_INVERT (MPOL_MF_INTERNAL << 1)		/* Invert check for nodemask */
@@ -1183,6 +1187,11 @@ static long do_mbind(unsigned long start, unsigned long len,
 	{
 		NODEMASK_SCRATCH(scratch);
 		if (scratch) {
+#ifdef CONFIG_POPCORN_HYPE
+			if (distributed_process(current)) {
+				BUG(); // $$$
+			}
+#endif
 			down_write(&mm->mmap_sem);
 			task_lock(current);
 			err = mpol_set_nodemask(new, nmask, scratch);
diff --git a/mm/mlock.c b/mm/mlock.c
index 9d2e773f3a95..d75b5232143b 100644
--- a/mm/mlock.c
+++ b/mm/mlock.c
@@ -623,6 +623,14 @@ static int do_mlock(unsigned long start, size_t len, vm_flags_t flags)
 	lock_limit >>= PAGE_SHIFT;
 	locked = len >> PAGE_SHIFT;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		BUG();
+	    //if (INTERESTED_GVA(start)) {
+		//	printk("%s(): [%d] %lx $$$\n", __func__, current->pid, start);
+		//}
+	}
+#endif
 	down_write(&current->mm->mmap_sem);
 
 	locked += current->mm->locked_vm;
@@ -666,6 +674,14 @@ SYSCALL_DEFINE2(munlock, unsigned long, start, size_t, len)
 	len = PAGE_ALIGN(len + (offset_in_page(start)));
 	start &= PAGE_MASK;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		BUG();
+	    //if (INTERESTED_GVA(start)) {
+		//	printk("%s(): [%d] %lx $$$\n", __func__, current->pid, start);
+		//}
+	}
+#endif
 	down_write(&current->mm->mmap_sem);
 	ret = apply_vma_lock_flags(start, len, 0);
 	up_write(&current->mm->mmap_sem);
@@ -737,6 +753,14 @@ SYSCALL_DEFINE1(mlockall, int, flags)
 	lock_limit >>= PAGE_SHIFT;
 
 	ret = -ENOMEM;
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		BUG();
+	    //if (INTERESTED_GVA(start)) {
+		//	printk("%s(): [%d] %lx $$$\n", __func__, current->pid, start);
+		//}
+	}
+#endif
 	down_write(&current->mm->mmap_sem);
 
 	if (!(flags & MCL_CURRENT) || (current->mm->total_vm <= lock_limit) ||
@@ -753,6 +777,14 @@ SYSCALL_DEFINE0(munlockall)
 {
 	int ret;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		BUG();
+	    //if (INTERESTED_GVA(start)) {
+		//	printk("%s(): [%d] %lx $$$\n", __func__, current->pid, start);
+		//}
+	}
+#endif
 	down_write(&current->mm->mmap_sem);
 	ret = apply_mlockall_flags(0);
 	up_write(&current->mm->mmap_sem);
diff --git a/mm/mmap.c b/mm/mmap.c
index 9a0084358929..561069f4c49f 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -54,6 +54,10 @@
 #include <popcorn/vma_server.h>
 #endif
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/hype_kvm.h>
+#endif
+
 #include "internal.h"
 
 #ifndef arch_mmap_check
@@ -1479,6 +1483,7 @@ unsigned long do_mmap(struct file *file, unsigned long addr,
 	return addr;
 }
 
+extern int get_file_path(struct file *file, char *sz, size_t size);
 SYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,
 		unsigned long, prot, unsigned long, flags,
 		unsigned long, fd, unsigned long, pgoff)
@@ -1526,6 +1531,25 @@ SYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,
 		retval = vma_server_mmap_remote(file, addr, len, prot, flags, pgoff);
 		goto out_fput;
 	}
+#ifdef CONFIG_POPCORN_HYPE
+	else if (distributed_process(current)) {
+		/* pophype INTALL vcpu info into hype_node_info[nid][fd] */
+		/* normal mmap doesn't have a FD.
+			This must be for vcpu 3pages mmap in our case */
+		HYPEBOOTDBGPRINTK("\n\n******************************\n");
+		HYPEBOOTDBGPRINTK("%s(): [%d] mmap fd %lu addr %lx (INSTALL MMAP)\n",
+							__func__, my_nid, fd, addr);
+		HYPEBOOTDBGPRINTK("******************************\n\n");
+		if (addr && fd >= FD_START && fd < MAX_POPCORN_VCPU) {
+			// fd some how very high / negtive
+			// or VCPU_FD_BASE
+			hype_node_info[my_nid][fd]->uaddr = addr;
+		}
+		// run
+		// vcpu
+		// vcpu_id
+	}
+#endif
 #endif
 
 	retval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);
@@ -2454,6 +2478,8 @@ find_extend_vma(struct mm_struct *mm, unsigned long addr)
 		return vma;
 	if (!(vma->vm_flags & VM_GROWSDOWN))
 		return NULL;
+
+	/* expand vma->start to start  */
 	start = vma->vm_start;
 	if (expand_stack(vma, addr))
 		return NULL;
@@ -2718,6 +2744,11 @@ int vm_munmap(unsigned long start, size_t len)
 
 #ifdef CONFIG_POPCORN
 	if (distributed_process(current)) {
+#ifdef CONFIG_POPCORN_HYPE
+	    if (INTERESTED_GVA(start)) {
+			POP_PK("%s(): [%d] %lx $$$\n", __func__, current->pid, start);
+		}
+#endif
 		while (!down_write_trylock(&mm->mmap_sem))
 			schedule();
 	} else {
@@ -2941,6 +2972,11 @@ unsigned long vm_brk(unsigned long addr, unsigned long len)
 	unsigned long ret;
 	bool populate;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (INTERESTED_GVA(addr)) {
+		POP_PK("%s(): [%d] %lx $$$\n", __func__, current->pid, addr);
+	}
+#endif
 	down_write(&mm->mmap_sem);
 	ret = do_brk(addr, len);
 	populate = ((mm->def_flags & VM_LOCKED) != 0);
diff --git a/mm/mmu_notifier.c b/mm/mmu_notifier.c
index 5fbdd367bbed..33fcd0a52c67 100644
--- a/mm/mmu_notifier.c
+++ b/mm/mmu_notifier.c
@@ -19,6 +19,12 @@
 #include <linux/sched.h>
 #include <linux/slab.h>
 
+#ifdef CONFIG_POPCORN
+#include <popcorn/types.h>
+//#include "../arch/x86/kvm/trace.h"
+#include "../kernel/popcorn/trace_events.h"
+#endif
+
 /* global SRCU for all MMs */
 static struct srcu_struct srcu;
 
@@ -179,6 +185,12 @@ void __mmu_notifier_invalidate_page(struct mm_struct *mm,
 	struct mmu_notifier *mn;
 	int id;
 
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	/* (USED) DSM pg fault ->
+		__mmu_notifier_invalidate_page -> kvm_mmu_notifier_invalidate_page */
+	//trace_kvm_ept_retry(0, 0, address);
+#endif
+
 	id = srcu_read_lock(&srcu);
 	hlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {
 		if (mn->ops->invalidate_page)
@@ -262,12 +274,26 @@ static int do_mmu_notifier_register(struct mmu_notifier *mn,
 	if (unlikely(!mmu_notifier_mm))
 		goto out;
 
-	if (take_mmap_sem)
+	if (take_mmap_sem) {
+#ifdef CONFIG_POPCORN_HYPE
+		if (distributed_process(current)) {
+			KVMINITRINTK("%s(): [%d] - 1 $$$ down_write()\n", __func__, current->pid);
+		}
+#endif
 		down_write(&mm->mmap_sem);
+	}
+
 	ret = mm_take_all_locks(mm);
 	if (unlikely(ret))
 		goto out_clean;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		KVMINITRINTK("%s(): $$$[%d] %smm_has_notifiers\n",
+					__func__, current->pid, mm_has_notifiers(mm) ? "" : "!");
+	}
+#endif
+
 	if (!mm_has_notifiers(mm)) {
 		INIT_HLIST_HEAD(&mmu_notifier_mm->list);
 		spin_lock_init(&mmu_notifier_mm->lock);
diff --git a/mm/mprotect.c b/mm/mprotect.c
index 12c62604b18d..f878cd65a247 100644
--- a/mm/mprotect.c
+++ b/mm/mprotect.c
@@ -388,6 +388,13 @@ SYSCALL_DEFINE3(mprotect, unsigned long, start, size_t, len,
 
 	vm_flags = calc_vm_prot_bits(prot);
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+	    if (INTERESTED_GVA(start)) {
+			printk("%s(): [%d] %lx $$$\n", __func__, current->pid, start);
+		}
+	}
+#endif
 	down_write(&current->mm->mmap_sem);
 
 	vma = find_vma(current->mm, start);
diff --git a/mm/mremap.c b/mm/mremap.c
index eab6d074126b..7b4b141f3b0c 100644
--- a/mm/mremap.c
+++ b/mm/mremap.c
@@ -510,6 +510,13 @@ SYSCALL_DEFINE5(mremap, unsigned long, addr, unsigned long, old_len,
 	if (!new_len)
 		return ret;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		if (INTERESTED_GVA(addr)) {
+			printk("%s(): [%d] %lx $$$\n", __func__, current->pid, addr);
+		}
+	}
+#endif
 	down_write(&current->mm->mmap_sem);
 
 	if (flags & MREMAP_FIXED) {
diff --git a/mm/rmap.c b/mm/rmap.c
index 1bceb49aa214..fd33b19c3368 100644
--- a/mm/rmap.c
+++ b/mm/rmap.c
@@ -67,6 +67,11 @@
 
 #include "internal.h"
 
+#ifdef CONFIG_POPCORN
+#include <popcorn/types.h>
+#include <popcorn/debug.h>
+#endif
+
 static struct kmem_cache *anon_vma_cachep;
 static struct kmem_cache *anon_vma_chain_cachep;
 
@@ -232,14 +237,29 @@ static inline struct anon_vma *lock_anon_vma_root(struct anon_vma *root, struct
 			up_write(&root->rwsem);
 		root = new_root;
 		down_write(&root->rwsem);
+#ifdef CONFIG_POPCORN_HYPE
+		if (distributed_process(current)) {
+			LKPRINTK("%s() [%d] $$$ down_write(&root->rwsem) %p\n",
+										__func__, current->pid,
+										&root->rwsem);
+		}
+#endif
 	}
 	return root;
 }
 
 static inline void unlock_anon_vma_root(struct anon_vma *root)
 {
-	if (root)
+	if (root) {
 		up_write(&root->rwsem);
+#ifdef CONFIG_POPCORN_HYPE
+		if (distributed_process(current)) {
+			LKPRINTK("%s() [%d] $$$ up_write(&root->rwsem) %p\n",
+										__func__, current->pid,
+										&root->rwsem);
+		}
+#endif
+	}
 }
 
 /*
diff --git a/mm/shmem.c b/mm/shmem.c
index 1b11ccc0a3b7..ea988a06e92e 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -33,6 +33,13 @@
 #include <linux/swap.h>
 #include <linux/uio.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#if !POPHYPE_HOST_KERNEL
+#include <linux/delay.h>
+#endif
+#endif
+
 static struct vfsmount *shm_mnt;
 
 #ifdef CONFIG_SHMEM
@@ -3228,6 +3235,9 @@ static struct file_system_type shmem_fs_type = {
 int __init shmem_init(void)
 {
 	int error;
+#ifdef CONFIG_POPCORN_HYPE
+    SMPBSPPRINTK("<BSP> %s():\n", __func__);
+#endif
 
 	/* If rootfs called this, don't re-init */
 	if (shmem_inode_cachep)
@@ -3237,6 +3247,10 @@ int __init shmem_init(void)
 	if (error)
 		goto out3;
 
+#ifdef CONFIG_POPCORN_HYPE
+    SMPBSPPRINTK("<BSP> %s(): adter shmem_init_inodecache()\n", __func__);
+#endif
+
 	error = register_filesystem(&shmem_fs_type);
 	if (error) {
 		printk(KERN_ERR "Could not register tmpfs\n");
diff --git a/mm/util.c b/mm/util.c
index 5fae5b9c2885..7fd39f09f86b 100644
--- a/mm/util.c
+++ b/mm/util.c
@@ -15,6 +15,10 @@
 #include <asm/sections.h>
 #include <asm/uaccess.h>
 
+#include <popcorn/vma_server.h>
+//#include <popcorn/debug.h>
+#include <popcorn/hype.h>
+
 #include "internal.h"
 
 static inline int is_kernel_rodata(unsigned long addr)
@@ -311,6 +315,17 @@ unsigned long vm_mmap(struct file *file, unsigned long addr,
 	if (unlikely(offset_in_page(offset)))
 		return -EINVAL;
 
+#ifdef CONFIG_POPCORN_HYPE
+#if POPHYPE_PRIVATE_TSS
+	if (!file) {
+		HPPRINTK("vm_mmap() for checking\n");
+		if (distributed_remote_process(current)) {
+			/* anon pg's pgoff = 0 */ // requesing a new one
+			return vma_server_mmap_remote(NULL, addr, len, prot, flag, 0);
+		}
+	}
+#endif
+#endif
 	return vm_mmap_pgoff(file, addr, len, prot, flag, offset >> PAGE_SHIFT);
 }
 EXPORT_SYMBOL(vm_mmap);
diff --git a/msg_layer/common.h b/msg_layer/common.h
index b2364c43a66c..4862bf0442e6 100644
--- a/msg_layer/common.h
+++ b/msg_layer/common.h
@@ -19,6 +19,12 @@
 #include "config.h"
 
 #define MAX_NUM_NODES		ARRAY_SIZE(ip_addresses)
+#define MAX_CONN_PER_NODE	1
+#if (MAX_CONN_PER_NODE > 1)
+#define MULTI_MSG_CANNEL_PER_NODE 1
+#else
+#define MULTI_MSG_CANNEL_PER_NODE 0
+#endif
 
 static uint32_t ip_table[MAX_NUM_NODES] = { 0 };
 
diff --git a/msg_layer/config.h b/msg_layer/config.h
index 435283311371..e8b416f92200 100644
--- a/msg_layer/config.h
+++ b/msg_layer/config.h
@@ -6,8 +6,42 @@
  */
 
 const char *ip_addresses[] = {
-	/* Node 0 */ "10.4.4.100",
-	/* Node 1 */ "10.4.4.101",
+	/* Node 0 */ "10.1.12.120",
+	/* Node 1 */ "10.1.12.121",
+
+//	/* Node 0 */ "10.2.10.17",
+//	/* Node 0 */ "10.2.10.16",
+//	/* Node 1 */ "10.2.10.15",
+//	/* Node 2 */ "10.2.10.14",
+//	/* Node 0 */ "10.2.10.13",
+//	/* Node 0 */ "10.2.10.12",
+//	/* Node 1 */ "10.2.10.11",
+//	/* Node 2 */ "10.2.10.10",
+
+//	/* Node 0 */ "10.1.10.17",
+//	/* Node 0 */ "10.1.10.16",
+//	/* Node 1 */ "10.1.10.15",
+//	/* Node 2 */ "10.1.10.14",
+//	/* Node 0 */ "10.1.10.13",
+//	/* Node 0 */ "10.1.10.12",
+//	/* Node 1 */ "10.1.10.11",
+//	/* Node 2 */ "10.1.10.10",
+
+
+//	/* Node 0 */ "10.2.10.10",
+//	/* Node 0 */ "10.2.10.11",
+//	/* Node 1 */ "10.2.10.12",
+//	/* Node 2 */ "10.2.10.13",
+//	/* Node 0 */ "10.2.10.14",
+//	/* Node 0 */ "10.2.10.15",
+//	/* Node 1 */ "10.2.10.16",
+//	/* Node 2 */ "10.2.10.17",
+
+//	/* Node 0 */ "10.1.10.17",
+//	/* Node 0 */ "10.1.10.16",
+//	/* Node 1 */ "10.1.10.15",
+//	/* Node 2 */ "10.1.10.14",
+	///* Node 3 */ "10.1.12.123",
 	/*   ...  */
 };
 
diff --git a/msg_layer/msg_test.c b/msg_layer/msg_test.c
index 41614070c1aa..1eca5ef984cf 100644
--- a/msg_layer/msg_test.c
+++ b/msg_layer/msg_test.c
@@ -9,13 +9,26 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 
+//#include <popcorn/sync.h>
 #include "../../kernel/popcorn/types.h"
 #include "common.h"
 
-#define MAX_THREADS 32
+#ifdef CONFIG_X86_64
+//#define MAX_THREADS 16
+#else
+//#define MAX_THREADS 96
+#endif
+#define MAX_THREADS 288
+
+
 #define DEFAULT_PAYLOAD_SIZE_KB	4
 #define DEFAULT_NR_ITERATIONS 1
 
+static int cnt = 0; /* 4's remote info */
+#define REMOTE_HANDLE_WRITE_TIME 0
+#define LOCAL_RR_PAGE_TIME 0
+
+
 enum TEST_REQUEST_FLAG {
 	TEST_REQUEST_FLAG_REPLY = 0,
 	TEST_REQUEST_FLAG_RDMA_WRITE = 1,
@@ -37,16 +50,31 @@ DEFINE_PCN_KMSG(test_request_t, TEST_REQUEST_FIELDS);
 	unsigned long flags;
 DEFINE_PCN_KMSG(test_rdma_request_t, TEST_RDMA_REQUEST_FIELDS);
 
+#define TEST_RDMA_DSMRR_REQUEST_FIELDS \
+	dma_addr_t rdma_addr; \
+	u32 rdma_key; \
+	size_t size; \
+	int id; \
+	unsigned long done; \
+	unsigned long flags;
+DEFINE_PCN_KMSG(test_dsmrr_request_t, TEST_RDMA_DSMRR_REQUEST_FIELDS);
+
 #define TEST_RESPONSE_FIELDS \
 	unsigned long done;
 DEFINE_PCN_KMSG(test_response_t, TEST_RESPONSE_FIELDS);
 
+#define TEST_PAGE_RESPONSE_FIELDS \
+	unsigned long done; \
+	int id;
+DEFINE_PCN_KMSG(test_page_response_t, TEST_PAGE_RESPONSE_FIELDS);
 
 enum test_action {
 	TEST_ACTION_SEND = 0,
 	TEST_ACTION_POST,
 	TEST_ACTION_RDMA_WRITE,
 	TEST_ACTION_RDMA_READ,
+	TEST_ACTION_DSM_RR,
+	TEST_ACTION_CLEAR = 9,
 	TEST_ACTION_MAX,
 };
 
@@ -326,35 +354,44 @@ static int kthread_rdma_farm2_data(void* arg0)
 /**
  * Fundamental performance tests
  */
+char per_t_buf[MAX_THREADS][PCN_KMSG_MAX_SIZE];
 static int test_send(void *arg)
 {
 	struct test_params *param = arg;
 	DECLARE_COMPLETION_ONSTACK(done);
-	test_request_t *req;
+	test_request_t *req = (void *)per_t_buf[param->tid];
+	//test_request_t *req;
+	//char buffer[256];
 	int i;
-	char buffer[256];
 	size_t msg_size = PCN_KMSG_SIZE(param->payload_size);
 
+	printk("pid: %d\n", current->pid);
+
 	__barrier_wait(param->barrier);
 	for (i = 0; i < param->nr_iterations; i++) {
+#if 0
 		if (msg_size > sizeof(buffer)) {
-			req = kmalloc(sizeof(msg_size), GFP_KERNEL);
+			//req = kmalloc(sizeof(msg_size), GFP_KERNEL); /* BUG */
+			req = kmalloc(msg_size, GFP_KERNEL);
 			BUG_ON(!req);
 		} else {
 			req = (void *)buffer;
 		}
-
-		req->flags = 0;
-		set_bit(TEST_REQUEST_FLAG_REPLY, &req->flags);
+#endif
+		req->flags = 1;
+//		req->flags = 0;
+//		set_bit(TEST_REQUEST_FLAG_REPLY, &req->flags); // alignment fault on ARM
 		req->done = (unsigned long)&done;
 		*(unsigned long *)req->msg = 0xcafe00dead00beef;
 
 		pcn_kmsg_send(PCN_KMSG_TYPE_TEST_REQUEST, !my_nid, req, msg_size);
 
 		wait_for_completion(&done);
+#if 0
 		if (msg_size > sizeof(buffer)) {
 			kfree(req);
 		}
+#endif
 	}
 	__barrier_wait(param->barrier);
 	return 0;
@@ -371,8 +408,9 @@ static int test_post(void *arg)
 	for (i = 0; i < param->nr_iterations; i++) {
 		req = pcn_kmsg_get(PCN_KMSG_SIZE(param->payload_size));
 
-		req->flags = 0;
-		set_bit(TEST_REQUEST_FLAG_REPLY, &req->flags);
+		req->flags = 1;
+//		req->flags = 0;
+//		set_bit(TEST_REQUEST_FLAG_REPLY, &req->flags); // alignment fault on ARM
 		req->done = (unsigned long)&done;
 		*(unsigned long *)req->msg = 0xcafe00dead00beef;
 
@@ -451,6 +489,333 @@ static int test_rdma_read(void *arg)
 	return 0;
 }
 
+static int test_rdma_dsm_rr(void *arg)
+{
+	int i, my_id;
+	struct test_params *param = arg;
+
+#if LOCAL_RR_PAGE_TIME
+	/* TODO per t */
+	ktime_t dt1, t1e, t1s;
+	ktime_t t2e, t2s;
+	ktime_t t3e, t3s;
+	ktime_t t4e, t4s;
+	ktime_t t5e, t5s;
+	long long t2 = 0, t3 = 0, t4 = 0, t5 = 0;
+#endif
+
+#if 0
+    remote_page_response_t *rp;
+    struct wait_station *ws = get_wait_station(tsk);
+    struct pcn_kmsg_rdma_handle *rh = NULL;
+    remote_page_request_t *req; //
+
+	// t1: get send buffer/rdma buffer from pool
+    req = pcn_kmsg_get(sizeof(*req));
+	req->origin_ws = ws->ws_id;
+
+	rh = pcn_kmsg_pin_rdma_buffer(NULL, PAGE_SIZE);
+	if (IS_ERR(rh)) {
+		pcn_kmsg_put(req);
+		return PTR_ERR(rh);
+	}
+	req->rdma_addr = rh->dma_addr;
+	req->rdma_key = rh->rkey;
+
+	// t1
+
+	// t2
+    pcn_kmsg_post(PCN_KMSG_TYPE_REMOTE_PAGE_REQUEST, //
+					from_nid, req, sizeof(*req));
+	// t2 end
+    rp = wait_at_station(ws);
+#endif
+
+	/* write */
+	DECLARE_COMPLETION_ONSTACK(done);
+	test_dsmrr_request_t *req;
+	struct pcn_kmsg_rdma_handle *rh;
+
+	/* Warm up */
+	req = pcn_kmsg_get(sizeof(*req));
+	rh = pcn_kmsg_pin_rdma_buffer(NULL, PAGE_SIZE); /* max write size */
+	BUG_ON(!rh || !req);
+	req->rdma_addr = rh->dma_addr;
+	req->id = param->tid;
+	req->rdma_key = rh->rkey;
+	req->size = param->payload_size;
+	req->done = (unsigned long)&done;
+	*(unsigned long *)rh->addr = 0xcafecaf00eadcafe; // touch. need?
+//	printk("[%d] %p sent ->\n", req->id, req);
+	pcn_kmsg_post(PCN_KMSG_TYPE_TEST_RDMA_DSMRR_REQUEST,
+							!my_nid, req, sizeof(*req));
+	wait_for_completion(&done);
+	pcn_kmsg_unpin_rdma_buffer(rh);
+	//pcn_kmsg_put(req);
+
+//	printk("[%d] wait barrier\n", req->id);
+	__barrier_wait(param->barrier);
+//	printk("[%d] warmup done = benchmark start\n", req->id);
+#if LOCAL_RR_PAGE_TIME
+	t1s = ktime_get();
+#endif
+	for (i = 0; i < param->nr_iterations; i++) {
+#if LOCAL_RR_PAGE_TIME
+		// t2
+		t2s = ktime_get();
+#endif
+//		printk("[%d] iter %d\n", req->id, i);
+		req = pcn_kmsg_get(sizeof(*req));
+		rh = pcn_kmsg_pin_rdma_buffer(NULL, PAGE_SIZE);
+		req->rdma_addr = rh->dma_addr;
+		req->rdma_key = rh->rkey;
+		req->size = param->payload_size;
+		req->done = (unsigned long)&done;
+		req->id = my_id;
+		//*(unsigned long *)rh->addr = 0xcafecaf00eadcafe; // touch. need?
+#if LOCAL_RR_PAGE_TIME
+		t2e = ktime_get();
+		t2 += ktime_to_ns(ktime_sub(t2e, t2s));
+		// t2
+#endif
+
+#if LOCAL_RR_PAGE_TIME
+		// t3
+		t3s = ktime_get();
+#endif
+		pcn_kmsg_post(PCN_KMSG_TYPE_TEST_RDMA_DSMRR_REQUEST,
+								!my_nid, req, sizeof(*req));
+#if LOCAL_RR_PAGE_TIME
+		t3e = ktime_get();
+		t3 += ktime_to_ns(ktime_sub(t3e, t3s));
+		// t3
+#endif
+
+#if LOCAL_RR_PAGE_TIME
+		// t4
+		t4s = ktime_get();
+#endif
+		wait_for_completion(&done);
+#if LOCAL_RR_PAGE_TIME
+		t4e = ktime_get();
+		t4 += ktime_to_ns(ktime_sub(t4e, t4s));
+		// t4
+#endif
+
+#if LOCAL_RR_PAGE_TIME
+		// t5
+		t5s = ktime_get();
+#endif
+		pcn_kmsg_unpin_rdma_buffer(rh);
+		//pcn_kmsg_put(req);
+#if LOCAL_RR_PAGE_TIME
+		t5e = ktime_get();
+		t5 += ktime_to_ns(ktime_sub(t5e, t5s));
+		// t5
+#endif
+	}
+#if LOCAL_RR_PAGE_TIME
+	t1e = ktime_get();
+	dt1 = ktime_sub(t1e, t1s);
+	//dt2 = ktime_sub(t2e, t2s);
+	//dt3 = ktime_sub(t3e, t3s);
+	//dt4 = ktime_sub(t4e, t4s);
+	//dt5 = ktime_sub(t5e, t5s);
+	/* TODO per t */
+	printk("%s(): dsm rr lat done %lld ns %lld us!!!\n",
+					__func__, ktime_to_ns(dt1) / param->nr_iterations,
+					ktime_to_ns(dt1) / param->nr_iterations / 1000);
+	printk("t2 %lld ns %lld us!!!\n",
+					t2 / param->nr_iterations,
+					t2 / param->nr_iterations / 1000);
+	printk("t3 %lld ns %lld us!!!\n",
+					t3 / param->nr_iterations,
+					t3 / param->nr_iterations / 1000);
+	printk("t4 %lld ns %lld us!!!\n",
+					t4 / param->nr_iterations,
+					t4 / param->nr_iterations / 1000);
+	printk("t5 %lld ns %lld us!!!\n",
+					t5 / param->nr_iterations,
+					t5 / param->nr_iterations / 1000);
+
+
+	printk("\n\n");
+#endif
+
+	//
+	// send
+	//
+#if 0
+	struct test_params *param = arg;
+	DECLARE_COMPLETION_ONSTACK(done);
+	test_request_t *req;
+	int i;
+	char buffer[256];
+	size_t msg_size = PCN_KMSG_SIZE(param->payload_size);
+
+	__barrier_wait(param->barrier);
+	for (i = 0; i < param->nr_iterations; i++) {
+		if (msg_size > sizeof(buffer)) {
+			req = kmalloc(sizeof(msg_size), GFP_KERNEL);
+			BUG_ON(!req);
+		} else {
+			req = (void *)buffer;
+		}
+
+		req->flags = 0;
+		set_bit(TEST_REQUEST_FLAG_REPLY, &req->flags);
+		req->done = (unsigned long)&done;
+		*(unsigned long *)req->msg = 0xcafe00dead00beef;
+
+		pcn_kmsg_send(PCN_KMSG_TYPE_TEST_REQUEST, !my_nid, req, msg_size);
+
+		wait_for_completion(&done);
+		if (msg_size > sizeof(buffer)) {
+			kfree(req);
+		}
+	}
+	__barrier_wait(param->barrier);
+#endif
+	__barrier_wait(param->barrier);
+	return 0;
+}
+
+static int test_clear_all(void *arg)
+{
+	//printk("remove me: cnt brfore = %d\n", cnt);
+	cnt = 0;
+	//printk("remove me: cnt after = %d\n", cnt);
+	return 0;
+}
+
+void *_buffer[MAX_POPCORN_THREADS] = {NULL}; /* For RDMA write */
+/* For remote handling time */
+#define ITER 1000001
+#define ONE_M 1000000
+static void process_test_dsmrr_request(struct work_struct *work)
+{
+
+//  send example from DSM
+//	START_KMSG_WORK(test_request_t, req, work);
+//	if (test_bit(TEST_REQUEST_FLAG_REPLY, &req->flags)) {
+//		test_response_t *res = pcn_kmsg_get(sizeof(*res));
+//		res->done = req->done;
+//
+//		pcn_kmsg_post(PCN_KMSG_TYPE_TEST_RESPONSE,
+//				PCN_KMSG_FROM_NID(req), res, sizeof(*res));
+//	}
+//	END_KMSG_WORK(req);
+
+	int ret;
+	START_KMSG_WORK(test_dsmrr_request_t, req, work);
+	test_page_response_t *res;
+#if REMOTE_HANDLE_WRITE_TIME
+	ktime_t t2e, t2s;
+	ktime_t t3e, t3s;
+	ktime_t t4e, t4s;
+	ktime_t t5e, t5s;
+	static long long t2 = 0, t3 = 0, t4 = 0, t5 = 0;
+#endif
+
+//	printk("->-> recv 4 [%d]\n", req->id);
+
+#if REMOTE_HANDLE_WRITE_TIME
+	// tr2
+	t2s = ktime_get();
+#endif
+	//res = kmalloc(sizeof(*res), GFP_KERNEL);
+	res = pcn_kmsg_get(sizeof(*res));
+	res->done = req->done;
+	res->id = req->id;
+#if REMOTE_HANDLE_WRITE_TIME
+	//*(unsigned long *)_buffer = 0xbaffdeafbeefface; // touch. need?
+	t2e = ktime_get();
+	// tr2
+#endif
+
+#if REMOTE_HANDLE_WRITE_TIME
+	//tr3: directly any kernel_vaddr
+	t3s = ktime_get();
+#endif
+	ret = pcn_kmsg_rdma_write(PCN_KMSG_FROM_NID(req),
+			req->rdma_addr, _buffer[req->id], req->size, req->rdma_key);
+#if REMOTE_HANDLE_WRITE_TIME
+	t3e = ktime_get();
+	//tr3
+#endif
+
+#if REMOTE_HANDLE_WRITE_TIME
+	//tr4
+	t4s = ktime_get();
+#endif
+	pcn_kmsg_post(PCN_KMSG_TYPE_TEST_RDMA_DSMRR_RESPONSE,
+	//pcn_kmsg_send(PCN_KMSG_TYPE_TEST_RDMA_DSMRR_RESPONSE,
+					PCN_KMSG_FROM_NID(req), res, sizeof(*res));
+//	printk("<-<- response 4 [%d]\n", req->id);
+#if REMOTE_HANDLE_WRITE_TIME
+	t4e = ktime_get();
+	// had put *res
+	//tr4
+#endif
+
+#if REMOTE_HANDLE_WRITE_TIME
+	//tr5
+	//free_page((unsigned long)_buffer);
+	t5s = ktime_get();
+#endif
+	//pcn_kmsg_put(res);
+	END_KMSG_WORK(req);
+#if REMOTE_HANDLE_WRITE_TIME
+	t5e = ktime_get();
+	//tr5
+#endif
+
+#if REMOTE_HANDLE_WRITE_TIME
+	t2 += ktime_to_ns(ktime_sub(t2e, t2s));
+	t3 += ktime_to_ns(ktime_sub(t3e, t3s));
+	t4 += ktime_to_ns(ktime_sub(t4e, t4s));
+	t5 += ktime_to_ns(ktime_sub(t5e, t5s));
+
+	cnt++;
+	if (cnt <= 1) {
+		t2 = 0, t3 = 0, t4 = 0, t5 = 0;
+	}
+
+	if (cnt >= ITER) {
+        printk("%s(): t2 %lld ns %lld us!!!\n",
+                        __func__,
+                        t2 / ONE_M,
+                        t2 / ONE_M / 1000);
+        printk("%s(): t3 %lld ns %lld us!!!\n",
+                        __func__,
+                        t3 / ONE_M,
+                        t3 / ONE_M / 1000);
+        printk("%s(): t4 %lld ns %lld us!!!\n",
+                        __func__,
+                        t4 / ONE_M,
+                        t4 / ONE_M / 1000);
+        printk("%s(): t5 %lld ns %lld us!!!\n",
+                        __func__,
+                        t5 / ONE_M,
+                        t5 / ONE_M / 1000);
+	}
+#endif
+}
+
+static int handle_test_dsmrr_response(struct pcn_kmsg_message *msg)
+{
+	//t5
+	test_page_response_t *res = (test_page_response_t *)msg;
+//	printk("-> recv response 4 [%d] \n", res->id);
+	if (res->done) {
+//		printk("-> recv response 4 comp* [%d]\n", res->id);
+		complete((struct completion *)res->done);
+	}
+	//t5
+	pcn_kmsg_done(res);
+	return 0;
+}
+
 static void process_test_rdma_request(struct work_struct *work)
 {
 	START_KMSG_WORK(test_rdma_request_t, req, work);
@@ -488,22 +853,28 @@ static struct test_desc tests[] = {
 	[TEST_ACTION_POST]			= { test_post, "synchronous post" },
 	[TEST_ACTION_RDMA_WRITE]	= { test_rdma_write, "RDMA write" },
 	[TEST_ACTION_RDMA_READ]		= { test_rdma_read, "RDMA read" },
+	[TEST_ACTION_DSM_RR]		= { test_rdma_dsm_rr, "RDMA RR" }, /* 4 */
+	[TEST_ACTION_CLEAR]			= { test_clear_all, "CLEAR ALL" }, /* 9 */
 };
 
 static void __run_test(enum test_action action, struct test_params *param)
 {
-	struct test_params thread_params[MAX_THREADS] = {};
-	struct task_struct *tsks[MAX_THREADS] = { NULL };
+	/* Stack frame over 4k */
+	struct test_params *thread_params; /* test_params thread_params[MAX_THREADS] */
+	struct task_struct **tsks; /* task_struct *tsks[MAX_THREADS] */
 	struct test_barrier barrier;
 	ktime_t t_start, t_end;
 	DECLARE_COMPLETION_ONSTACK(done);
 	unsigned long elapsed;
 	int i;
 
-	printk("Starting testing %s with %lu payload, %u thread%s, %lu iteration%s\n",
-			tests[action].description, param->payload_size,
-			param->nr_threads, param->nr_threads == 1 ? "" : "s",
-			param->nr_iterations, param->nr_iterations == 1 ? "" : "s");
+	thread_params = kzalloc(sizeof(*thread_params) * MAX_THREADS, GFP_KERNEL);
+	tsks = kzalloc(sizeof(struct task_struct*) * MAX_THREADS, GFP_KERNEL);
+	printk("%s: %d %lu %u %lu\n",
+			tests[action].description, action,
+			param->payload_size,
+			param->nr_threads,
+			param->nr_iterations);
 
 	__barrier_init(&barrier, param->nr_threads + 1);
 	param->barrier = &barrier;
@@ -523,14 +894,26 @@ static void __run_test(enum test_action action, struct test_params *param)
 	__barrier_wait(&barrier);
 	t_end = ktime_get();
 
+	kfree(thread_params);
+	kfree(tsks);
 
 	elapsed = ktime_to_ns(ktime_sub(t_end, t_start));
 
-	printk("Done testing %s\n", tests[action].description);
+	//printk("Done testing %s\n", tests[action].description);
 	printk("  %9lu ns in total\n", elapsed);
-	printk("  %3lu.%05lu ns per operation\n",
-			elapsed / param->nr_iterations,
-			(elapsed % param->nr_iterations) * 1000 /  param->nr_iterations);
+	//printk("  %3lu.%05lu ns per operation\n",
+	//		elapsed / param->nr_iterations,
+	//		(elapsed % param->nr_iterations) * 1000 /  param->nr_iterations);
+	printk("lat: %3lu.%05lu us per operation\n",
+		elapsed / param->nr_iterations / 1000,
+		((elapsed % param->nr_iterations) * 1000 * 1000) /
+									(param->nr_iterations));
+
+	printk("tps: %lu MB/s\n",
+			((param->nr_iterations * param->payload_size * param->nr_threads)
+									* (1000 * 1000) /
+											(elapsed / 1000)) // 1/ns * 1000 => 1/us (GB)
+													/ 1000 / 1000);
 }
 
 
@@ -580,8 +963,10 @@ static int __parse_cmd(const char __user *buffer, size_t count, struct test_para
 		if (nr_threads > MAX_THREADS) {
 			printk(KERN_ERR "# of threads cannot be larger than %d\n",
 					MAX_THREADS);
+			params->payload_size = 24;
 			kfree(cmd);
-			return -EINVAL;
+			//return -EINVAL;
+			return 0;
 		}
 		params->nr_threads = nr_threads;
 	}
@@ -596,7 +981,6 @@ static ssize_t start_test(struct file *file, const char __user *buffer, size_t c
 {
 	int ret;
 	int action;
-
 	struct test_params params = {
 		.payload_size = DEFAULT_PAYLOAD_SIZE_KB << 10,
 		.nr_threads = 1,
@@ -611,6 +995,11 @@ static ssize_t start_test(struct file *file, const char __user *buffer, size_t c
 	if (!try_module_get(THIS_MODULE))
 		return -EPERM;
 
+	if (params.nr_threads > MAX_THREADS) {
+		printk("action %d thread exceed %d threads.\n", action, MAX_THREADS);
+		return 0; /* For simplifying script */
+	}
+
 	/* do the coresponding work */
 	switch(action) {
 	case TEST_ACTION_SEND:
@@ -619,12 +1008,20 @@ static ssize_t start_test(struct file *file, const char __user *buffer, size_t c
 		break;
 	case TEST_ACTION_RDMA_WRITE:
 	case TEST_ACTION_RDMA_READ:
+	case TEST_ACTION_DSM_RR:
 		if (pcn_kmsg_has_features(PCN_KMSG_FEATURE_RDMA)) {
-			__run_test(action, &params);
+			if (params.payload_size == PAGE_SIZE)
+				__run_test(action, &params);
+			else
+				printk("action %d only support page size %lu.\n",
+												action, PAGE_SIZE);
 		} else {
 			printk(KERN_ERR "Transport does not support RDMA.\n");
 		}
 		break;
+	case TEST_ACTION_CLEAR:
+		test_clear_all(NULL);
+		break;
 	default:
 		printk("Unknown test no #%d\n", action);
 	}
@@ -641,7 +1038,9 @@ static void __show_usage(void)
 	printk(" Default: %d KB payload, iterate %d time%s, single thread\n",
 			DEFAULT_PAYLOAD_SIZE_KB,
 			DEFAULT_NR_ITERATIONS, DEFAULT_NR_ITERATIONS == 1 ? "" : "s");
-
+	printk("echo 0 4096 16 50000 > /proc/msg_test\n");
+	printk("echo 0 24 1 50000 > /proc/msg_test\n");
+	printk("echo 0 65536 16 50000 > /proc/msg_test\n");
 	printk(" Tests:\n");
 	for (i = 0; i < TEST_ACTION_MAX; i++) {
 		if (!tests[i].test_fn) continue;
@@ -671,13 +1070,20 @@ static struct file_operations kmsg_test_ops = {
 
 DEFINE_KMSG_WQ_HANDLER(test_send_request);
 DEFINE_KMSG_WQ_HANDLER(test_rdma_request);
+DEFINE_KMSG_WQ_HANDLER(test_dsmrr_request);
 
 static struct proc_dir_entry *kmsg_test_proc = NULL;
 
 static int __init msg_test_init(void)
 {
+	int i;
 	printk("\nLoading Popcorn messaging layer tester...\n");
 
+	for (i = 0; i < MAX_POPCORN_THREADS; i++) {
+		_buffer[i] = (void *)__get_free_page(GFP_KERNEL); // move to global
+		BUG_ON(!_buffer[i]);
+	}
+
 #ifdef CONFIG_POPCORN_STAT
 	printk(KERN_WARNING " * You are collecting statistics "
 			"and may get inaccurate performance data now *\n");
@@ -693,15 +1099,23 @@ static int __init msg_test_init(void)
 	REGISTER_KMSG_WQ_HANDLER(PCN_KMSG_TYPE_TEST_REQUEST, test_send_request);
 	REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_TEST_RESPONSE, test_send_response);
 	REGISTER_KMSG_WQ_HANDLER(PCN_KMSG_TYPE_TEST_RDMA_REQUEST, test_rdma_request);
+	REGISTER_KMSG_WQ_HANDLER(PCN_KMSG_TYPE_TEST_RDMA_DSMRR_REQUEST,
+												test_dsmrr_request);
+	REGISTER_KMSG_HANDLER(PCN_KMSG_TYPE_TEST_RDMA_DSMRR_RESPONSE,
+												test_dsmrr_response);
 
 	__show_usage();
 	return 0;
 }
 
-static void __exit msg_test_exit(void) 
+static void __exit msg_test_exit(void)
 {
+	int i;
 	if (kmsg_test_proc) proc_remove(kmsg_test_proc);
 
+	for (i = 0;i < MAX_POPCORN_THREADS; i++)
+		free_page((unsigned long)_buffer[i]);
+
 	printk("Unloaded Popcorn messaging layer tester. Good bye!\n");
 }
 
diff --git a/msg_layer/rdma.c b/msg_layer/rdma.c
index 677800b00668..7a15be0fef1b 100644
--- a/msg_layer/rdma.c
+++ b/msg_layer/rdma.c
@@ -1,6 +1,7 @@
 #include <linux/module.h>
 #include <linux/bitmap.h>
 #include <linux/seq_file.h>
+#include <linux/delay.h>
 
 #include <rdma/rdma_cm.h>
 #include <popcorn/stat.h>
@@ -11,9 +12,30 @@
 #define RDMA_PORT 11453
 #define RDMA_ADDR_RESOLVE_TIMEOUT_MS 5000
 
+#define DEVELOP_DBG 1
+#if DEVELOP_DBG
+#define DEVPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#else
+#define DEVPRINTK(...)
+#endif
+
+#define SENDRECV_DBG 0
+#if SENDRECV_DBG
+#define SRPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#else
+#define SRPRINTK(...)
+#endif
+
+
+#if MULTI_MSG_CANNEL_PER_NODE
+//static atomic_t send_rond_robin[MAX_NUM_NODES] = { ATOMIC_INIT(0) };
+//static atomic_t write_rond_robin[MAX_NUM_NODES] = { ATOMIC_INIT(0) };
+#endif
+
+/* this is related to rb size */
 #define MAX_RECV_DEPTH	((PAGE_SIZE << (MAX_ORDER - 1)) / PCN_KMSG_MAX_SIZE)
 #define MAX_SEND_DEPTH	(MAX_RECV_DEPTH)
-#define RDMA_SLOT_SIZE	(PAGE_SIZE * 2)
+#define RDMA_SLOT_SIZE	(PAGE_SIZE * 2) // Max per RDMA region size
 #define NR_RDMA_SLOTS	((PAGE_SIZE << (MAX_ORDER - 1)) / RDMA_SLOT_SIZE)
 
 static unsigned int use_rb_thr = PAGE_SIZE / 2;
@@ -59,6 +81,7 @@ struct rdma_work {
 
 struct rdma_handle {
 	int nid;
+	unsigned int channel;
 	enum {
 		RDMA_INIT,
 		RDMA_ADDR_RESOLVED,
@@ -70,9 +93,10 @@ struct rdma_handle {
 	} state;
 	struct completion cm_done;
 
-	struct recv_work *recv_works;
-	void *recv_buffer;
-	dma_addr_t recv_buffer_dma_addr;
+	/* Support multi continuous phy addr mem regions */
+	struct recv_work *recv_works[MSG_POOL_SIZE];
+	void *recv_buffer[MSG_POOL_SIZE];
+	dma_addr_t recv_buffer_dma_addr[MSG_POOL_SIZE];
 
 	struct rdma_cm_id *cm_id;
 	struct ib_device *device;
@@ -81,11 +105,13 @@ struct rdma_handle {
 };
 
 /* RDMA handle for each node */
-static struct rdma_handle *rdma_handles[MAX_NUM_NODES] = { NULL };
+static struct rdma_handle *rdma_handles[MAX_NUM_NODES][MAX_CONN_PER_NODE];
+//= { NULL }; // warnning
+/* Jack TODO: multi conn to a node - rdma_handles[MAX_NUM_NODES][MAX_CONN]*/
 
 /* Global protection domain (pd) and memory region (mr) */
-static struct ib_pd *rdma_pd = NULL;
-static struct ib_mr *rdma_mr = NULL;
+static struct ib_pd *rdma_pd = NULL; // Jack
+static struct ib_mr *rdma_mr = NULL; // Jack
 
 /* Global RDMA sink */
 static DEFINE_SPINLOCK(__rdma_slots_lock);
@@ -145,8 +171,20 @@ static struct send_work *__get_send_work_map(struct pcn_kmsg_message *msg, size_
 	struct send_work *sw;
 	void *map_start = NULL;
 
+retry:
+	/* get a send work */
 	spin_lock_irqsave(&send_work_pool_lock, flags);
-	BUG_ON(!send_work_pool);
+	if (!send_work_pool) {
+		dump_stack();
+		spin_unlock_irqrestore(&send_work_pool_lock, flags);
+		printk(KERN_WARNING "send_work pool full type %d\n", msg->header.type);
+		BUG_ON("maybe not recycling correctly");
+		/* performance related */
+		/* 64k will triger this bug (req addr more -> get_work more) */
+		//io_schedule();
+		udelay(100); /* rr msg usually takes only xx us */
+		goto retry;
+	}
 	sw = send_work_pool;
 	send_work_pool = sw->next;
 	spin_unlock_irqrestore(&send_work_pool_lock, flags);
@@ -154,20 +192,43 @@ static struct send_work *__get_send_work_map(struct pcn_kmsg_message *msg, size_
 	sw->done = NULL;
 	sw->flags = 0;
 
+	/* Get a buf */
 	if (!msg) {
 		struct rb_alloc_header *ah;
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+        static unsigned long cnt2 = 0;
+#endif
 		sw->addr = ring_buffer_get_mapped(&send_buffer,
 				sizeof(struct rb_alloc_header) + size, &sw->sgl.addr);
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+        cnt2++;
+        if (!(cnt2 % 2000) || cnt2 < 100)
+            printk("rb util: %lu %lu #%lu\n",
+					ring_buffer_usage(&send_buffer),
+					send_buffer.used, cnt2);
+        if (!(cnt2 % 10000)) {
+			dump_stack();
+			printk("\n");
+		}
+#endif
 		if (likely(sw->addr)) {
 			sw->sgl.addr += sizeof(struct rb_alloc_header);
 		} else {
 			/* Fall back to kmalloc in case of buffer full */
 #ifdef CONFIG_POPCORN_CHECK_SANITY
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
 			if (WARN_ON_ONCE("ring buffer is full")) {
-				printk(KERN_WARNING"ring buffer utilization: %lu\n",
-					ring_buffer_usage(&send_buffer));
+				static unsigned long cnt = 0;
+				if (!(cnt % 2000)) {
+					printk(KERN_WARNING"rb util: %lu %lu #%lu\n",
+							ring_buffer_usage(&send_buffer),
+							send_buffer.used, cnt);
+					dump_stack();
+				}
+				cnt++;
 			}
 #endif
+#endif
 			sw->addr = kmalloc(
 					sizeof(struct rb_alloc_header) + size, GFP_ATOMIC);
 			BUG_ON(!sw->addr);
@@ -217,7 +278,21 @@ static void __put_send_work(struct send_work *sw)
 		if (unlikely(test_bit(SW_FLAG_MAPPED, &sw->flags))) {
 			kfree(sw->addr);
 		} else {
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+//			static unsigned long cnt = 0;
+#endif
 			ring_buffer_put(&send_buffer, sw->addr);
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+//			cnt++;
+//			if (!(cnt % 2000) || cnt < 100)
+//				printk("(health put) rb util: %lu %lu #%lu\n",
+//						ring_buffer_usage(&send_buffer),
+//						send_buffer.used, cnt);
+//			if (!(cnt % 10000)) {
+//				dump_stack();
+//				printk("\n");
+//			}
+#endif
 		}
 	}
 
@@ -326,17 +401,91 @@ void rdma_kmsg_put(struct pcn_kmsg_message *msg)
 	__put_send_work(sw);
 }
 
+#ifdef CONFIG_POPCORN_STAT_MSG
+atomic64_t recv_cq_cnt = ATOMIC64_INIT(0);
+atomic64_t rdma_write_cnt = ATOMIC64_INIT(0);
+
+atomic64_t t_cq_sig_handle = ATOMIC64_INIT(0);
+atomic64_t t_cq_handle_end = ATOMIC64_INIT(0);
+// t_cq_sig_handle = signal to __process_recv // poll_cq
+// t_cq_handle_end = after __process to ib_req_notify_cq end
+
+atomic64_t t_rdma_w_prepare = ATOMIC64_INIT(0);
+atomic64_t t_rdma_w_post = ATOMIC64_INIT(0);
+atomic64_t t_rdma_w_wait = ATOMIC64_INIT(0);
+atomic64_t t_rdma_w_clean = ATOMIC64_INIT(0);
+#define MICROSECOND 1000000
+#define NANOSECOND 1000000000
+#endif
 void rdma_kmsg_stat(struct seq_file *seq, void *v)
 {
 	if (seq) {
 		seq_printf(seq, POPCORN_STAT_FMT,
 				(unsigned long long)ring_buffer_usage(&send_buffer),
-#ifdef CONFIG_POPCORN_STAT
+#ifdef CONFIG_POPCORN_STAT_MSG
 				(unsigned long long)send_buffer.peak_usage,
 #else
 				0ULL,
 #endif
 				"Send buffer usage");
+
+#ifdef CONFIG_POPCORN_STAT_MSG
+		/* rdma_write */
+		seq_printf(seq, "%4s  %7ld.%09ld (s)  %3s %-10ld   %3s %-6ld (ns)\n",
+            "wp", (atomic64_read(&t_rdma_w_prepare)) / NANOSECOND,
+                    (atomic64_read(&t_rdma_w_prepare)) % NANOSECOND,
+            "cnt", atomic64_read(&rdma_write_cnt),
+            "per", atomic64_read(&rdma_write_cnt) ?
+		 atomic64_read(&t_rdma_w_prepare)/atomic64_read(&rdma_write_cnt) : 0);
+		seq_printf(seq, "%4s  %7ld.%09ld (s)  %3s %-10ld   %3s %-6ld (ns)\n",
+            "wpo", (atomic64_read(&t_rdma_w_post)) / NANOSECOND,
+                    (atomic64_read(&t_rdma_w_post)) % NANOSECOND,
+            "cnt", atomic64_read(&rdma_write_cnt),
+            "per", atomic64_read(&rdma_write_cnt) ?
+		 atomic64_read(&t_rdma_w_post)/atomic64_read(&rdma_write_cnt) : 0);
+		seq_printf(seq, "%4s  %7ld.%09ld (s)  %3s %-10ld   %3s %-6ld (us)\n",
+            "wwai", (atomic64_read(&t_rdma_w_wait)) / NANOSECOND,
+                    (atomic64_read(&t_rdma_w_wait)) % NANOSECOND,
+//            "wwai", (atomic64_read(&t_rdma_w_wait) / 1000) / MICROSECOND,
+//                    (atomic64_read(&t_rdma_w_wait) / 1000) % MICROSECOND,
+            "cnt", atomic64_read(&rdma_write_cnt),
+            "per", atomic64_read(&rdma_write_cnt) ?
+	 atomic64_read(&t_rdma_w_wait)/atomic64_read(&rdma_write_cnt) / 1000 : 0);
+		seq_printf(seq, "%4s  %7ld.%09ld (s)  %3s %-10ld   %3s %-6ld (ns)\n",
+            "wcln", (atomic64_read(&t_rdma_w_clean)) / NANOSECOND,
+                    (atomic64_read(&t_rdma_w_clean)) % NANOSECOND,
+            "cnt", atomic64_read(&rdma_write_cnt),
+            "per", atomic64_read(&rdma_write_cnt) ?
+		 atomic64_read(&t_rdma_w_clean)/atomic64_read(&rdma_write_cnt) : 0);
+
+		/* cq */
+		seq_printf(seq, "%4s  %7ld.%09ld (s)  %3s %-10ld   %3s %-6ld (ns)\n",
+            "cqsi", (atomic64_read(&t_cq_sig_handle)) / NANOSECOND,
+                    (atomic64_read(&t_cq_sig_handle)) % NANOSECOND,
+            "cnt", atomic64_read(&recv_cq_cnt),
+            "per", atomic64_read(&recv_cq_cnt) ?
+		atomic64_read(&t_cq_sig_handle)/atomic64_read(&recv_cq_cnt) : 0);
+		seq_printf(seq, "%4s  %7ld.%09ld (s)  %3s %-10ld   %3s %-6ld (ns)\n",
+            "cqed", (atomic64_read(&t_cq_handle_end)) / NANOSECOND,
+                    (atomic64_read(&t_cq_handle_end)) % NANOSECOND,
+            "cnt", atomic64_read(&recv_cq_cnt),
+            "per", atomic64_read(&recv_cq_cnt) ?
+		 atomic64_read(&t_cq_handle_end)/atomic64_read(&recv_cq_cnt) : 0);
+#endif
+	} else {
+#ifdef CONFIG_POPCORN_STAT_MSG
+		atomic64_set(&recv_cq_cnt, 0);
+		atomic64_set(&rdma_write_cnt, 0);
+
+		atomic64_set(&t_cq_sig_handle, 0);
+		atomic64_set(&t_cq_handle_end, 0);
+
+		atomic64_set(&t_rdma_w_prepare, 0);
+		atomic64_set(&t_rdma_w_post, 0);
+		atomic64_set(&t_rdma_w_wait, 0);
+		atomic64_set(&t_rdma_w_clean, 0);
+
+#endif
 	}
 }
 
@@ -346,9 +495,41 @@ void rdma_kmsg_stat(struct seq_file *seq, void *v)
  */
 static int __send_to(int to_nid, struct send_work *sw, size_t size)
 {
-	struct rdma_handle *rh = rdma_handles[to_nid];
-	struct ib_send_wr *bad_wr = NULL;
 	int ret;
+	struct ib_send_wr *bad_wr = NULL;
+	int channel;
+	struct rdma_handle *rh;
+/*
+	if (MAX_CONN_PER_NODE > 1) {
+		//int atomic_val = atomic_inc_return(&send_rond_robin[to_nid]);
+		//channel = atomic_val % (MAX_CONN_PER_NODE);
+		//DEVPRINTK("-> send dbg: atomic_val %d mod this %d channel %d\n", atomic_val, (MAX_CONN_PER_NODE), channel);
+		channel = atomic_inc_return(&send_rond_robin[to_nid]) %
+													MAX_CONN_PER_NODE;
+	} else {
+		channel = 0;
+	}
+*/
+#if MULTI_MSG_CANNEL_PER_NODE
+	// too much overhead
+	//channel = atomic_inc_return(&send_rond_robin[to_nid]) %
+	//											MAX_CONN_PER_NODE;
+	channel = current->pid % MAX_CONN_PER_NODE;
+#else
+	channel = 0;
+#endif
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+    BUG_ON(channel < 0);
+#endif
+
+
+	rh = rdma_handles[to_nid][channel];
+#if MULTI_CONN_PER_NODE
+	((struct pcn_kmsg_message *)sw->addr)->header.channel = channel;
+#endif
+	//msg->header.from_nid = my_nid;
+	SRPRINTK("-> send: to_nid %d channel %u\n", to_nid, channel);
+
 
 #ifdef CONFIG_POPCORN_CHECK_SANITY
 	BUG_ON(size > sw->sgl.length);
@@ -432,7 +613,7 @@ struct pcn_kmsg_rdma_handle *rdma_kmsg_pin_rdma_buffer(void *msg, size_t size)
 		return ERR_PTR(-EINVAL);
 	}
 #endif
-	rh->rkey = rdma_mr->rkey;
+	rh->rkey = rdma_mr->rkey; // Jack
 	rh->private = (void *)
 		(unsigned long)__get_rdma_buffer(&rh->addr, &rh->dma_addr);
 
@@ -448,35 +629,91 @@ void rdma_kmsg_unpin_rdma_buffer(struct pcn_kmsg_rdma_handle *handle)
 int rdma_kmsg_write(int to_nid, dma_addr_t rdma_addr, void *addr, size_t size, u32 rdma_key)
 {
 	DECLARE_COMPLETION_ONSTACK(done);
-	struct rdma_work *rw;
 	struct ib_send_wr *bad_wr = NULL;
-
+	struct rdma_work *rw;
 	dma_addr_t dma_addr;
 	int ret;
+	int channel;
+#ifdef CONFIG_POPCORN_STAT_MSG
+	ktime_t t5e, t5s;
+	ktime_t t4e, t4s;
+	ktime_t t3e, t3s;
+	ktime_t t2e, t2s = ktime_get();
+#endif
+
+/*
+	if (MAX_CONN_PER_NODE > 1) {
+		//int atomic_val = atomic_inc_return(&write_rond_robin[to_nid]);
+		//channel = atomic_val % (MAX_CONN_PER_NODE);
+		//DEVPRINTK("-> write dbg: atomic_val %d mod this %d channel %d\n", atomic_val, (MAX_CONN_PER_NODE), channel);
+		channel = atomic_inc_return(&write_rond_robin[to_nid]) %
+													MAX_CONN_PER_NODE;
+	} else {
+		channel = 0;
+	}
+*/
+#if MULTI_MSG_CANNEL_PER_NODE
+	//channel = atomic_inc_return(&write_rond_robin[to_nid]) %
+	//											MAX_CONN_PER_NODE;
+	channel = current->pid % MAX_CONN_PER_NODE;
+#else
+	channel = 0;
+#endif
+
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+    BUG_ON(channel < 0);
+#endif
+
 
 	dma_addr = ib_dma_map_single(rdma_mr->device, addr, size, DMA_TO_DEVICE);
 	ret = ib_dma_mapping_error(rdma_mr->device, dma_addr);
 	BUG_ON(ret);
 
+	/* rdma_key done by "rdma_kmsg_pin_rdma_buffer()" */
 	rw = __get_rdma_work(dma_addr, size, rdma_addr, rdma_key);
 	BUG_ON(!rw);
 
 	rw->done = &done;
+#ifdef CONFIG_POPCORN_STAT_MSG
+	t2e = ktime_get();
+	atomic64_add(ktime_to_ns(ktime_sub(t2e, t2s)), &t_rdma_w_prepare);
 
-	ret = ib_post_send(rdma_handles[to_nid]->qp, &rw->wr.wr, &bad_wr);
+	t3s = ktime_get();
+#endif
+	ret = ib_post_send(rdma_handles[to_nid][channel]->qp, &rw->wr.wr, &bad_wr);
 	if (ret || bad_wr) {
 		printk("Cannot post rdma write, %d, %p\n", ret, bad_wr);
 		if (ret == 0) ret = -EINVAL;
 		goto out;
 	}
+#ifdef CONFIG_POPCORN_STAT_MSG
+	t3e = ktime_get();
+	atomic64_add(ktime_to_ns(ktime_sub(t3e, t3s)), &t_rdma_w_post);
+
+	t4s = ktime_get();
+#endif
 	/* XXX polling??? */
 	if (!try_wait_for_completion(&done)) {
 		wait_for_completion(&done);
 	}
+#ifdef CONFIG_POPCORN_STAT_MSG
+	t4e = ktime_get();
+	atomic64_add(ktime_to_ns(ktime_sub(t4e, t4s)), &t_rdma_w_wait);
+
+	atomic64_inc(&rdma_write_cnt);
+#endif
 
 out:
+#ifdef CONFIG_POPCORN_STAT_MSG
+	t5s = ktime_get();
+#endif
 	ib_dma_unmap_single(rdma_mr->device, dma_addr, size, DMA_TO_DEVICE);
 	__put_rdma_work(rw);
+#ifdef CONFIG_POPCORN_STAT_MSG
+	t5e = ktime_get();
+	atomic64_add(ktime_to_ns(ktime_sub(t5e, t5s)), &t_rdma_w_clean);
+#endif
+
 	return ret;
 }
 
@@ -492,17 +729,49 @@ int rdma_kmsg_read(int from_nid, void *addr, dma_addr_t rdma_addr, size_t size,
 void rdma_kmsg_done(struct pcn_kmsg_message *msg)
 {
 	/* Put back the receive work */
-	int ret;
+	int ret, i, index;
 	struct ib_recv_wr *bad_wr = NULL;
 	int from_nid = PCN_KMSG_FROM_NID(msg);
-	struct rdma_handle *rh = rdma_handles[from_nid];
-	int index = ((void *)msg - rh->recv_buffer) / PCN_KMSG_MAX_SIZE;
+#if MULTI_CONN_PER_NODE
+	unsigned int channel = msg->header.channel;
+#else
+	unsigned int channel = 0;
+#endif
+	struct rdma_handle *rh = rdma_handles[from_nid][channel]; // iter
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	bool found = false;
+#endif
+
+	SRPRINTK("\t<- recv: kmsg_done: from_nid %d channel %u\n",
+												from_nid, channel);
+
+	/* Look for the right pool */
+	for (i = 0; i < MSG_POOL_SIZE ;i++) {
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+		if (!rh->recv_buffer[i]) continue;
+#endif
+		if ((void *)msg >= rh->recv_buffer[i] &&
+			(void *)msg < rh->recv_buffer[i] + (PAGE_SIZE << (MAX_ORDER - 1))) {
+			index = ((void *)msg - rh->recv_buffer[i]) / PCN_KMSG_MAX_SIZE;
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+			found = true;
+#endif
+			break;
+		} // else { /* try next */ }
+	}
 
 #ifdef CONFIG_POPCORN_CHECK_SANITY
+	if (index < 0 || index >= MAX_RECV_DEPTH || !found) {
+		printk(KERN_WARNING "i %d idx %d\n", i, index);
+		PCNPRINTK_ERR("\t<- (warnning)recv: kmsg_done: "
+								"from_nid %d channel %u\n",
+										from_nid, channel);
+	}
+	BUG_ON(!found);
 	BUG_ON(index < 0 || index >= MAX_RECV_DEPTH);
 #endif
 
-	ret = ib_post_recv(rh->qp, &rh->recv_works[index].wr, &bad_wr);
+	ret = ib_post_recv(rh->qp, &rh->recv_works[i][index].wr, &bad_wr);
 	BUG_ON(ret || bad_wr);
 }
 
@@ -541,8 +810,14 @@ static void __process_comp_wakeup(struct ib_wc *wc, const char *msg)
 static void __process_faulty_work(struct ib_wc *wc)
 {
 	struct work_header *header = (struct work_header *)wc->wr_id;
-
-	printk("abnormal status %d with %d, %p\n", wc->status, wc->opcode, header);
+#ifdef CONFIG_POPCORN_STAT /* pophype for developing */
+	static unsigned long cnt = 0;
+	cnt++;
+	if (cnt < 20)
+#endif
+	{
+		printk("abnormal status %d with %d, %p\n", wc->status, wc->opcode, header);
+	}
 	switch(header->type) {
 	case WORK_TYPE_SEND: {
 		struct send_work *w = (struct send_work *)wc->wr_id;
@@ -559,7 +834,12 @@ static void __process_faulty_work(struct ib_wc *wc)
 	}
 	case WORK_TYPE_RECV: {
 		struct recv_work *w = (struct recv_work *)wc->wr_id;
-		printk("  type: recv, %llx + %d\n", w->sgl.addr, w->sgl.length);
+#ifdef CONFIG_POPCORN_STAT /* pophype for developing */
+		if (cnt < 20)
+#endif
+		{
+			printk("  type: recv, %llx + %d\n", w->sgl.addr, w->sgl.length);
+		}
 		break;
 	}
 	case WORK_TYPE_RDMA: {
@@ -577,8 +857,15 @@ void cq_comp_handler(struct ib_cq *cq, void *context)
 {
 	int ret;
 	struct ib_wc wc;
+#ifdef CONFIG_POPCORN_STAT_MSG
+	ktime_t t3e, t3s;
+	ktime_t t2e, t2s;
+#endif
 
 retry:
+#ifdef CONFIG_POPCORN_STAT_MSG
+	t2s = ktime_get();
+#endif
 	while ((ret = ib_poll_cq(cq, 1, &wc)) > 0) {
 		if (wc.opcode < 0 || wc.status) {
 			__process_faulty_work(&wc);
@@ -589,7 +876,20 @@ retry:
 			__process_sent(&wc);
 			break;
 		case IB_WC_RECV:
+#ifdef CONFIG_POPCORN_STAT_MSG
+			t2e = ktime_get();
+			atomic64_add(ktime_to_ns(ktime_sub(t2e, t2s)), &t_cq_sig_handle);
+#endif
+
+#if MULTI_CONN_PER_NODE
+			((struct pcn_kmsg_message *)(((struct recv_work *)(wc.wr_id))->addr))->header.channel = *((unsigned int *)cq->cq_context);
+#endif
+//			printk("<- recv: cq->cq_context = %d (%p)\n",
+//					*((int *)cq->cq_context), cq->cq_context);
 			__process_recv(&wc);
+#ifdef CONFIG_POPCORN_STAT_MSG
+			t3s = ktime_get();
+#endif
 			break;
 		case IB_WC_RDMA_WRITE:
 		case IB_WC_RDMA_READ:
@@ -602,8 +902,18 @@ retry:
 			printk("Unknown completion op %d\n", wc.opcode);
 			break;
 		}
+#ifdef CONFIG_POPCORN_STAT_MSG
+		t2s = ktime_get();
+#endif
 	}
 	ret = ib_req_notify_cq(cq, IB_CQ_NEXT_COMP | IB_CQ_REPORT_MISSED_EVENTS);
+#ifdef CONFIG_POPCORN_STAT_MSG
+	if (wc.opcode == IB_WC_RECV) {
+		t3e = ktime_get();
+		atomic64_add(ktime_to_ns(ktime_sub(t3e, t3s)), &t_cq_handle_end);
+		atomic64_inc(&recv_cq_cnt);
+	}
+#endif
 	if (ret > 0) goto retry;
 }
 
@@ -625,24 +935,32 @@ static __init int __setup_pd_cq_qp(struct rdma_handle *rh)
 			rdma_pd = NULL;
 			goto out_err;
 		}
+		DEVPRINTK("ib_alloc_pd pass\n");
 	}
 
 	/* create completion queue */
 	if (!rh->cq) {
 		struct ib_cq_init_attr cq_attr = {
-			.cqe = MAX_SEND_DEPTH + MAX_RECV_DEPTH + NR_RDMA_SLOTS,
+			.cqe = (MAX_SEND_DEPTH) +
+					(MAX_RECV_DEPTH * MSG_POOL_SIZE) + NR_RDMA_SLOTS,
 			.comp_vector = 0,
 		};
 
-		rh->cq = ib_create_cq(
-				rh->device, cq_comp_handler, NULL, rh, &cq_attr);
+		DEVPRINTK("createing cq rh->channel %d\n", rh->channel);
+		rh->cq = ib_create_cq(rh->device,
+			cq_comp_handler, (void *)&(rh->channel), rh, &cq_attr);
 		if (IS_ERR(rh->cq)) {
 			ret = PTR_ERR(rh->cq);
 			goto out_err;
 		}
+		DEVPRINTK("ib_create_cq pass\n");
+
+		/* Manually copy channel_id to rh->cq for handler usage */
+		rh->cq->cq_context = &(rh->channel);
 
 		ret = ib_req_notify_cq(rh->cq, IB_CQ_NEXT_COMP);
 		if (ret < 0) goto out_err;
+		DEVPRINTK("rdma_create_cq pass\n");
 	}
 
 	/* create queue pair */
@@ -651,21 +969,42 @@ static __init int __setup_pd_cq_qp(struct rdma_handle *rh)
 			.event_handler = NULL, // qp_event_handler,
 			.qp_context = rh,
 			.cap = {
-				.max_send_wr = MAX_SEND_DEPTH,
-				.max_recv_wr = MAX_RECV_DEPTH + NR_RDMA_SLOTS,
-				.max_send_sge = PCN_KMSG_MAX_SIZE >> PAGE_SHIFT,
-				.max_recv_sge = PCN_KMSG_MAX_SIZE >> PAGE_SHIFT,
-			},
+					.max_send_wr = (MAX_SEND_DEPTH * MSG_POOL_SIZE),
+					.max_recv_wr = (MAX_RECV_DEPTH * MSG_POOL_SIZE) + NR_RDMA_SLOTS,
+					.max_send_sge = (PCN_KMSG_MAX_SIZE >> PAGE_SHIFT), // per msg
+					.max_recv_sge = (PCN_KMSG_MAX_SIZE >> PAGE_SHIFT), // per msg
+				},
 			.sq_sig_type = IB_SIGNAL_REQ_WR,
 			.qp_type = IB_QPT_RC,
 			.send_cq = rh->cq,
 			.recv_cq = rh->cq,
 		};
 
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+		struct ib_device_attr dev_cap;
+		int rc;
+		rc = ib_query_device(rh->device, &dev_cap);
+		BUG_ON(rc);
+		printk("dev_cap.max_qp_wr %d dev_cap.max_sge %d\n",
+						dev_cap.max_qp_wr, dev_cap.max_sge);
+		printk("msg_pools %d DEPTH s %lu r %lu rdma slot %lu max_kmsg_size %lu\n",
+								MSG_POOL_SIZE, MAX_SEND_DEPTH,
+								MAX_RECV_DEPTH, NR_RDMA_SLOTS, PCN_KMSG_MAX_SIZE);
+		printk("s %lu r %lu ssg %lu rsg %lu\n", MAX_SEND_DEPTH * MSG_POOL_SIZE,
+						(MAX_RECV_DEPTH * MSG_POOL_SIZE) + NR_RDMA_SLOTS,
+						(PCN_KMSG_MAX_SIZE >> PAGE_SHIFT),
+						(PCN_KMSG_MAX_SIZE >> PAGE_SHIFT));
+		BUG_ON(qp_attr.cap.max_send_wr > dev_cap.max_qp_wr ||
+				qp_attr.cap.max_recv_wr  > dev_cap.max_qp_wr ||
+				qp_attr.cap.max_send_sge > dev_cap.max_sge ||
+				qp_attr.cap.max_recv_sge > dev_cap.max_sge);
+#endif
+
 		ret = rdma_create_qp(rh->cm_id, rdma_pd, &qp_attr);
 		if (ret) goto out_err;
 		rh->qp = rh->cm_id->qp;
 	}
+	DEVPRINTK("rdma_create_qp pass\n");
 	return 0;
 
 out_err:
@@ -674,61 +1013,69 @@ out_err:
 
 static __init int __setup_buffers_and_pools(struct rdma_handle *rh)
 {
-	int ret = 0, i;
+	int ret = 0, i, j;
 	dma_addr_t dma_addr;
 	char *recv_buffer = NULL;
 	struct recv_work *rws = NULL;
 	const size_t buffer_size = PCN_KMSG_MAX_SIZE * MAX_RECV_DEPTH;
 
-	/* Initalize receive buffers */
-	recv_buffer = kmalloc(buffer_size, GFP_KERNEL);
-	if (!recv_buffer) {
-		return -ENOMEM;
-	}
-	rws = kmalloc(sizeof(*rws) * MAX_RECV_DEPTH, GFP_KERNEL);
-	if (!rws) {
-		ret = -ENOMEM;
-		goto out_free;
-	}
-
-	/* Populate receive buffer and work requests */
-	dma_addr = ib_dma_map_single(
-			rh->device, recv_buffer, buffer_size, DMA_FROM_DEVICE);
-	ret = ib_dma_mapping_error(rh->device, dma_addr);
-	if (ret) goto out_free;
-
-	for (i = 0; i < MAX_RECV_DEPTH; i++) {
-		struct recv_work *rw = rws + i;
-		struct ib_recv_wr *wr, *bad_wr = NULL;
-		struct ib_sge *sgl;
-
-		rw->header.type = WORK_TYPE_RECV;
-		rw->dma_addr = dma_addr + PCN_KMSG_MAX_SIZE * i;
-		rw->addr = recv_buffer + PCN_KMSG_MAX_SIZE * i;
-
-		sgl = &rw->sgl;
-		sgl->lkey = rdma_pd->local_dma_lkey;
-		sgl->addr = rw->dma_addr;
-		sgl->length = PCN_KMSG_MAX_SIZE;
-
-		wr = &rw->wr;
-		wr->sg_list = sgl;
-		wr->num_sge = 1;
-		wr->next = NULL;
-		wr->wr_id = (u64)rw;
+	BUG_ON(buffer_size > (PAGE_SIZE << (MAX_ORDER - 1)));
+	MSGPRINTK("recv pools = %d \n", MSG_POOL_SIZE);
+	for (j = 0; j < MSG_POOL_SIZE; j++) {
+		/* Initalize receive buffers */
+		recv_buffer = kmalloc(buffer_size, GFP_KERNEL);
+		if (!recv_buffer) {
+			return -ENOMEM;
+		}
+		rh->recv_buffer[j] = recv_buffer;
 
-		ret = ib_post_recv(rh->qp, wr, &bad_wr);
-		if (ret || bad_wr) goto out_free;
+		rws = kmalloc(sizeof(*rws) * MAX_RECV_DEPTH, GFP_KERNEL);
+		if (!rws) {
+			ret = -ENOMEM;
+			goto out_free;
+		}
+		rh->recv_works[j] = rws;
+
+		/* Populate receive buffer and work requests */
+		dma_addr = ib_dma_map_single(
+				rh->device, recv_buffer, buffer_size, DMA_FROM_DEVICE);
+		ret = ib_dma_mapping_error(rh->device, dma_addr);
+		if (ret) goto out_free;
+		rh->recv_buffer_dma_addr[j] = dma_addr;
+
+		for (i = 0; i < MAX_RECV_DEPTH; i++) {
+			struct recv_work *rw = rws + i;
+			struct ib_recv_wr *wr, *bad_wr = NULL;
+			struct ib_sge *sgl;
+
+			rw->header.type = WORK_TYPE_RECV;
+			rw->dma_addr = dma_addr + PCN_KMSG_MAX_SIZE * i;
+			rw->addr = recv_buffer + PCN_KMSG_MAX_SIZE * i;
+
+			sgl = &rw->sgl;
+			sgl->lkey = rdma_pd->local_dma_lkey;
+			sgl->addr = rw->dma_addr;
+			sgl->length = PCN_KMSG_MAX_SIZE;
+
+			wr = &rw->wr;
+			wr->sg_list = sgl;
+			wr->num_sge = 1;
+			wr->next = NULL;
+			wr->wr_id = (u64)rw;
+
+			ret = ib_post_recv(rh->qp, wr, &bad_wr);
+			if (ret || bad_wr) goto out_free;
+		}
 	}
-	rh->recv_works = rws;
-	rh->recv_buffer = recv_buffer;
-	rh->recv_buffer_dma_addr = dma_addr;
-
 	return ret;
 
 out_free:
-	if (recv_buffer) kfree(recv_buffer);
-	if (rws) kfree(rws);
+	for (j = 0; j < MSG_POOL_SIZE; j++) {
+		if (rh->recv_buffer[j])
+			kfree(rh->recv_buffer[j]);
+		if (rh->recv_works[j])
+			kfree(rh->recv_works[j]);
+	}
 	return ret;
 }
 
@@ -780,7 +1127,7 @@ static __init int __setup_rdma_buffer(const int nr_chunks)
 	 * rdma_handles[my_nid] is for accepting connection without qp & cp.
 	 * So, let's use rdma_handles[1] for nid 0 and rdma_handles[0] otherwise.
 	 */
-	ret = ib_post_send(rdma_handles[!my_nid]->qp, &reg_wr.wr, &bad_wr);
+	ret = ib_post_send(rdma_handles[!my_nid][0]->qp, &reg_wr.wr, &bad_wr);
 	if (ret || bad_wr) {
 		printk("Cannot register mr, %d %p\n", ret, bad_wr);
 		if (bad_wr) ret = -EINVAL;
@@ -793,7 +1140,7 @@ static __init int __setup_rdma_buffer(const int nr_chunks)
 		goto out_dereg;
 	}
 
-	rdma_mr = mr;
+	rdma_mr = mr; //Jack
 	//printk("lkey: %x, rkey: %x, length: %x\n", mr->lkey, mr->rkey, mr->length);
 	return 0;
 
@@ -823,9 +1170,8 @@ static int __init __setup_work_request_pools(void)
 		if (ret) goto out_unmap;
 		send_buffer.dma_addr_base[i] = dma_addr;
 	}
-
 	/* Initialize send work request pool */
-	for (i = 0; i < MAX_SEND_DEPTH; i++) {
+	for (i = 0; i < MAX_SEND_DEPTH * MSG_POOL_SIZE; i++) {
 		struct send_work *sw;
 
 		sw = kzalloc(sizeof(*sw), GFP_KERNEL);
@@ -845,11 +1191,11 @@ static int __init __setup_work_request_pools(void)
 		sw->wr.num_sge = 1;
 		sw->wr.opcode = IB_WR_SEND;
 		sw->wr.send_flags = IB_SEND_SIGNALED;
+		//sw->id = j; /* does this matter? if not just for MAX_SEND_DEPTH * MSG_POOL_SIZE here in the beginning (=>remove id) - trying now */
 
 		sw->next = send_work_pool;
 		send_work_pool = sw;
 	}
-
 	/* Initalize rdma work request pool */
 	__refill_rdma_work(NR_RDMA_SLOTS);
 	return 0;
@@ -914,11 +1260,14 @@ int cm_client_event_handler(struct rdma_cm_id *cm_id, struct rdma_cm_event *cm_e
 	return 0;
 }
 
-static int __connect_to_server(int nid)
+static int __connect_to_server(int nid, int iter)
 {
 	int ret;
 	const char *step;
-	struct rdma_handle *rh = rdma_handles[nid];
+	struct rdma_handle *rh = rdma_handles[nid][iter]; // MAX_CONN_PER_NODE
+	int my_nid_iter[2] = {my_nid, iter};
+	//my_nid_iter[0] = my_nid
+	//my_nid_iter[1] = iter;
 
 	step = "create rdma id";
 	rh->cm_id = rdma_create_id(&init_net,
@@ -929,21 +1278,21 @@ static int __connect_to_server(int nid)
 	{
 		struct sockaddr_in addr = {
 			.sin_family = AF_INET,
-			.sin_port = htons(RDMA_PORT),
+			.sin_port = htons(RDMA_PORT + iter), // MAX_CONN_PER_NODE
 			.sin_addr.s_addr = ip_table[nid],
 		};
 
 		ret = rdma_resolve_addr(rh->cm_id, NULL,
 				(struct sockaddr *)&addr, RDMA_ADDR_RESOLVE_TIMEOUT_MS);
 		if (ret) goto out_err;
-		ret = wait_for_completion_interruptible(&rh->cm_done);
+		ret = wait_for_completion_interruptible(&rh->cm_done); // per conn
 		if (ret || rh->state != RDMA_ADDR_RESOLVED) goto out_err;
 	}
 
 	step = "resolve routing path";
 	ret = rdma_resolve_route(rh->cm_id, RDMA_ADDR_RESOLVE_TIMEOUT_MS);
 	if (ret) goto out_err;
-	ret = wait_for_completion_interruptible(&rh->cm_done);
+	ret = wait_for_completion_interruptible(&rh->cm_done); // per conn
 	if (ret || rh->state != RDMA_ROUTE_RESOLVED) goto out_err;
 
 	/* cm_id->device is valid after the address and route are resolved */
@@ -960,14 +1309,16 @@ static int __connect_to_server(int nid)
 	step = "connect";
 	{
 		struct rdma_conn_param conn_param = {
-			.private_data = &my_nid,
-			.private_data_len = sizeof(my_nid),
+			//.private_data = &my_nid,
+			//.private_data_len = sizeof(my_nid),
+			.private_data = &my_nid_iter,
+			.private_data_len = sizeof(my_nid_iter),
 		};
 
 		rh->state = RDMA_CONNECTING;
-		ret = rdma_connect(rh->cm_id, &conn_param);
+		ret = rdma_connect(rh->cm_id, &conn_param); // connect to remote
 		if (ret) goto out_err;
-		ret = wait_for_completion_interruptible(&rh->cm_done);
+		ret = wait_for_completion_interruptible(&rh->cm_done); // per conn
 		if (ret) goto out_err;
 		if (rh->state != RDMA_CONNECTED) {
 			ret = -ETIMEDOUT;
@@ -975,11 +1326,11 @@ static int __connect_to_server(int nid)
 		}
 	}
 
-	MSGPRINTK("Connected to %d\n", nid);
+	MSGPRINTK("(Client) connected to %d-%d\n", nid, iter);
 	return 0;
 
 out_err:
-	PCNPRINTK_ERR("Unable to %s, %pI4, %d\n", step, ip_table + nid, ret);
+	PCNPRINTK_ERR("Unable to %s, %pI4 - %d, %d\n", step, ip_table + nid, iter, ret);
 	return ret;
 }
 
@@ -987,9 +1338,9 @@ out_err:
 /****************************************************************************
  * Server-side connection handling
  */
-static int __accept_client(int nid)
+static int __accept_client(int nid, int iter)
 {
-	struct rdma_handle *rh = rdma_handles[nid];
+	struct rdma_handle *rh = rdma_handles[nid][iter];
 	struct rdma_conn_param conn_param = {};
 	int ret;
 
@@ -1014,8 +1365,10 @@ static int __accept_client(int nid)
 }
 static int __on_client_connecting(struct rdma_cm_id *cm_id, struct rdma_cm_event *cm_event)
 {
-	int peer_nid = *(int *)cm_event->param.conn.private_data;
-	struct rdma_handle *rh = rdma_handles[peer_nid];
+	int peer_nid = *((int *)cm_event->param.conn.private_data + 0);
+	int peer_nid_iter = *((int *)cm_event->param.conn.private_data + 1);
+	//int peer_nid_iter = *(int *)cm_event->param.conn.private_data;
+	struct rdma_handle *rh = rdma_handles[peer_nid][peer_nid_iter];
 
 	cm_id->context = rh;
 	rh->cm_id = cm_id;
@@ -1032,7 +1385,7 @@ static int __on_client_connected(struct rdma_cm_id *cm_id, struct rdma_cm_event
 	rh->state = RDMA_CONNECTED;
 	complete(&rh->cm_done);
 
-	MSGPRINTK("Connected to %d\n", rh->nid);
+	MSGPRINTK("(Server) connected to %d-%u\n", rh->nid, rh->channel);
 	return 0;
 }
 
@@ -1066,27 +1419,29 @@ int cm_server_event_handler(struct rdma_cm_id *cm_id, struct rdma_cm_event *cm_e
 	return 0;
 }
 
-static int __listen_to_connection(void)
+static int __listen_to_connection(int iter)
 {
 	int ret;
 	struct sockaddr_in addr = {
 		.sin_family = AF_INET,
-		.sin_port = htons(RDMA_PORT),
+		.sin_port = htons(RDMA_PORT + iter), // MAX_CONN_PER_NODE
 		.sin_addr.s_addr = ip_table[my_nid],
 	};
 
 	struct rdma_cm_id *cm_id = rdma_create_id(&init_net,
 			cm_server_event_handler, NULL, RDMA_PS_IB, IB_QPT_RC);
 	if (IS_ERR(cm_id)) return PTR_ERR(cm_id);
-	rdma_handles[my_nid]->cm_id = cm_id;
+	rdma_handles[my_nid][iter]->cm_id = cm_id; // MAX_CONN_PER_NODE
 
-	ret = rdma_bind_addr(cm_id, (struct sockaddr *)&addr);
+	MSGPRINTK("listening from %d - %d\n", my_nid, iter);
+
+	ret = rdma_bind_addr(cm_id, (struct sockaddr *)&addr); // done by addr
 	if (ret) {
 		PCNPRINTK_ERR("Cannot bind server address, %d\n", ret);
 		return ret;
 	}
 
-	ret = rdma_listen(cm_id, MAX_NUM_NODES);
+	ret = rdma_listen(cm_id, MAX_NUM_NODES * MAX_CONN_PER_NODE);
 	if (ret) {
 		PCNPRINTK_ERR("Cannot listen to incoming requests, %d\n", ret);
 		return ret;
@@ -1098,23 +1453,27 @@ static int __listen_to_connection(void)
 
 static int __establish_connections(void)
 {
-	int i, ret;
+	int i, j, ret;
 
-	ret = __listen_to_connection();
-	if (ret) return ret;
+	for (j = 0; j < MAX_CONN_PER_NODE; j++) {
+		ret = __listen_to_connection(j);
+		if (ret) return ret;
+	}
 
 	/* Wait for a while so that nodes are ready to listen to connections */
 	msleep(100);
 
 	for (i = 0; i < my_nid; i++) {
-		if ((ret = __connect_to_server(i))) return ret;
+		for (j = 0; j < MAX_CONN_PER_NODE; j++)
+			if ((ret = __connect_to_server(i, j))) return ret;
 		set_popcorn_node_online(i, true);
 	}
 
 	set_popcorn_node_online(my_nid, true);
 
 	for (i = my_nid + 1; i < MAX_NUM_NODES; i++) {
-		if ((ret = __accept_client(i))) return ret;
+		for (j = 0; j < MAX_CONN_PER_NODE; j++)
+			if ((ret = __accept_client(i, j))) return ret;
 		set_popcorn_node_online(i, true);
 	}
 
@@ -1124,31 +1483,35 @@ static int __establish_connections(void)
 
 void __exit exit_kmsg_rdma(void)
 {
-	int i;
+	int i, j, k;
 
 	/* Detach from upper layer to prevent race condition during exit */
 	pcn_kmsg_set_transport(NULL);
 
 	for (i = 0; i < MAX_NUM_NODES; i++) {
-		struct rdma_handle *rh = rdma_handles[i];
-		set_popcorn_node_online(i, false);
-		if (!rh) continue;
-
-		if (rh->recv_buffer) {
-			ib_dma_unmap_single(rh->device, rh->recv_buffer_dma_addr,
-					PCN_KMSG_MAX_SIZE * MAX_RECV_DEPTH, DMA_FROM_DEVICE);
-			kfree(rh->recv_buffer);
-			kfree(rh->recv_works);
-		}
+		for (k = 0; k < MAX_CONN_PER_NODE; k++) {
+			struct rdma_handle *rh = rdma_handles[i][k];
+			set_popcorn_node_online(i, false);
+			if (!rh) continue;
+
+			for (j = 0; j < MSG_POOL_SIZE; j++) {
+				if (rh->recv_buffer[j]) {
+					ib_dma_unmap_single(rh->device, rh->recv_buffer_dma_addr[j],
+							PCN_KMSG_MAX_SIZE * MAX_RECV_DEPTH, DMA_FROM_DEVICE);
+					kfree(rh->recv_buffer[j]);
+					kfree(rh->recv_works[j]);
+				}
+			}
 
-		if (rh->qp && !IS_ERR(rh->qp)) rdma_destroy_qp(rh->cm_id);
-		if (rh->cq && !IS_ERR(rh->cq)) ib_destroy_cq(rh->cq);
-		if (rh->cm_id && !IS_ERR(rh->cm_id)) rdma_destroy_id(rh->cm_id);
+			if (rh->qp && !IS_ERR(rh->qp)) rdma_destroy_qp(rh->cm_id);
+			if (rh->cq && !IS_ERR(rh->cq)) ib_destroy_cq(rh->cq);
+			if (rh->cm_id && !IS_ERR(rh->cm_id)) rdma_destroy_id(rh->cm_id);
 
-		kfree(rdma_handles[i]);
+			kfree(rdma_handles[i][k]);
+		}
 	}
 
-	/* MR is set correctly iff rdma buffer and pd are correctly allocated */
+	/* MR is set correctly if rdma buffer and pd are correctly allocated */
 	if (rdma_mr && !IS_ERR(rdma_mr)) {
 		ib_dereg_mr(rdma_mr);
 		ib_dma_unmap_single(rdma_pd->device, __rdma_sink_dma_addr,
@@ -1200,21 +1563,33 @@ struct pcn_kmsg_transport transport_rdma = {
 
 int __init init_kmsg_rdma(void)
 {
-	int i;
+	int i, j;
 
 	MSGPRINTK("\nLoading Popcorn messaging layer over RDMA...\n");
 
+#if MAX_CONN_PER_NODE > 1
+#if !MULTI_CONN_PER_NODE
+	BUG();
+#endif
+#endif
+
 	if (!identify_myself()) return -EINVAL;
 	pcn_kmsg_set_transport(&transport_rdma);
 
 	for (i = 0; i < MAX_NUM_NODES; i++) {
-		struct rdma_handle *rh;
-		rh = rdma_handles[i] = kzalloc(sizeof(struct rdma_handle), GFP_KERNEL);
-		if (!rh) goto out_free;
-
-		rh->nid = i;
-		rh->state = RDMA_INIT;
-		init_completion(&rh->cm_done);
+		//send_rond_robin[i] = ATOMIC_INIT(0);
+		//write_rond_robin[i] = ATOMIC_INIT(0);
+		for (j = 0; j < MAX_CONN_PER_NODE; j++) {
+			struct rdma_handle *rh;
+			rh = rdma_handles[i][j] =
+					kzalloc(sizeof(struct rdma_handle), GFP_KERNEL);
+			if (!rh) goto out_free;
+
+			rh->nid = i;
+			rh->channel = j;
+			rh->state = RDMA_INIT;
+			init_completion(&rh->cm_done);
+		}
 	}
 
 	if (__establish_connections())
diff --git a/msg_layer/ring_buffer.c b/msg_layer/ring_buffer.c
index fd5ae614b344..ac84fefd470a 100644
--- a/msg_layer/ring_buffer.c
+++ b/msg_layer/ring_buffer.c
@@ -8,7 +8,6 @@
 #define RB_HEADER_MAGIC 0xa9
 #endif
 #define RB_ALIGN 64
-#define RB_NR_CHUNKS 8
 
 struct ring_buffer_header {
 	bool reclaim:1;
@@ -22,20 +21,47 @@ size_t ring_buffer_usage(struct ring_buffer *rb)
 {
 	size_t used = 0;
 	unsigned long flags;
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+	static unsigned long cnt = 0;
+	cnt++;
+#endif
 
 	spin_lock_irqsave(&rb->lock, flags);
 	if (rb->head_chunk == rb->tail_chunk) {
 		if (!rb->wraparounded) {
+			/* same chunk (*ptr - *ptr) */
 			used = rb->tail - rb->head;
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+			MSGPRINTK("used 1-1 chunk[%d] t %p - h %p = %lu (last)\n",
+							rb->head_chunk, rb->tail, rb->head, used);
+#endif
 		} else {
-			used  = RB_CHUNK_SIZE * rb->nr_chunks;
+			used  = RB_CHUNK_SIZE * rb->nr_chunks; /* all */
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+			MSGPRINTK("used 2-1 %lu\n", used);
+#endif
 			used -= rb->head - rb->tail;
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+			MSGPRINTK("used 2-2 %lu (last)\n", used);
+#endif
 		}
 	} else {
+		/* not common */
+		/* end of current chunk - current msg_payload entry */
 		used  = rb->chunk_end[rb->head_chunk] - rb->head;
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+		MSGPRINTK("used 3-1 %lu\n", used);
+#endif
+		/* */
 		used += rb->tail - rb->chunk_start[rb->tail_chunk];
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+		MSGPRINTK("used 3-2 %lu\n", used);
+#endif
 		used += ((rb->tail_chunk + rb->wraparounded * rb->nr_chunks)
 				- rb->head_chunk - 1) * RB_CHUNK_SIZE;
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+		MSGPRINTK("used 3-3 %lu (last)\n", used);
+#endif
 	}
 #ifdef CONFIG_POPCORN_STAT
 	rb->peak_usage = max(rb->peak_usage, used);
@@ -50,8 +76,12 @@ static int __init_ring_buffer(struct ring_buffer *rb, const unsigned short nr_ch
 	unsigned short i;
 	int ret = 0;
 
+	//MSGPRINTK("msg: (rb->tail&head are based on the order to get usage)\n"
+	//			"---------------\n");
 	for (i = 0; i < nr_chunks; i++) {
 		void *buffer = (void *)__get_free_pages(GFP_KERNEL, RB_CHUNK_ORDER);
+		//MSGPRINTK("msg: check rb order %p ~ %p chunk[%d]\n",
+		//					buffer, buffer + RB_CHUNK_SIZE, i);
 		if (!buffer) {
 			ret = -ENOMEM;
 			goto out_free;
@@ -166,6 +196,8 @@ void *ring_buffer_get_mapped(struct ring_buffer *rb, size_t size, dma_addr_t *dm
 	/* Is buffer full? */
 	if (rb->wraparounded && rb->head_chunk == rb->tail_chunk) {
 		if (rb->tail + sizeof(*header) + size > rb->head) {
+			//printk(KERN_ERR "rb full roll back to kmalloc!!!\n");
+			WARN_ON_ONCE("rb full roll back to kmalloc!!!\n");
 			spin_unlock_irqrestore(&rb->lock, flags);
 			return NULL;
 		}
@@ -183,6 +215,7 @@ void *ring_buffer_get_mapped(struct ring_buffer *rb, size_t size, dma_addr_t *dm
 		rb->tail = rb->chunk_start[rb->tail_chunk];
 	}
 	__set_header(header, false, size);
+
 	spin_unlock_irqrestore(&rb->lock, flags);
 #ifdef CONFIG_POPCORN_CHECK_SANITY
 	memset(header + 1, 0xcd, size);
@@ -200,10 +233,20 @@ void *ring_buffer_get(struct ring_buffer *rb, size_t size)
 	return ring_buffer_get_mapped(rb, size, NULL);
 }
 
+/*
+ * Since put buffer is not in order, reclaim is for this purpose.
+ * Example: get 1 2 3 4 5 6
+ * 		put 1(head1) 2(head2) 6(head3 !claim I guess)
+ *		5(head3 !claim I guess) 4(head3 !claim I guess) 3(3 claimed!!!!456)
+ */
 void ring_buffer_put(struct ring_buffer *rb, void *buffer)
 {
 	struct ring_buffer_header *header;
 	unsigned long flags;
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+	static unsigned long cnt = 0;
+	cnt++;
+#endif
 
 	header = buffer - sizeof(*header);
 #ifdef CONFIG_POPCORN_CHECK_SANITY
@@ -213,19 +256,61 @@ void ring_buffer_put(struct ring_buffer *rb, void *buffer)
 	spin_lock_irqsave(&rb->lock, flags);
 	header->reclaim = true;
 
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+	if (!(cnt % 10000) || cnt < 100) {
+		MSGPRINTK("msg: put - 0: rb->head %p *buf header %p* "
+					"(buf %p - fixed sizeof %lu) #%lu\n",
+					rb->head, header, buffer, sizeof(*header), cnt);
+	}
+#endif
+
 	header = rb->head;
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+	if (!(cnt % 10000) || cnt < 100) {
+		MSGPRINTK("msg: put - 1: rb->head %p = header %p (global) "
+				"reclaim(%c) #%lu\n",
+				rb->head, header, header->reclaim ? 'O' : 'X', cnt);
+	}
+#endif
 	while (header->reclaim) {
 #ifdef CONFIG_POPCORN_CHECK_SANITY
 		BUG_ON(header->magic != RB_HEADER_MAGIC);
 #endif
 		rb->head += sizeof(*header) + header->size;
-		if (rb->head == rb->chunk_end[rb->head_chunk]) {
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+		if (!(cnt % 10000) || cnt < 100) {
+			MSGPRINTK("msg: put - 2: rb->head %p "
+						"(changed + %lu + %d dec) #%lu\n",
+						rb->head, sizeof(*header), header->size, cnt);
+		}
+#endif
+		if (rb->head == rb->chunk_end[rb->head_chunk]) { /* last entry */
 			if (__get_next_chunk(rb, &rb->head_chunk))
 				rb->wraparounded--;
+
 			rb->head = rb->chunk_start[rb->head_chunk];
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+			if (!(cnt % 10000) || cnt < 100) {
+				MSGPRINTK("msg: put - 3: rb->head %p\n", rb->head);
+			}
+#endif
+		}
+		if (rb->head == rb->tail) {
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+			if (!(cnt % 10000) || cnt < 100) {
+				MSGPRINTK("msg: put - 4: rb->head %p (h=t -> break)\n",
+																rb->head);
+			}
+#endif
+			break;
 		}
-		if (rb->head == rb->tail) break;
 		header = rb->head;
 	}
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+	if (!(cnt % 10000) || cnt < 100) {
+		MSGPRINTK("msg: put - 5: rb->head %p\n", rb->head);
+	}
+	rb->used--;
+#endif
 	spin_unlock_irqrestore(&rb->lock, flags);
 }
diff --git a/msg_layer/ring_buffer.h b/msg_layer/ring_buffer.h
index 80d9ab8ced51..c68da4784c72 100644
--- a/msg_layer/ring_buffer.h
+++ b/msg_layer/ring_buffer.h
@@ -1,10 +1,15 @@
 #ifndef __POPCORN_RING_BUFFER_H__
 #define __POPCORN_RING_BUFFER_H__
 
-#define RB_MAX_CHUNKS	16
+#define MSG_POOL_SIZE (16 * 5) /* send/recv pool */ /* 16*8 doesn't work*/
+//#define MSG_POOL_SIZE (16 * 7) /* send/recv pool */ /* 16*6 doesn't work on Jack_sc on fox4*/
+#define RB_MAX_CHUNKS	128 /* Max. Actual used size  RB_NR_CHUNKS */
+#define RB_NR_CHUNKS	128 /* Actual used size */
 #define RB_CHUNK_ORDER	(MAX_ORDER - 1)
 #define RB_CHUNK_SIZE	(PAGE_SIZE << RB_CHUNK_ORDER)
 
+#include <popcorn/debug.h>
+
 struct ring_buffer {
 	unsigned short head_chunk;
 	void *head;
@@ -22,6 +27,9 @@ struct ring_buffer {
 	size_t total_size;
 	size_t peak_usage;
 #endif
+#if HYPE_PERF_CRITICAL_MSG_DEBUG
+	unsigned long used;
+#endif
 	char name[80];
 };
 
diff --git a/net/core/dev.c b/net/core/dev.c
index 3bcbf931a910..76b265798d25 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -140,6 +140,12 @@
 
 #include "net-sysfs.h"
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#include <popcorn/hype_kvm.h>
+struct net *pophype_tap0_at_origin;
+#endif
+
 /* Instead of increasing this, you should create a hash table. */
 #define MAX_GRO_SKBS 8
 
@@ -1168,8 +1174,14 @@ int dev_change_name(struct net_device *dev, const char *newname)
 		return err;
 	}
 
-	if (oldname[0] && !strchr(oldname, '%'))
+	if (oldname[0] && !strchr(oldname, '%')) {
+#if POPHYPE_NET_OPTIMIZE
+		POP_PK("pophype: net: netdev name %s -> %s "
+				"(I need socket* but this is a net_device*\n",
+											oldname, newname);
+#endif
 		netdev_info(dev, "renamed from %s\n", oldname);
+	}
 
 	old_assign_type = dev->name_assign_type;
 	dev->name_assign_type = NET_NAME_RENAMED;
@@ -2483,6 +2495,21 @@ int skb_checksum_help(struct sk_buff *skb)
 	}
 
 	offset = skb_checksum_start_offset(skb);
+#if POPHYPE_NET_OPTIMIZE /* killme debug */
+	if (offset >= skb_headlen(skb)) {
+		VHOSTNET_OPTIMIZE_PK("\t\t [[[[[[host*]%s():]]]]] BUG_ON{ "
+			"offset(skb->csum_start %d - skb->data %lu - skb->head %lu)) [[[%d]]]"
+			" >= skb_headlen(skb->len %d - skb->data_len %d) [[[%d]]]} "
+			"csum_offset %u [[csum=%d]] csum %d\n",
+			__func__,
+			skb->csum_start, (unsigned long)skb->data, (unsigned long)skb->head,
+				skb_checksum_start_offset(skb),
+			skb->len, skb->data_len,
+				skb_headlen(skb),
+			skb->csum_offset, skb_checksum(skb, offset, skb->len - offset, 0), skb->csum);
+		BUG();
+	}
+#endif
 	BUG_ON(offset >= skb_headlen(skb));
 	csum = skb_checksum(skb, offset, skb->len - offset, 0);
 
@@ -2954,6 +2981,9 @@ static inline int __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q,
 
 		qdisc_bstats_update(q, skb);
 
+#if POPHYPE_GUEST_NET_OPTIMIZE
+		/* if it has q->enqueue method */
+#endif
 		if (sch_direct_xmit(skb, q, dev, txq, root_lock, true)) {
 			if (unlikely(contended)) {
 				spin_unlock(&q->busylock);
@@ -3072,6 +3102,25 @@ static u16 __netdev_pick_tx(struct net_device *dev, struct sk_buff *skb)
 	return queue_index;
 }
 
+#if POPCORN_STAT_MQ_INFO
+#define MAX_MQ 4
+u64 tx_total[MAX_MQ] = {0, 0, 0, 0};
+u64 tx_not_match_vcpu = 0;
+void pophype_mq_tx_stat(struct seq_file *seq, void *v)
+{
+	if (seq) {
+		seq_printf(seq, "cpu 0\t1\t2\t3\tsmp pinned\n");
+		seq_printf(seq, "tx %llu\t%llu\t%llu\t%llu\t\t%llu\n",
+					tx_total[0], tx_total[1], tx_total[2], tx_total[3], tx_not_match_vcpu);
+	} else {
+		/* Clean all in all q (host:32/128 vm:1/4) */
+		int i;
+		for (i = 0; i < MAX_MQ; i++)
+			tx_total[i] = 0;
+	}
+}
+#endif
+
 struct netdev_queue *netdev_pick_tx(struct net_device *dev,
 				    struct sk_buff *skb,
 				    void *accel_priv)
@@ -3087,9 +3136,13 @@ struct netdev_queue *netdev_pick_tx(struct net_device *dev,
 
 	if (dev->real_num_tx_queues != 1) {
 		const struct net_device_ops *ops = dev->netdev_ops;
-		if (ops->ndo_select_queue)
+		if (ops->ndo_select_queue) {
 			queue_index = ops->ndo_select_queue(dev, skb, accel_priv,
 							    __netdev_pick_tx);
+#if !POPHYPE_HOST_KERNEL && POPCORN_STAT_MQ_INFO
+			/* Never reached */
+#endif
+		}
 		else
 			queue_index = __netdev_pick_tx(dev, skb);
 
@@ -3097,6 +3150,35 @@ struct netdev_queue *netdev_pick_tx(struct net_device *dev,
 			queue_index = netdev_cap_txqueue(dev, queue_index);
 	}
 
+#if !POPHYPE_HOST_KERNEL
+#define TESTING_GUEST_TX_PINNED 0
+#if TESTING_GUEST_TX_PINNED
+	/* Popcorn overwrites */
+	if (smp_processor_id() < 2) { /* Hardcode */
+		queue_index = smp_processor_id();
+		/* Remember to overwrite skb */
+		sk_tx_queue_set(skb, queue_index);
+	}
+//bug look into __netdev_pick_tx(dev, skb)
+#endif
+#endif
+
+#if POPCORN_STAT_MQ_INFO && POPHYPE_NET_OPTIMIZE_TMP_DEBUG
+	if (queue_index < MAX_MQ)
+		tx_total[queue_index]++;
+
+
+	if (smp_processor_id() != queue_index)
+		tx_not_match_vcpu++;
+	const struct net_device_ops *ops = dev->netdev_ops;
+	static int cnt = 0;
+	cnt++;
+	if (!(cnt % 1000)) {
+		printk("(guest) <%d> %s(): dev \"%s\" queue_index %d %p (%s) #%d\n",
+				smp_processor_id(), __func__, dev->name, queue_index,
+				ops->ndo_select_queue, __FILE__, cnt);
+	}
+#endif
 	skb_set_queue_mapping(skb, queue_index);
 	return netdev_get_tx_queue(dev, queue_index);
 }
@@ -3171,10 +3253,35 @@ static int __dev_queue_xmit(struct sk_buff *skb, void *accel_priv)
 	skb->tc_verd = SET_TC_AT(skb->tc_verd, AT_EGRESS);
 #endif
 	trace_net_dev_queue(skb);
+#if POPHYPE_GUEST_NET_OPTIMIZE
+	/* if it has q->enqueue method */
+#endif
 	if (q->enqueue) {
 		rc = __dev_xmit_skb(skb, q, dev, txq);
+#if POPHYPE_GUEST_NET_OPTIMIZE
+		{
+			/* -> dev_hard_start_xmit */
+			static u64 _cnt = 0;
+			_cnt++;
+			if ((_cnt > 20 && _cnt < 50) || !(_cnt % 1000)) {
+				POP_PK("\tpophype: vhost-net: <%d> %s: %s(): 111 #%llu\n",
+						smp_processor_id(), __FILE__, __func__, _cnt);
+			}
+		}
+#endif
 		goto out;
 	}
+#if POPHYPE_GUEST_NET_OPTIMIZE
+	//BUG_ON("we only support cases having q->enqueue method");
+	{
+		static u64 cnt = 0;
+		cnt++;
+		if ((cnt < 100) || !(cnt % 1000)) {
+			POP_PK("\tpophype: vhost-net: <%d> %s: %s(): 222 #%llu\n",
+					smp_processor_id(), __FILE__, __func__, cnt);
+		}
+	}
+#endif
 
 	/* The device has no queue. Common case for software devices:
 	   loopback, all the sorts of tunnels...
@@ -3546,6 +3653,22 @@ static int enqueue_to_backlog(struct sk_buff *skb, int cpu,
 	unsigned long flags;
 	unsigned int qlen;
 
+//#ifdef POPHYPE_GUEST_NET_OPTIMIZE
+#if POPHYPE_NET_OPTIMIZE_TMP_DEBUG
+	{
+		static u64 cnt = 0;
+		cnt++;
+		if ((cnt > 70 && cnt < 100) || !(cnt % 1000)) {
+			POP_PK("\t(kernel*/guest?) pophype: net: optimize-tx :<%d> %s: %s(): "
+					"skb %p sock %p (net_device) dev %p \"%s\" #%llu\n",
+					smp_processor_id(), __FILE__, __func__,
+					skb, skb->sk, skb->dev, skb->dev->name, cnt);
+					//skb->sk //sock
+					//skb->dev // net_device
+		}
+	}
+#endif
+
 	sd = &per_cpu(softnet_data, cpu);
 
 	local_irq_save(flags);
@@ -4925,6 +5048,9 @@ out_unlock:
 	return work;
 }
 
+#ifdef CONFIG_POPCORN_HYPE
+/* Triggered by host irq - rx path */
+#endif
 static void net_rx_action(struct softirq_action *h)
 {
 	struct softnet_data *sd = this_cpu_ptr(&softnet_data);
@@ -4937,6 +5063,15 @@ static void net_rx_action(struct softirq_action *h)
 	list_splice_init(&sd->poll_list, &list);
 	local_irq_enable();
 
+#if !POPHYPE_HOST_KERNEL
+#ifdef CONFIG_POPCORN_HYPE
+	/* guest vm */
+    CRITICALNETPK("<%u> %s(): in_atomic %d "
+				"here is a jiffies + 2 trick  %p %p\n",
+				smp_processor_id(), __func__, in_atomic(), h, h->action);
+#endif
+#endif
+
 	for (;;) {
 		struct napi_struct *n;
 
@@ -4956,6 +5091,13 @@ static void net_rx_action(struct softirq_action *h)
 		if (unlikely(budget <= 0 ||
 			     time_after_eq(jiffies, time_limit))) {
 			sd->time_squeeze++;
+#if !POPHYPE_HOST_KERNEL
+#ifdef CONFIG_POPCORN_HYPE
+			/* guest vm when load is high */
+			CRITICALNETPK("<%u> %s(): OVER jiffies + 2\n",
+							smp_processor_id(), __func__);
+#endif
+#endif
 			break;
 		}
 	}
@@ -4968,7 +5110,7 @@ static void net_rx_action(struct softirq_action *h)
 	if (!list_empty(&sd->poll_list))
 		__raise_softirq_irqoff(NET_RX_SOFTIRQ);
 
-	net_rps_action_and_irq_enable(sd);
+	net_rps_action_and_irq_enable(sd); /* pophype: transition from vcpu0 to vcpuX */
 }
 
 struct netdev_adjacent {
@@ -6819,6 +6961,14 @@ int register_netdevice(struct net_device *dev)
 	    dev->rtnl_link_state == RTNL_LINK_INITIALIZED)
 		rtmsg_ifinfo(RTM_NEWLINK, dev, ~0U, GFP_KERNEL);
 
+#if POPHYPE_NET_OPTIMIZE
+	if(!strcmp(dev->name, POPHYPE_ORIGIN_TAP_NAME)) {
+		pophype_tap0_at_origin = net;
+		POP_PK("pophype: net: %s(): Jack netdev name \"%s\" net %p\n",
+											__func__, dev->name, net);
+	}
+#endif
+
 out:
 	return ret;
 
@@ -7240,6 +7390,15 @@ struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,
 
 	nf_hook_ingress_init(dev);
 
+#if defined(CONFIG_POPCORN_HYPE)
+    POP_PK("pophype: %s(): at %s dev %p \"%s\" "
+			"dev->tx_queue_len %lu ->num_tx_queues %u ->real_num_tx_queues %u "
+			"dev->num_rx_queues %u dev->real_num_rx_queues %u\n",
+			__func__, __FILE__, dev, dev->name,
+			dev->tx_queue_len, dev->num_tx_queues, dev->real_num_tx_queues,
+			dev->num_rx_queues, dev->real_num_rx_queues);
+#endif
+
 	return dev;
 
 free_all:
@@ -7835,6 +7994,10 @@ static int __init net_dev_init(void)
 
 	BUG_ON(!dev_boot_phase);
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("pophype: net: %s():\n", __func__);
+#endif
+
 	if (dev_proc_init())
 		goto out;
 
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index fa02c680eebc..c65ebc803aa9 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -2097,7 +2097,14 @@ __wsum __skb_checksum(const struct sk_buff *skb, int offset, int len,
 		}
 		start = end;
 	}
+#if POPHYPE_NET_OPTIMIZE
+	if (unlikely(len)) {
+		dump_stack();
+		BUG();
+	}
+#else
 	BUG_ON(len);
+#endif
 
 	return csum;
 }
diff --git a/net/core/sock.c b/net/core/sock.c
index 4238835a0e4e..690ee4240515 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -2405,6 +2405,19 @@ void sock_init_data(struct socket *sock, struct sock *sk)
 			af_callback_keys + sk->sk_family,
 			af_family_clock_key_strings[sk->sk_family]);
 
+#if defined(CONFIG_POPCORN_HYPE)
+	{
+		static u64 cnt = 0;
+		cnt++; // many on host
+		if ((cnt > 70 && cnt < 100) || !(cnt % 1000)) {
+			POP_NET_PK_TMP("%s(): at %s sock %p "
+								"(may from tun_chr_open()) #%llu\n",
+										__func__, __FILE__, sock, cnt);
+		}
+		/* ./net/core/sock.c */
+	}
+#endif
+
 	sk->sk_state_change	=	sock_def_wakeup;
 	sk->sk_data_ready	=	sock_def_readable;
 	sk->sk_write_space	=	sock_def_write_space;
diff --git a/net/ethernet/eth.c b/net/ethernet/eth.c
index 52dcd414c2af..5c6a25c073cd 100644
--- a/net/ethernet/eth.c
+++ b/net/ethernet/eth.c
@@ -383,6 +383,11 @@ EXPORT_SYMBOL(ether_setup);
 struct net_device *alloc_etherdev_mqs(int sizeof_priv, unsigned int txqs,
 				      unsigned int rxqs)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("%s(): at %s ->alloc_netdev_mqs() \"eth?\" "
+			"sizeof_priv %d txqs %u rxqs %u\n",
+			__func__, __FILE__, sizeof_priv, txqs, rxqs);
+#endif
 	return alloc_netdev_mqs(sizeof_priv, "eth%d", NET_NAME_UNKNOWN,
 				ether_setup, txqs, rxqs);
 }
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index 967a47ff78a4..28910568e91a 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -121,6 +121,9 @@
 #endif
 #include <net/l3mdev.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/hype_kvm.h>
+#endif
 
 /* The inetsw table contains everything that inet_create needs to
  * build a new socket.
@@ -1705,6 +1708,12 @@ static int __init inet_init(void)
 	struct list_head *r;
 	int rc = -EINVAL;
 
+#if !POPHYPE_HOST_KERNEL
+	POP_PK("%s %s(): pophype: net: set cpu0, register ICMP/UDP/TCP/ping protocol "
+				"(problematic point)\n", __FILE__, __func__);
+	pophype_set_cpu0();
+#endif
+
 	sock_skb_cb_check_size(sizeof(struct inet_skb_parm));
 
 	rc = proto_register(&tcp_prot, 1);
diff --git a/net/ipv4/ping.c b/net/ipv4/ping.c
index 82c878224bfc..1ac2d66dae97 100644
--- a/net/ipv4/ping.c
+++ b/net/ipv4/ping.c
@@ -53,6 +53,12 @@
 #include <net/transp_v6.h>
 #endif
 
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+#define DEBUG
+#endif
+#endif
+
 struct ping_table {
 	struct hlist_nulls_head	hash[PING_HTABLE_SIZE];
 	rwlock_t		lock;
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index a0f0a7db946b..50304a4b678c 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -282,6 +282,12 @@
 #include <asm/unaligned.h>
 #include <net/busy_poll.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+//#include <popcorn/bundle.h>
+#include <popcorn/debug.h>
+#include <popcorn/hype_kvm.h>
+#endif
+
 int sysctl_tcp_fin_timeout __read_mostly = TCP_FIN_TIMEOUT;
 
 int sysctl_tcp_min_tso_segs __read_mostly = 2;
@@ -1105,10 +1111,108 @@ int tcp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size)
 	bool sg;
 	long timeo;
 
+#if POPHYPE_NET_OPTIMIZE && !POPHYPE_GUEST_NET_OPTIMIZE
+	/* host */
+	if (msg->msg_iter.count == 233) {
+		static u64 host_cnt = 0;
+		host_cnt++;
+		POP_PK("Jack: [host]: vanilla: <%d> sk %p "
+				"msg->msg_iter.count [[[%lu]]](total bytes) = size %lu "
+				"msg->msg_namelen %d (blocks) ->msg_controllen [%lu] "
+				"msg->msg_iter.iov %p "
+				"msg->msg_iter.iov->iov_base _%p_ "
+				"msg->msg_iter.iov->iov_len [[[%lu]]] "
+				"msg->msg_iter.nr_segs %lu "
+				"msg->msg_iter.count %lu "
+				"#%llu\n",
+				smp_processor_id(), sk, msg->msg_iter.count, size,
+				msg->msg_namelen, msg->msg_controllen,
+				msg->msg_iter.iov,
+				msg->msg_iter.iov->iov_base,
+				msg->msg_iter.iov->iov_len,
+				msg->msg_iter.nr_segs,
+				msg->msg_iter.count,
+				host_cnt);
+	}
+#endif
+
+#if POPHYPE_GUEST_NET_OPTIMIZE
+	{
+		static u64 cnt = 0;
+		cnt++;
+		if ((cnt > 70 && cnt < 100) || !(cnt % 1000) || msg->msg_controllen) {
+			POP_PK("Jack: vanilla: <%d> sk %p "
+					"msg->msg_iter.count [[[%lu]]](total bytes) = size %lu "
+					"msg->msg_namelen %d (blocks) ->msg_controllen [%lu] "
+					"msg->msg_iter.iov %p "
+					"msg->msg_iter.iov->iov_base _%p_ "
+					"msg->msg_iter.iov->iov_len [[[%lu]]] "
+					"msg->msg_iter.nr_segs %lu "
+					"msg->msg_iter.count %lu "
+					"#%llu\n",
+					smp_processor_id(), sk, msg->msg_iter.count, size,
+					msg->msg_namelen, msg->msg_controllen,
+					msg->msg_iter.iov,
+					msg->msg_iter.iov->iov_base,
+					msg->msg_iter.iov->iov_len,
+					msg->msg_iter.nr_segs,
+					msg->msg_iter.count,
+					cnt);
+		}
+		//if (msg->msg_iter.count != 1) {
+		//	POP_PK("\t(BAD2) pophype: vhost-net-opti: "
+		//			"<%d> %s: %s(): msg->msg_iter.count %d\n",
+		//			smp_processor_id(), __FILE__, __func__, msg->msg_iter.count);
+		//}
+		if (smp_processor_id() && !msg->msg_controllen && cnt > 1000) {
+			static u64 cnt2 = 0; // net on vcpu2 cnt
+			cnt2++;
+			POP_PK("Jack <%d> sk %p "
+					"[cmp] msg->msg_iter.count [[[%lu]]](total bytes) = len/size %lu "
+					"msg->msg_namelen %d (blocks) msg->msg_controllen %lu  msg->msg_flags 0x%x "
+					"msg->msg_iter.nr_segs %lu "
+					"msg->msg_iter.count %lu "
+					"msg->msg_iter.iov_offset %lu "
+					"msg->msg_iter.type %d "
+					"msg->msg_iter.iov %p "
+					"msg->msg_iter.iov->iov_base %p "
+					"msg->msg_iter.iov->iov_len [[[%lu]]] "
+					"#%llu 2#%llu\n",
+					smp_processor_id(), sk, msg->msg_iter.count, size,
+					msg->msg_namelen, msg->msg_controllen, msg->msg_flags,
+					msg->msg_iter.nr_segs,
+					msg->msg_iter.count,
+					msg->msg_iter.iov_offset,
+					msg->msg_iter.type,
+					msg->msg_iter.iov,
+					msg->msg_iter.iov->iov_base,
+					msg->msg_iter.iov->iov_len,
+					cnt, cnt2);
+			POP_PK("Jack <%d> [workingon] TODO do msghdr copy to host origin kernel #%llu 2#%llu\n",
+												smp_processor_id(), cnt, cnt2);
+			// TODO - BUG_ON(SIZE)
+
+			/* Pophype - we dont deal with msg_control!!! (TODO?) */
+			guest_delegate_net_msg_tx_hypercall(sk, msg, size);
+			return 0;
+		}
+		if (msg->msg_controllen) {
+			POP_PK("\t(BAD) pophype: vhost-net-opti: "
+				"<%d> %s: %s(): msg->msg_controllen %lu\n",
+				smp_processor_id(), __FILE__, __func__, msg->msg_controllen);
+			/* We cannot handle otherwise we are good sice no need to handle *msg_control */
+
+		}
+	}
+#endif
+
 	lock_sock(sk);
 
 	flags = msg->msg_flags;
 	if ((flags & MSG_FASTOPEN) && !tp->repair) {
+#if POPHYPE_GUEST_NET_OPTIMIZE
+		POP_PK("Jack bad - TODO handle it\n");
+#endif
 		err = tcp_sendmsg_fastopen(sk, msg, &copied_syn, size);
 		if (err == -EINPROGRESS && copied_syn > 0)
 			goto out;
@@ -1280,6 +1384,9 @@ wait_for_memory:
 		if (copied)
 			tcp_push(sk, flags & ~MSG_MORE, mss_now,
 				 TCP_NAGLE_PUSH, size_goal);
+#if POPHYPE_GUEST_NET_OPTIMIZE
+		/* tcp_push sends out skb */
+#endif
 
 		err = sk_stream_wait_memory(sk, &timeo);
 		if (err != 0)
@@ -1289,6 +1396,23 @@ wait_for_memory:
 	}
 
 out:
+#if POPHYPE_GUEST_NET_OPTIMIZE
+	{
+		static u64 cnt = 0;
+		cnt++;
+		if ((cnt > 70 && cnt < 100) || !(cnt % 1000)) {
+			POP_PK("\t(kernel(x)/guest*) pophype: net: optimize-tx: <%d> %s: %s(): "
+					"skb %p sock %p (net_device) dev %p \"%s\" "
+					"copied(fromuser_to_kern) %d "
+					"size_goal %d mss_now %d copied_syn %d #%llu\n",
+					smp_processor_id(), __FILE__, __func__,
+					skb, skb->sk, skb->dev, skb->dev->name, copied,
+					size_goal, mss_now, copied_syn, cnt);
+					//skb->sk //sock
+					//skb->dev // net_device
+		}
+	}
+#endif
 	if (copied)
 		tcp_push(sk, flags, mss_now, tp->nonagle, size_goal);
 out_nopush:
@@ -3211,6 +3335,14 @@ void __init tcp_init(void)
 	sysctl_tcp_rmem[1] = 87380;
 	sysctl_tcp_rmem[2] = max(87380, max_rshare);
 
+#ifdef CONFIG_POPCORN_HYPE
+#if !POPHYPE_HOST_KERNEL
+    GSMPBSPPRINTK("<%d> %s():\n", smp_processor_id(), __func__);
+    //GSMPBSPPRINTK("\t\t\t===============\n");
+	//dump_stack();
+    //GSMPBSPPRINTK("\t\t\t===============\n\n");
+#endif
+#endif
 	pr_info("Hash tables configured (established %u bind %u)\n",
 		tcp_hashinfo.ehash_mask + 1, tcp_hashinfo.bhash_size);
 
diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c
index 637a0e41b0aa..58a485052de8 100644
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@ -64,6 +64,10 @@
 #include <asm/uaccess.h>
 #include <linux/mroute6.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/hype_kvm.h>
+#endif
+
 MODULE_AUTHOR("Cast of dozens");
 MODULE_DESCRIPTION("IPv6 protocol stack for Linux");
 MODULE_LICENSE("GPL");
@@ -837,6 +841,11 @@ static int __init inet6_init(void)
 	struct list_head *r;
 	int err = 0;
 
+#if !POPHYPE_HOST_KERNEL
+    POP_PK("%s %s(): set cpu0 (problematic point)\n", __FILE__, __func__);
+	pophype_set_cpu0();
+#endif
+
 	sock_skb_cb_check_size(sizeof(struct inet6_skb_parm));
 
 	/* Register the socket-side information for inet6_create.  */
diff --git a/net/openvswitch/vport.c b/net/openvswitch/vport.c
index 31cbc8c5c7db..e62476c171b9 100644
--- a/net/openvswitch/vport.c
+++ b/net/openvswitch/vport.c
@@ -47,6 +47,9 @@ static struct hlist_head *dev_table;
  */
 int ovs_vport_init(void)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\tpophype: net: ovs: %s():\n", __func__);
+#endif
 	dev_table = kzalloc(VPORT_HASH_BUCKETS * sizeof(struct hlist_head),
 			    GFP_KERNEL);
 	if (!dev_table)
@@ -453,6 +456,10 @@ int ovs_vport_receive(struct vport *vport, struct sk_buff *skb,
 		tun_info = NULL;
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\tpophype: net: ovs: %s(): call ovs_flow_key_extract\n", __func__);
+#endif
+
 	/* Extract flow from 'skb' into 'key'. */
 	error = ovs_flow_key_extract(tun_info, skb, &key);
 	if (unlikely(error)) {
diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c
index aa4725038f94..d2654908074a 100644
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@ -161,8 +161,13 @@ int sch_direct_xmit(struct sk_buff *skb, struct Qdisc *q,
 
 	if (likely(skb)) {
 		HARD_TX_LOCK(dev, txq, smp_processor_id());
-		if (!netif_xmit_frozen_or_stopped(txq))
+		if (!netif_xmit_frozen_or_stopped(txq)) {
+#if POPHYPE_GUEST_NET_OPTIMIZE
+			/* if it has q->enqueue method */
+			/* Will call start_xmit */
+#endif
 			skb = dev_hard_start_xmit(skb, dev, txq, &ret);
+		}
 
 		HARD_TX_UNLOCK(dev, txq);
 	} else {
diff --git a/virt/kvm/eventfd.c b/virt/kvm/eventfd.c
index 49001fa84ead..591b0c56dd5c 100644
--- a/virt/kvm/eventfd.c
+++ b/virt/kvm/eventfd.c
@@ -40,6 +40,12 @@
 
 #include <kvm/iodev.h>
 
+#ifdef CONFIG_POPCORN_HYPE
+#include <popcorn/debug.h>
+#include <popcorn/hype_kvm.h>
+struct hype_eventfd_info_t *hype_eventfd_info[MAX_POPCORN_FD];
+#endif
+
 #ifdef CONFIG_HAVE_KVM_IRQFD
 
 static struct workqueue_struct *irqfd_cleanup_wq;
@@ -194,6 +200,17 @@ irqfd_wakeup(wait_queue_t *wait, unsigned mode, int sync, void *key)
 	unsigned seq;
 	int idx;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (irqfd) {
+//		POP_PK("%s %s(): gsi if printk, CRASH\n",
+//			__FILE__, __func__);
+		CRITICALNETPK("%s %s(): gsi %d gsi %u "
+					"(after irqfd_wakeup, then kvm inj msi irq)\n",
+					__FILE__, __func__, irqfd->gsi, irqfd->irq_entry.gsi);
+	} else {
+		printk(KERN_ERR "NEED YOUR ATTENSION!!");
+	}
+#endif
 	if (flags & POLLIN) {
 		idx = srcu_read_lock(&kvm->irq_srcu);
 		do {
@@ -304,12 +321,20 @@ kvm_irqfd_assign(struct kvm *kvm, struct kvm_irqfd *args)
 	INIT_WORK(&irqfd->shutdown, irqfd_shutdown);
 	seqcount_init(&irqfd->irq_entry_sc);
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* struct kvm_kernel_irqfd *irqfd->eventfd = eventfd; */
+
+	/* fd -> struct fd (we need .file) */
+#endif
 	f = fdget(args->fd);
 	if (!f.file) {
 		ret = -EBADF;
 		goto out;
 	}
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* file to event_ctx */
+#endif
 	eventfd = eventfd_ctx_fileget(f.file);
 	if (IS_ERR(eventfd)) {
 		ret = PTR_ERR(eventfd);
@@ -318,6 +343,32 @@ kvm_irqfd_assign(struct kvm *kvm, struct kvm_irqfd *args)
 
 	irqfd->eventfd = eventfd;
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* !in_atomic() */
+//    POP_PK("%s %s(): init irqfd_wakeup gsi if printk, CRASH\n",
+//					__FILE__, __func__);
+    POP_PK("%s %s(): init irqfd_wakeup ***args->fd %d <-> gsi %d "
+			"<-> ctx %p*** called right after ++gsi\n",
+			__FILE__, __func__, args->fd, args->gsi, eventfd);
+	/* from lkvm 22 -> notify_vq_gsi() -> irq__add_irqfd() -> ioctl(KVM_IRQFD) */
+
+	/* pophype log (this turns out is from 22 but not for vhost-net eventfd) */
+	if (!hype_eventfd_info[args->fd]) {
+		hype_eventfd_info[args->fd] =
+			kmalloc(sizeof(**hype_eventfd_info), GFP_ATOMIC);
+		BUG_ON(!hype_eventfd_info[args->fd]);
+		hype_eventfd_info[args->fd]->eventfd_ctx = eventfd;
+		hype_eventfd_info[args->fd]->irqfd = irqfd;
+		POP_PK("\n\n\t\t%s %s(): [ADD] hype_eventfd_info[%d] "
+				"eventfd ctx %p irqfd %p\n\n\n",
+				__FILE__, __func__, args->fd, eventfd, irqfd);
+		/* optimize - record the smallest fd for faster lookup */
+	} else {
+		POP_PK("\n\t\t%s %s(): [ADD] hype_eventfd_info[%d] "
+				"already exist\n\n", __FILE__, __func__, args->fd);
+	}
+#endif
+
 	if (args->flags & KVM_IRQFD_FLAG_RESAMPLE) {
 		struct kvm_kernel_irqfd_resampler *resampler;
 
@@ -330,6 +381,11 @@ kvm_irqfd_assign(struct kvm *kvm, struct kvm_irqfd *args)
 		irqfd->resamplefd = resamplefd;
 		INIT_LIST_HEAD(&irqfd->resampler_link);
 
+#ifdef CONFIG_POPCORN_HYPE
+		POP_PK("%s %s(): this is a eventfd_ctx (resamplefd) %p\n",
+									__FILE__, __func__, resamplefd);
+#endif
+
 		mutex_lock(&kvm->irqfds.resampler_lock);
 
 		list_for_each_entry(resampler,
@@ -366,6 +422,14 @@ kvm_irqfd_assign(struct kvm *kvm, struct kvm_irqfd *args)
 		mutex_unlock(&kvm->irqfds.resampler_lock);
 	}
 
+
+#ifdef CONFIG_POPCORN_HYPE
+	/* important (I guess) */
+    POP_PK("%s %s(): key install args->fd %d <-> gsi %d "
+			"called right after ++gsi\n",
+			__FILE__, __func__, args->fd, args->gsi);
+#endif
+
 	/*
 	 * Install our own custom wake-up handling so we are notified via
 	 * a callback whenever someone signals the underlying eventfd
@@ -561,6 +625,10 @@ kvm_irqfd_deassign(struct kvm *kvm, struct kvm_irqfd *args)
 int
 kvm_irqfd(struct kvm *kvm, struct kvm_irqfd *args)
 {
+#ifdef CONFIG_POPCORN_HYPE
+    POP_PK("%s %s(): args->fd %u (from 22)\n", __FILE__, __func__, args->fd);
+	/* from lkvm 22 -> notify_vq_gsi() -> irq__add_irqfd() -> ioctl(KVM_IRQFD) */
+#endif
 	if (args->flags & ~(KVM_IRQFD_FLAG_DEASSIGN | KVM_IRQFD_FLAG_RESAMPLE))
 		return -EINVAL;
 
@@ -627,6 +695,9 @@ void kvm_irq_routing_update(struct kvm *kvm)
  */
 int kvm_irqfd_init(void)
 {
+#ifdef CONFIG_POPCORN_HYPE
+    POP_PK("%s %s(): create irqfd_cleanup_wq\n", __FILE__, __func__);
+#endif
 	irqfd_cleanup_wq = create_singlethread_workqueue("kvm-irqfd-cleanup");
 	if (!irqfd_cleanup_wq)
 		return -ENOMEM;
@@ -726,6 +797,14 @@ ioeventfd_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this, gpa_t addr,
 {
 	struct _ioeventfd *p = to_ioeventfd(this);
 
+#ifdef CONFIG_POPCORN_HYPE
+	CRITICALNETPK("\t%s %s(): vcpu->vcpu_id %d kvm_io_device %p "
+					"to _ioeventfd %p ioeventfd->addr 0x%llx "
+					"gpa 0x%llx len %d val %d\n",
+					__FILE__, __func__, vcpu->vcpu_id,
+					this, p, p->addr, addr, len, *(int*)val);
+#endif
+
 	if (!ioeventfd_in_range(p, addr, len, val))
 		return -EOPNOTSUPP;
 
@@ -818,6 +897,11 @@ static int kvm_assign_ioeventfd_idx(struct kvm *kvm,
 
 	kvm_iodevice_init(&p->dev, &ioeventfd_ops);
 
+#ifdef CONFIG_POPCORN_HYPE
+    POP_PK("\t\tpophype: vhost-net-evenfd: %s: %s(): fd %d "
+			"register gpa_t 0x%llx bus_idx %d dev %p\n",
+			__FILE__, __func__, args->fd, p->addr, bus_idx, &p->dev);
+#endif
 	ret = kvm_io_bus_register_dev(kvm, bus_idx, p->addr, p->length,
 				      &p->dev);
 	if (ret < 0)
@@ -900,6 +984,11 @@ kvm_assign_ioeventfd(struct kvm *kvm, struct kvm_ioeventfd *args)
 	int ret;
 
 	bus_idx = ioeventfd_bus_from_flags(args->flags);
+#ifdef CONFIG_POPCORN_HYPE
+    POP_PK("\t\tpophype: vhost-net-evenfd: %s: %s(): "
+			"***fd %d*** gpa_t 0x%llx bus_idx %d\n",
+			__FILE__, __func__, args->fd, args->addr, bus_idx);
+#endif
 	/* must be natural-word sized, or 0 to ignore length */
 	switch (args->len) {
 	case 0:
diff --git a/virt/kvm/irqchip.c b/virt/kvm/irqchip.c
index 7d31d8c5b9ea..bffa97ed5fc2 100644
--- a/virt/kvm/irqchip.c
+++ b/virt/kvm/irqchip.c
@@ -84,6 +84,18 @@ int kvm_set_irq(struct kvm *kvm, int irq_source_id, u32 irq, int level,
 	struct kvm_kernel_irq_routing_entry irq_set[KVM_NR_IRQCHIPS];
 	int ret = -1, i, idx;
 
+#if defined(CONFIG_POPCORN_HYPE) && HYPEBOOTDEBUG
+	// This hpaanes twice every keyin on guest terminal
+	// Net-related command "ping" doesn't enter this function at all
+	// from virt/kvm/kvm_main.c KVM_IRQ_LINE/KVM_IRQ_LINE_STATUS
+	if (irq != 4) { /* 4: serial 24: virtio0-config
+						25: virtio0-input.0 26: virtio0-output.0 */
+		printk("\t[%d] %s: %s(): irq_source_id %d irq %u "
+				"level %d line_status %c\n", current->pid, __FILE__, __func__,
+				irq_source_id, irq, level, line_status ? 'O' : 'X');
+	}
+#endif
+
 	trace_kvm_set_irq(irq, level, irq_source_id);
 
 	/* Not possible to detect if the guest uses the PIC or the
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index b814ae6822b6..26f333c1cb02 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -60,6 +60,19 @@
 #include "async_pf.h"
 #include "vfio.h"
 
+#ifdef CONFIG_POPCORN_HYPE
+//#include <popcorn/hype.h>
+#include <popcorn/hype_kvm.h>
+#include <popcorn/debug.h>
+#define RETRY_LOCALFAULT_MOD 4 // appear 4 times
+#define RETRY_LOCALFAULT 100
+//#define RETRY_LOCALFAULT 10000
+//#define RETRY_LOCALFAULT 10000000 //good
+//#define RETRY_LOCALFAULT 100000000 // supper enough time
+#include <linux/delay.h>
+//#include "../../kernel/popcorn/trace_events.h"
+#endif
+
 #define CREATE_TRACE_POINTS
 #include <trace/events/kvm.h>
 
@@ -249,6 +262,11 @@ int kvm_vcpu_init(struct kvm_vcpu *vcpu, struct kvm *kvm, unsigned id)
 	r = kvm_arch_vcpu_init(vcpu);
 	if (r < 0)
 		goto fail_free_run;
+
+#ifdef CONFIG_POPCORN_HYPE
+	VCPUPRINTK("%s(): vcpu %d (kern)vcpu->run %p created!!\n",
+										__func__, id, vcpu->run);
+#endif
 	return 0;
 
 fail_free_run:
@@ -278,6 +296,11 @@ static void kvm_mmu_notifier_invalidate_page(struct mmu_notifier *mn,
 {
 	struct kvm *kvm = mmu_notifier_to_kvm(mn);
 	int need_tlb_flush, idx;
+#if defined(CONFIG_POPCORN_HYPE) && defined(CONFIG_POPCORN_STAT)
+	/* USED: DSM pg fault ->
+		__mmu_notifier_invalidate_page -> kvm_mmu_notifier_invalidate_page */
+	//trace_kvm_ept_inv(address);
+#endif
 
 	/*
 	 * When ->invalidate_page runs, the linux pte has been zapped
@@ -476,6 +499,14 @@ static int kvm_init_mmu_notifier(struct kvm *kvm)
 	return mmu_notifier_register(&kvm->mmu_notifier, current->mm);
 }
 
+#ifdef CONFIG_POPCORN_HYPE
+static int kvm_init_mmu_notifier_tsk(struct task_struct *tsk, struct kvm *kvm)
+{
+	kvm->mmu_notifier.ops = &kvm_mmu_notifier_ops;
+	return mmu_notifier_register(&kvm->mmu_notifier, tsk->mm);
+}
+#endif
+
 #else  /* !(CONFIG_MMU_NOTIFIER && KVM_ARCH_WANT_MMU_NOTIFIER) */
 
 static int kvm_init_mmu_notifier(struct kvm *kvm)
@@ -541,6 +572,87 @@ static void kvm_free_memslots(struct kvm *kvm, struct kvm_memslots *slots)
 	kvfree(slots);
 }
 
+#ifdef CONFIG_POPCORN_HYPE
+static struct kvm *kvm_create_vm_tsk(struct task_struct *tsk, unsigned long type)
+{
+	int r, i;
+	struct kvm *kvm = kvm_arch_alloc_vm();
+
+	if (!kvm)
+		return ERR_PTR(-ENOMEM);
+
+	spin_lock_init(&kvm->mmu_lock);
+	atomic_inc(&tsk->mm->mm_count);
+	kvm->mm = tsk->mm;
+	kvm_eventfd_init(kvm);
+	mutex_init(&kvm->lock);
+	mutex_init(&kvm->irq_lock);
+	mutex_init(&kvm->slots_lock);
+	atomic_set(&kvm->users_count, 1);
+	INIT_LIST_HEAD(&kvm->devices);
+
+	r = kvm_arch_init_vm(kvm, type);
+	if (r)
+		goto out_err_no_disable;
+
+	r = hardware_enable_all();
+	if (r)
+		goto out_err_no_disable;
+
+#ifdef CONFIG_HAVE_KVM_IRQFD
+	INIT_HLIST_HEAD(&kvm->irq_ack_notifier_list);
+#endif
+
+	BUILD_BUG_ON(KVM_MEM_SLOTS_NUM > SHRT_MAX);
+
+	r = -ENOMEM;
+	for (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {
+		kvm->memslots[i] = kvm_alloc_memslots();
+		if (!kvm->memslots[i])
+			goto out_err_no_srcu;
+	}
+
+	if (init_srcu_struct(&kvm->srcu))
+		goto out_err_no_srcu;
+	if (init_srcu_struct(&kvm->irq_srcu))
+		goto out_err_no_irq_srcu;
+	for (i = 0; i < KVM_NR_BUSES; i++) {
+		kvm->buses[i] = kzalloc(sizeof(struct kvm_io_bus),
+					GFP_KERNEL);
+		if (!kvm->buses[i])
+			goto out_err;
+	}
+
+	r = kvm_init_mmu_notifier_tsk(tsk, kvm);
+	if (r)
+		goto out_err;
+
+	spin_lock(&kvm_lock);
+	list_add(&kvm->vm_list, &vm_list);
+	spin_unlock(&kvm_lock);
+
+	preempt_notifier_inc();
+
+	HPPRINTK("%s: Done\n", __func__);
+	return kvm;
+
+out_err:
+	cleanup_srcu_struct(&kvm->irq_srcu);
+out_err_no_irq_srcu:
+	cleanup_srcu_struct(&kvm->srcu);
+out_err_no_srcu:
+	hardware_disable_all();
+out_err_no_disable:
+	for (i = 0; i < KVM_NR_BUSES; i++)
+		kfree(kvm->buses[i]);
+	for (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++)
+		kvm_free_memslots(kvm, kvm->memslots[i]);
+	kvm_arch_free_vm(kvm);
+	mmdrop(tsk->mm);
+	return ERR_PTR(r);
+}
+#endif
+
 static struct kvm *kvm_create_vm(unsigned long type)
 {
 	int r, i;
@@ -827,7 +939,7 @@ int __kvm_set_memory_region(struct kvm *kvm,
 	gfn_t base_gfn;
 	unsigned long npages;
 	struct kvm_memory_slot *slot;
-	struct kvm_memory_slot old, new;
+	struct kvm_memory_slot old, new; /* new: waiting for setup */
 	struct kvm_memslots *slots = NULL, *old_memslots;
 	int as_id, id;
 	enum kvm_mr_change change;
@@ -861,6 +973,10 @@ int __kvm_set_memory_region(struct kvm *kvm,
 	base_gfn = mem->guest_phys_addr >> PAGE_SHIFT;
 	npages = mem->memory_size >> PAGE_SHIFT;
 
+#ifdef CONFIG_POPCORN_HYPE
+	DDPRINTK("%s(): from usr - guest_phys_addr %llx size %llx\n",
+			__func__, mem->guest_phys_addr, mem->memory_size);
+#endif
 	if (npages > KVM_MEM_MAX_NR_PAGES)
 		goto out;
 
@@ -871,8 +987,9 @@ int __kvm_set_memory_region(struct kvm *kvm,
 	new.npages = npages;
 	new.flags = mem->flags;
 
-	if (npages) {
-		if (!old.npages)
+	/* Determin operation */
+	if (npages) { /* !DELETE */
+		if (!old.npages) /* Brand new */
 			change = KVM_MR_CREATE;
 		else { /* Modify an existing slot. */
 			if ((mem->userspace_addr != old.userspace_addr) ||
@@ -899,7 +1016,7 @@ int __kvm_set_memory_region(struct kvm *kvm,
 	}
 
 	if ((change == KVM_MR_CREATE) || (change == KVM_MR_MOVE)) {
-		/* Check for overlaps */
+		/* Check for existing memslots overlaps */
 		r = -EEXIST;
 		kvm_for_each_memslot(slot, __kvm_memslots(kvm, as_id)) {
 			if (slot->id == id)
@@ -976,6 +1093,19 @@ int __kvm_set_memory_region(struct kvm *kvm,
 	kvm_free_memslot(kvm, &old, &new);
 	kvfree(old_memslots);
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* From 1. KVM_SET_TSS_ADDR -> vmx_set_tss_addr -> __x86_set_memory_region
+			2. KVM_SET_USER_MEMORY_REGION
+			3. KVM_CREATE_VCPU					(ordered) */
+	DDPRINTK("%s(): as_id %d base_gfn[%d(usr)/%d] "
+					"base %llx pgs %lx uaddr %lx\n",
+					__func__, as_id, new.id, slots->used_slots - 1, //mem->slot
+					new.base_gfn,
+					new.npages,
+					new.userspace_addr);
+	//if (current->at_remote) { dump_stack(); }
+#endif
+
 	/*
 	 * IOMMU mapping:  New slots need to be mapped.  Old slots need to be
 	 * un-mapped and re-mapped if their base changes.  Since base change
@@ -1005,7 +1135,6 @@ int kvm_set_memory_region(struct kvm *kvm,
 			  const struct kvm_userspace_memory_region *mem)
 {
 	int r;
-
 	mutex_lock(&kvm->slots_lock);
 	r = __kvm_set_memory_region(kvm, mem);
 	mutex_unlock(&kvm->slots_lock);
@@ -1016,6 +1145,9 @@ EXPORT_SYMBOL_GPL(kvm_set_memory_region);
 static int kvm_vm_ioctl_set_memory_region(struct kvm *kvm,
 					  struct kvm_userspace_memory_region *mem)
 {
+#ifdef CONFIG_POPCORN_HYPE
+	DDPRINTK("%s(): \n", __func__);
+#endif
 	if ((u16)mem->slot >= KVM_USER_MEM_SLOTS)
 		return -EINVAL;
 
@@ -1200,8 +1332,10 @@ unsigned long kvm_host_page_size(struct kvm *kvm, gfn_t gfn)
 	size = vma_kernel_pagesize(vma);
 
 out:
+#ifdef CONFIG_POPCORN_HYPE
+	; /* TODO 0523 */
+#endif
 	up_read(&current->mm->mmap_sem);
-
 	return size;
 }
 
@@ -1213,9 +1347,98 @@ static bool memslot_is_readonly(struct kvm_memory_slot *slot)
 static unsigned long __gfn_to_hva_many(struct kvm_memory_slot *slot, gfn_t gfn,
 				       gfn_t *nr_pages, bool write)
 {
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef CONFIG_POPCORN_STAT
+	// even 0x1a0c many forever.........
+	//if (gfn == 0x99 || (gfn == 0x1a0c)) {
+	if (gfn == 0x99) {
+		POP_PK("%s(): [%d] <%s> - gfn %llx 0 REMOTE DIES HERE "
+				"(cannot pass this check) [[[[slot %p]]] slot->flags %x\n",
+				__func__, current->pid, "?", gfn, slot,slot?slot->flags:0);
+	}
+#endif
+#endif
+
 	if (!slot || slot->flags & KVM_MEMSLOT_INVALID)
 		return KVM_HVA_ERR_BAD;
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef CONFIG_POPCORN_STAT
+	if (gfn == 0x99) {
+		POP_PK("%s(): [%d] <%s> gfn %llx - 1\n", __func__, current->pid, "?", gfn);
+	}
+#endif
+#endif
+	if (memslot_is_readonly(slot) && write)
+		return KVM_HVA_ERR_RO_BAD;
+
+	if (nr_pages)
+		*nr_pages = slot->npages - (gfn - slot->base_gfn);
+
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef CONFIG_POPCORN_STAT
+	if (gfn == 0x99) {
+		POP_PK("%s(): [%d] <%s> nr_pages(dec) %lld slot %p || hva [[[%llx]]] = "
+					"->userspace_addr %lx + (gfn %llx ->base_gfn %llx) * %lu\n",
+					__func__, current->pid, "?",
+					nr_pages ? *nr_pages : -1, slot,
+					slot ? slot->userspace_addr +
+						(gfn - slot->base_gfn) * PAGE_SIZE : -1,
+					slot ? slot->userspace_addr : -1,
+					gfn, slot ? slot->base_gfn : -1, PAGE_SIZE);
+	}
+#endif
+#endif
+	return __gfn_to_hva_memslot(slot, gfn);
+}
 
+unsigned long gfn_to_hva_many_pub(struct kvm_memory_slot *slot, gfn_t gfn,
+				       gfn_t *nr_pages, bool write)
+{
+#ifdef CONFIG_POPCORN_HYPE
+	// even 0x1a0c many forever.........
+	//if (gfn == 0x99 || (gfn == 0x1a0c)) {
+	if (gfn == 0x99) {
+		POP_PK("%s(): [%d] <%s> - gfn %llx 0 REMOTE DIES HERE "
+				"(cannot pass this check) [[[[slot %p]]] slot->flags %x\n",
+				__func__, current->pid, "?", gfn, slot,slot?slot->flags:0);
+	}
+#endif
+
+	if (!slot || slot->flags & KVM_MEMSLOT_INVALID)
+		return KVM_HVA_ERR_BAD;
+#ifdef CONFIG_POPCORN_HYPE
+	if (gfn == 0x99) {
+		POP_PK("%s(): [%d] <%s> gfn %llx - 1\n", __func__, current->pid, "?", gfn);
+	}
+#endif
+	if (memslot_is_readonly(slot) && write)
+		return KVM_HVA_ERR_RO_BAD;
+
+	if (nr_pages)
+		*nr_pages = slot->npages - (gfn - slot->base_gfn);
+
+#ifdef CONFIG_POPCORN_HYPE
+	if (gfn == 0x99) {
+		POP_PK("%s(): [%d] <%s> nr_pages(dec) %lld slot %p || hva [[[%llx]]] = "
+					"->userspace_addr %lx + (gfn %llx ->base_gfn %llx) * %lu\n",
+					__func__, current->pid, "?",
+					nr_pages ? *nr_pages : -1, slot,
+					slot ? slot->userspace_addr +
+						(gfn - slot->base_gfn) * PAGE_SIZE : -1,
+					slot ? slot->userspace_addr : -1,
+					gfn, slot ? slot->base_gfn : -1, PAGE_SIZE);
+	}
+#endif
+	return __gfn_to_hva_memslot(slot, gfn);
+}
+//EXPORT_SYMBOL_GPL(gfn_to_hva_many_pub);
+
+#ifdef CONFIG_POPCORN_HYPE /* debug */
+unsigned long pop_gfn_to_hva_many(struct kvm_memory_slot *slot, gfn_t gfn,
+				       gfn_t *nr_pages, bool write)
+{
+	if (!slot || slot->flags & KVM_MEMSLOT_INVALID)
+		return KVM_HVA_ERR_BAD;
 	if (memslot_is_readonly(slot) && write)
 		return KVM_HVA_ERR_RO_BAD;
 
@@ -1224,6 +1447,7 @@ static unsigned long __gfn_to_hva_many(struct kvm_memory_slot *slot, gfn_t gfn,
 
 	return __gfn_to_hva_memslot(slot, gfn);
 }
+#endif
 
 static unsigned long gfn_to_hva_many(struct kvm_memory_slot *slot, gfn_t gfn,
 				     gfn_t *nr_pages)
@@ -1283,6 +1507,11 @@ static int get_user_page_nowait(struct task_struct *tsk, struct mm_struct *mm,
 	unsigned long start, int write, struct page **page)
 {
 	int flags = FOLL_TOUCH | FOLL_NOWAIT | FOLL_HWPOISON | FOLL_GET;
+	/* special flag for gup */
+#ifdef CONFIG_POPCORN_HYPE
+	flags = FOLL_TOUCH | FOLL_HWPOISON | FOLL_GET;
+	/* FOLL_NOWAIT will return immediately */
+#endif
 
 	if (write)
 		flags |= FOLL_WRITE;
@@ -1320,12 +1549,26 @@ static bool hva_to_pfn_fast(unsigned long addr, bool atomic, bool *async,
 	if (!(write_fault || writable))
 		return false;
 
+	/* pophype - all except write_fault = 0 (R fault) + !writable (not a ptr) */
+#ifdef CONFIG_POPCORN_HYPE
+	// -> __get_user_pages_fast():arch/x86/mm/gup.c
+#endif
 	npages = __get_user_pages_fast(addr, 1, 1, page);
 	if (npages == 1) {
 		*pfn = page_to_pfn(page[0]);
 
+		// pophype dbg - count it
 		if (writable)
 			*writable = true;
+
+#ifdef CONFIG_POPCORN_HYPE
+		if ((distributed_process(current) &&
+			(current->at_remote || INTERESTED_GVA(addr))) &&
+			NOTINTERESTED_GVA(addr)) {
+			EPTVPRINTK("\t\t=fast: [%d] DONE %lx (!lock)\n",
+											current->pid, addr);
+		}
+#endif
 		return true;
 	}
 
@@ -1341,25 +1584,154 @@ static int hva_to_pfn_slow(unsigned long addr, bool *async, bool write_fault,
 {
 	struct page *page[1];
 	int npages = 0;
+#ifdef CONFIG_POPCORN_HYPE
+	unsigned long try_lock_cnt = 0; /* try_lock */
+	unsigned long retry_cnt = 0;
+	if (distributed_process(current) && !writable) {
+		EPTVPRINTK("\t\t=slow: [%d] %lx not from eptfault but gfn_to_pfn()\n",
+									current->pid, addr);
+	}
+#endif
 
 	might_sleep();
 
 	if (writable)
 		*writable = write_fault;
 
+#ifdef CONFIG_POPCORN_HYPE
+#if 0
+	//if ((current->at_remote && !async) ||
+	if ((INTERESTED_GVA(addr) && !async)) {
+		EPTVPRINTK("\t\t=slow: [%d] XXXXX !async(since it's 2nd try) addr %lx\n",
+					current->pid, addr);
+		//dump_stack();
+	}
+#endif
+#endif
+
 	if (async) {
+//#if 0
+		//npages = __get_user_pages_unlocked(current, current->mm, addr, 1,
+		//				   write_fault, 0, page,
+		//				   FOLL_TOUCH|FOLL_HWPOISON); /* !forece */
+//#else
+retry:
+#ifdef CONFIG_POPCORN_HYPE
+		if ((current->at_remote || INTERESTED_GVA(addr)) &&
+			 NOTINTERESTED_GVA(addr)
+			 ) {
+			EPTVVPRINTK("\t\t=slow: [%d] before LOCK %lx\n",
+									current->pid, addr);
+		}
+#endif
+
+#ifdef CONFIG_POPCORN_HYPE
+		while (!down_read_trylock(&current->mm->mmap_sem)) {
+			if ((!(try_lock_cnt % (RETRY_LOCALFAULT / RETRY_LOCALFAULT_MOD))) &&
+				NOTINTERESTED_GVA(addr)) {
+				EPTVVPRINTK("\t\t=slow: [%d] =1st TRYLOCK %lx "
+						"owner [%d] cnt %ld #%lu %s\n",
+						current->pid, addr,
+						current->mm->mmap_sem.owner ?
+							current->mm->mmap_sem.owner->pid :
+							REMOTE_CANNOT_DOWN_MMAP_SEM,
+						current->mm->mmap_sem.count,
+						try_lock_cnt,
+						try_lock_cnt >= RETRY_LOCALFAULT ?
+									"***FALLBACK***" : "");
+
+				/* Retry is not used becaus
+				 * get_user_page_nowait must return 1 pg */
+#if 0
+				if (try_lock_cnt >= RETRY_LOCALFAULT) {
+					*pfn = REMOTE_CANNOT_DOWN_MMAP_SEM;
+					/* ret=npages=!1, do botton-half =afslow */
+					return REMOTE_CANNOT_DOWN_MMAP_SEM;
+					//BUG();
+				}
+#endif
+			}
+			try_lock_cnt++;
+			io_schedule();
+		}
+
+		if ((current->at_remote || INTERESTED_GVA(addr)) &&
+			 NOTINTERESTED_GVA(addr)
+			 ) {
+			EPTVVPRINTK("\t\t=slow: [%d] =1st [[[LOCKed]]] %lx\n",
+									current->pid, addr);
+		}
+#else
 		down_read(&current->mm->mmap_sem);
+#endif
+
+		/* 1st __gfn_to_pfn_memslot() / hva_to_pfn() */
 		npages = get_user_page_nowait(current, current->mm,
 					      addr, write_fault, page);
 		up_read(&current->mm->mmap_sem);
-	} else
+
+#ifdef CONFIG_POPCORN_HYPE
+		if (distributed_process(current)) {
+			if ((current->at_remote ||
+				//(((addr >> PAGE_SHIFT) & PAGE_MASK) > 0x1a00 &&
+				 //((addr >> PAGE_SHIFT) & PAGE_MASK) < 0x1aff) ||
+				 INTERESTED_GVA(addr)) &&
+				 NOTINTERESTED_GVA(addr)
+				 ) {
+				EPTVVPRINTK("\t\t=slow: [%d] [[[UNLOCKed]]] %lx retpg %s%d%s "
+									"atomic %s #%lu\n",
+									current->pid, addr,
+									npages != 1 ? "*****" : "",
+									npages,
+									npages != 1 ? "***** Jack !RETRY" : "",
+									in_atomic() ? "O" : "X", retry_cnt);
+			}
+		}
+
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+		/* Retry is not used becaus
+		 * get_user_page_nowait must return 1 pg */
+		/* I made/hope get_user_page_nowait() must successful -
+			So RETRY_FIRST_EPT is not nessary........
+			but this is not ture...... (why??? so far stable)
+			BUG BUG BUG */
+		/* Jack: popcorn_hype retry dsm failure */
+		if (RETRY_FIRST_EPT) {
+			/* hacking/fixing for RETRY CASE -
+				THIS IS BAD. HERE IS NOT THE PLACE FOR SWAP
+				meaning failure is fine */
+			if (npages != 1) { // TODO assumming RETY != 1 which is not 100% true
+				printk(KERN_ERR "[SYSTEM CORRUPTED] !![%d] I don't think this should happen, I thought "
+						"get_user_page_nowait MUST return 1 pg, npages %d\n",
+						current->pid, npages);
+				BUG_ON(npages < 0 && "system corrupted");
+				//schedule();
+				retry_cnt++;
+				goto retry;
+				/* old BUG: retry never get down_read() lock
+					meanwhile origin is asking for the same page */
+			}
+		}
+#endif
+#endif
+//#endif
+	} else { /* 2nd __gfn_to_pfn_memslot() (aka hva_to_pfn())  or !!gfn_to_page(1st remote #ept )!!!  */
+		/* Have to handle this as well */
 		npages = __get_user_pages_unlocked(current, current->mm, addr, 1,
-						   write_fault, 0, page,
-						   FOLL_TOUCH|FOLL_HWPOISON);
+					   write_fault, 0, page,
+					   FOLL_TOUCH|FOLL_HWPOISON); /* lkvm interested forece=0 */
+#ifdef CONFIG_POPCORN_HYPE
+		BUG_ON(distributed_process(current) &&
+				npages != 1 && "ifso, handle it");
+#endif
+	}
+
 	if (npages != 1)
 		return npages;
 
+#if !DISABLE_WRITABLE_EPT /* !important */
 	/* map read fault as writable if possible */
+	/* https://patchwork.kernel.org/patch/10630897/ */
 	if (unlikely(!write_fault) && writable) {
 		struct page *wpage[1];
 
@@ -1372,6 +1744,8 @@ static int hva_to_pfn_slow(unsigned long addr, bool *async, bool write_fault,
 
 		npages = 1;
 	}
+#endif
+
 	*pfn = page_to_pfn(page[0]);
 	return npages;
 }
@@ -1401,54 +1775,230 @@ static bool vma_is_valid(struct vm_area_struct *vma, bool write_fault)
  * 2): @write_fault = false && @writable, @writable will tell the caller
  *     whether the mapping is writable.
  */
+/* from ./arch/x86/kvm/mmu.c try_async_pf() -> __gfn_to_pfn_memslot() */
+/* __gfn_to_pfn_memslot() ~= hva_to_pfn = fast + slow
+	1st: &async(false)
+	2nd: NULL(this hva_to_pfn has changed to true one time before)
+
+	slow: takes different async to get_usr_page
+		async!=NULL
+		async==NULL
+ */
 static pfn_t hva_to_pfn(unsigned long addr, bool atomic, bool *async,
-			bool write_fault, bool *writable)
+			bool write_fault, bool *writable
+#ifdef CONFIG_POPCORN_HYPE
+			, gfn_t gfn
+#endif
+)
 {
 	struct vm_area_struct *vma;
 	pfn_t pfn = 0;
 	int npages;
+#ifdef CONFIG_POPCORN_HYPE
+	int cnt = 0;
+	static unsigned long hva_pfn_cnt = 0;
+	if (((current->at_remote ||
+		INTERESTED_GVA(addr))) &&
+//		 !( gfn > 0x12a800 && gfn < 0x12ff21) &&
+//		 !( gfn > 0xcc013 && gfn < 0xcffeb)) &&
+		NOTINTERESTED_GVA(addr)
+		) {
+//		if (
+//			(!(gfn > 0x12a490 && gfn < 0x12fbf3) &&
+//			!(gfn > 0xcb9f6 && gfn < 0xcffea)) &&
+//			NOTINTERESTED_GVA(gfn)
+//			) {
+			hva_pfn_cnt++;
+			EPTVPRINTK("\t@@ =[%d] <%s> hva_to_pfn/fastslow gfn %llx hva %lx "
+					"%s writable %s &async_ptr %s #%lu\n",
+					current->pid, "?", gfn, addr,
+					write_fault ? "W" : "R",
+					writable ? *writable ? "O" : "X" : "-",
+					async ? "O (1st)" : "X (2nd)", hva_pfn_cnt);
+			//if (((hva_pfn_cnt >= 150 && hva_pfn_cnt <= 180) ||
+			//	(hva_pfn_cnt >= 170 && hva_pfn_cnt <= 200) ||
+			//	hva_pfn_cnt >= 200) &&
+			//	current->at_remote
+			//	){
+			//	dump_stack();
+			//}
+//		}
+	}
+#endif
 
 	/* we can do it either atomically or asynchronously, not both */
 	BUG_ON(atomic && async);
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* !First touch - !!pte - check TLB cache
+		Both fast&slow will do __get_user_pages_fast() */
+#endif
 	if (hva_to_pfn_fast(addr, atomic, async, write_fault, writable, &pfn))
-		return pfn;
+		return pfn; /* succ */
 
 	if (atomic)
 		return KVM_PFN_ERR_FAULT;
 
+#ifdef CONFIG_POPCORN_HYPE
+	/* PAGE FAULT */
+	// hva_to_pfn_slow() =
+	// 		if (async) {
+	//			hold mm lock
+	//			npages = get_user_page_nowait(current, current->mm,
+	//				      addr, write_fault, page);
+	//			release mm lock
+	// 		} else
+	//			__get_user_pages_unlocked(current, current->mm, addr, 1,
+	//									write_fault, 0, page,
+	//									FOLL_TOUCH|FOLL_HWPOISON); /* !forece *
+	/* First touch - !pte */
+#endif
 	npages = hva_to_pfn_slow(addr, async, write_fault, writable, &pfn);
 	if (npages == 1)
 		return pfn;
 
+
+
+#ifdef CONFIG_POPCORN_HYPE
+	/* 0521shold we really need to do afslow?????????? */
+	if (npages == REMOTE_CANNOT_DOWN_MMAP_SEM)
+		return REMOTE_CANNOT_DOWN_MMAP_SEM; /* no need to retry again */
+
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+	if (npages == 0) {
+		POP_PK("\t [%d] %lx npages 0 (If, handle it)\n", current->pid, addr);
+	}
+	BUG_ON(distributed_process(current) && npages > 1);
+#endif
+	EPTVVPRINTK("\t =afslow: [%d] before LOCK mmap_sem "
+				"addr %lx npages %d(0/%d)\n",
+				current->pid, addr, npages, REMOTE_CANNOT_DOWN_MMAP_SEM);
+
+	while (!down_read_trylock(&current->mm->mmap_sem)) {
+		if (!(cnt % (RETRY_LOCALFAULT / RETRY_LOCALFAULT_MOD))) {
+			EPTVVPRINTK("\t =afslow: [%d] try LOCK %lx "
+					"owner [%d] cnt %ld #%d %s\n",
+					current->pid, addr,
+					current->mm->mmap_sem.owner ?
+						current->mm->mmap_sem.owner->pid :
+						REMOTE_CANNOT_DOWN_MMAP_SEM,
+					current->mm->mmap_sem.count,
+					cnt, cnt >= RETRY_LOCALFAULT ? "***FALLBACK***" : "");
+
+			/* Jack's modification */
+			if (cnt >= RETRY_LOCALFAULT) {
+				if (async) {
+					//*async = true; /* Jack: TODO take care this */
+					/* *async:true - try 2nd IOasyncfault
+							:false - dmap()(default) */
+
+					/* Make sure we don't allow *sync=true, which will
+												go 2nd (e.g swapping )*/
+					/* Jack: NOW I NEED IT GO OUT before dmap()'s -87 checking */
+					*async = false;
+				}
+				return REMOTE_CANNOT_DOWN_MMAP_SEM; /* !1, do botton-half */
+				//BUG();
+			}
+		}
+		//schedule();
+		cnt++;
+	}
+#else /* !CONFIG_POPCORN_HYPE */
 	down_read(&current->mm->mmap_sem);
+#endif /* CONFIG_POPCORN_HYPE end */
+
+#ifdef CONFIG_POPCORN_HYPE
+	EPTVVPRINTK("\t=afslow $$[%d] [[[LOCKed]]] mmap_sem "
+				"addr %lx npages %d(0)\n", current->pid, addr, npages);
+#endif
 	if (npages == -EHWPOISON ||
 	      (!async && check_user_page_hwpoison(addr))) {
+#ifdef CONFIG_POPCORN_HYPE
+		EPTVPRINTK("\t=afslow $$[%d] addr %lx "
+					"npages %d==-EHWPOISON pfn %llx\n",
+					current->pid, addr, npages, KVM_PFN_ERR_HWPOISON);
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+		BUG_ON(distributed_remote_process(current));
+#endif
+#endif
+		/* Send signal to user process */
 		pfn = KVM_PFN_ERR_HWPOISON;
 		goto exit;
 	}
 
 	vma = find_vma_intersection(current->mm, addr, addr + 1);
 
-	if (vma == NULL)
+	if (vma == NULL) {
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+		if (distributed_process(current)) {
+			WARN_ON("!vma TODO\n"); BUG();
+		}
+#endif
+#endif
 		pfn = KVM_PFN_ERR_FAULT;
-	else if ((vma->vm_flags & VM_PFNMAP)) {
+	} else if ((vma->vm_flags & VM_PFNMAP)) { /* !struct page - recalculate */
+		/* The only good */
+		/* Such pages are typically created by device drivers that
+								  map the pages into user space.
+			  http://man7.org/linux/man-pages/man2/madvise.2.html */
 		pfn = ((addr - vma->vm_start) >> PAGE_SHIFT) +
 			vma->vm_pgoff;
+
+#ifdef CONFIG_POPCORN_HYPE
+#ifdef CONFIG_POPCORN_CHECK_SANITY
+		BUG_ON(distributed_process(current));
+#endif
+#endif
 		BUG_ON(!kvm_is_reserved_pfn(pfn));
 	} else {
-		if (async && vma_is_valid(vma, write_fault))
-			*async = true;
+		/* If host page is not here, keep async = false */
+		if (async && vma_is_valid(vma, write_fault)) {
+			/* fail, go to botton half */
+			*async = true; /* async IO is needed (e.g. is swap-out) = skip dmap */
+#ifdef CONFIG_POPCORN_HYPE
+			if (distributed_remote_process(current) ||
+				(distributed_process(current) && INTERESTED_GVA(addr))) {
+				EPTVPRINTK("\t=afslow %s(): [%d] <%s> [[[SWAPINing pfn %llx]]] "
+								"go to 2nd/asyncIO\n",
+								__func__, current->pid, "?", KVM_PFN_ERR_FAULT);
+			}
+			/* no swap allowed in pophype */
+			BUG_ON(distributed_remote_process(current));
+#endif
+		}
+#ifdef CONFIG_POPCORN_HYPE
+		if (distributed_process(current)) {
+			printk("\t=afslow %s(): ??[%d] <%s> 0x%llx ?????? "
+					"host doesn't have the page. what's going on?\n",
+					__func__, current->pid, "?", KVM_PFN_ERR_FAULT);
+			BUG();
+		}
+#endif
 		pfn = KVM_PFN_ERR_FAULT;
 	}
 exit:
+#ifdef CONFIG_POPCORN_HYPE
+	EPTVPRINTK("\t=afslow $$[%d] before UNLOCK mmap_sem "
+				"addr %lx ***EMGPATH****\n", current->pid, addr);
+#endif
 	up_read(&current->mm->mmap_sem);
+#ifdef CONFIG_POPCORN_HYPE
+	EPTVPRINTK("\t=afslow $$[%d] [[[UNLOCKed]]] mmap_sem "
+				"addr %lx ***EMGPATH****\n", current->pid, addr);
+#endif
+#ifdef CONFIG_POPCORN_HYPE
+	/* PAGE FAULT above */
+#endif
 	return pfn;
 }
 
+/* gfn -> hva -> pfn */
 pfn_t __gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn, bool atomic,
 			   bool *async, bool write_fault, bool *writable)
 {
+	/*gfn -> hva(addr) */
 	unsigned long addr = __gfn_to_hva_many(slot, gfn, NULL, write_fault);
 
 	if (addr == KVM_HVA_ERR_RO_BAD)
@@ -1460,11 +2010,15 @@ pfn_t __gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn, bool atomic,
 	/* Do not map writable pfn in the readonly memslot. */
 	if (writable && memslot_is_readonly(slot)) {
 		*writable = false;
-		writable = NULL;
+		writable = NULL; /* overwrite writable ptr */
 	}
 
-	return hva_to_pfn(addr, atomic, async, write_fault,
-			  writable);
+	/* hva(addr) -> pfn */
+	return hva_to_pfn(addr, atomic, async, write_fault, writable
+#ifdef CONFIG_POPCORN_HYPE
+			  ,gfn
+#endif
+			  );
 }
 EXPORT_SYMBOL_GPL(__gfn_to_pfn_memslot);
 
@@ -1478,12 +2032,22 @@ EXPORT_SYMBOL_GPL(gfn_to_pfn_prot);
 
 pfn_t gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn)
 {
+#ifdef CONFIG_POPCORN_HYPE
+#if !POP_CLEAN
+	printk_once("%s(): (not used)\n", __func__);
+#endif
+#endif
 	return __gfn_to_pfn_memslot(slot, gfn, false, NULL, true, NULL);
 }
 EXPORT_SYMBOL_GPL(gfn_to_pfn_memslot);
 
 pfn_t gfn_to_pfn_memslot_atomic(struct kvm_memory_slot *slot, gfn_t gfn)
 {
+#ifdef CONFIG_POPCORN_HYPE
+#if !POP_CLEAN
+	printk_once("%s(): (not used)\n", __func__);
+#endif
+#endif
 	return __gfn_to_pfn_memslot(slot, gfn, true, NULL, true, NULL);
 }
 EXPORT_SYMBOL_GPL(gfn_to_pfn_memslot_atomic);
@@ -1546,6 +2110,12 @@ struct page *gfn_to_page(struct kvm *kvm, gfn_t gfn)
 {
 	pfn_t pfn;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_process(current)) {
+		EPTVPRINTK("\t_memslot: [%d] %s(): pfn 0x%llx\n",
+							current->pid, __func__, pfn);
+	}
+#endif
 	pfn = gfn_to_pfn(kvm, gfn);
 
 	return kvm_pfn_to_page(pfn);
@@ -2201,23 +2771,56 @@ void kvm_vcpu_on_spin(struct kvm_vcpu *me)
 }
 EXPORT_SYMBOL_GPL(kvm_vcpu_on_spin);
 
+/* vaddr to kaddr's page
+ * vcpu 3 pages
+ * vaddr[0] fault and return (kaddr[0])vcpu->run's pages directly (usr: vcpu->kvm_run)
+ * vaddr[1]: vcpu->arch.pio_data
+ * vaddr[2]: vcpu->kvm->coalesced_mmio_ring
+ */
 static int kvm_vcpu_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 {
 	struct kvm_vcpu *vcpu = vma->vm_file->private_data;
 	struct page *page;
 
-	if (vmf->pgoff == 0)
+#ifdef CONFIG_POPCORN_HYPE
+	static int first = 1;
+	if (first) {
+		POP_PK("\n=====================================\n");
+#if !POP_CLEAN
+		dump_stack();
+#endif
+		POP_PK("=====================================\n");
+		first = 0;
+	}
+	VCPUPRINTK("\t<%d> kvm_vcpu_fault %p + 0x%lx return phy_page\n",
+			vcpu->vcpu_id, vmf->virtual_address, vmf->pgoff);
+#endif
+	if (vmf->pgoff == 0) {
 		page = virt_to_page(vcpu->run);
 #ifdef CONFIG_X86
-	else if (vmf->pgoff == KVM_PIO_PAGE_OFFSET)
+	} else if (vmf->pgoff == KVM_PIO_PAGE_OFFSET) {
 		page = virt_to_page(vcpu->arch.pio_data);
 #endif
 #ifdef KVM_COALESCED_MMIO_PAGE_OFFSET
-	else if (vmf->pgoff == KVM_COALESCED_MMIO_PAGE_OFFSET)
+	} else if (vmf->pgoff == KVM_COALESCED_MMIO_PAGE_OFFSET) {
 		page = virt_to_page(vcpu->kvm->coalesced_mmio_ring);
 #endif
-	else
+	} else {
 		return kvm_arch_vcpu_fault(vcpu, vmf);
+	}
+
+#ifdef CONFIG_POPCORN_HYPE
+	VCPUPRINTK("\t\t<%d> %p (+ofs %lx) (usr) - (kern) %s %p ret struct page\n",
+				vcpu->vcpu_id, vmf->virtual_address, vmf->pgoff,
+				vmf->pgoff == 0 ? "vcpu->run" :
+					vmf->pgoff == 1 ? "vcpu->arch.pio_data" :
+									"vcpu->kvm->coalesced_mmio_ring", /* kvm */
+				vmf->pgoff == 0 ? vcpu->run :
+					vmf->pgoff == 1 ? vcpu->arch.pio_data :
+									vcpu->kvm->coalesced_mmio_ring);
+	VCPUPRINTK("\n");
+#endif
+
 	get_page(page);
 	vmf->page = page;
 	return 0;
@@ -2227,9 +2830,51 @@ static const struct vm_operations_struct kvm_vcpu_vm_ops = {
 	.fault = kvm_vcpu_fault,
 };
 
+#ifdef CONFIG_POPCORN_HYPE
+void *popcorn_vcpu_op = NULL;
+#endif
 static int kvm_vcpu_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	vma->vm_ops = &kvm_vcpu_vm_ops;
+#ifdef CONFIG_POPCORN_HYPE
+	struct kvm_vcpu *vcpu = file->private_data;
+#endif
+	vma->vm_ops = &kvm_vcpu_vm_ops; /*pophype -
+										this has to be install on each kernel */
+#ifdef CONFIG_POPCORN_HYPE
+	popcorn_vcpu_op = (void *)&kvm_vcpu_vm_ops;
+	VCPUPRINTK("%s(): fd vcpu <%d> installing vm->vm_ops %p "
+				"(kvm_vcpu_vm_ops) for vma %lx - %lx\n",
+				__func__, vcpu->vcpu_id, vma->vm_ops,
+				vma->vm_start, vma->vm_end);
+
+	if (distributed_process(current)) {
+        // I wanna log hype info for vpu. This [0][fd] is sosososososo important.
+        // I will record all first. Then see how it works.
+        //printk("\n\n");
+        //printk("******************************\n");
+        //printk("%s(): [%d] <%d> mmap addr %lx\n",
+		//		__func__, my_nid, vcpu->vcpu_id, vma->vm_start);
+        //printk("******************************\n");
+        //printk("\n\n");
+        if (vma->vm_start) {
+			/* fd is done by pophype */
+			int fd = vcpuid_to_fd(vcpu->vcpu_id);
+			POP_PK("\n\n");
+			POP_PK("*******install pophype vcpu info*************\n");
+			POP_PK("%s(): [%d/%d]<%d> mmap addr %lx [my_nid %d][req->fd %d] "
+					"vcpu %p tsk %p (INSTALL VCPU)\n",
+					__func__, my_nid, current->pid,
+					vcpu->vcpu_id, vma->vm_start, my_nid, fd, vcpu, current);
+			POP_PK("*********************************************\n");
+			POP_PK("\n\n");
+            //hype_node_info[my_nid][fd]->run = xxx;
+            hype_node_info[my_nid][fd]->vcpu = vcpu;
+            hype_node_info[my_nid][fd]->uaddr = vma->vm_start;
+            hype_node_info[my_nid][fd]->vcpu_id = vcpu->vcpu_id;
+            hype_node_info[my_nid][fd]->tsk = current;
+		}
+    }
+#endif
 	return 0;
 }
 
@@ -2254,9 +2899,15 @@ static struct file_operations kvm_vcpu_fops = {
 /*
  * Allocates an inode for the vcpu.
  */
+#define ITOA_MAX_LEN 12
 static int create_vcpu_fd(struct kvm_vcpu *vcpu)
 {
-	return anon_inode_getfd("kvm-vcpu", &kvm_vcpu_fops, vcpu, O_RDWR | O_CLOEXEC);
+	char name[8 + 1 + ITOA_MAX_LEN + 1];
+
+	/* TODO name for remote 0? so that both node has only its vcpu's meta */
+	snprintf(name, sizeof(name), "kvm-vcpu:%d", vcpu->vcpu_id);
+	return anon_inode_getfd(name, &kvm_vcpu_fops, vcpu, O_RDWR | O_CLOEXEC);
+//	return anon_inode_getfd("kvm-vcpu", &kvm_vcpu_fops, vcpu, O_RDWR | O_CLOEXEC);
 }
 
 /*
@@ -2270,16 +2921,25 @@ static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)
 	if (id >= KVM_MAX_VCPUS)
 		return -EINVAL;
 
-	vcpu = kvm_arch_vcpu_create(kvm, id);
+	vcpu = kvm_arch_vcpu_create(kvm, id); /* main */
 	if (IS_ERR(vcpu))
 		return PTR_ERR(vcpu);
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("%s(): KVM_CREATE_VCPU -> kvm_arch_vcpu_create vcpu %d done\n",
+															__func__, id);
+#endif
+
 	preempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);
 
 	r = kvm_arch_vcpu_setup(vcpu);
 	if (r)
 		goto vcpu_destroy;
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("%s(): kvm_arch_vcpu_setup vcpu %d done\n", __func__, id);
+#endif
+
 	mutex_lock(&kvm->lock);
 	if (!kvm_vcpu_compatible(vcpu)) {
 		r = -EINVAL;
@@ -2290,6 +2950,7 @@ static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)
 		goto unlock_vcpu_destroy;
 	}
 
+	/* Check if exiting */
 	kvm_for_each_vcpu(r, v, kvm)
 		if (v->vcpu_id == id) {
 			r = -EEXIST;
@@ -2305,6 +2966,9 @@ static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)
 		kvm_put_kvm(kvm);
 		goto unlock_vcpu_destroy;
 	}
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t(inside check id#) vcpu_id %d created\n", vcpu->vcpu_id);
+#endif
 
 	kvm->vcpus[atomic_read(&kvm->online_vcpus)] = vcpu;
 
@@ -2317,7 +2981,7 @@ static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)
 
 	mutex_unlock(&kvm->lock);
 	kvm_arch_vcpu_postcreate(vcpu);
-	return r;
+	return r; /* user vcpu_fd */
 
 unlock_vcpu_destroy:
 	mutex_unlock(&kvm->lock);
@@ -2361,19 +3025,106 @@ static long kvm_vcpu_ioctl(struct file *filp,
 		return kvm_arch_vcpu_ioctl(filp, ioctl, arg);
 #endif
 
+#ifdef CONFIG_POPCORN_HYPE
+	// many
+	//PHMIGRATEPRINTK("[%d] %s: going to call vcpu_load "
+	//				"vcpu_id <%d> smp_processor_id() %d\n",
+	//				current->pid, __func__, vcpu->vcpu_id, smp_processor_id());
+#endif
+
+#if defined(CONFIG_POPCORN_HYPE) && POPCORN_DEBUG_FT
+	if (ioctl == KVM_GET_SREGS ||
+			ioctl == KVM_GET_MP_STATE) { // KVM_GET_MSRS //killme
+		int lock_retry_lock = 0;
+		PHMIGRATEPRINTK("[%d] <%d> %s: start - 5 (0x%x)\n",
+				current->pid, vcpu->vcpu_id, __func__, ioctl);
+		PHMIGRATEPRINTK("[%d] <%d> %s: dies between 5 & 6 (0x%x) "
+				"KVM_GET_SREGS 0x%lx KVM_GET_MP_STATE 0x%lx\n",
+				current->pid, vcpu->vcpu_id, __func__, ioctl,
+				KVM_GET_SREGS, KVM_GET_MP_STATE);
+		PHMIGRATEPRINTK("[%d] <%d> %s: start - 5.5 (0x%x) [debug] "
+				"mutex debug start\n",
+				current->pid, vcpu->vcpu_id, __func__, ioctl);
+
+		if (!mutex_trylock(&vcpu->mutex)) { // contention
+			PHMIGRATEPRINTK("[%d] <%d> %s: start - 5.6 (0x%x) "
+					"[debug] lock contention -  the owner is [[[%d]]]\n",
+					current->pid, vcpu->vcpu_id, __func__, ioctl,
+					vcpu->mutex.owner->pid);
+		} else { // no contention (grabed)
+			PHMIGRATEPRINTK("[%d] <%d> %s: start - 5.5 (0x%x) "
+					"[debug] lock GOOD no contention\n",
+					current->pid, vcpu->vcpu_id, __func__, ioctl);
+			mutex_unlock(&vcpu->mutex);
+		}
+
+		while (!mutex_trylock(&vcpu->mutex)) {
+			lock_retry_lock++;
+		};
+		mutex_unlock(&vcpu->mutex); // grabed
+
+		//if (mutex_trylock(&vcpu->mutex)) {
+		if (!lock_retry_lock) {
+			PHMIGRATEPRINTK("[%d] <%d> %s: start - 5.6 (0x%x) "
+					"[debug] lock GOOD no contention\n",
+					current->pid, vcpu->vcpu_id, __func__, ioctl);
+		} else {
+			PHMIGRATEPRINTK("[%d] <%d> %s: start - 5.6 (0x%x) "
+					"[debug] lock contention #%d time\n",
+					current->pid, vcpu->vcpu_id, __func__,
+					ioctl, lock_retry_lock);
+//			PHMIGRATEPRINTK("[%d] <%d> %s: start - 5.6 (0x%x) "
+//					"[debug] the lock owner is [[[%d]]]\n",
+//					current->pid, vcpu->vcpu_id, __func__, ioctl,
+//					vcpu->mutex.owner->pid);
+		}
+	}
+#endif
 
 	r = vcpu_load(vcpu);
+#if defined(CONFIG_POPCORN_HYPE)
+	if (r) {
+		if (unlikely(signal_pending_state(TASK_KILLABLE, current))) {
+			PHMIGRATEPRINTK("[dbg] [%d] <%d> %s: this is the problem r = %d\n",
+				current->pid, vcpu->vcpu_id, __func__, r);
+		}else{
+			PHMIGRATEPRINTK("[dbg] [%d] <%d> %s: this is NOT the problem r = %d\n",
+				current->pid, vcpu->vcpu_id, __func__, r);
+		}
+		PHMIGRATEPRINTK("[%d] <%d> %s: start - 5 fail r = %d "
+						"(expect -4 mutex_lock() fails)\n",
+						current->pid, vcpu->vcpu_id, __func__, r);
+	}
+#endif
 	if (r)
 		return r;
+
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_remote_process(current)) {
+		HPPRINTK("%s: 0x%x\n", __func__, ioctl);
+	}
+#endif
 	switch (ioctl) {
 	case KVM_RUN:
+		HPPRINTK("<%d> %s: KVM_RUN\n", current->pid, __func__);
 		r = -EINVAL;
+#ifdef CONFIG_POPCORN_HYPE
+		HPPRINTK("[%d] %s: KVM_RUN 1\n", current->pid, __func__);
+#endif
 		if (arg)
 			goto out;
+#ifdef CONFIG_POPCORN_HYPE
+		HPPRINTK("[%d] %s: KVM_RUN 2\n", current->pid, __func__);
+#endif
 		if (unlikely(vcpu->pid != current->pids[PIDTYPE_PID].pid)) {
 			/* The thread running this VCPU changed. */
 			struct pid *oldpid = vcpu->pid;
 			struct pid *newpid = get_task_pid(current, PIDTYPE_PID);
+#ifdef CONFIG_POPCORN_HYPE
+			PHMIGRATEPRINTK("[%d] %s: KVM_RUN pophype migration vcpu->pid "
+							"chagned [old %p] [new %p]\n",
+							current->pid, __func__, oldpid, newpid);
+#endif
 
 			rcu_assign_pointer(vcpu->pid, newpid);
 			if (oldpid)
@@ -2381,10 +3132,51 @@ static long kvm_vcpu_ioctl(struct file *filp,
 			put_pid(oldpid);
 		}
 		r = kvm_arch_vcpu_ioctl_run(vcpu, vcpu->run);
+								/* arch/x86/kvm/x86.c */
 		trace_kvm_userspace_exit(vcpu->run->exit_reason, r);
+#ifdef CONFIG_POPCORN_HYPE
+		//if (vcpu->run->exit_reason != KVM_EXIT_IO && current->at_remote) { // 2
+		//if (current->at_remote) // 2
+		//}
+#if 0
+		{ /* pophype debug */
+			static unsigned int cnt = 0;
+			static unsigned int exit_two = 0;
+			//if (vcpu->run->exit_reason == KVM_EXIT_INTERNAL_ERROR) {
+									//17-3 KVM_INTERNAL_ERROR_DELIVERY_EV
+				if (vcpu->run->exit_reason == KVM_EXIT_IO)
+					exit_two++;
+				if (exit_two > 500 && !current->at_remote) // bug...
+					goto outprint;
+
+				cnt++;
+				if (cnt < 1150 || current->at_remote) { // bug
+					//printk("\t[%d][%d]<%d> vcpu->run [[[%p]]] "
+					VMPRINTK("\t[%d/%d] <%d> vcpu->run [[[%p]]] "
+							"->run->exit %u-%u r %d %lx #%u reting!\n",
+							//current->at_remote ? 1:0, current->pid,
+							current->at_remote ? 1:0, current->pid,
+							vcpu->vcpu_id, vcpu->run,
+							vcpu->run->exit_reason,
+							vcpu->run->internal.suberror,
+							r, (unsigned long)r, cnt);
+				}
+				/* a test was done - result: kernel and usr are shareing
+												struct vcpu now (999) workd */
+			//}
+		}
+outprint:
+#endif
+#endif
 		break;
 	case KVM_GET_REGS: {
 		struct kvm_regs *kvm_regs;
+#if defined(CONFIG_POPCORN_HYPE)
+		HPPRINTK("[%d] <%d> %s: KVM_GET_REGS\n",
+				current->pid, vcpu->vcpu_id, __func__);
+		PHMIGRATEPRINTK("[%d] <%d> %s: KVM_GET_REGS\n",
+				current->pid, vcpu->vcpu_id, __func__);
+#endif
 
 		r = -ENOMEM;
 		kvm_regs = kzalloc(sizeof(struct kvm_regs), GFP_KERNEL);
@@ -2403,6 +3195,10 @@ out_free1:
 	}
 	case KVM_SET_REGS: {
 		struct kvm_regs *kvm_regs;
+#if defined(CONFIG_POPCORN_HYPE)
+		HPPRINTK("%s: KVM_SET_REGS\n", __func__);
+		PHMIGRATEPRINTK("%s: KVM_SET_REGS\n", __func__);
+#endif
 
 		r = -ENOMEM;
 		kvm_regs = memdup_user(argp, sizeof(*kvm_regs));
@@ -2415,6 +3211,17 @@ out_free1:
 		break;
 	}
 	case KVM_GET_SREGS: {
+#if defined(CONFIG_POPCORN_HYPE)
+		HPPRINTK("[%d] <%d> %s: KVM_GET_SREGS\n",
+					current->pid, vcpu->vcpu_id, __func__);
+		PHMIGRATEPRINTK("[%d] <%d> %s: KVM_GET_SREGS\n",
+					current->pid, vcpu->vcpu_id, __func__);
+		//static int debug = 0;
+		//if (debug < 15) {
+//			dump_stack(); // kill me
+		//}
+		//debug = 1;
+#endif
 		kvm_sregs = kzalloc(sizeof(struct kvm_sregs), GFP_KERNEL);
 		r = -ENOMEM;
 		if (!kvm_sregs)
@@ -2429,6 +3236,13 @@ out_free1:
 		break;
 	}
 	case KVM_SET_SREGS: {
+#if defined(CONFIG_POPCORN_HYPE)
+		HPPRINTK("[%d] <%d> %s: KVM_SET_SREGS\n",
+				current->pid, vcpu->vcpu_id, __func__);
+		PHMIGRATEPRINTK("[%d] <%d> %s: KVM_SET_SREGS\n",
+					current->pid, vcpu->vcpu_id, __func__);
+#endif
+
 		kvm_sregs = memdup_user(argp, sizeof(*kvm_sregs));
 		if (IS_ERR(kvm_sregs)) {
 			r = PTR_ERR(kvm_sregs);
@@ -2440,6 +3254,12 @@ out_free1:
 	}
 	case KVM_GET_MP_STATE: {
 		struct kvm_mp_state mp_state;
+#if defined(CONFIG_POPCORN_HYPE)
+		HPPRINTK("[%d] <%d> %s: KVM_GET_MP_STATE\n\n",
+				current->pid, vcpu->vcpu_id, __func__);
+		PHMIGRATEPRINTK("[%d] <%d> %s: KVM_GET_MP_STATE\n\n",
+						current->pid, vcpu->vcpu_id, __func__);
+#endif
 
 		r = kvm_arch_vcpu_ioctl_get_mpstate(vcpu, &mp_state);
 		if (r)
@@ -2452,6 +3272,9 @@ out_free1:
 	}
 	case KVM_SET_MP_STATE: {
 		struct kvm_mp_state mp_state;
+#if defined(CONFIG_POPCORN_HYPE)
+		HPPRINTK("%s: KVM_SET_MP_STATE\n", __func__);
+#endif
 
 		r = -EFAULT;
 		if (copy_from_user(&mp_state, argp, sizeof(mp_state)))
@@ -2461,6 +3284,9 @@ out_free1:
 	}
 	case KVM_TRANSLATE: {
 		struct kvm_translation tr;
+#if defined(CONFIG_POPCORN_HYPE)
+		HPPRINTK("%s: KVM_TRANSLATE\n", __func__);
+#endif
 
 		r = -EFAULT;
 		if (copy_from_user(&tr, argp, sizeof(tr)))
@@ -2476,6 +3302,9 @@ out_free1:
 	}
 	case KVM_SET_GUEST_DEBUG: {
 		struct kvm_guest_debug dbg;
+#if defined(CONFIG_POPCORN_HYPE)
+		HPPRINTK("%s: KVM_SET_GUEST_DEBUG\n", __func__);
+#endif
 
 		r = -EFAULT;
 		if (copy_from_user(&dbg, argp, sizeof(dbg)))
@@ -2487,6 +3316,9 @@ out_free1:
 		struct kvm_signal_mask __user *sigmask_arg = argp;
 		struct kvm_signal_mask kvm_sigmask;
 		sigset_t sigset, *p;
+#if defined(CONFIG_POPCORN_HYPE)
+		HPPRINTK("%s: KVM_SET_SIGNAL_MASK\n", __func__);
+#endif
 
 		p = NULL;
 		if (argp) {
@@ -2507,6 +3339,10 @@ out_free1:
 		break;
 	}
 	case KVM_GET_FPU: {
+#if defined(CONFIG_POPCORN_HYPE)
+		HPPRINTK("<%d> %s: KVM_GET_FPU\n", current->pid, __func__);
+#endif
+
 		fpu = kzalloc(sizeof(struct kvm_fpu), GFP_KERNEL);
 		r = -ENOMEM;
 		if (!fpu)
@@ -2521,6 +3357,11 @@ out_free1:
 		break;
 	}
 	case KVM_SET_FPU: {
+#if defined(CONFIG_POPCORN_HYPE)
+		HPPRINTK("<%d> %s: KVM_SET_FPU\n", current->pid, __func__);
+		PHMIGRATEPRINTK("<%d> %s: KVM_SET_FPU\n", current->pid, __func__);
+#endif
+
 		fpu = memdup_user(argp, sizeof(*fpu));
 		if (IS_ERR(fpu)) {
 			r = PTR_ERR(fpu);
@@ -2531,9 +3372,15 @@ out_free1:
 		break;
 	}
 	default:
+#if defined(CONFIG_POPCORN_HYPE)
+		HPPRINTK("<%d> %s: (default) -> kvm_arch_vcpu_ioctl()\n",
+											current->pid, __func__);
+#endif
 		r = kvm_arch_vcpu_ioctl(filp, ioctl, arg);
 	}
 out:
+	HPPRINTK("<%d> %s: vcpu %d return %d\n",
+				current->pid, __func__, vcpu->vcpu_id, r);
 	vcpu_put(vcpu);
 	kfree(fpu);
 	kfree(kvm_sregs);
@@ -2749,6 +3596,7 @@ static long kvm_vm_ioctl_check_extension_generic(struct kvm *kvm, long arg)
 	return kvm_vm_ioctl_check_extension(kvm, arg);
 }
 
+#include <linux/fdtable.h>
 static long kvm_vm_ioctl(struct file *filp,
 			   unsigned int ioctl, unsigned long arg)
 {
@@ -2756,14 +3604,39 @@ static long kvm_vm_ioctl(struct file *filp,
 	void __user *argp = (void __user *)arg;
 	int r;
 
+#ifdef CONFIG_POPCORN_HYPE
+	HPPRINTK("%s:\n", __func__);
+#endif
+
 	if (kvm->mm != current->mm)
 		return -EIO;
 	switch (ioctl) {
 	case KVM_CREATE_VCPU:
+		DDPRINTK("======================================\n");
+		POP_PK("======================================\n");
+		POP_PK("%s: [[KVM_CREATE_VCPU]] vcpu %lu\n", __func__, arg);
+		POP_PK("======================================\n");
+		DDPRINTK("======================================\n");
 		r = kvm_vm_ioctl_create_vcpu(kvm, arg);
+#ifdef CONFIG_POPCORN_HYPE
+		if (r < 0) {
+			POP_PK("\n**********************************\n"
+					"**********************************\n"
+					"\t\t[[[[[[[vcpu_id %d failed to create ret %d ]]]]]]]\n"
+					"**********************************\n"
+					"**********************************\n",
+					atomic_read(&kvm->online_vcpus), r);
+		} else {
+			POP_PK("%s(): vcpu_id %d fd %d (#%d) sucessfully created!!\n",
+							__func__, atomic_read(&kvm->online_vcpus) - 1,
+							popcorn_file_to_fd(current, filp, true),
+							atomic_read(&kvm->online_vcpus));
+		}
+#endif
 		break;
 	case KVM_SET_USER_MEMORY_REGION: {
 		struct kvm_userspace_memory_region kvm_userspace_mem;
+		POP_PK("%s: KVM_SET_USER_MEMORY_REGION 1 bank\n", __func__);
 
 		r = -EFAULT;
 		if (copy_from_user(&kvm_userspace_mem, argp,
@@ -2775,6 +3648,7 @@ static long kvm_vm_ioctl(struct file *filp,
 	}
 	case KVM_GET_DIRTY_LOG: {
 		struct kvm_dirty_log log;
+		HPPRINTK("%s: KVM_GET_DIRTY_LOG\n", __func__);
 
 		r = -EFAULT;
 		if (copy_from_user(&log, argp, sizeof(log)))
@@ -2785,6 +3659,7 @@ static long kvm_vm_ioctl(struct file *filp,
 #ifdef KVM_COALESCED_MMIO_PAGE_OFFSET
 	case KVM_REGISTER_COALESCED_MMIO: {
 		struct kvm_coalesced_mmio_zone zone;
+		POP_PK("%s: KVM_REGISTER_COALESCED_MMIO\n", __func__);
 
 		r = -EFAULT;
 		if (copy_from_user(&zone, argp, sizeof(zone)))
@@ -2794,6 +3669,7 @@ static long kvm_vm_ioctl(struct file *filp,
 	}
 	case KVM_UNREGISTER_COALESCED_MMIO: {
 		struct kvm_coalesced_mmio_zone zone;
+		POP_PK("%s: KVM_UNREGISTER_COALESCED_MMIO\n", __func__);
 
 		r = -EFAULT;
 		if (copy_from_user(&zone, argp, sizeof(zone)))
@@ -2804,6 +3680,11 @@ static long kvm_vm_ioctl(struct file *filp,
 #endif
 	case KVM_IRQFD: {
 		struct kvm_irqfd data;
+		POP_PK("%s: KVM_IRQFD\n", __func__);
+#ifdef CONFIG_POPCORN_HYPE
+        POP_PK("\t\tpophype: %s: %s(): KVM_IRQFD e.g. vhost-net\n",
+												__FILE__, __func__);
+#endif
 
 		r = -EFAULT;
 		if (copy_from_user(&data, argp, sizeof(data)))
@@ -2813,6 +3694,7 @@ static long kvm_vm_ioctl(struct file *filp,
 	}
 	case KVM_IOEVENTFD: {
 		struct kvm_ioeventfd data;
+		POP_PK("%s: KVM_IOEVENTFD (vhost-net-eventfd)\n", __func__);
 
 		r = -EFAULT;
 		if (copy_from_user(&data, argp, sizeof(data)))
@@ -2823,7 +3705,16 @@ static long kvm_vm_ioctl(struct file *filp,
 #ifdef CONFIG_HAVE_KVM_MSI
 	case KVM_SIGNAL_MSI: {
 		struct kvm_msi msi;
-
+#if POPHYPE_NET_OPTIMIZE_TMP_DEBUG
+		{
+			static int cnt = 0;
+			cnt++;
+			if (cnt < 100 || !(cnt % 100)) {
+				POP_PK("%s: KVM_SIGNAL_MSI - "
+						"vanilla virtio-host many #%d\n", __func__, cnt);
+			}
+		}
+#endif
 		r = -EFAULT;
 		if (copy_from_user(&msi, argp, sizeof(msi)))
 			goto out;
@@ -2835,6 +3726,7 @@ static long kvm_vm_ioctl(struct file *filp,
 	case KVM_IRQ_LINE_STATUS:
 	case KVM_IRQ_LINE: {
 		struct kvm_irq_level irq_event;
+		//printk("%s: KVM_IRQ_LINE/KVM_IRQ_LINE_STATUS\n", __func__);
 
 		r = -EFAULT;
 		if (copy_from_user(&irq_event, argp, sizeof(irq_event)))
@@ -2860,6 +3752,10 @@ static long kvm_vm_ioctl(struct file *filp,
 		struct kvm_irq_routing routing;
 		struct kvm_irq_routing __user *urouting;
 		struct kvm_irq_routing_entry *entries;
+		POP_PK("%s: %s(): KVM_SET_GSI_ROUTING from PCI "
+				"20VIRTIO_MSI_CONFIG_VECTOR/22VIRTIO_MSI_QUEUE_VECTOR "
+				"(vcpu init & vhost-net: first ping)\n",
+				__FILE__, __func__);
 
 		r = -EFAULT;
 		if (copy_from_user(&routing, argp, sizeof(routing)))
@@ -2887,6 +3783,7 @@ out_free_irq_routing:
 #endif /* CONFIG_HAVE_KVM_IRQ_ROUTING */
 	case KVM_CREATE_DEVICE: {
 		struct kvm_create_device cd;
+		POP_PK("%s: KVM_CREATE_DEVICE\n", __func__);
 
 		r = -EFAULT;
 		if (copy_from_user(&cd, argp, sizeof(cd)))
@@ -2904,9 +3801,13 @@ out_free_irq_routing:
 		break;
 	}
 	case KVM_CHECK_EXTENSION:
+		HPPRINTK("%s: KVM_CHECK_EXTENSION\n", __func__);
 		r = kvm_vm_ioctl_check_extension_generic(kvm, arg);
 		break;
 	default:
+#ifdef CONFIG_POPCORN_HYPE
+		HPPRINTK("%s: (default) -> kvm_arch_vm_ioctl() 0x%x\n", __func__, ioctl);
+#endif
 		r = kvm_arch_vm_ioctl(filp, ioctl, arg);
 	}
 out:
@@ -2957,7 +3858,11 @@ out:
 }
 #endif
 
+#ifdef CONFIG_POPCORN_HYPE
 static struct file_operations kvm_vm_fops = {
+#else
+struct file_operations kvm_vm_fops = {
+#endif
 	.release        = kvm_vm_release,
 	.unlocked_ioctl = kvm_vm_ioctl,
 #ifdef CONFIG_KVM_COMPAT
@@ -2966,15 +3871,52 @@ static struct file_operations kvm_vm_fops = {
 	.llseek		= noop_llseek,
 };
 
+#ifdef CONFIG_POPCORN_HYPE
+// replay
+int replay_kvm_dev_ioctl_create_vm_tsk(struct task_struct *tsk, unsigned long type)
+{
+	int r;
+	struct kvm *kvm;
+
+	kvm = kvm_create_vm_tsk(tsk, type);
+	if (IS_ERR(kvm))
+		return PTR_ERR(kvm);
+#ifdef KVM_COALESCED_MMIO_PAGE_OFFSET /* Using */
+	r = kvm_coalesced_mmio_init(kvm);
+	if (r < 0) {
+		kvm_put_kvm(kvm);
+		return r;
+	}
+#endif
+	r = anon_inode_getfd_tsk(tsk, "kvm-vm", &kvm_vm_fops, kvm, O_RDWR | O_CLOEXEC);
+	if (r < 0)
+		kvm_put_kvm(kvm);
+
+	return r;
+}
+EXPORT_SYMBOL_GPL(replay_kvm_dev_ioctl_create_vm_tsk);
+#endif
+
 static int kvm_dev_ioctl_create_vm(unsigned long type)
 {
 	int r;
 	struct kvm *kvm;
 
+#ifdef CONFIG_POPCORN_HYPE
+	if (distributed_remote_process(current)) { /* remote */
+		HPPRINTK("%s: do nothing now\n", __func__);
+		//return popcorn_kvm_dev_ioctl_create_vm_tsk(type);
+	}
+#endif
+
 	kvm = kvm_create_vm(type);
 	if (IS_ERR(kvm))
 		return PTR_ERR(kvm);
+#ifdef CONFIG_POPCORN_HYPE
+	HPPRINTK("%s: struct kvm %p\n", __func__, kvm);
+#endif
 #ifdef KVM_COALESCED_MMIO_PAGE_OFFSET
+	HPPRINTK("[arch] %s: KVM_COALESCED_MMIO_PAGE_OFFSET ON\n", __func__);
 	r = kvm_coalesced_mmio_init(kvm);
 	if (r < 0) {
 		kvm_put_kvm(kvm);
@@ -2988,24 +3930,30 @@ static int kvm_dev_ioctl_create_vm(unsigned long type)
 	return r;
 }
 
+/* from vcpu->kvm->sys_fd */
 static long kvm_dev_ioctl(struct file *filp,
 			  unsigned int ioctl, unsigned long arg)
 {
 	long r = -EINVAL;
 
+	HPPRINTK("%s:\n", __func__);
 	switch (ioctl) {
 	case KVM_GET_API_VERSION:
+		HPPRINTK("%s: KVM_GET_API_VERSION\n", __func__);
 		if (arg)
 			goto out;
 		r = KVM_API_VERSION;
 		break;
 	case KVM_CREATE_VM:
+		HPPRINTK("%s: KVM_CREATE_VM\n", __func__);
 		r = kvm_dev_ioctl_create_vm(arg);
 		break;
 	case KVM_CHECK_EXTENSION:
+		HPPRINTK("%s: KVM_CHECK_EXTENSION\n", __func__);
 		r = kvm_vm_ioctl_check_extension_generic(NULL, arg);
 		break;
 	case KVM_GET_VCPU_MMAP_SIZE:
+		HPPRINTK("%s: KVM_GET_VCPU_MMAP_SIZE\n", __func__);
 		if (arg)
 			goto out;
 		r = PAGE_SIZE;     /* struct kvm_run */
@@ -3015,6 +3963,7 @@ static long kvm_dev_ioctl(struct file *filp,
 #ifdef KVM_COALESCED_MMIO_PAGE_OFFSET
 		r += PAGE_SIZE;    /* coalesced mmio ring page */
 #endif
+		HPPRINTK("%s: KVM_GET_VCPU_MMAP_SIZE ret %ld\n", __func__, r);
 		break;
 	case KVM_TRACE_ENABLE:
 	case KVM_TRACE_PAUSE:
@@ -3022,6 +3971,7 @@ static long kvm_dev_ioctl(struct file *filp,
 		r = -EOPNOTSUPP;
 		break;
 	default:
+		HPPRINTK("%s: (default) -> kvm_arch_dev_ioctl()\n", __func__);
 		return kvm_arch_dev_ioctl(filp, ioctl, arg);
 	}
 out:
@@ -3251,8 +4201,27 @@ static int __kvm_io_bus_write(struct kvm_vcpu *vcpu, struct kvm_io_bus *bus,
 	while (idx < bus->dev_count &&
 		kvm_io_bus_cmp(range, &bus->range[idx]) == 0) {
 		if (!kvm_iodevice_write(vcpu, bus->range[idx].dev, range->addr,
-					range->len, val))
+					range->len, val)) {
+#ifdef CONFIG_POPCORN_HYPE
+			/* matching bus */
+			static unsigned long cnt = 0;
+			static unsigned long no_print_cnt = 0;
+			cnt++;
+			//if (cnt > 0 && (cnt < 10000 || idx > 2) ) {
+			if (idx > 0) {
+				/* This is not only for critical net debugging... */
+				CRITICALNETPK("\t\t|| %s(): <%d> bus->dev_count %d "
+						"->ioeventfd_count %d idx %d "
+						"gpa 0x%llx (input) gpa 0x%llx #%lu (#%lu)\n",
+						__func__, vcpu->vcpu_id,
+						bus->dev_count, bus->ioeventfd_count, idx,
+						bus->range[idx].addr, range->addr, cnt, no_print_cnt);
+			} else {
+				no_print_cnt++;
+			}
+#endif
 			return idx;
+		}
 		idx++;
 	}
 
@@ -3266,6 +4235,9 @@ int kvm_io_bus_write(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,
 	struct kvm_io_bus *bus;
 	struct kvm_io_range range;
 	int r;
+#ifdef CONFIG_POPCORN_HYPE
+    //static unsigned long cnt = 0;
+#endif
 
 	range = (struct kvm_io_range) {
 		.addr = addr,
@@ -3275,6 +4247,15 @@ int kvm_io_bus_write(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,
 	bus = srcu_dereference(vcpu->kvm->buses[bus_idx], &vcpu->kvm->srcu);
 	if (!bus)
 		return -ENOMEM;
+
+#ifdef CONFIG_POPCORN_HYPE
+    // many
+	//cnt++;
+    //if (cnt > 0) {
+	//	printk("\t\t|| %s(): <%d> bus->ioeventfd_count %d #%lu\n",
+	//			__func__, vcpu->vcpu_id, bus->ioeventfd_count, cnt);
+	//}
+#endif
 	r = __kvm_io_bus_write(vcpu, bus, &range, val);
 	return r < 0 ? r : 0;
 }
@@ -3297,10 +4278,12 @@ int kvm_io_bus_write_cookie(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx,
 
 	/* First try the device referenced by cookie. */
 	if ((cookie >= 0) && (cookie < bus->dev_count) &&
-	    (kvm_io_bus_cmp(&range, &bus->range[cookie]) == 0))
+	    (kvm_io_bus_cmp(&range, &bus->range[cookie]) == 0)) {
+
 		if (!kvm_iodevice_write(vcpu, bus->range[cookie].dev, addr, len,
 					val))
 			return cookie;
+	}
 
 	/*
 	 * cookie contained garbage; fall back to search and return the
@@ -3357,6 +4340,11 @@ int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,
 {
 	struct kvm_io_bus *new_bus, *bus;
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t\tpophype: vhost-net-evenfd: %s(): "
+			"register gpa_t 0x%llx bus_idx %d dev %p\n",
+			__func__, addr, bus_idx, dev);
+#endif
 	bus = kvm->buses[bus_idx];
 	if (!bus)
 		return -ENOMEM;
@@ -3529,6 +4517,21 @@ static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
 
 	kvm_arch_sched_in(vcpu, cpu);
 
+#if defined(CONFIG_POPCORN_HYPE) && HYPEBOOTDEBUG && POPHYPE_MIGRATE_VERBOSE_DEBUG
+	{
+		static int cnt = 0;
+		if (!(cnt % 10000)) {
+			PHMIGRATEVPRINTK("------- %s(): <%d> host cpu %d ------- #%d\n",
+										__func__, vcpu->vcpu_id, cpu, cnt);
+		}
+		if ((cnt++ % 10000) == 0) {
+			/* From ...
+				kvm_arch_vcpu_load()
+				vmx_vcpu_load() */
+			//dump_stack(); /* turn on to debug why this happens in default */
+		}
+	}
+#endif
 	kvm_arch_vcpu_load(vcpu, cpu);
 }
 
@@ -3548,6 +4551,10 @@ int kvm_init(void *opaque, unsigned vcpu_size, unsigned vcpu_align,
 	int r;
 	int cpu;
 
+#ifdef CONFIG_POPCORN_HYPE
+	POP_PK("\t%s():\n", __func__);
+#endif
+
 	r = kvm_arch_init(opaque);
 	if (r)
 		goto out_fail;
